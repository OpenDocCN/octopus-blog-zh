<html>
<head>
<title>Octopus Deploy version changes for 2018 - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Octopus Deploy 2018版本变更- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/version-change-2018#2022-07-07">https://octopus.com/blog/version-change-2018#2022-07-07</a></blockquote>
                        <p>几天前，Paul发布了一个关于Octopus Deploy 2017年的回顾，随后是我们2018年的<a href="/blog/roadmap-2018">路线图。在这篇文章中，我将讨论为什么我们决定将Octopus Deploy的版本策略与每月发布的节奏保持一致。</a></p>

<p>但是与其花太多的时间来描述原因和好处，我想描述一下我们是如何走到这一步的——也许这对你也有帮助？</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-01/blogimage-shipping-2018-1.png" class="zoom" data-title=""><img src="../Images/3208f0daeb55ba8e833a207a245d51bf.png" class="img-fluid center" alt="Roadmap for 2018" data-original-src="https://i.octopus.com/blog/2018-01/blogimage-shipping-2018-1.png"/>T2】</a></p>

<h2 id="what-we-are-changing">我们正在改变什么</h2>

<p>不多，真的。下面是我们计划改变的简要总结:</p>

<ul>
<li>我们将在2018年发布第一版Octopus <code>2018.1</code>，而不是在几天后发布Octopus <code>4.2</code></li>
<li>尽管从<code>4.x</code>到<code>2018.x</code>的跳跃可能看起来意义重大，但除了我们计划作为章鱼<code>4.2</code>发布的新功能之外，代码并没有从章鱼<code>4.1</code>发生重大变化</li>
<li><strong>定价和许可保持不变</strong></li>
<li>我们仍计划每月发货一次</li>
<li>我们将在每个日历年的第一次发布时删除版本的主要部分(第一个数字)</li>
<li>我们将在每月发布的节奏上增加版本的次要部分(第二个数字);除非我们因为某些原因跳过了一个月</li>
<li>我们仍然会在这个月发布<strong>补丁</strong>,包括一些小的改进和错误修复</li>
</ul>

<h2 id="there-and-back-again">去了又回来</h2>

<p>改变我们的版本策略的决定实际上是我们作为一个软件产品公司发展的副产品，我认为值得分享一些故事，以防对您的情况有所帮助。</p>

<p>我们喜欢用实验的方法来经营我们的公司。我们不会纯粹假设新的方式会比旧的方式更好，或者盲目地跟随他人的脚步来做出决定，而是花时间来反思我们过去所做的改变，并决定如何从那里进行有机的迭代。我们最好用某种可量化的指标来做这件事。找到最适合我们的可能需要更长的时间，但是最大的成功是:<strong>我们理解<em>为什么</em>我们以我们的方式做事</strong>。转述一下<a href="https://en.wikipedia.org/wiki/Wikipedia:Chesterton%27s_fence" rel="nofollow">切斯特顿栅栏</a>的负责人:</p>

<blockquote class="blockquote">
<p>在你拆掉围墙之前，首先要明白为什么要把它放在那里。</p>
</blockquote>

<p>如果G. K .切斯特顿是2018年的开发者，他可能会说:</p>

<blockquote class="blockquote">
<p>在你阅读git历史之前，不要拆掉围墙！</p>
</blockquote>

<p>也许我们故事的一部分会对你自己的情况有所帮助？</p>

<h3 id="versioning-things">版本化事物</h3>

<p>决定如何对事物进行版本化证明是一个比我最初设想的更棘手的问题。一路走来，我们尝试了:</p>

<ul>
<li>从<code>0.1</code>开始，从那里开始做当时觉得正确的事情</li>
<li>对所有事情使用严格的<a href="https://semver.org" rel="nofollow"> SemVer </a>！</li>
<li>区分“产品版本化”(版本更多地与营销和沟通联系在一起)和“组件版本化”(遵循语义版本化)</li>
<li>让版本反映每月和每年的节奏，中间有补丁</li>
</ul>

<p>每种方法都有一些优点和一些缺点。</p>

<h3 id="doing-what-feels-right-at-the-time">做当时觉得正确的事</h3>

<p>从Octopus <code>1.x</code>到<code>2.x</code>再到<code>3.x</code>的变化都是合理的:我们做了大的架构改变，增加了主要功能，有时还会破坏兼容性。</p>

<p>在<code>3.0</code>之后，我们在<code>3.3</code>之前发布了几个特性版本，并最终致力于构建<a href="https://octopus.com/docs/deployments/patterns/multi-tenant-deployments">对多租户部署的一流支持</a>。在某个时间点，我们承诺在Octopus <code>3.4</code>中发布多租户部署，并坚持使用该版本。回想起来，我认为这个版本应该是章鱼<code>4.0</code>。这是对产品及其功能的重大改变，从开始到结束花了六个月的时间。</p>

<p>在许多方面，这种方法是可行的，但它也让人感觉非常随意，没有一套清晰的指导方针来推动我们的决策。这导致了大版本变化时的一些内部紧张，并使我们的版本不可预测。</p>

<h3 id="high-autonomy-and-semver">高度自治和永久自治</h3>

<p>多租户部署是一种入侵性的变化，它就像一个代码坝，阻碍了其他功能，直到它完成，因为一切都开始依赖于这些代码变化。在那次经历的基础上，我们决定让团队在高度自治的情况下工作，一完成就把较小的功能独立地发布给彼此。</p>

<p>我们还想使用一种语义版本化的形式来帮助指导我们决定每个版本的版本应该是什么样子。我们为Octopus Deploy产品采用了这个策略，我们的每个库和其他组件(比如触手)都将使用语义版本控制。</p>

<p>同样，这种方法通常适用于版本控制，但是我们发现我们的团队过于独立。我们最终运送Octopus <code>3.9</code>和<code>3.10</code>仅相隔几天，一周后又运送Octopus <code>3.11</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-01/version-change-2018-too-quickly.png" class="zoom" data-title=""><img src="../Images/713cd16936d74950541ee3a5882df945.png" class="img-fluid center" alt="Octopus 3.9, 3.10, and 3.11 merely days apart" data-original-src="https://i.octopus.com/blog/2018-01/version-change-2018-too-quickly.png"/>T2】</a></p>

<p>就其本身而言，我们并不认为这是一个问题——代码很好，而且这些变化对我们和我们的客户都很重要...但是我们已经优化以减少内部摩擦，代价是外部的可预测性和我们讲述一个有凝聚力的产品故事的能力。</p>

<h4 id="marketing-and-communication-suffered">营销和沟通受到影响</h4>

<p>我们是如此自主地工作，摩擦如此之少，以至于我们团队的一半人甚至没有意识到我们已经达到了<code>3.11</code>，并且我们已经为<a href="https://octopus.com/docs/deployments/certificates">发布了管理和部署X.509证书的特性</a>——可以说这是Octopus能为你做的最好的事情之一——而我们并没有真正充分利用这个机会来宣扬它！同时，我们在类型化变量上犯了一个小错误，两个团队在解决同一个问题时采用了稍微不同的方法。</p>

<p>这不是版本问题，这是一个<strong>计划</strong>问题！我们运送的东西真的很好，但我们并没有刻意保持凝聚力和一致性。</p>

<h3 id="starting-the-cadence">开始节奏</h3>

<p>2017年4月，我们承诺从<a href="/blog/octopus-april-release"> Octopus Deploy 3.12 </a>开始，每月发布一个新的Octopus Deploy“功能”版本。在那篇文章中:</p>

<blockquote class="blockquote">
<p>这意味着我们将按照您可以信赖的可预测的时间表发布新版本。这些版本将包括新的特性，以及当月所有补丁的汇总。我们做这个实验的目的如下:</p>
</blockquote>

<blockquote class="blockquote">   </blockquote>

<blockquote class="blockquote">
<p><strong>注意</strong>:我们仍然会继续在补丁中发布小的改进和错误修复，只要它们准备好了。我们希望尽快将这些改变交到你们手中，这样就不会改变。</p>
</blockquote>

<p>自2017年4月以来，我们每月大约在同一时间发布一个新功能版本。我们认为它帮助我们更好地规划对产品的更小的、增量的和有价值的改变。</p>

<p>这种节奏有助于我们更好地计划，但它不是灵丹妙药。每个团队会自主地找到他们能创造的最高价值的东西，并着手去创造它们。在每个月初，我们会查看哪些产品即将发布，然后为该版本构建一个有凝聚力的故事。我们有几个月没有准备好发布，所以我们推迟了几周发布。</p>

<p>使用这种方法，我们发布了Octopus <code>3.12</code> - <code>3.17</code>所有有价值的功能，最终当我们在一个大版本中发布了<a href="/blog/octopus-release-4-0">新用户界面</a>和<a href="/blog/octopus-v4-blog-series-kickoff">一大堆其他有价值的功能</a>时，我们升级到了<code>4.0</code>。</p>

<h3 id="a-missing-piece-deliberate-alignment">一个缺失的部分:故意排列</h3>

<p>我故意用故意这个词。我们最终发布了一些非常好的版本，这些版本的内聚性更多的是一个快乐的意外，而不是刻意的设计。2017年底，我们开始思考下一个有机步骤。我们真的希望Octopus Deploy在2018年向拥抱DevOps文化的人们讲述一个有凝聚力的相关故事。</p>

<p>我们的每个团队仍然在高度自治的情况下工作，但随着2018年的进展，我们已经迭代到每个团队都在努力讲述一个有凝聚力的故事的地方。</p>

<h2 id="conclusion">结论</h2>

<p>没有太多变化。<strong>定价和许可保持不变。</strong>我们只是将我们的版本号与我们的月度和年度节奏保持一致。这意味着我们将不再使用我们的主版本号来传达推断的含义，就这样。现在，我们被迫对产品进行更小、更多的增量更改，这对每个人都有好处。</p>

<p>无聊的部分结束了，我认为这篇文章的真正结论是:<strong>持续交付是变革的高效代理</strong>。通过继续信奉我们公司自己的核心价值观之一，我们多次重新审视我们的版本战略，并从根本上改变了我们规划、设计、构建和交付我们自己的软件的方式。</p>

                    
                    
</body>
</html>