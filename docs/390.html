<html>
<head>
<title>Beyond Hello World: Kubernetes for the uninitiated - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>超越Hello World:面向门外汉的Kubernetes章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/kubernetes-for-the-uninitiated#2021-08-12">https://octopus.com/blog/kubernetes-for-the-uninitiated#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/kubernetes-for-the-uninitiated.png" class="zoom" data-title=""><img src="../Images/e36ddd013f66d731cbebda2697012ac9.png" class="img-fluid center" alt="Beyond Hello World - Kubernetes for the uninitiated" data-original-src="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/kubernetes-for-the-uninitiated.png"/>T2】</a></p>

<p>Docker容器和Kubernetes是您DevOps工具箱中的优秀技术。这个<strong>超越Hello World </strong>博客系列涵盖了如何在现实应用中使用它们。</p>



<hr/>

<p>到目前为止，你肯定听说过Kubernetes这个词，但它是最新的流行词还是有更多含义？在这篇文章中，我将介绍Kubernetes(或简称k8s)是什么，并演示如何在k8s上运行真实世界的web应用程序<a href="https://github.com/OctopusSamples/OctoPetShop" rel="nofollow"> OctoPetShop </a>。</p>

<p>在Kubernetes的K和S之间有八个字母，因此是k8s。</p>


<h2 id="what-is-kubernetes">What is Kubernetes?</h2>

<p>Kubernetes是一种容器编排技术。从概念上讲，Kubernetes架构非常简单。运行Kubernetes的机器被称为<code>nodes</code>。节点组成了一个Kubernetes <code>cluster</code>，尽管一个集群也可能只有一个节点。节点在所谓的<code>pod</code>中运行容器。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/kubernetes-node.png" class="zoom" data-title=""><img src="../Images/7b158961e958a0e22f1fbda44e5bde69.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/kubernetes-node.png"/>T2】</a></p>

<h2 id="docker-desktop-and-kubernetes">桌面对接器和库比特</h2>

<p>我的<a href="/blog/containerize-a-real-world-web-app">上一篇文章</a>使用Docker Desktop进行Docker容器的本地开发，但Docker Desktop也包含Kubernetes的一个实现，这使得本地开发和测试变得轻而易举。</p>

<h2 id="create-the-octopetshop-kubernetes-components">创建OctoPetShop Kubernetes组件</h2>

<p>为了在Kubernetes上运行OctoPetShop容器图像，我们需要创建YAML文件来定义应用程序所需的不同资源。资源类型称为<code>kind</code>，容器类型称为<code>deployment</code>。</p>

<p>OctoPetShop应用程序有三个主要组件:</p>

<ul>
<li>一个web前端。</li>
<li>产品服务。</li>
<li>购物车服务。</li>
</ul>

<p>除了这些组件，OctoPetShop还需要一个数据库服务器和数据库来运行。对于OctoPetShop，我们需要创建以下部署:</p>

<ul>
<li>Web前端。</li>
<li>产品服务。</li>
<li>购物车服务。</li>
<li>Microsoft SQL Server。</li>
</ul>

<h3 id="kubernetes-deployments">Kubernetes部署</h3>

<p>以下是前端的部署YAML文件:</p>

<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: octopetshop-web-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      component: web
  template:
    metadata:
      labels:
        component: web
    spec:
      containers:
        - name: web
          image: octopussamples/octopetshop-web
          ports:
            - containerPort: 5000
              name: http-port
            - containerPort: 5001
              name: https-port
          env:
            - name: ProductServiceBaseUrl
              value: http://octopetshop-productservice-cluster-ip-service:5011/
            - name: ShoppingCartServiceBaseUrl
              value: http://octopetshop-shoppingcart-cluster-ip-service:5012
</code></pre>

<h3 id="anatomy-of-the-kubernetes-yaml-file">库贝内特斯·YAML档案剖析</h3>

<ul>
<li><strong> apiVersion </strong> : Kubernetes提供了一个<a href="https://kubernetes.io/docs/reference/#api-reference" rel="nofollow"> API参考</a>来帮助决定选择哪个版本。对于种类<em>部署</em>，<code>apps/v1</code>是正确的选择。</li>
<li>种类:这告诉Kubernetes我们正在部署什么类型的资源。</li>
<li><strong>元数据名称</strong>:这是我们部署的唯一名称。</li>
<li><strong> spec - replicas </strong>:要运行的容器实例的数量。</li>
<li><strong>规格选择器-匹配标签</strong>:          <ul>
<li><strong>选择器</strong>:选择器字段定义Kubernetes对象如何找到要管理的窗格。</li>
<li><strong>标签</strong>:标签是附在对象上的键/值对，用于指定识别属性。</li>
</ul>
</li>
<li><strong>模板</strong>:pod的模板规格。</li>
<li><strong>template-spec-containers</strong>:这个部分是这个部署将运行的容器的数组。</li>
</ul>

<p>每个容器获得:</p>

<ul>
<li><strong>名称</strong>:我们给容器起的名字。</li>
<li><strong>图像</strong>:用于容器的Docker Hub图像。</li>
<li><strong> Ports </strong>:容器将向pod网络公开的一组端口。</li>
<li><strong> Env </strong>:容器的环境变量数组。</li>
</ul>

<p>其余的部署YAML文件见<a href="https://github.com/OctopusSamples/OctoPetShop/tree/master/k8s" class="alert-link" rel="nofollow"> OctoPetShop </a>。</p>


<p>部署将为我们的应用程序创建pod，但是我们仍然需要一种方法让它们进行通信。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/kubernetes-pod.png" class="zoom" data-title=""><img src="../Images/883d83b98d66f10ccbaf29ad8ce18dce.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/kubernetes-pod.png"/>【T37】T2】</a></p>

<p>节点上的每个pod都有一个由该节点分配的内部IP地址。在我们的容器中，我们已经指定了向pod公开的端口，但是这些端口仍然只在pod中，而没有向节点公开。为了允许节点上的pod之间的连接，我们需要为每个pod创建一个<code>service</code>。</p>

<h3 id="kubernetes-services">Kubernetes服务</h3>

<p>通过API可以获得许多不同的服务，但是我们将把重点放在允许我们的OctoPetShop应用程序运行的特定服务上。我们的web前端pod需要能够与产品服务和购物车服务pod对话。产品服务和购物车服务窗格需要能够与SQL Server窗格通信。为了实现这一点，我们需要为产品服务、购物车服务和SQL Server pods创建一个<code>ClusterIP</code>服务。下面是为产品服务创建ClustIP服务的YAML:</p>

<pre><code>apiVersion: v1
kind: Service
metadata:
  name: octopetshop-productservice-cluster-ip-service
spec:
  type: ClusterIP
  selector:
    component: productservice
  ports:
    - port: 5011
      targetPort: 5011
      name: http-port
    - port: 5014
      targetPort: 5014
      name: https-port
</code></pre>

<p>在上面的Kubernetes YAML中，我们创建了一个服务，将一个pod端口映射到一个容器端口，以允许节点内的pod到容器通信。此服务不在节点级别公开端口，因此不可能进行外部访问。记录元数据名称很重要，因为该名称将创建一个DNS条目，以便可以通过DNS名称引用该服务。在之前的web前端YAML中，我们为产品服务URL声明了一个环境变量，其中包含octopet shop-product service-cluster-IP-service作为DNS条目。产品服务的ClusterIP服务就是其来源。</p>

<h3 id="allow-external-access">允许外部访问</h3>

<p>为了允许外部访问节点，我们需要定义一个<code>Ingress</code>或<code>LoadBalancer</code>服务。在我们的例子中，我们选择了一个负载平衡器服务来允许对web前端的访问:</p>

<pre><code>apiVersion: v1
kind: Service
metadata:
  name: web-loadbalancer
spec:
  selector:
    component: web
  ports:
    - port: 80
      targetPort: 5000
      name: http-port
    - port: 5001
      targetPort: 5001
      name: https-port
  type: LoadBalancer
  externalIP: &lt;IPAddress&gt;
</code></pre>

<p><strong>警告</strong></p>


<h3 id="kubernetes-jobs">Kubernetes乔布斯</h3>

<p>我们的OctoPetShop解决方案中包括一个DbUp项目，它包含创建和播种数据库的脚本。DbUp是一个控制台应用程序，它会执行然后停止，所以我们不想使用<code>kind: Deployment</code>，因为Kubernetes会试图让它保持运行。为此，我们想使用<code>kind: Job</code>，它专门用于在完成以下操作后终止:</p>

<pre><code>apiVersion: batch/v1
kind: Job
metadata:
  name: octopetshop-dbup
spec:
  template:
    spec:
      containers:
        - name: dbup
          image: octopussamples/octopetshop-database
          env:
            - name: DbUpConnectionString
              value: Data Source=octopetshop-sqlserver-cluster-ip-service;Initial Catalog=OctoPetShop; User ID=sa; Password=SomePassword
      restartPolicy: Never
</code></pre>

<h2 id="kubectl">库贝特尔</h2>

<p>Kubectl是用于Kubernetes的命令行程序。</p>

<h3 id="start-octopetshop-in-kubernetes">在Kubernetes开始OctoPetShop</h3>

<p>要运行Kubernetes YAML文件，您可以运行命令<code>kubectl apply -f &lt;YAMLFile&gt;</code>。但是，可以指定一个文件夹，而不是单个文件。这是OctoPetShop repo将所有Kubernetes YAML文件存储在k8s文件夹中的主要原因。如果您已经克隆了repo，您可以运行<code>kubectl apply -f k8s</code>让整个集群运行，只需一个命令:</p>

<pre><code>PS C:\GitHub\OctoPetShop&gt; kubectl apply -f k8s
job.batch/octopetshop-dbup created
service/web-loadbalancer created
service/octopetshop-productservice-cluster-ip-service created
deployment.apps/octopetshop-productservice-deployment created
service/octopetshop-shoppingcart-cluster-ip-service created
deployment.apps/octopetshop-shoppingcartservice-deployment created
deployment.apps/sqlserver-deployment created
service/octopetshop-sqlserver-cluster-ip-service created
service/octopetshop-web-cluster-ip-service created
deployment.apps/octopetshop-web-deployment created
</code></pre>

<h3 id="check-kubernetes-pod-status">检查Kubernetes pod状态</h3>

<p>apply命令向我们显示，它运行了YAML文件，但没有运行其他文件。为了检查pod的状态，我们运行命令<code>kubectl get pods</code>:</p>

<pre><code>PS C:\GitHub\blog&gt; kubectl get pods
NAME                                                         READY   STATUS      RESTARTS   AGE
octopetshop-dbup-9kt54                                       0/1     Completed   0          2m55s
octopetshop-productservice-deployment-6f955ff576-4nwtw       1/1     Running     0          2m55s
octopetshop-shoppingcartservice-deployment-9f94574f9-t96ck   1/1     Running     0          2m55s
octopetshop-web-deployment-7b6d499d69-f9jsp                  1/1     Running     0          2m55s
sqlserver-deployment-784d755db-8vbwk                         1/1     Running     0          2m55s
</code></pre>

<p>该命令向我们显示有多少pod正在运行，以及应该有多少pod正在运行。在我们的例子中，我们将副本指定为1，因此在我们的pod中应该只有1个实例。您会注意到octopetshop-dbup pod已准备好0/1个pod。因为我们用<code>kind: Job</code>定义了octopershop-dbup，这是正常的，因为它应该在运行后终止。</p>

<h3 id="display-logs">显示日志</h3>

<p>与docker compose不同，运行kubectl apply命令不会显示来自pod或容器的任何输出。当一个pod出现故障时，知道原因是很有用的。让我们更改octopetshop-dbup作业的密码，使其失败:</p>

<pre><code>apiVersion: batch/v1
kind: Job
metadata:
  name: octopetshop-dbup
spec:
  template:
    spec:
      containers:
        - name: dbup
          image: octopussamples/octopetshop-database
          command: [ "dotnet", "run", "--no-launch-profile" ]
          env:
            - name: DbUpConnectionString
              value: Data Source=octopetshop-sqlserver-cluster-ip-service;Initial Catalog=OctoPetShop; User ID=sa; Password=ThisPasswordIsWrong
      restartPolicy: Never
</code></pre>

<p>如果我们运行<code>kubectl apply -f k8s</code>命令，我们将看到如下所示:</p>

<pre><code>PS C:\GitHub\OctoPetShop&gt; kubectl get pods
NAME                                                         READY   STATUS    RESTARTS   AGE
octopetshop-dbup-76cxk                                       1/1     Running   0          5s
octopetshop-dbup-bjsj8                                       0/1     Error     0          35s
octopetshop-dbup-mt9lk                                       0/1     Error     0          25s
octopetshop-dbup-rm97t                                       0/1     Error     0          49s
octopetshop-productservice-deployment-6f955ff576-bvc88       1/1     Running   0          49s
octopetshop-shoppingcartservice-deployment-9f94574f9-mkr7h   1/1     Running   0          49s
octopetshop-web-deployment-7b6d499d69-975kg                  1/1     Running   0          49s
sqlserver-deployment-784d755db-7dh95                         1/1     Running   0          49s
</code></pre>

<p>Kubernetes三次尝试运行octopetshop-dbup作业，但都失败了。重试三次后，Kubernetes将停止尝试运行pod。为了解决这个问题，我们可以运行<code>kubectl logs jobs/octopetshop-dbup</code>来显示容器的输出:</p>

<pre><code>PS C:\GitHub\OctoPetShop&gt; kubectl logs job/octopetshop-dbup
Found 3 pods, using pod/octopetshop-dbup-rm97t
Master ConnectionString =&gt; Data Source=octopetshop-sqlserver-cluster-ip-service;Initial Catalog=master;User ID=sa;Password=*********************

Unhandled Exception: System.Data.SqlClient.SqlException: A connection was successfully established with the server, but then an error occurred during the pre-login handshake. (provider: TCP Provider, error: 0 - Success)
   at System.Data.SqlClient.SqlInternalConnectionTds..ctor(DbConnectionPoolIdentity identity, SqlConnectionString connectionOptions, Object providerInfo, Boolean redirectedUserInstance, SqlConnectionString userConnectionOptions, SessionData reconnectSessionData, Boolean applyTransientFaultHandling)
   at System.Data.SqlClient.SqlConnectionFactory.CreateConnection(DbConnectionOptions options, DbConnectionPoolKey poolKey, Object poolGroupProviderInfo, DbConnectionPool pool, DbConnection owningConnection, DbConnectionOptions userOptions)
   at System.Data.ProviderBase.DbConnectionFactory.CreatePooledConnection(DbConnectionPool pool, DbConnection owningObject, DbConnectionOptions options, DbConnectionPoolKey poolKey, DbConnectionOptio   at System.Data.ProviderBase.DbConnectionPool.CreateObject(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   at System.Data.ProviderBase.DbConnectionPool.UserCreateRequest(DbConnection owningObject, DbConnectionOptions userOptions, DbConnectionInternal oldConnection)
   at System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal&amp; connection)
   at System.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal&amp; connection)
   at System.Data.ProviderBase.DbConnectionFactory.TryGetConnection(DbConnection owningConnection, TaskCompletionSource`1 retry, DbConnectionOptions userOptions, DbConnectionInternal oldConnection, DbConnectionInternal&amp; connection)
   at System.Data.ProviderBase.DbConnectionInternal.TryOpenConnectionInternal(DbConnection outerConnection, DbConnectionFactory connectionFactory, TaskCompletionSource`1 retry, DbConnectionOptions userOptions)
   at System.Data.SqlClient.SqlConnection.TryOpen(TaskCompletionSource`1 retry)
   at System.Data.SqlClient.SqlConnection.Open()
   at SqlServerExtensions.SqlDatabase(SupportedDatabasesForEnsureDatabase supported, String connectionString, IUpgradeLog logger, Int32 timeout, AzureDatabaseEdition azureDatabaseEdition, String collation)
   at OctopusSamples.OctoPetShopDatabase.Program.Main(String[] args) in /src/Program.cs:line 16
</code></pre>

<h2 id="run-octopetshop-in-kubernetes">在Kubernetes经营OctoPetShop</h2>

<p>YAML成功运行后，OctoPetShop应用程序应该正在运行。导航到http://localhost:5000。</p>

<p>OctoPetShop被编写为重定向到https，您很可能会收到关于该站点不安全的警告。这是正常的，继续操作是安全的，因为我们没有在过程中配置证书。</p>


<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/octopetshop.png" class="zoom" data-title=""><img src="../Images/fd7ef41f575b3ea55097f93b0a9cb300.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/kubernetes-for-the-uninitiated/octopetshop.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>在踏上将OctoPetShop容器化的旅程，最终目标是让它在Kubernetes上运行之前，我将Kubernetes视为一个复杂的怪物。现在我已经完成了将应用程序容器化并让它运行的过程，我仍然这样认为，但是让应用程序在其上运行并没有那么难。</p>

<p><a href="https://github.com/OctopusSamples/OctoPetShop" rel="nofollow"> OctoPetShop </a> GitHub repo包含OctoPetShop应用程序的所有docker、docker-compose和Kubernetes YAML文件。</p>

                    
                    
</body>
</html>