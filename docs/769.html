<html>
<head>
<title>Using the Alpine Docker image - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Alpine Docker图像- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/using-alpine-docker-image#2022-09-12">https://octopus.com/blog/using-alpine-docker-image#2022-09-12</a></blockquote>
                        <p>由于尺寸较小，<a href="https://hub.docker.com/_/alpine" rel="nofollow"> Alpine Docker图像</a>经常被用作其他自定义图像的基础。在Docker Hub上有超过10亿的下载量，Alpine也是最受欢迎的图片之一。(你也可以阅读我在<a href="https://octopus.com/blog/using-ubuntu-docker-image">发的关于Ubuntu </a>的帖子，它目前是Docker Hub下载最多的图片。)</p>

<p>在这篇文章中，我向你展示了当你在Alpine上创建自己的图片时可以采用的最佳实践。</p>

<h2 id="cleaning-the-cache">清理缓存</h2>

<p>在工作站和服务器上安装软件时，缓存的软件包列表非常有用，因为它们提供了对软件包存储库中可用软件包的快速访问。然而，安装在Docker容器中的包很少在运行时更新；相反，Docker映像本身被更新，容器被重新创建。这意味着将包缓存列表烘焙到Docker映像中是不必要且低效的。</p>

<p>删除缓存包列表的一种方法是用<code>apk add --update-cache</code>命令安装新的包，然后删除<code>/var/cache/apk</code>下的文件，作为单个<code>RUN</code>指令的一部分。这可确保创建软件包缓存，这是安装其他软件包所必需的，然后在不捕获中间映像层中的软件包缓存的情况下进行清理:</p>

<pre><code class="language-dockerfile">RUN apk add --update-cache \
    python \
    python-dev \
    py-pip \
    build-base \
  &amp;&amp; pip install virtualenv \
  &amp;&amp; rm -rf /var/cache/apk/*
</code></pre>

<p>您也可以使用<code>apk add --no-cache</code>选项。这相当于前面的命令，但更简洁:</p>

<pre><code class="language-dockerfile">RUN apk add --no-cache nginx
</code></pre>

<h2 id="virtual-packages">虚拟包</h2>

<p>虚拟包提供了一种将包捆绑在一个通用名称下的方法，允许它们作为一个组被删除。<a href="https://github.com/alpinelinux/docker-alpine/blob/master/docs/usage.adoc" rel="nofollow"> Alpine Docker图像文档</a>提供了安装Python开发库、下载Python应用程序的依赖项，然后移除Python开发库的示例:</p>

<pre><code class="language-dockerfile">FROM alpine

WORKDIR /myapp
COPY . /myapp

RUN apk add --no-cache python py-pip openssl ca-certificates
RUN apk add --no-cache --virtual build-dependencies python-dev build-base wget \
  &amp;&amp; pip install -r requirements.txt \
  &amp;&amp; python setup.py install \
  &amp;&amp; apk del build-dependencies

CMD ["myapp", "start"]
</code></pre>

<p>虽然这个例子可行，但是效率很低。由于Docker缓存的实现方式，对使用指令<code>COPY . /myapp</code>复制到映像中的文件的任何更改都会使缓存失效，迫使后续指令重新运行。实际上，这意味着上面的例子将在每次Python代码改变时下载、安装和删除Python开发库。</p>

<p>更好的解决方案是使用<a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="nofollow">多阶段构建</a>。下面显示了一个示例:</p>

<pre><code class="language-dockerfile">FROM alpine AS compile-image

RUN apk add --no-cache python3 py-pip openssl ca-certificates python3-dev build-base wget

WORKDIR /myapp

COPY requirements.txt /myapp/
RUN python3 -m venv /myapp
RUN /myapp/bin/pip install -r requirements.txt

FROM alpine AS runtime-image

RUN apk add --no-cache python3 openssl ca-certificates

WORKDIR /myapp
COPY . /myapp

COPY --from=compile-image /myapp/ ./

CMD ["/myapp/bin/python", "myapp.py", "start"]
</code></pre>

<p>多阶段构建允许您使用构建应用程序源代码所需的开发库来创建映像。这个“编译映像”在两次构建之间保留了这些开发库，消除了每次下载它们的需要。</p>

<p>创建第二个映像来托管可执行的应用程序代码和运行时库，但具体来说不包括任何仅在编译时需要的库。这个“运行时映像”尽可能小，因为它复制由编译映像产生的文件，而不需要相关的编译时库。</p>

<h2 id="musl-vs-glibc">musl vs glibc</h2>

<p>在很大程度上，Alpine可以作为任何其他基本Docker图像的替代物。然而，了解Alpine和其他常见的基础Docker映像(如Ubuntu、Debian或Fedora)之间的架构差异非常重要。</p>

<p>Alpine使用<a href="http://musl.libc.org/" rel="nofollow"> musl C标准库</a>，而Ubuntu、Debian、Fedora使用<a href="https://www.gnu.org/software/libc/" rel="nofollow"> glibc </a>。下面是<a href="http://www.etalabs.net/compare_libcs.html" rel="nofollow">两个库</a>的详细对比。</p>

<p>在某些情况下，第三方工具假设或需要glibc。例如，<a href="https://code.visualstudio.com/docs/remote/containers" rel="nofollow"> Visual Studio代码远程容器执行文档</a>提供了以下警告:</p>

<blockquote class="blockquote">
<p>当使用Alpine Linux容器时，由于扩展中本机代码的glibc依赖性，一些扩展可能无法工作。</p>
</blockquote>

<p>基于Alpine的图像也<a href="https://octopus.com/docs/projects/steps/execution-containers-for-workers">不适合用作Octopus容器图像</a>:</p>

<blockquote class="blockquote">
<p>构建在musl上的Linux发行版，尤其是Alpine，不支持Calamari，也不能用作容器映像。这是因为Calamari目前只针对glibc编译，而不是musl。</p>
</blockquote>

<p>PythonSpeed的博客文章<a href="https://pythonspeed.com/articles/alpine-docker-python/" rel="nofollow">使用Alpine可以让Python Docker构建速度慢50倍</a>，详细介绍了在Alpine上构建Python应用时的一些性能问题:</p>

<blockquote class="blockquote">
<p>大多数Linux发行版使用标准C库的GNU版本(glibc ),几乎每个C程序都需要它，包括Python。但是Alpine Linux使用的是musl，那些二进制轮子是针对glibc编译的，因此Alpine禁用了Linux轮子支持。</p>
</blockquote>

<p>除了已知与musl不兼容的特定用例之外，我发现Alpine是一个可靠而实用的选择，可以作为我自己的Docker图像的基础。但是了解使用实现musl的发行版的含义是有好处的。</p>

<h2 id="conclusion">结论</h2>

<p>Alpine提供了一个轻量级和流行的Docker映像，与其他流行的映像(如Ubuntu)相比，它可以改进您的映像构建和部署时间。</p>

<p>Alpine使用musl C标准库，这在某些情况下可能会引入兼容性问题，但是您通常可以假设Alpine为您的定制Docker映像提供了所需的一切。虚拟包等高级功能也可以让您缩小映像大小，尽管多阶段构建可能是更好的选择。</p>

<p>了解如何使用其他流行的容器图像:</p>



<h2 id="resources">资源</h2>



<h2 id="learn-more">了解更多信息</h2>

<p>如果您想在AWS平台(如EKS和ECS)上构建和部署容器化的应用程序，请尝试使用<a href="https://octopusworkflowbuilder.octopus.com/#/" rel="nofollow"> Octopus Workflow Builder </a>。构建器使用GitHub Actions工作流构建的示例应用程序填充GitHub存储库，并使用示例部署项目配置托管的Octopus实例，这些项目展示了最佳实践，如漏洞扫描和基础架构代码(IaC)。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>