<html>
<head>
<title>Octostache Update - JSON, Indexing, Formatting and Dates - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Octostache更新- JSON，索引，格式化和日期- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octostache-json-formatting#2017-09-29">https://octopus.com/blog/octostache-json-formatting#2017-09-29</a></blockquote>
                        

<p>作为支持Docker部署的一部分，我们意识到我们需要一种方法来访问作为集装箱检查输出返回的JSON格式的信息。与其递归遍历JSON对象并在运行Docker步骤后将所有属性转换为Octopus变量，<em>以防后续步骤需要它，我们决定在需要变量</em>时更新<a href="https://github.com/OctopusDeploy/Octostache">Octopus che</a>(我们的<a href="http://docs.octopusdeploy.com/display/OD/Variable+Substitution+Syntax">变量替换库</a>)来支持解析JSON <em>。虽然我们已经接触了变量解析库，但是我们认为在3.5中增加一些其他有用的特性是一个很好的借口！</em></p>

<h3>JSON解析</h3>

<p>例如，如果将项目或输出变量设置为JSON值:</p>

<pre><code>Variables:
Custom.Json = "{Name: 't-shirt', Sizes: [{size: 'small', price: 15.00}, {size: 'large', price: 20.00}]}"  

Expressions:
#{Custom.Json.Name}
#{Custom.Json.Sizes[0].price}
#{Custom.Json.Sizes[1]}

Resolves to:
"t-shirt"
"15.00"
"{size: "large", price: 20.00}"
</code></pre>

<p>请注意，如果您已经显式地提供了一个与将解析为JSON路径的值相匹配的变量，例如，如果您显式地设置了一个项目变量</p>

<pre><code>Custom.Json.Name = "pants"
</code></pre>

<p>那么将返回显式变量<code>pants</code>。这个新的解析支持如上所示的点符号或索引符号，因此<code>#{Custom.Json.[Sizes][0][price]}</code>也可以解析为<code>'15.00'</code>。这最后一点把我带到下一个更新...</p>

<h3>索引替换</h3>

<p>不久前，我们增加了在索引中执行变量替换的支持。</p>

<pre><code>Variables:
Server[Asia] = "Beijing"
Server[Europe] = "London"
Continent = "Asia"

Expression:
#{Server[#{Continent}]}

Resolves To:
"Beijing"
</code></pre>

<p>作为变量替换本身的结果，您现在可以动态解析适当的<code>Server</code>变量。顺便说一下，它对Docker步骤也很方便，您可能希望从容器JSON输出中访问一个变量，该变量由另一个步骤的一些属性输出索引，而这些属性输出只能在部署时知道。</p>

<h3>条件式</h3>

<p>直到最近，变量替换中的条件语句需要一个<em>真值</em>比较。也就是说，只有当变量的值类似于<code>"True"</code>时，它们才会将条件解析为<code>true</code>。现在不再是这种情况，比较现在可以检查直接字符串相等或使用内部变量替换。</p>

<pre><code>Variables:
City = "London"
Capital = "London"

Expressions:
#{if City == "London"}'Ello Guvna#{/if}
#{if City != "Paris"}'Ello Guvna#{/if}
#{if City == Capital}'Ello Guvna#{/if}

Resolve To:
'Ello Guvna
'Ello Guvna
'Ello Guvna
</code></pre>

<h3>格式化</h3>

<p>我们的一些用户面临的一个问题是，当我们将项目变量中的日期保存到数据库中时，序列化程序会将它们转换成不同的格式。我们引入了一个新的内置八进制函数，允许你将日期变量格式化为. NET支持的任何自定义格式</p>

<pre><code>#{&lt;VariableName&gt; | Format &lt;DataType&gt; &lt;Format&gt;}
</code></pre>

<p>其中<code>&lt;DataType&gt;</code>可以是“DateTime”、“DateTimeOffset”、“Double”、“Decimal”或“Int”之一(不区分大小写)。Octostache然后会尝试将在<code>&lt;VariableName&gt;</code>解析的变量解析为指定的类型，然后用C# <code>.ToString()</code>方法转换回一个字符串，传入提供的<code>&lt;Format&gt;</code>参数。</p>

<pre><code>Variables:
Cash = "12.1"
MyDate = "2030/05/22 09:05:00"
CustomFormat = "MMM dd, yyyy"

Expressions:
#{Cash | Format double C}
#{MyDate | Format DateTime \"HH dd-MM-yyyy\"}
#{MyDate | Format DateTime #{CustomFormat}}

Resolve To:
$12.1
09 22-May-2030
May 22, 2030
</code></pre>

<p>请注意，格式化将使用进行转换的计算机的当前区域性。此外，由于这些参数由空格分隔，如果您的格式包含空格，就像上面的日期格式一样，您将需要包含引号。如果缺少<code>&lt;DataType&gt;</code>参数，格式化程序将首先尝试将变量解析为小数，然后解析为DateTimeOffset。</p>

<p>除了新的<code>NowDate</code>和<code>NowDateUtc</code>函数(没有变量输入)，您还可以获得当前时间戳，并将其与格式化函数链接在一起。</p>

<pre><code>Expression:
#{ | NowDate | Format yyyy}

Resolves to
"2016"
</code></pre>

<h3>结论</h3>

<p>我们希望您会发现这些新的变量替换功能非常有用。Octostache，我们的变量替换库是开源的，并且已经在GitHub 上提供了<a href="https://github.com/OctopusDeploy/Octostache">，所以请随意查看并贡献您自己的增强建议，或者从我们的</a><a href="http://docs.octopusdeploy.com/display/OD/Variable+Substitution+Syntax">在线文档</a>中了解更多关于在您的部署中使用这些新表达式的信息。Octopus 3.5的这些新增功能允许变量和作用域之间更丰富和复杂的关系。让我们知道它们如何(或不如何)对您的部署有用！</p>

                    
                    
</body>
</html>