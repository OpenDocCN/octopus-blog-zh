<html>
<head>
<title>Performing canary deployments in Kubernetes - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Kubernetes - Octopus Deploy中执行金丝雀部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/kubernetes-canary-deployments#2021-07-07">https://octopus.com/blog/kubernetes-canary-deployments#2021-07-07</a></blockquote>
                        <p>当推出应用程序的新版本时，将少量流量导向新版本并观察任何错误可能是有用的。这种策略被称为金丝雀部署，意味着新版本中出现的任何错误只会影响一小部分用户。不断增加新版本的流量可以提高对没有问题的信心，如果出现任何问题，部署可以回滚到以前的版本。</p>

<p>Kubernetes特别适合canary部署，因为它提供了管理部署和引导流量的灵活性。在这篇博文中，我们将看看如何使用<a href="https://appscode.com/products/voyager" rel="nofollow"> Voyager入口控制器</a>和Octopus实现金丝雀部署。</p>

<h2 id="prerequisites">先决条件</h2>

<p>要阅读这篇博文，您需要有一个Kubernetes集群，以及一个配置了管理凭证的Octopus中的Kubernetes目标。我将使用一个Google Cloud Kubernetes集群和一个具有<code>Google Cloud Kubernetes Admin</code>角色的管理Kubernetes目标。</p>

<p>Kubernetes集群也需要安装Helm。Google提供了将Helm安装到他们的Kubernetes集群中的这些指令。</p>

<h2 id="installing-voyager">安装Voyager</h2>

<p>在开始将任何应用程序部署到Kubernetes之前，我们需要将Voyager安装到我们的集群中。Voyager提供了许多不同的安装方法，但是我发现Helm对于这种情况是最方便的。</p>

<p>我们将利用Octopus本身的舵步骤来部署Voyager舵图。</p>

<h3 id="the-external-feed">外部供给</h3>

<p>第一步是创建一个指向<a href="https://github.com/appscode/charts" rel="nofollow"> AppsCode图表库</a>的外部提要。外部提要位于<span class="path">➜图书馆外部提要</span>下。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/external-feed.png" class="zoom" data-title=""><img src="../Images/1fb41abbf4796390a81a75cba2b0d98a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/external-feed.png"/>T2】</a></p>

<h3 id="the-helm-executable">舵可执行文件</h3>

<p>Helm对于什么版本的客户端可以与服务器上的特定版本协同工作的要求非常严格。因此，与类似于<code>kubectl</code>的工具不同，您经常被迫使用与安装在服务器上的<code>helm</code>可执行文件完全相同的客户端版本。</p>

<p>为了满足精确匹配的需要，Octopus中的Helm步骤允许在部署图表时使用包中的可执行文件。</p>

<p>要获得<code>helm</code>可执行文件的打包版本，请前往<a href="https://github.com/helm/helm/releases" rel="nofollow"> Helm GitHub发布页面</a>并下载适用于您平台的二进制文件。除非你用的是workers，否则你的平台很可能是Windows。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-client.png" class="zoom" data-title=""><img src="../Images/0fcc31b2799879e91ccb0335c633492a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-client.png"/>T2】</a></p>

<p>这将下载一个类似于<code>helm-v2.11.0-windows-amd64.zip</code>的文件。将其重命名为类似于<code>helm-windows-amd64.2.11.0.zip</code>的名称，因为这种文件格式更适合Octopus内置的提要。</p>

<p>然后将文件上传到内置提要，可以通过<span class="path">库➜包</span>访问。在下面的截图中，你可以看到我已经上传了Windows和Linux的<code>helm</code>二进制文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/packages.png" class="zoom" data-title=""><img src="../Images/abbe9e0dab038b67c4d6bbf6f6713ba3.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/packages.png"/>T2】</a></p>

<h3 id="deploying-the-helm-chart">展开舵图</h3>

<p>为了部署航海家掌舵图，我们使用Octopus中的<code>Run a Helm Update</code>步骤。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-project.png" class="zoom" data-title=""><img src="../Images/316f477ec485ed651a6bf566e0e4dacc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-project.png"/>T2】</a></p>

<p>下面的屏幕截图显示了填充的步骤。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-step.png" class="zoom" data-title=""><img src="../Images/96e3cee3a2ed62138808f0545d50fbb2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-step.png"/>T2】</a></p>

<p>这一步中有几个有趣的设置。首先是<code>Helm Client Tool</code>配置。我已经使用了<code>Custom packaged helm client tool</code>选项，并将其指向我们之前上传到内置提要的Helm二进制包。<code>windows-amd64/helm.exe</code>中的<code>Helm executable location</code>是指档案中的<code>helm.exe</code>文件。在下面的截图中，您可以看到归档的目录结构。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-archive.png" class="zoom" data-title=""><img src="../Images/60f11e8505b817c8f0b2781d25462c2b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-archive.png"/>T2】</a></p>

<p>我们还在<code>Explicit Key Values</code>部分的舵图上设置了两个值。<code>cloudProvider</code>设置被设置为<code>gce</code>,因为我正在部署到谷歌云环境。其他选项包括:</p>

<ul>
<li>美国化学学会</li>
<li>美国焊接协会</li>
<li>蔚蓝的</li>
<li>裸机</li>
<li>炮控设备</li>
<li>gke</li>
<li>迷你库贝</li>
<li>openstack</li>
</ul>

<p><code>rbac.create</code>值被设置为<code>true</code>,因为我的Kubernetes集群启用了RBAC。</p>

<p>来自部署的日志为我们提供了一个命令，我们可以运行该命令来验证安装。我的命令是<code>kubectl --namespace=default get deployments -l "release=voyager-operator, app=voyager"</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-logs.png" class="zoom" data-title=""><img src="../Images/a07ac2c60967822ddb1fd9791124ba2a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/helm-logs.png"/>T2】</a></p>

<p>我们可以通过Octopus脚本控制台运行这些特别的命令，该控制台可以通过<span class="path">任务➜脚本控制台</span>访问。</p>

<p>在这里，我对名为<code>GoogleK8SAdmin</code>的Kubernetes管理目标运行了命令。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/script-console.png" class="zoom" data-title=""><img src="../Images/81cb11a5b8dbe1222ce8b0e29b100679.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/script-console.png"/>T2】</a></p>

<p>结果显示航海家号已经安装就绪。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/script-console-result.png" class="zoom" data-title=""><img src="../Images/a0bcab6baee9d74e0177638e51283fe1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/script-console-result.png"/>T2】</a></p>

<p>通过Octopus运行专门的脚本有很多优点，比如能够针对不同的目标运行命令，而无需在本地配置上下文，以及提供已经运行的脚本的历史记录。</p>


<h3 id="the-canary-environments">金丝雀环境</h3>

<p>我们将把canary部署的进展建模为Octopus环境。这样做有很多好处，比如在仪表板上显示当前进度，并允许轻松地回滚到以前的状态。</p>

<p>环境可以在<span class="path">基础设施➜环境</span>下找到。</p>

<p>对于这个博客，我们将有三个环境:<code>Canary 25%</code>、<code>Canary 75%</code>和<code>Canary 100%</code>。每一个都代表将被定向到canary部署的不断增加的流量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/environments.png" class="zoom" data-title=""><img src="../Images/217ab927c94ef218490b561a4e4bdd41.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/environments.png"/>T2】</a></p>

<p>重要的是，这些环境允许<code>Dynamic Infrastructure</code>，我们将利用这一点来创建我们的受限Kubernetes目标，而不是将管理目标用于所有部署。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/dynamic-infrastructure.png" class="zoom" data-title=""><img src="../Images/0e76a7559c78f0ceb38e6313ee4b3cd7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/dynamic-infrastructure.png"/>T2】</a></p>

<p>为了在这些环境中推进我们的应用程序，我们将创建一个包含三个阶段的生命周期，每个阶段对应一个canary环境。</p>

<p>生命周期可以在<span class="path">➜图书馆生命周期</span>中找到。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/lifecycle.png" class="zoom" data-title=""><img src="../Images/c513b2bd561b1b49315551a69e87938b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/lifecycle.png"/>T2】</a></p>

<p>最后，通过将它们添加到<code>Environments</code>字段，确保Kubernetes管理目标可以访问canary环境。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/admin-target.png" class="zoom" data-title=""><img src="../Images/902d295a62cc437d94cbbc7da6c2c158.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/admin-target.png"/>T2】</a></p>

<h3 id="the-deployment-project">部署项目</h3>

<p>我们现在已经有了开始部署应用程序的所有基础设施。下一步是创建一个新的部署项目，将应用程序容器推送到Kubernetes。</p>

<p>对于这个例子，我们将使用HTTPD映像，这是一个web服务器，我们将配置它来显示一个定制的web页面，该页面显示已部署映像的版本。通过将版本显示为网页，我们可以观察到被导向canary版本的web流量的百分比在增加。</p>

<h4 id="the-variables">变量</h4>

<p>我们将从定义一些将被部署过程使用的变量开始。</p>

<table class="table" octopus.action.kubernetescontainers.configmapname="">
<thead>
<tr>
<th>可变的</th>
<th>目的</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>部署命名新</td>
<td>新(或金丝雀)部署资源的名称</td>
<td>httpd-新</td>
</tr>
<tr>
<td>部署名称前一个</td>
<td>先前部署资源的名称</td>
<td>httpd-以前的</td>
</tr>
<tr>
<td>新交通</td>
<td>要定向到新部署资源的流量</td>
<td>100(作用于<code>Canary 100%</code>环境)，75(作用于<code>Canary 75%</code>环境)，25(作用于<code>Canary 25%</code>环境)</td>
</tr>
<tr>
<td>以前的交通</td>
<td>新交通的对立面</td>
<td>0(作用于<code>Canary 100%</code>环境)、25(作用于<code>Canary 75%</code>环境)、75(作用于<code>Canary 25%</code>环境)</td>
</tr>
<tr>
<td>章鱼。action . kubernetescontainers . configmapname template</td>
<td>生成使用部署资源创建的ConfigMap资源名称的自定义模板</td>
<td>#-http canary</td>
</tr>
<tr>
<td>previousreplicaccount</td>
<td>上一次部署的pod计数</td>
<td>1，0(作用于<code>Canary 100%</code>环境)</td>
</tr>
<tr>
<td>章鱼打印评估变量</td>
<td>允许在日志中显示变量</td>
<td>False(但是如果需要额外的调试，可以设置为True)</td>
</tr>
</tbody>
</table>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/variables.png" class="zoom" data-title=""><img src="../Images/82dcf8cfa49ab73e9b3e3295d8117b71.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/variables.png"/>T2】</a></p>

<h4 id="create-the-target">创建目标</h4>

<p>流程的第一步是<code>Run a kubectl CLI Script</code>步骤。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/run-kubectl.png" class="zoom" data-title=""><img src="../Images/5d49b90fb5480330d186b97d7b531fab.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/run-kubectl.png"/>T2】</a></p>

<p>这一步的目的是创建一个Kubernetes目标，其权限仅限于单个名称空间。我们将使用这个新的Kubernetes目标来部署组成应用程序的资源，而不是总是使用管理帐户来部署资源。使用受限帐户给了我们一定程度的安全性，并限制了错误配置的步骤可能在我们的集群中造成的潜在损害。</p>

<p>话虽如此，这一步是与管理Kubernetes目标一起运行的，因为我们必须从某个地方开始。</p>

<p>下面的PowerShell代码用于创建Kubernetes服务帐户，提取用帐户创建的令牌，使用令牌创建Octopus令牌帐户，并使用令牌帐户创建Kubernetes目标。</p>

<pre><code># The account name is the project and tenant
$projectNameSafe = $($OctopusParameters["Octopus.Project.Name"] -replace "[^A-Za-z0-9]","")
$accountName = if (![string]::IsNullOrEmpty($OctopusParameters["Octopus.Deployment.Tenant.Id"])) {
    $projectNameSafe + "-" + `
    $($OctopusParameters["Octopus.Deployment.Tenant.Name"] -replace "[^A-Za-z0-9]","")
} else {
    $projectNameSafe
}

# The namespace is the account name, but lowercase
$namespace = $accountName.ToLower()
# The project name is used for a number of k8s names, which must be lowercase
$projectNameSafeLower = $projectNameSafe.ToLower()
#Save the namespace for other steps
Set-OctopusVariable -name "Namespace" -value $namespace
Set-OctopusVariable -name "AccountName" -value $accountName

Set-Content -Path serviceaccount.yml -Value @"
---
kind: Namespace
apiVersion: v1
metadata:
  name: $namespace
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: $projectNameSafeLower-deployer
  namespace: $namespace
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: $namespace
  name: $projectNameSafeLower-deployer-role
rules:
- apiGroups: ["", "extensions", "apps"]
  resources: ["deployments", "replicasets", "pods", "services", "ingresses", "secrets", "configmaps", "namespaces"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
- apiGroups: ["voyager.appscode.com"]
  resources: ["ingresses"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: $projectNameSafeLower-deployer-binding
  namespace: $namespace
subjects:
- kind: ServiceAccount
  name: $projectNameSafeLower-deployer
  apiGroup: ""
roleRef:
  kind: Role
  name: $projectNameSafeLower-deployer-role
  apiGroup: ""
"@

kubectl apply -f serviceaccount.yml

$data = kubectl get secret $(kubectl get serviceaccount "$projectNameSafeLower-deployer" -o jsonpath="{.secrets[0].name}" --namespace=$namespace) -o jsonpath="{.data.token}" --namespace=$namespace
$Token = [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String($data))

New-OctopusTokenAccount `
    -name $accountName `
    -token $Token `
    -updateIfExisting

New-OctopusKubernetesTarget `
    -name $accountName `
    -clusterUrl #{Octopus.Action.Kubernetes.ClusterUrl} `
    -octopusRoles "HTTPD" `
    -octopusAccountIdOrName $accountName `
    -namespace $namespace `
    -updateIfExisting `
    -skipTlsVerification True
</code></pre>

<p>运行该脚本的结果是一个名为<code>HTTPDCanary</code>(在项目名称之后)的新Kubernetes目标，其角色<code>HTTPD</code>定位于Kubernetes名称空间<code>httpdcanary</code>(也在项目名称之后，但是小写，因为Kubernetes在其名称中只允许小写字符)。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/target.png" class="zoom" data-title=""><img src="../Images/22486a2cbef424a372db40d4144fd273.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/target.png"/>T2】</a></p>

<p>PowerShell函数<code>New-OctopusKubernetesTarget</code>只有在运行它的环境允许动态目标时才起作用，这就是为什么我们的<code>Canary ##%</code>环境被配置为允许动态目标。</p>


<h4 id="create-the-previous-deployment-resource">创建以前的部署资源</h4>

<p>第二步是<code>Deploy Kubernetes containers</code>步骤。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deploy-container-step.png" class="zoom" data-title=""><img src="../Images/075e637a29a8628818602cd094bf6731.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deploy-container-step.png"/>T2】</a></p>

<p>我们将使用这一步来部署应用程序的“稳定”版本。这是金丝雀版本最终将取代的版本。</p>

<p>这一步将代表角色为<code>HTTPD</code>的任何目标运行，正如您在上一步中回忆的那样，这是我们分配给新Kubernetes目标的角色。通过在有限的Kubernetes目标的上下文中执行部署，我们可以确保我们的部署步骤不能删除或修改名称空间<code>httpdcanary</code>之外的任何内容。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/on-behalf-of.png" class="zoom" data-title=""><img src="../Images/9d69044dc51975e351f0e443b888d01e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/on-behalf-of.png"/>T2】</a></p>

<p><code>Deployment</code>部分为部署资源配置一些高级细节。</p>

<p><code>Deployment name</code>字段引用了我们之前配置的<code>DeploymentNamePrevious</code>变量。</p>

<p><code>Replica</code>字段引用了<code>PreviousReplicaCount</code>变量。默认情况下，<code>PreviousReplicaCount</code>变量设置为1，当部署到<code>Canary 100%</code>环境时，设置为0。这是因为<code>Canary 100%</code>环境会将所有流量导向新版本的应用程序，而以前的版本不再需要任何Pod资源，因为它们不会接收任何流量。</p>

<p>我们还定义了一个标签，键为<code>app</code>，值为<code>httpd</code>。此处定义的标签将应用于部署资源和部署资源创建的Pod资源。稍后将使用这些标签从服务资源中选择pod。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment.png" class="zoom" data-title=""><img src="../Images/837e79eba1364bc8efa2ff55d0ee3670.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment.png"/>T2】</a></p>

<p><code>Deployment strategy</code>部分保留了默认选项<code>Recreate deployments</code>。</p>

<p>实际上，部署策略的选择在我们的部署中不起作用，因为我们不是就地更新部署资源，而是并排部署两个资源。我们正在自己实现canary部署模式，而不是使用Kubernetes提供的标准模式。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-strategy.png" class="zoom" data-title=""><img src="../Images/f856335868f542ecf692fb7b23a159dd.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-strategy.png"/>T2】</a></p>

<p>在<code>Volumes</code>部分，我们需要将一个项目从我们稍后将创建的名为<code>index</code>的配置映射映射到一个名为<code>index.html</code>的文件。ConfigMap将保存一些自定义内容，这些内容作为一个名为<code>index.html</code>的文件暴露给我们的容器，这个文件将由HTTPD提供。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/volumes.png" class="zoom" data-title=""><img src="../Images/854af7564b7be22f16c9a892e6cb4043.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/volumes.png"/>T2】</a></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/volumes2.png" class="zoom" data-title=""><img src="../Images/034e476a50a080fcace9641ff8c944f9.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/volumes2.png"/>T2】</a></p>

<p>接下来是<code>Containers</code>部分，我们在这里添加一个容器。</p>

<p>容器和映像部署都被称为<code>httpd</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/image.png" class="zoom" data-title=""><img src="../Images/ab5e45d941c1dd6137eee7d56e6794a2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/image.png"/>T2】</a></p>

<p>作为web服务器，HTTPD公开了80端口。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/ports.png" class="zoom" data-title=""><img src="../Images/69685787fcc10033572f6739b99fb27c.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/ports.png"/>T2】</a></p>

<p>在容器内部，我们将前面定义的卷挂载到路径<code>/usr/local/apache2/htdocs</code>。这条路就是HTTPD寻找内容的地方。因为我们将名为<code>index</code>的ConfigMap项公开为名为<code>index.html</code>的文件，所以我们最终在容器中装载了一个名为<code>/usr/local/apache2/htdocs/index.html</code>的文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/volume-mount.png" class="zoom" data-title=""><img src="../Images/9aaf48811672f76910c55657cdfabf82.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/volume-mount.png"/>T2】</a></p>

<p>设置好这些值后，我们将看到如下所示的容器摘要。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/container-summary.png" class="zoom" data-title=""><img src="../Images/a14faf352521ac947c4e7e0bd968ed13.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/container-summary.png"/>T2】</a></p>

<p>在<code>Pod Annotations</code>部分，我们用变量<code>PreviousTraffic</code>的值定义了一个名为<code>ingress.appscode.com/backend-weight</code>的注释。<code>PreviousTraffic</code>变量可以是<code>0</code>、<code>25</code>或<code>75</code>，这取决于我们要部署到的环境。</p>

<p>Voyager入口控制器将该注释<a href="https://appscode.com/products/voyager/5.0.0/guides/ingress/http/blue-green-deployment/" rel="nofollow">识别为定义发送给Pod资源的流量。</a></p>

<p>因此，当部署到<code>Canary 25%</code>环境时，<code>PreviousTraffic</code>被设置为<code>75</code>，这意味着先前的部署将接收75%的流量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/pod-annotations.png" class="zoom" data-title=""><img src="../Images/6eafdaf1ab967572ef2eff9031d10ea8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/pod-annotations.png"/>T2】</a></p>

<p>在ConfigMap特性中，我们构建了最终将为<code>index.html</code>文件提供内容的ConfigMap资源。</p>

<p>ConfigMap的名称被设置为<code>#{DeploymentNamePrevious}-configmap</code>，我们添加一个名为<code>index</code>的条目，其值为<code>#{Octopus.Action[HTTPD Old].Package[httpd].PackageVersion}</code>。</p>

<p>变量<code>Octopus.Action[HTTPD Old].Package[httpd].PackageVersion</code>将保存这个容器正在部署的httpd映像的版本。因此，如果HTTPD提供的文件包含Docker映像的版本，我们将会看到什么。这篇<a href="https://octopus.com/blog/octopus-release-2018.8">博客</a>文章有更多关于这些变量的信息。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/configmap-previous.png" class="zoom" data-title=""><img src="../Images/225286ab20def1f697075ae9a04ca754.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/configmap-previous.png"/>T2】</a></p>

<h4 id="configmap-name-templates">配置映射名称模板</h4>

<p>如果你回头看看我们添加到这个项目中的变量，你会注意到我们定义了一个名为<code>Octopus.Action.KubernetesContainers.ConfigMapNameTemplate</code>的变量。此变量会影响部署期间管理此配置图的方式。</p>

<p>通常Octopus环境是独立的，用于表示从测试到生产的不同过程。也就是说，部署到测试环境不会影响生产环境，反之亦然。</p>

<p>我们在这里使用的环境略有不同。我们的环境代表的不是截然不同的独立环境，而是被导向新版本或金丝雀版本的流量的逐渐变化。</p>

<p>这是一个微妙但重要的区别，因为这意味着<code>Canary 25%</code>环境和<code>Canary 75%</code>环境是同一个逻辑环境。这意味着对<code>Canary 75%</code>环境的部署会覆盖对<code>Canary 25%</code>环境的部署。</p>

<p>然而，Kubernetes的步骤是在假设环境各不相同的情况下配置的。这个假设的一个含义是，当我们将ConfigMap资源作为容器步骤的一部分部署到<code>Canary 25%</code>环境时，它将具有唯一的名称，当我们再次将ConfigMap部署到<code>Canary 75%</code>环境时，该名称不会被覆盖。当您从测试转移到生产时，不覆盖资源通常是有意义的，但是在我们的例子中，我们确实希望覆盖资源。</p>

<p>通过为每个部署提供一个唯一的名称，可以防止覆盖ConfigMap资源。默认情况下，这个惟一的名称是通过在名称末尾附加Octopus部署ID生成的。</p>

<p>例如，我们给配置映射命名为<code>#{DeploymentNamePrevious}-configmap</code>，它将解析为名称<code>http-previous-configmap</code>。在部署过程中，这个名称与部署ID结合起来产生一个唯一的名称，如<code>http-previous-configmap-deployment-1234</code>。</p>

<p>然而，我们不需要唯一的名称。我们希望名称在我们的canary环境之间是相同的，因此资源将被覆盖。</p>

<p>这就是我们将<code>Octopus.Action.KubernetesContainers.ConfigMapNameTemplate</code>变量设置为<code>#{Octopus.Action.KubernetesContainers.ConfigMapName}-httpdcanary</code>的原因。这将覆盖附加部署ID的默认行为，而是附加固定字符串<code>httpdcanary</code>。</p>

<p>这意味着我们的canary环境每次都会部署一个名为<code>http-previous-configmap-httpdcanary</code>的ConfigMap资源。而且因为名称不再唯一，所以在每个环境中都会被覆盖。</p>

<p>我们这样做是为了防止旧的未使用的ConfigMap资源填满我们的名称空间。通过在环境之间使用公共名称，我们最终为每个部署资源提供一个配置图。</p>

<h4 id="create-the-canary-deployment-resource">创建Canary部署资源</h4>

<p>第三步几乎是第二步的完全复制。在这里，我们部署了代表canary版本的部署资源。</p>

<p>由于这一步与上一步非常相似，所以我将在这里强调不同之处。</p>

<p>将<code>Deployment name</code>设置为<code>#{DeploymentNameNew}</code>，将<code>Replicas</code>设置为固定值<code>1</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-new.png" class="zoom" data-title=""><img src="../Images/89f11bb5a3b704213c664e83d2219dd5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-new.png"/>T2】</a></p>

<p><code>Pod Annotations</code>值被设置为<code>#{NewTraffic}</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/pod-annotations-new.png" class="zoom" data-title=""><img src="../Images/2d241dd3b36b011695efbc0e34c99fc9.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/pod-annotations-new.png"/>T2】</a></p>

<p>配置图名称设置为<code>#{DeploymentNameNew}-configmap</code>，项目值设置为<code>#{Octopus.Action[HTTPD New].Package[httpd].PackageVersion}</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/configmap-new.png" class="zoom" data-title=""><img src="../Images/e353b1c98b6cbefa49a436b6f60af9b6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/configmap-new.png"/>T2】</a></p>

<p>否则，容器、卷和部署策略的配置与上一步相同。</p>

<h4 id="the-service">服务</h4>

<p>第四步是用<code>Deploy Kubernetes service resource</code>步骤创建一个服务资源。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-step.png" class="zoom" data-title=""><img src="../Images/72664d10fe50a9875e80d71cab789f89.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-step.png"/>T2】</a></p>

<p>与之前的容器步骤一样，这个步骤部署在具有<code>HTTPD</code>角色的目标的上下文中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-on-behalf-of.png" class="zoom" data-title=""><img src="../Images/06295179c0d3b5c488990894a6abfff1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-on-behalf-of.png"/>T2】</a></p>

<p>我们将该服务命名为<code>httpd-service</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-name.png" class="zoom" data-title=""><img src="../Images/650e6f12fc271c27c3bac54c4789da53.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-name.png"/>T2】</a></p>

<p>将<code>Service Type</code>设置为<code>Cluster IP</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/cluster-ip.png" class="zoom" data-title=""><img src="../Images/f06f435577e80cc0f22dedc8b8d983f5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/cluster-ip.png"/>T2】</a></p>

<p>该服务接受流量并将流量定向到端口80。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-port.png" class="zoom" data-title=""><img src="../Images/ec9ba048987b839568ec538a2cbd79d7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-port.png"/>T2】</a></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-port-summary.png" class="zoom" data-title=""><img src="../Images/9a739e6bf808ca16d7ec549dbc887429.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-port-summary.png"/>T2】</a></p>

<p>该服务通过将<code>Service Selector Labels</code>设置为名称<code>app</code>和值<code>httpd</code>来选择它将流量导向的Pod资源。这些是我们在前面的容器步骤中定义的相同标签。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-label-selectors.png" class="zoom" data-title=""><img src="../Images/c07835f46a34df98ef3ed4a9950d88b7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/service-label-selectors.png"/>T2】</a></p>

<h4 id="the-voyager-ingress-resource">旅行者号入口资源</h4>

<p>第五步也是最后一步是定义航海家号的入口资源。这个资源不是标准的Kubernetes资源，所以我们不能使用Octopus中的标准入口步骤来部署它。相反，我们再次使用<code>Run a kubectl CLI Script</code>步骤保存一个YAML文件，并用<code>kubectl</code>命令应用它。</p>

<pre><code class="language-PowerShell">Set-Content -Path "ingress.yaml" -Value @"
apiVersion: voyager.appscode.com/v1beta1
kind: Ingress
metadata:
  name: httpd-ingress
spec:
  backend:
    serviceName: httpd-service
    servicePort: "80"
"@

kubectl apply -f ingress.yaml
</code></pre>

<h2 id="deploying-the-project">部署项目</h2>

<p>让我们创建这个项目的部署。作为部署的一部分，我们有机会选择将作为部署资源的一部分进行部署的Docker映像的版本。</p>

<p>这里我把旧的或者以前的版本设置为<code>2.4.18</code>。在本例中，该版本代表部署的最后一个稳定版本。</p>

<p>然后我将新的或淡黄色的版本设置为<code>2.4.20</code>。这代表了我想要逐步推出的应用程序的新版本，以检查任何可能的问题。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/versions.png" class="zoom" data-title=""><img src="../Images/10361bc73c5a136500088fd036e24035.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/versions.png"/>T2】</a></p>

<p>然后，我们将把它部署到<code>Canary 25%</code>环境中。</p>

<h2 id="what-have-we-just-deployed">我们刚刚部署了什么？</h2>

<p>仅仅配置这些步骤，就很难理解我们到底在部署什么。一旦我们将这个项目部署到<code>Canary 25%</code>环境中，我们将得到这样的结果:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-overview.jpg" class="zoom" data-title=""><img src="../Images/ef29076b0a701cbf721418ea79453253.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-overview.jpg"/>T2】</a></p>

<p>Voyager入口资源将流量定向到服务资源，服务资源又将流量定向到两个部署资源(或者从技术上讲，由部署资源创建的Pod资源)。</p>

<p>由于Pod资源上的<code>ingress.appscode.com/backend-weight</code>注释，Voyager知道将25%的流量导向金丝雀Pod资源，75%导向先前的Pod资源。</p>

<p>一旦部署，每个Voyager入口资源创建一个相关的负载平衡器服务资源。这个负载平衡器有一个公共IP地址，我们可以从浏览器访问它。在我的情况下，公共IP是35.194.2.130。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/loadbalancer.png" class="zoom" data-title=""><img src="../Images/3ac0d111fc35a3483d1712ecc6c5b08d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/loadbalancer.png"/>T2】</a></p>

<p>在浏览器中打开此页面会显示为该页面提供服务的HTTPD版本。</p>

<p>我的第一个页面显示的是版本<code>2.4.20</code>。这意味着我被引导到金丝雀豆荚资源。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/canary-web-page.png" class="zoom" data-title=""><img src="../Images/93d07865a486b1103289411d20cb55ed.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/canary-web-page.png"/>T2】</a></p>

<p>刷新后，我看到了版本<code>2.4.18</code>。这意味着我被引导到以前的Pod资源。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/previous-web-page.png" class="zoom" data-title=""><img src="../Images/546587a5adcf76435578e29c552add53.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/previous-web-page.png"/>T2】</a></p>

<p>当我一次又一次刷新页面时，我看到的版本<code>2.4.18</code>比看到的<code>2.4.20</code>多。这证实了大部分的流量都被导向以前版本的HTTPD，只有25%被导向金丝雀豆荚。</p>

<p>如您所料，将部署提升到<code>Canary 75%</code>环境会逆转流量比例。现在75%的流量被导向金丝雀豆荚资源。</p>

<p>提升到<code>Canary 100%</code>环境就完成了我们的部署。所有流量都被发送到canary Pods，并且之前的Pod资源已被移除，因为在<code>Canary 100%</code>环境中<code>Replicas</code>值为0。</p>

<h2 id="reverting-a-deployment">恢复部署</h2>

<p>将canary部署表示为Octopus环境的好处是，我们可以恢复到以前的状态。比方说，在部署到<code>Canary 75%</code>环境之后，您开始看到在部署到<code>Canary 25%</code>环境时不存在的网络中断。</p>

<p>要回滚到<code>Canary 25%</code>环境，在Octopus中打开部署并从垂直菜单中选择<code>Deploy to</code>选项。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deploy-to.png" class="zoom" data-title=""><img src="../Images/261acab9c9de0b684cff6464638783eb.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deploy-to.png"/>T2】</a></p>

<p>选择<code>Canary 25%</code>环境并点击<code>Deploy</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/redeploy.png" class="zoom" data-title=""><img src="../Images/204cd0fd8e0f55d40377f2535e63b6ba.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/redeploy.png"/>T2】</a></p>

<p>Octopus然后将重新运行部署，这又会将canary部署恢复到25%的流量被定向到新版本的状态。</p>

<h2 id="starting-the-next-canary-deployment">开始下一次金丝雀部署</h2>

<p>一旦我们部署到<code>Canary 100%</code>环境，我们的Kubernetes集群看起来就像这样:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-100.jpg" class="zoom" data-title=""><img src="../Images/99bd815b942da6dfa9597ddabd7df97b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/deployment-100.jpg"/>T2】</a></p>

<p>100%的流量被发送到canary Pod资源，而之前的Pod资源已缩减为0。</p>

<p>让我们开始部署新版本。现在我们的老版本或者以前的版本就是<code>2.4.20</code>的最后一个金丝雀版本。新的或金丝雀版本是<code>2.4.23</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/versions2.png" class="zoom" data-title=""><img src="../Images/2cc7a8ec12bd1a3c4d2810e6ffbf5b06.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/kubernetes-canary-deployments/versions2.png"/>T2】</a></p>

<p>这一新部署将:</p>

<ol>
<li>使用版本<code>2.4.20</code>部署先前的部署资源(目前缩减为0)。注释将此部署配置为接收75%的流量。</li>
<li>用新版本的<code>2.4.23</code>部署当前配置有版本<code>2.4.20</code>的canary部署资源。注释将此部署配置为接收25%的流量。</li>
<li>服务和航海家号入口资源在这一点上保持不变。</li>
</ol>

<p>第二次部署的好处是没有太多的停机时间。在进行步骤1中的部署时，旧的canary部署仍在为流量提供服务。在进行步骤2的部署时，步骤1中的部署正在为流量提供服务。在步骤3之后，所有流量都根据分配的百分比进行路由。</p>

<h2 id="summary">摘要</h2>

<p>在这篇文章中，我们看了如何配置Octopus和Voyager Ingress控制器，以在Kubernetes中提供金丝雀部署。</p>

<p>通过将canary部署的进展建模为环境，我们创建了一个解决方案，可以将流量增量增加到canary版本，同时提供回滚到以前状态的可能性。</p>

                    
                    
</body>
</html>