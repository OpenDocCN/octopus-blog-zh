<html>
<head>
<title>Running manual tests against cloud infrastructure deployed by Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>针对Octopus - Octopus Deploy部署的云基础架构运行手动测试</h1>
<blockquote>原文：<a href="https://octopus.com/blog/running-tests#2021-08-12">https://octopus.com/blog/running-tests#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/blogimage-runningtests.png" class="zoom" data-title=""><img src="../Images/9ccd40711a3aa321596a3138c768b367.png" class="img-fluid center" alt="Octopus Professor running tests in a lab with chemicals and beakers" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/blogimage-runningtests.png"/>T2】</a></p>

<p>今年悉尼NDC会议期间出现的一个问题是，如何针对以前在各种环境中的部署运行UI测试。测试不一定是部署过程的一部分，但是可以手动运行或者按照单独的时间表运行。尽管不是这样的部署，但从Octopus运行测试将会很方便，因为Octopus拥有关于应用程序部署位置的所有信息。</p>

<p>所以从高层次来看，问题是这样的:</p>

<ol>
<li>将应用程序部署到环境中。</li>
<li>部署会产生一个URL。</li>
<li>在部署完成后的某个时间点，开始对最后一次部署进行UI测试。</li>
</ol>

<p>为了演示这个用例，我们将首先向AWS部署一个CloudFormation模板，它创建一个带有公共IP地址的EC2实例。EC2实例将运行Tomcat来模拟可测试的web服务器。</p>

<p>下面的YAML文件可以和<code>Deploy an AWS CloudFormation template</code>步骤一起使用来启动一个安装了Tomcat 8的Ubuntu实例。</p>

<pre><code class="language-yaml">AWSTemplateFormatVersion: 2010-09-09
Parameters:
  InstanceTypeParameter:
    Type: String
    Default: m3.medium
    AllowedValues:
      - t1.micro
      - t2.nano
      - t2.micro
      - t2.small
      - t2.medium
      - t2.large
      - m1.small
      - m1.medium
      - m1.large
      - m1.xlarge
      - m2.xlarge
      - m2.2xlarge
      - m2.4xlarge
      - m3.medium
      - m3.large
      - m3.xlarge
      - m3.2xlarge
      - m4.large
      - m4.xlarge
      - m4.2xlarge
      - m4.4xlarge
      - m4.10xlarge
      - c1.medium
      - c1.xlarge
      - c3.large
      - c3.xlarge
      - c3.2xlarge
      - c3.4xlarge
      - c3.8xlarge
      - c4.large
      - c4.xlarge
      - c4.2xlarge
      - c4.4xlarge
      - c4.8xlarge
      - g2.2xlarge
      - g2.8xlarge
      - r3.large
      - r3.xlarge
      - r3.2xlarge
      - r3.4xlarge
      - r3.8xlarge
      - i2.xlarge
      - i2.2xlarge
      - i2.4xlarge
      - i2.8xlarge
      - d2.xlarge
      - d2.2xlarge
      - d2.4xlarge
      - d2.8xlarge
      - hi1.4xlarge
      - hs1.8xlarge
      - cr1.8xlarge
      - cc2.8xlarge
      - cg1.4xlarge
    Description: Enter instance size. Default is m3.medium.
  AMI:
    Type: String
    Default: ami-ea9b6597
    Description: AMI Image
Resources:
  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22, and open web port 8080
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: '22'
        ToPort: '22'
        CidrIp: '0.0.0.0/0'
      - IpProtocol: tcp
        FromPort: '8080'
        ToPort: '8080'
        CidrIp: '0.0.0.0/0'
  Ubuntu:
    Type: 'AWS::EC2::Instance'
    Properties:
      ImageId: !Ref AMI
      InstanceType:
        Ref: InstanceTypeParameter
      KeyName: DukeLegion
      SecurityGroups:
        - Ref: InstanceSecurityGroup
      Tags:
        -
          Key: Name
          Value: Ubuntu with Tomcat
      UserData:
        Fn::Base64: |
          #cloud-boothook
          #!/bin/bash
          sudo apt-get update
          sudo apt-get install -y tomcat8
          sudo service tomcat8 start
Outputs:
  PublicIp:
    Value:
      Fn::GetAtt:
      - Ubuntu
      - PublicIp
    Description: Server's PublicIp Address
</code></pre>

<p>下面是章鱼里的步骤截图。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/step-screenshot.png" class="zoom" data-title=""><img src="../Images/f662ebf5b0d39c5f41d8d6e83e3cfbe1.png" class="img-fluid center" alt="Step Screenshot" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/step-screenshot.png"/>T2】</a></p>

<p>运行这个步骤会导致新EC2实例的公共IP被保存为一个变量。在该步骤生成的日志输出中，您可以看到文本<code>Saving variable "Octopus.Action[Deploy Tomcat].Output.AwsOutputs[PublicIp]"</code>，它记录了如何访问该变量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/log-output.png" class="zoom" data-title=""><img src="../Images/446ee7a517b3e4718e8899528d157399.png" class="img-fluid center" alt="Log output" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/log-output.png"/>T2】</a></p>

<p>这样的变量在后续步骤中很容易消耗。但是在这个用例中，我们希望在以后访问这些变量，而不是作为当前部署的一部分。</p>

<p>为了演示使用从以前的部署中生成的URL运行测试，我们将创建第二个Octopus项目。该项目将包含以下Powershell的单个脚本步骤。这个脚本利用Octopus客户端库来查询部署的细节。</p>

<p>虽然在这个例子中这段代码是在Octopus中运行的，但是如果需要的话，它也可以在外部运行。只是要确保提供<code>$ServerUrl</code>、<code>$ApiKey</code>和<code>$OctopusParameters["Octopus.Environment.Name"]</code>变量的替代变量，因为这些变量是由Octopus提供的。</p>

<pre><code class="language-PowerShell">[Reflection.Assembly]::LoadFrom("Octopus.Client\lib\net45\Octopus.Client.dll")

$endpoint = new-object Octopus.Client.OctopusServerEndpoint($ServerUrl, $ApiKey)
$repository = new-object Octopus.Client.OctopusRepository($endpoint)

$project = $repository.Projects.FindByName("Deploy EC2 Tomcat");
$env = $repository.Environments.FindByName($OctopusParameters["Octopus.Environment.Name"]);
$progression = $repository.Projects.GetProgression($project);
$item = $progression.Releases |
    % { $_.Deployments.Values } |
    % { $_ } |
    ? { $_.EnvironmentId -eq $env.Id } |
    Sort-Object -Property CompletedTime -Descending |
    Select-Object -first 1

$deployment = $repository.Deployments.Get($item.DeploymentId);
$variables = $repository.VariableSets.Get($deployment.ManifestVariableSetId);
$publicIp = $variables.Variables |
    ? {$_.Name.Contains("Octopus.Action[Deploy Tomcat].Output.AwsOutputs[PublicIp]")}  |
    Select-Object -first 1

Write-Host "$($publicIp.Name) $($publicIp.Value)"

invoke-webrequest "http://$($publicIp.Value):8080" -DisableKeepAlive -UseBasicParsing -Method head
</code></pre>

<p>注意，我们已经加载了代码为<code>[Reflection.Assembly]::LoadFrom("Octopus.Client\lib\net45\Octopus.Client.dll")</code>的Octopus客户端库。这个dll文件已经被Octopus 2018.8中的一个新特性暴露了，这个特性就是<a href="https://octopus.com/blog/script-step-packages">允许在一个脚本步骤</a>中包含额外的包。我们利用这一点来下载<code>Octopus.Client</code>包并将其解压缩，这样我们的Powershell代码就可以加载dll了。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/additional-package.png" class="zoom" data-title=""><img src="../Images/2f0ace89d6be4de1baf35e23adffd795.png" class="img-fluid center" alt="Additional package" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/additional-package.png"/>T2】</a></p>

<p>项目中定义了<code>$ServerUrl</code>和<code>$ApiKey</code>变量。您可以从<a href="https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key">文档</a>中找到关于生成API密钥的更多信息。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/variables.png" class="zoom" data-title=""><img src="../Images/abbc8f5ca5e2ddacfe8f197192e580c4.png" class="img-fluid center" alt="Variables" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/variables.png"/>T2】</a></p>

<p>为了方便起见，您可能希望能够在任何时候针对任何环境运行该脚本。典型的Octopus生命周期包括在投入生产之前通过测试和内部环境进行部署。当运行一个测试时，你可能想直接在生产中运行它。</p>

<p>为了实现这一点，我们创建了一个包含所有环境的单一阶段的生命周期。这意味着部署过程可以以任何顺序针对任何环境。</p>

<p>在下面的截图中，我们有名为<code>Standard Lifecycle</code>的应用程序部署生命周期和名为<code>Standard Lifecycle Unrestricted</code>的测试生命周期。请注意，无限制的生命周期将所有环境都放在一个阶段中。</p>

<p>您可以在<a href="https://octopus.com/docs/deployment-process/lifecycles">文档</a>中找到关于生命周期的更多信息。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/lifecycles.png" class="zoom" data-title=""><img src="../Images/f13c0daea6c78dcb048a14ace387b2f1.png" class="img-fluid center" alt="Lifecycles" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/lifecycles.png"/></a>T2】</p>

<p>这种不受限制的生命周期的效果是，您会得到一个要部署到的环境的下拉列表。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/deployto.png" class="zoom" data-title=""><img src="../Images/69698ea0658fed44f93085e9052d8b05.png" class="img-fluid center" alt="Deploy to" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/deployto.png"/>T2】</a></p>

<p>在这一点上，我们可以在任何时候针对任何环境部署测试脚本。Powershell代码将询问最后一次部署，以找到EC2实例的IP地址，并将其用作测试的目标。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/running-tests/test-results.png" class="zoom" data-title=""><img src="../Images/7cc8aba18001ce608e89883d1d9a5f80.png" class="img-fluid center" alt="Test results" data-original-src="https://i.octopus.com/blog/2018-09/running-tests/test-results.png"/>T2】</a></p>

<p>这是一个简单的例子，展示了如何获取以前的部署细节来运行一个简单的网络测试。但是你还可以做更多的事情。一些例子可能是:</p>

<ul>
<li>使用不同地区的<a href="https://octopus.com/docs/infrastructure/workers/worker-pools">工人池</a>来模拟来自国际客户的连接测试。</li>
<li>使用<a href="https://octopus.com/docs/deployment-process/project-triggers/scheduled-project-trigger">预定触发器</a>运行自动化测试。</li>
<li>使用<a href="https://octopus.com/docs/deployment-process/conditions#run-condition">步骤条件</a>生成松弛时间或电子邮件通知，以报告测试中的任何错误。</li>
</ul>

                    
                    
</body>
</html>