<html>
<head>
<title>Java CI/CD: From Continuous Integration to Kubernetes deployments - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Java CI/CD:从持续集成到Kubernetes部署——Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/java-ci-cd-co/from-ci-to-cloud#2021-08-12">https://octopus.com/blog/java-ci-cd-co/from-ci-to-cloud#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/blogimage-java-blog-series-4.png" class="zoom" data-title=""><img src="../Images/95949a4f84b72dc99ad0a0ba6e20be97.png" class="img-fluid center" alt="Java CI/CD: From Continuous Integration to Kubernetes deployments" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/blogimage-java-blog-series-4.png"/>T2】</a></p>

<p>本文是展示Jenkins、Docker和Octopus示例部署管道系列的一部分:</p>



<p><a href="/blog/java-ci-cd-co/from-local-to-ci">在之前的博文</a>中，我们用Jenkins配置了一个CI服务器，它提供了一个中心位置来构建和发布我们的Docker映像。该映像现在可以从Docker Hub公开获得，下一步是创建可以托管我们的Docker容器的基础设施。</p>

<p>在本文中，我们将从Octopus的AWS中创建一个弹性Kubernetes服务(EKS)实例。</p>

<h2 id="getting-an-octopus-cloud-instance">获取Octopus云实例</h2>

<p>我们将使用Octopus编写EKS星团的创建脚本。获得Octopus的最简单方法是注册一个免费的Octopus Cloud实例。启动并运行一个实例只需要几分钟时间。</p>

<p>第一步是在Octopus中创建一个AWS帐户，该帐户将用于创建并连接到EKS集群。AWS帐户由帐户密钥和密钥组成:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/awsaccount.png" class="zoom" data-title=""> <img src="../Images/765ac265ff95722419ff4ed87881ef73.png" class="img-fluid center" alt="An example AWS account" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/awsaccount.png"/> </a> <em>一个AWS账户的例子。</em></p>

<p>名为<strong>eks CTL-Create Cluster(bash)</strong>的社区步骤可以添加到runbook中，以便在Octopus中快速创建EKS集群和相关的Kubernetes目标。该脚本执行<a href="https://aws.amazon.com/blogs/opensource/eksctl-eks-cli/" rel="nofollow"> EKS CLI工具</a>来创建EKS集群:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/steptile.png" class="zoom" data-title=""> <img src="../Images/41d2bde6a29b42050b6b3191738d1243.png" class="img-fluid center" alt="The community step to create an EKS cluster" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/steptile.png"/> </a> <em>社区一步创建一个EKS集群。</em></p>

<p>为了方便使用<strong> ekscli </strong>工具，Octopus支持基于图像在Docker容器内运行一个步骤，并且<a href="https://hub.docker.com/r/octopusdeploy/worker-tools" rel="nofollow">为图像</a>提供了广泛的常用云工具选择，包括<strong> ekscli </strong>。</p>

<p>要使用Octopus Cloud中的Docker映像，我们需要选择Ubuntu动态工作器:</p>
<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/ubuntu-dynamic-workers.png" class="zoom" data-title=""><img src="../Images/558450837e9b0ffd9fbaa5c3397e7ea1.png" class="img-fluid center" alt="Ubuntu dynamic workers" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/ubuntu-dynamic-workers.png"/>T2】</a></p>


<p>为了使用工人工具图像，我们在<strong>容器图像</strong>部分选择它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/worker-tools.png" class="zoom" data-title=""><img src="../Images/d03913b677baff7854ba8497b2bcc64b.png" class="img-fluid center" alt="Selecting the worker tools image" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/worker-tools.png"/>T2】</a></p>

<p>用要创建的EKS集群的详细信息填充该步骤。对于本例，下面的<strong> eksctl配置</strong> YAML创建了一个包含两个t3a.small节点的集群:</p>

<pre><code class="language-YAML">apiVersion: eksctl.io/v1alpha5
kind: ClusterConfig

metadata:
  name: k8s-cluster
  region: us-east-1

nodeGroups:
  - name: ng-1
    instanceType: t3a.small
    desiredCapacity: 2
    volumeSize: 80
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/eksctl.png" class="zoom" data-title=""> <img src="../Images/693c296c2b272874e1e84d7732d10b68.png" class="img-fluid center" alt="The populated step" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/eksctl.png"/> </a> <em>人口密集的一步。</em></p>

<p>如果在<code>us-east-1</code>中出现<code>UnsupportedAvailabilityZoneException</code>错误，请尝试另一个可用区域。eksctl文档指出<code>us-east-1</code>容易出现这种错误。</p>


<p>在执行runbook之前，我们需要允许将动态创建的目标放置在目标环境中，在本例中称为<strong> Dev </strong>。启用此设置允许脚本步骤(如我们刚刚配置的社区步骤模板)创建Octopus目标:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/dynamictargets.png" class="zoom" data-title=""> <img src="../Images/f7ffa40587baf4afeaaf68ce4d40c51a.png" class="img-fluid center" alt="Enabling dynamic infrastructure in the Dev environment" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/dynamictargets.png"/> </a> <em>在开发环境中启用动态基础设施。</em></p>

<p>现在执行操作手册。当runbook完成时，一个新的Kubernetes目标被创建，我们可以将我们的应用程序部署到:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/k8starget.png" class="zoom" data-title=""> <img src="../Images/45b920113aba3f0ca37f46c2c830d110.png" class="img-fluid center" alt="The Octopus Kubernetes target" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/k8starget.png"/> </a> <em>章鱼目标。</em></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/eks.png" class="zoom" data-title=""><img src="../Images/3b36013d49841043a21f3170ce89dbcc.png" class="img-fluid center" alt="The EKS cluster" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/eks.png"/></a><em>EKS集群。</em></p>

<h2 id="create-the-docker-feed">创建Docker提要</h2>

<p>为了使用Docker图像，我们需要在Octopus中创建一个Docker提要。这个提要指向https://index.docker.io ，这是Docker Hub注册表的URL:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/dockerfeed.png" class="zoom" data-title=""> <img src="../Images/0b2618de224e4d807950c7c54415cb65.png" class="img-fluid center" alt="The Docker Hub feed in Octopus" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/dockerfeed.png"/> </a> <em>将Docker集线器馈入章鱼。</em></p>

<p>然后我们可以测试提要，以确保Octopus可以找到我们的<strong> Petclinic </strong>图像:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/testfeed.png" class="zoom" data-title=""> <img src="../Images/d0f02b3de1c20d0cddbe7888d74a7de8.png" class="img-fluid center" alt="Test the Docker feed" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/testfeed.png"/> </a> <em>测试对接器进给。</em></p>

<h2 id="deploy-the-image-to-kubernetes">将映像部署到Kubernetes</h2>

<p>现在，我们已经完成了部署到Kubernetes集群的所有配置。我们将使用<strong>部署Kubernetes容器</strong>步骤来配置Kubernetes部署资源，并通过负载平衡器服务公开它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/deployk8scontainers.png" class="zoom" data-title=""> <img src="../Images/184ca7007735e27f511124f04f871ab6.png" class="img-fluid center" alt="The Deploy Kubernetes containers step" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/deployk8scontainers.png"/> </a> <em>部署Kubernetes容器的步骤。</em></p>

<p>您可以通过两种方式与此步骤进行交互。</p>

<p>第一种方法是使用UI来构建Kubernetes部署。当您不太熟悉Kubernetes YAML酒店时，这很方便，因为您可以通过专用的表单字段构建资源。</p>

<p>使用该步骤的第二种方法是通过点击<strong>编辑YAML </strong>按钮时显示的YAML表示法来编辑值:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/edityaml.png" class="zoom" data-title=""> <img src="../Images/1c11e7f515e7ccb6b40f01ca2e964f83.png" class="img-fluid center" alt="The Edit YAML section" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/edityaml.png"/> </a> <em>编辑YAML章节。</em></p>

<p>然后，您可以直接以YAML的身份编辑部署资源，这很方便，因为复制和粘贴现有的YAML只需一个操作就可以填充该步骤。通过将下面的YAML粘贴到文本框中，我们创建了一个引用Docker映像的部署:</p>

<pre><code class="language-YAML">apiVersion: apps/v1
kind: Deployment
metadata:
  name: petclinic
spec:
  selector:
    matchLabels:
      octopusexport: OctopusExport
  replicas: 1
  strategy:
    type: RollingUpdate
    rollingUpdate: {}
  template:
    metadata:
      labels:
        octopusexport: OctopusExport
    spec:
      containers:
        - name: petclinic
          image: mcasperson/petclinic
          ports:
            - name: web
              containerPort: 8080
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/yaml.png" class="zoom" data-title=""> <img src="../Images/e2aa5835c406cf8c8df9c0ffe7d52566.png" class="img-fluid center" alt="Editing the step via YAML" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/yaml.png"/> </a> <em>通过YAML编辑步骤。</em></p>

<p>我们希望将我们的部署放在每个环境的单独名称空间中。这是通过将<strong>名称空间</strong>字段设置为<strong> petclinic-#{Octopus来实现的。Environment.Name | ToLower} </strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/namespace.png" class="zoom" data-title=""><img src="../Images/bef1f67ccc72d745bd341041a8b92bbd.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/namespace.png"/>T2】</a></p>

<p>以与配置部署相同的方式，我们可以用下面的YAML填充服务的详细信息。这个YAML创建一个负载平衡器服务，这将导致创建一个弹性负载平衡器(ELB)来公开部署。这个ELB有一个公共主机名，我们可以从我们的web浏览器访问:</p>

<pre><code class="language-YAML">apiVersion: v1
kind: Service
metadata:
  name: petclinic
spec:
  type: LoadBalancer
  ports:
    - name: web
      port: 80
      targetPort: 8080
      protocol: TCP
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/serviceyaml.png" class="zoom" data-title=""> <img src="../Images/8f68a08fa2128f9b84adb9a959227fe7.png" class="img-fluid center" alt="The service YAML" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/serviceyaml.png"/> </a> <em>为YAML服务。</em></p>

<p>有了这些设置，我们就可以部署到EKS集群了。日志显示Kubernetes部署和服务资源已成功创建:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/deployment.png" class="zoom" data-title=""> <img src="../Images/90ce778163e4b5a80d8cd6b23e4b0b7e.png" class="img-fluid center" alt="PetClinic has been successfully deployed" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/deployment.png"/> </a> <em> PetClinic已成功部署。</em></p>

<p>所以现在唯一的问题是<em>我们如何访问应用程序？</em></p>

<h2 id="query-the-cluster">查询群集</h2>

<p>我们将经常需要查询集群，以找到我们需要的信息，或者调试一个问题。通常，设置部署的人会在本地配置kubectl，并使用特定命令快速查询集群的状态。</p>

<p>虽然这是可行的，并且有时确实是必要的，但是执行这样的特别命令忽略了这样一个事实，即如果这些命令是成功完成初始部署所必需的，那么它们也可能是解决未来部署问题所必需的。</p>

<p>查找我们刚刚创建的负载平衡器的主机名就是一个很好的例子。我们可以通过多种方式获取这些信息，要么从AWS控制台获取，要么调用kubectl。然而，为了在我们完成后维护这个集群的人的利益，我们将通过另一个操作手册找到这个信息。</p>

<p>为了获得服务信息，使用名为<strong>Kubernetes-Inspect Resources</strong>的社区步骤模板创建一个runbook:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/inspectresources.png" class="zoom" data-title=""><img src="../Images/89fa6e7da0073cfac0b82ff95a7022d4.png" class="img-fluid center" alt="The Kubernetes - Inspect Resources community step template" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/inspectresources.png"/></a><em>Kubernetes-Inspect资源社区步骤模板。</em></p>

<p>配置从<strong> petclinic-#{Octopus获取服务资源的步骤。Environment.Name | ToLower} </strong>命名空间:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/getservice.png" class="zoom" data-title=""> <img src="../Images/05fb9c14567b425eff97f35d49d1e009.png" class="img-fluid center" alt="Getting the service details" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/getservice.png"/> </a> <em>获取服务详情。</em></p>

<p>运行runbook将代表我们用kubectl查询集群，在响应中显示负载平衡器的主机名:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/servicedetails.png" class="zoom" data-title=""> <img src="../Images/884d2fb5ab29a30da2f553a78c5f65ef.png" class="img-fluid center" alt="The service details" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/servicedetails.png"/> </a> <em>服务详情。</em></p>

<p>这个过程比直接跳到控制台并运行kubectl稍不方便，但好处是我们已经启动了一个runbook库，其中包含了我们知道对使用我们的集群有用的步骤。这个库将非常有价值，因为我们希望将对这个基础设施的支持交给另一个团队。当您考虑到下一个团队只需要对Octopus的适当访问，而不需要kubectl或任何凭证时，这一点尤其正确，当您的寻呼机在凌晨3点响起时，这是受欢迎的。</p>

<p>现在我们知道了ELB的主机名，我们可以访问我们公开托管的应用程序:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/petcliniclive.png" class="zoom" data-title=""> <img src="../Images/7705ac3dcdd946306f550b46a53ea700.png" class="img-fluid center" alt="PetClinic live and public" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cloud/petcliniclive.png"/> </a> <em> PetClinic live和public。</em></p>

<h2 id="conclusion">结论</h2>

<p>在本文中，我们使用EKS服务在AWS中创建了一个Kubernetes集群，并通过Octopus将我们的PetClinic应用程序部署到其中。我们还致力于通过runbooks调试集群，这提供了一个小但重要的基础，我们可以将它传递给在我们继续前进后最终负责该集群的团队。</p>

<p>我们还没有实现连续部署，因为Jenkins和Octopus之间没有集成。在下一篇文章的<a href="/blog/java-ci-cd-co/from-ci-to-cd">中，我们将连接我们的管道，以实现一个完整的CI/CD管道。</a></p>

                    
                    
</body>
</html>