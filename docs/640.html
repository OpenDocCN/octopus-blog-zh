<html>
<head>
<title>Using Infrastructure as Code with Operations Runbooks - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将基础设施用作运营手册代码- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/runbooks-with-infrastructure-as-code#2022-11-29">https://octopus.com/blog/runbooks-with-infrastructure-as-code#2022-11-29</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/runbooks-iac.png" class="zoom" data-title=""><img src="../Images/b87ef609fca41bf6d6cc71e6e40cd5bb.png" class="img-fluid center" alt="Using Infrastructure as Code with Operations Runbooks" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/runbooks-iac.png"/>T2】</a></p>

<p>基础设施即代码(IaC)是一种现代的声明性基础设施配置方法。在这篇文章中，我分享了一些关于Runbooks如何帮助您以简洁明了的方式管理基础设施安装和拆卸的经验教训。</p>

<p>在准备<a href="https://www.youtube.com/watch?v=M5ejzd8KdbQ&amp;feature=youtu.be" rel="nofollow"> Octopus 2020.1发布网上研讨会</a>时，我需要为我的演示上下旋转基础设施。在runbooks之前，我有一个单独的<em>基础设施作为代码</em>项目来处理这个问题。我不想再这样做了，Operations Runbooks就是根据这种情况设计的。网上研讨会的准备工作使我能够将我的过程移植到一本操作手册上，并且它给了我一个机会来调整我如何在Octopus Deploy中处理基础设施代码。</p>



<h2 id="what-is-infrastructure-as-code">什么是作为代码的基础设施？</h2>

<p>基础设施作为代码是一种在文件中建模所需基础设施的方式，通常用YAML、JSON或Hashcorp语言(HCL)编写。云提供商拥有接收该文件并调配您所请求的基础架构的机制，但每个提供商都有自己的基础架构定义:</p>



<p>使用云提供商提供的工具有其优势；例如，他们通常有一个UI来帮助调试。该过程由CLI启动，但是当出现问题时，您可以通过用户界面中的日志来查找根本原因。此外，为了帮助学习曲线，它们要么提供示例，要么让您在UI中定义所需的基础结构并将其导出到文件中。顺便说一下，这就是我如何创建ARM模板。</p>

<p>使用所提供的工具的不利方面是锁定的风险。AWS Cloudformation的术语不能翻译成Azure ARM模板。这就是第三方工具如<a href="https://www.terraform.io/" rel="nofollow"> Hashcorp的Terraform </a>有用的地方。它们提供了一个通用的框架，可以跨所有云提供商使用。</p>

<h2 id="infrastructure-as-code-before-runbooks">基础设施作为运行手册之前的代码</h2>

<p>在runbooks之前，我的基础设施代码流程是一个正常的部署流程，尽管我没有<em>部署</em>任何东西，而是针对云提供商运行脚本。我的过程目标很简单；只有一个项目可以摧毁我的基础设施。</p>

<p>这种方法导致了一些怪癖。首先，我必须创建一个生命周期，因为我正在使用一个部署过程，而部署过程有生命周期。在这个例子中，我有两个环境，<code>Test</code>和<code>Production</code>。然而，我需要一个环境来摧毁一切。这导致了我的第二个怪癖。我需要另一个叫做<code>Teardown</code>的环境。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_lifecycle_before_runbooks.png" class="zoom" data-title=""><img src="../Images/c7b1b51897bd0680ffd4b5684b208bb5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_lifecycle_before_runbooks.png"/>T2】</a></p>

<p>我的部署过程有点复杂，因为它包括以下步骤:</p>

<ul>
<li>作用于除<code>Teardown</code>之外的任何环境</li>
<li>范围扩大到<code>Teardown</code></li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_deployment_process_prior_to_runbooks.png" class="zoom" data-title=""><img src="../Images/a15ec4937cf8756ab4121e7794307f7a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_deployment_process_prior_to_runbooks.png"/>T2】</a></p>

<p>你会注意到在我的生命周期中<code>Test</code>和<code>Production</code>是可选的。这让我想到了我的下一个怪癖。第一次配置IaC，无论是对于AWS CloudFormation，Azure ARM Templates，GCP部署管理器，还是Hashicorp的Terraform，都需要大量的试错。通常，我在一两次尝试后就创建好了基础设施，但之后的一切都令人头疼。创建了一个虚拟机，但引导脚本遗漏了一些内容。正确测试修复需要拆除和旋转基础设施。有时错误发生在<code>Test</code>而其他时间发生在<code>Production</code>。如果部署真的失败了，我需要一个到达<code>Teardown</code>的方法。因此，<code>Test</code>和<code>Production</code>是可选的。</p>

<h2 id="aws-region-specific-settings">AWS区域特定设置</h2>

<p>对于本文，我使用AWS CloudFormation来启动一个Ubuntu VM，在该VM上安装一个触手，并向Octopus Deploy注册触手。在选择AWS时，我无意中发现了另一个怪癖:每个地区都是隔离的。绝大多数情况下，资源不能在地区之间共享；这包括:</p>

<ul>
<li>虚拟机的SSH密钥</li>
<li>AMI图像</li>
<li>子网</li>
<li>安全组</li>
</ul>

<p>这不是一份包罗万象的清单。</p>

<p>我<em>并不</em>希望每个地区都有一个环境(可扩展性很差)，但是我需要一种方法来进行特定地区的设置，所以我使用了<a href="https://octopus.com/docs/deployment-patterns/multi-tenant-deployments"> Octopus Deploy的多租户</a>功能。租户可以是:</p>

<ul>
<li>SaaS应用程序的客户</li>
<li>每个开发人员一个沙箱</li>
<li>数据中心</li>
<li>AWS区域</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_deploy_aws_tenant_regions.png" class="zoom" data-title=""><img src="../Images/ca4d174ed70ccd56a7febb6e26824bb1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_deploy_aws_tenant_regions.png"/>T2】</a></p>

<p>我最喜欢的租户特性之一是，每个环境中的每个租户都可以有一个唯一的变量值。这对于数据库连接字符串来说是有意义的，但是在我的IaC例子中，这会导致大量的重复值。我不想在<code>Test</code>、<code>Production</code>、<code>Teardown</code>上定义同一个AMI。幸运的是，可以配置特定于租户的变量，以便在所有环境中使用。</p>

<h3 id="option-1.leverage-tenant-tag-sets">备选方案1。利用租户标签集</h3>

<p>首先，我创建了一个名为<code>AWS Region</code>的租户标签集:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_tenant_tag_aws_region_set.png" class="zoom" data-title=""><img src="../Images/97f3cbaeaf8da1ae18d91c5a4642a6ab.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_tenant_tag_aws_region_set.png"/>T2】</a></p>

<p>我这样做是因为租户标签的作用域可以是一个变量。您可以通过点击<code>Open Editor</code>链接来访问该变量范围:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_open_scope_editor.png" class="zoom" data-title=""><img src="../Images/c7ce73ba00b0b5f0e661b17907f6333b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_open_scope_editor.png"/>T2】</a></p>

<p>这将打开一个模态窗口，让您选择租户标记:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_variable_scope_modal_window.png" class="zoom" data-title=""><img src="../Images/a607b968fefc4d2f9a9bd3277379b3ce.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_variable_scope_modal_window.png"/>T2】</a></p>

<p>我创建了一个名为<code>AWS</code>的变量集，其中填充了我的CloudFormation模板所需的变量:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_aws_variable_set.png" class="zoom" data-title=""><img src="../Images/a0c0d7612a6afbd1ff29109b42ea019a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_aws_variable_set.png"/>T2】</a></p>

<h3 id="option-2.leverage-variable-set-variable-templates">选项2。利用变量集变量模板</h3>

<p>我选择了选项1，因为它可以更容易地创建截图并向新用户演示。我发现大多数人<em>看到上面的截图就明白了</em>。它对于显示每个AWS区域的差异也很有用。但是，您必须复制租户名称作为租户标记。</p>

<p>另一个选择是利用变量集变量模板。在变量集中，有一个<code>Variable Templates</code>选项卡。首先，添加一个变量模板:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_variable_set_variable_templates.png" class="zoom" data-title=""><img src="../Images/7e65ee3e504d3df51f8f5c5806a33489.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_variable_set_variable_templates.png"/>T2】</a></p>

<p>在租户变量屏幕上，您会看到一个<code>Common Templates</code>选项卡。将出现您添加到变量集中的变量模板。加州地区给了我最大的心痛，这就是为什么它有一个阿诺德尖叫加州的图像:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_tenants_common_variables.png" class="zoom" data-title=""><img src="../Images/d7ab5c479088c2acf3c650c9afbd255a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_tenants_common_variables.png"/>T2】</a></p>

<p>租户必须连接到与变量集相连的项目。</p>


<p>如果我在企业环境中设置Octopus Deploy，我会使用这个选项。</p>

<h2 id="porting-the-deployment-process-to-runbooks">将部署过程移植到运行手册</h2>

<p>我很快意识到我不应该从部署过程直接移植到runbooks。我需要重新思考如何配置我的IaC进程。如前所述，我想要一个单一的进程来启动和关闭我的基础设施。我的<em>基础设施即代码</em>项目的过程反映了这个目标。然而，这个单一的项目目标让我做出了一些次优的配置。</p>

<p>这些次优配置是:</p>

<ul>
<li>一个<code>Teardown</code>环境的整个概念以及随后的生命周期。</li>
<li>必须确定一个步骤的范围，要么在<code>Teardown</code>中运行，要么在除<code>Teardown</code>之外的所有环境中运行。换句话说，我把两个进程挤成了一个。</li>
<li>那个<code>Teardown</code>环境要求我写脚本同时拆掉<code>Test</code>和<code>Production</code>。</li>
<li>因为我需要同时分解所有东西，所以我的变量范围变得更加复杂。</li>
</ul>

<p>让我们花一点时间来讨论变量范围，因为它很好地揭示了我的过程中的多个问题。在<code>Test</code>和<code>Production</code>中，虚拟机名称的变量模板遵循以下格式<code>[Application Name]-[Component]-[Environnment Abbreviation]</code>。例如，<code>todo-web-t</code>用于待办应用的web服务器。<code>Teardown</code>变量不包括环境缩写。刚好是<code>[Application Name]-[Component]</code>。为所有环境取消注册虚拟机所需的<code>Teardown</code>流程。该注销脚本找到并删除了所有以<code>[Application Name]-[Component]</code>开头的目标。这是一个简单的例子；添加区域变得更加复杂。想出一个不会导致意外删除错误目标的变量模板花了相当多的时间。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_complex_scoping_variable_names.png" class="zoom" data-title=""><img src="../Images/502a174d244e53597b36250d9aa4132d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_complex_scoping_variable_names.png"/>T2】</a></p>

<h3 id="split-the-process">拆分流程</h3>

<p>我做的第一个改变是将IaC过程分成两个操作手册。一个运行手册启动了基础设施，另一个则删除了它。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_list.png" class="zoom" data-title=""><img src="../Images/f0beece45bc9d43f4469a573ae738423.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_list.png"/>T2】</a></p>

<p>由于这种分离，我不再需要<code>Teardown</code>环境。这反过来简化了变量。我还了解到我可以将变量的范围扩展到特定的操作手册。这意味着我不会将未使用的变量传递到部署中。换句话说，我可以有简单的变量，它们只用于特定的操作手册:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_scope_variables_to_runbook.png" class="zoom" data-title=""><img src="../Images/61576fc16e85f61e16891bc35c86fe90.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_scope_variables_to_runbook.png"/>T2】</a></p>

<p>这个过程也让我更容易理解。我并没有试图将两个过程混为一谈:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_process.png" class="zoom" data-title=""><img src="../Images/a4f4a9accf5fd299bc48ff3d4405afe6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_process.png"/>T2】</a></p>

<h3 id="tenants">房客</h3>

<p>我仍然希望保持我的租户按区域配置。然而，我的示例应用程序不是多租户的；它是小号的。NET核心web应用程序运行在NGINX与NoSQL后端。它不需要任何东西，只需要在一些地区进行拆分。做一些类似金丝雀部署或蓝/绿部署的事情是多余的。</p>

<p>我想要的是:</p>

<ul>
<li>当我部署测试时，部署到<code>Ohio</code>区域中的服务器。</li>
<li>当我部署到生产环境时，使用滚动部署部署到<code>Ohio</code>、<code>California</code>和<code>Oregon</code>地区的所有服务器:</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_deploy_sample_deployment_process.png" class="zoom" data-title=""><img src="../Images/e9b777a51a9dde134ef4ecc6af58d44c.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_deploy_sample_deployment_process.png"/>T2】</a></p>

<p>这是我发现一个项目可能不允许租用部署，但是一个操作手册可以要求它们。在我的项目设置中，我将其设置为禁用租用部署:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_project_disable_tenant_deployments.png" class="zoom" data-title=""><img src="../Images/66196269a25fc45e7ae9a932d0bfa660.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_project_disable_tenant_deployments.png"/>T2】</a></p>

<p>但是，我将每个runbook设置为需要一个租户:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_require_tenant.png" class="zoom" data-title=""><img src="../Images/ed30d1aa5db591b0b5bac7835ff1d875.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_require_tenant.png"/>T2】</a></p>

<p>因为操作手册没有生命周期，所以概览屏幕看起来与您可能习惯的常见项目概览屏幕略有不同:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_overview.png" class="zoom" data-title=""><img src="../Images/1ede527366f86fb9d8abcdd6fd125974.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_overview.png"/>T2】</a></p>

<h3 id="spinning-up-and-down-infrastructure-on-a-schedule">按计划启动和关闭基础架构</h3>

<p>虚拟机需要钱。对于本例，我不需要虚拟机全天候运行。我宁愿让它们只在工作日运行。您可能对您的测试环境有类似的需求。如果没有任何东西在使用虚拟机，为什么要花钱让它们运行呢？</p>

<p>这让我想到了一个小问题。runbooks的预定触发器允许我选择1到N个环境:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_trigger.png" class="zoom" data-title=""><img src="../Images/ced8a7e4ed842fe41e561a283aa5a9d9.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_trigger.png"/>T2】</a></p>

<p>触发器将启动两个任务，每个任务对应我指定的一个环境。对于两个环境，这并不是什么大问题，但是当我配置另一个示例时遇到了瓶颈，我想要四个环境。正在运行的并发任务的数量将呈指数级增长。我不想让我的任务队列因我的基础设施上下旋转而过载。我的第一个想法是，我可以安排触发间隔15分钟。例如:</p>

<ul>
<li>项目A启动<code>Development</code>基础设施:早上6:00</li>
<li>项目A启动<code>Test</code>基础设施:上午6:15</li>
<li>项目B启动<code>Test</code>基础设施:早上6:30</li>
<li>项目A启动<code>Staging</code>基础设施:上午6:45</li>
<li>项目A启动<code>Production</code>基础设施:早上7:00</li>
<li>项目B启动基础设施:上午7:15</li>
</ul>

<p>这并不能很好地扩展。尤其是当我添加更多项目时。有时需要5分钟来启动基础设施，有时需要20分钟，我不想浪费时间等待，但同时，我希望避免任务队列过载。</p>

<p>我需要的是一本操作手册，它可以有序地启动我的所有基础架构。如果你熟悉JQuery承诺，本质上我想把我的承诺串起来。一次运行一本操作手册，完成后，开始下一本。</p>

<p>一个runbook启动另一个run book没有内置的步骤，所以我写了这个<a href="https://library.octopus.com/step-templates/0444b0b3-088e-4689-b755-112d1360ffe3/actiontemplate-run-octopus-deploy-runbook" rel="nofollow">步骤模板</a>。现在，我可以让一本操作手册有条不紊地在我的基础架构上运行。我把那本手册叫做<code>Unleash the Kraken</code>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_which_calls_runbook.png" class="zoom" data-title=""><img src="../Images/de78934a073ac45b3b1eef4805230745.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbook_which_calls_runbook.png"/>T2】</a></p>

<p>我有两个预定的触发器，一个用来启动一切，另一个用来摧毁一切。您会注意到拆除触发器每天都在运行，而旋转触发器只在周末运行。这只是以防任何基础设施在周末启动:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbooks_scheduled_trigger.png" class="zoom" data-title=""><img src="../Images/c37910590d60fa638d4902ecf523f4a1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/runbooks-with-infrastructure-as-code/octopus_runbooks_scheduled_trigger.png"/></a>T2】</p>

<h2 id="conclusion">结论</h2>

<p>从使用部署流程构建基础设施到使用操作手册，有一些变化。总的来说，我对这些变化感到高兴，一切都感觉干净了许多。</p>

<p>关于runbooks，我最喜欢的部分是不必为每次运行创建一个版本。为了让我的CloudFormation模板和bootstrap脚本正确，我不得不在成功之前做了大量的运行。不用跳释放舞感觉很好。</p>

                    
                    
</body>
</html>