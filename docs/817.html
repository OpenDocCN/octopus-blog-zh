<html>
<head>
<title>Deploying Certificates to WildFly - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将证书部署到WildFly - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/wildfly-https#2022-08-09">https://octopus.com/blog/wildfly-https#2022-08-09</a></blockquote>
                        <p>Octopus Deploy最近增加的一个功能是能够在您的基础设施中管理和部署证书。在这篇博文中，我将向您展示如何将证书从Octopus导出到Java密钥库中，然后使用该密钥库来保护运行在Windows上的WildFly独立实例或域实例。</p>

<h2 id="prerequisites">先决条件</h2>

<p>要运行这篇博文中的命令和脚本，您需要安装一些工具。</p>

<p>第一个是OpenSSL客户机。我使用了来自<a href="https://slproweb.com/products/Win32OpenSSL.html" rel="nofollow"> Shining Light Productions </a>的Windows OpenSSL二进制文件。</p>

<p>第二个是Groovy SDK。你可以从<a href="http://groovy-lang.org/download.html" rel="nofollow"> Groovy下载页面</a>下载安装程序。</p>

<p>这些步骤用<a href="http://wildfly.org/downloads/" rel="nofollow"> WildFly 11.0.0.Alpha1 </a>进行了测试。</p>

<p>最后，你还需要安装Java 8 JDK。</p>

<h2 id="creating-the-certificate-store">创建证书存储</h2>

<p>首先，我们需要将证书和私钥对上传到Octopus Deploy中。最简单的方法是创建一个自签名证书和私钥，然后将它们合并到一个PKCS12密钥库中。</p>

<p>要创建私钥和证书，请运行以下命令:</p>

<pre><code>openssl req -x509 -newkey rsa:2048 -keyout private.pem -out certificate.pem -days 356
</code></pre>

<p>系统会提示您提供密码并填写一些个人信息，之后会创建两个文件:<code>private.pem</code>和<code>certificate.pem</code>。这些文件是私钥和证书。</p>

<p>然后，我们需要将这两个文件组合成一个PKCS12密钥库，我们可以使用以下命令来完成:</p>

<pre><code>openssl pkcs12 -export -in certificate.pem -inkey private.pem -out combined.pfx -name octopus
</code></pre>

<p><code>combined.pfx</code>文件现在包含证书和私钥，可以上传到Octopus Deploy。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-06/certificate.png" class="zoom" data-title=""><img src="../Images/a8eecdf380f47cac8372fa1d01500758.png" class="img-fluid center" alt="Certificate" data-original-src="https://i.octopus.com/blog/2017-06/certificate.png"/>T2】</a></p>

<h2 id="exporting-the-certificate-store">导出证书存储</h2>

<p>既然证书是由Octopus管理的，我们需要创建一个带有自定义脚本步骤的项目，以便将证书放到我们的WildFly服务器上。</p>

<p>首先，我们需要通过变量引用证书。在Octopus项目的<code>Variables</code>部分，创建一个名为<code>Certificate</code>的新变量，该变量引用刚刚上传的证书。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-06/variable-editor.png" class="zoom" data-title=""><img src="../Images/c6a4305152b0a83394d69ab19b5781e2.png" class="img-fluid center" alt="Certificate" data-original-src="https://i.octopus.com/blog/2017-06/variable-editor.png"/>T2】</a></p>

<p>【T2 <img src="../Images/437fcc8ee35a8ff52f00afd0de864a8c.png" class="img-fluid center" alt="Certificate" data-original-src="https://i.octopus.com/blog/2017-06/certificate-variable.png"/></p>

<p>创建这个变量使我们能够访问证书中保存的信息的<a href="https://octopus.com/docs/projects/variables/certificate-variables#expanded-properties">种不同表示。</a></p>

<p>下面的脚本将证书和私钥作为PEM文件保存在目标服务器上，将它们合并到组合的PKCS12密钥库，然后将PKCS12密钥库导入到Java密钥库中。</p>

<p>作为我们<a href="https://octopus.com/blog/java-rfc" class="alert-link"> Java RFC </a>的一部分，将这个证书直接公开为Java密钥库是我们打算包含在Octopus中的一个特性。但是今天，我们必须使用一个手动脚本来提取证书细节并将其导入到Java密钥库中。</p>


<p>这个脚本的最终结果是一个名为<code>c:\keystore.jks</code>的文件，它是我们可以从WildFly引用的Java密钥库，以启用HTTPS支持。</p>

<pre><code class="language-powershell">if ([String]::IsNullOrWhiteSpace($OctopusParameters["Certificate.CertificatePem"])) {
    Write-Error "Certificate is empty"
}

if ([String]::IsNullOrWhiteSpace($OctopusParameters["Certificate.PrivateKeyPem"])) {
    Write-Error "Private key is empty"
}

$OctopusParameters["Certificate.CertificatePem"] | Out-File -Encoding ASCII "C:\certificate.pem"
$OctopusParameters["Certificate.PrivateKeyPem"] |  Out-File -Encoding ASCII "C:\private.pem"
# Fix the error
# WARNING: can't open config file: /usr/local/ssl/openssl.cnf
$env:OPENSSL_CONF="C:\OpenSSL-Win64\bin\openssl.cfg"
C:\OpenSSL-Win64\bin\openssl.exe pkcs12 -export -inkey C:\private.pem -in C:\certificate.pem -name octopus -out C:\keystore.pfx -password pass:Password01
if (Test-Path C:\keystore.jks) {
  rm C:\keystore.jks
}
C:\Java\x86\jdk1.8.0_131\bin\keytool -importkeystore -srckeystore C:\keystore.pfx -srcstoretype pkcs12 -destkeystore C:\keystore.jks -storepass Password01 -srcstorepass Password01 -noprompt
</code></pre>

<h2 id="configuring-https-support-in-wildfly">在WildFly中配置HTTPS支持</h2>

<p>在我们开始配置WildFly以利用Java密钥库之前，有必要回顾一下我们在WildFly中配置HTTPS支持的确切含义。</p>

<p>WildFly有两个web界面:客户端用来查看已部署的Java应用程序的界面，以及管理界面。两者都可以用HTTPS保护，尽管两者的过程略有不同。</p>

<p>此外，WildFly可以以独立模式部署，也可以作为域部署。同样，为独立服务器和域服务器配置HTTPS支持也有细微的区别。</p>

<p>虽然<a href="https://docs.jboss.org/author/display/WFLY10/CLI+Recipes" rel="nofollow"> WildFly CLI工具</a>功能强大，并公开了配置HTTPS支持所需的所有功能，但它的运行级别较低，不包括像<code>configureHTTPS()</code>这样的功能。CLI工具的一个缺点是它不是等幂的，这意味着使用CLI工具配置WildFly实例通常需要不同的步骤序列，这取决于服务器的当前状态。</p>

<p>当您从像Octopus这样的平台进行部署时，这并不理想。您想要的是有一种方法来描述您希望达到的理想状态(比如“配置HTTPS”)，而不必知道服务器的当前状态。</p>

<p>为了方便起见，我们创建了一个<a href="https://github.com/OctopusDeploy/JBossDeployment/blob/master/deploy-certificate.groovy" rel="nofollow"> Groovy脚本</a>，它隐藏了需要通过CLI工具发出的低级命令，以便在WildFly中配置(或重新配置)HTTPS支持。</p>

<h2 id="https-support-in-standalone-mode">独立模式下的HTTPS支持</h2>

<p>要配置具有HTTPS支持的独立WildFly实例，请运行以下命令:</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller localhost --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01
</code></pre>

<p>用户名和密码需要与您已经用adduser脚本配置的相匹配。您可以通过打开http://localhost:9990并在提示登录时输入这些凭据来验证这些凭据是否有效。</p>


<p>在后台，脚本首先创建一个名为<code>octopus-ssl-realm</code>的安全领域，它引用密钥库:</p>

<pre><code class="language-xml">&lt;management&gt;
   &lt;security-realms&gt;
      &lt;security-realm name="octopus-ssl-realm"&gt;
         &lt;server-identities&gt;
            &lt;ssl&gt;
               &lt;keystore path="C:\keystore.jks" keystore-password="Password01" alias="octopus" /&gt;
            &lt;/ssl&gt;
         &lt;/server-identities&gt;
      &lt;/security-realm&gt;
      ...
   &lt;/security-realms&gt;
&lt;/management&gt;
</code></pre>

<p>然后，它将配置一个引用安全领域的https侦听器:</p>

<pre><code class="language-xml">&lt;subsystem &gt;
   &lt;server name="default-server"&gt;
      &lt;http-listener name="default" socket-binding="http" redirect-socket="https" enable-http2="true" /&gt;
      &lt;https-listener name="https" socket-binding="https" security-realm="octopus-ssl-realm" enable-http2="true" /&gt;
      &lt;host name="default-host" alias="localhost"&gt;
         &lt;location name="/" handler="welcome-content" /&gt;
         &lt;filter-ref name="server-header" /&gt;
         &lt;filter-ref name="x-powered-by-header" /&gt;
         &lt;http-invoker http-authentication-factory="application-http-authentication" /&gt;
      &lt;/host&gt;
   &lt;/server&gt;
   ...
&lt;/subsystem&gt;
</code></pre>

<p>最后，重新启动服务器，以便新设置生效。当你打开https://localhost:8443/的时候，你会看到WildFly现在被你的自签名证书保护了。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-06/wildfly-standalone-https.png" class="zoom" data-title=""><img src="../Images/632ef195ba8f7244ec18614fc999cf30.png" class="img-fluid center" alt="Certificate" data-original-src="https://i.octopus.com/blog/2017-06/wildfly-standalone-https.png"/>T2】</a></p>



<h2 id="securing-the-standalone-management-interface">保护独立管理界面</h2>

<p>保护管理接口可以简单地通过添加<code>--management-interface</code>参数来完成。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller localhost --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01 --management-interface
</code></pre>

<p>虽然这只是对前一个命令的一个参数更改，但是实际完成的工作有点不同。</p>

<p>首先，从<code>ManagementRealm</code>中引用密钥库:</p>

<pre><code class="language-xml">&lt;security-realm name="ManagementRealm"&gt;
   &lt;server-identities&gt;
      &lt;ssl&gt;
         &lt;keystore path="C:\keystore.jks" keystore-password="Password01" alias="octopus" /&gt;
      &lt;/ssl&gt;
   &lt;/server-identities&gt;
   ...
&lt;/security-realm&gt;
</code></pre>

<p>然后，管理界面被更新以包括https套接字绑定:</p>

<pre><code class="language-xml">&lt;management-interfaces&gt;
   &lt;http-interface security-realm="ManagementRealm"&gt;
      &lt;http-upgrade enabled="true" /&gt;
      &lt;socket-binding http="management-http" https="management-https" /&gt;
   &lt;/http-interface&gt;
&lt;/management-interfaces&gt;
</code></pre>

<p>并再次重启WildFly实例以使更改生效。</p>

<p>现在，您可以打开https://localhost:9993，通过https与管理控制台进行交互。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-06/wildfly-standalone-management-https.png" class="zoom" data-title=""><img src="../Images/8d25ab10630cbca4ea2932911b01cfd2.png" class="img-fluid center" alt="Certificate" data-original-src="https://i.octopus.com/blog/2017-06/wildfly-standalone-management-https.png"/>T2】</a></p>

<h2 id="https-support-in-domain-mode">域模式下的HTTPS支持</h2>

<p>如果您作为域的一部分运行WildFly，那么使用HTTPS保护web界面的命令实际上与您在独立模式下运行时是一样的。</p>

<p>但是，关于配置WildFly域的成员，有一些重要的事情需要记住。</p>

<p>首先，您运行脚本的控制器是域控制器。在后台，域控制器正在更新两个文件:</p>

<ul>
<li>位于从服务器文件系统上的<code>host.xml</code>文件(或者当WildFly从服务器启动时传递到<code>--host-config</code>选项中的任何文件)。</li>
<li>位于域服务器文件系统上的<code>domain.xml</code>文件(或者当WildFly域控制器启动时传递给<code>--domain-config</code>选项的任何文件)。</li>
</ul>

<p>第二件事是密钥库路径是相对于从属服务器的。因此，在运行这个命令之前，将<code>keystore.jks</code>文件复制到从属服务器是很重要的。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller domaincontroller --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01
</code></pre>

<p>与独立服务器一样，在域中运行该命令将配置一个安全领域，但是这次是在当前域中所有从属服务器的<code>host.xml</code>文件中。</p>

<p>如果您只想更新特定的主机，请将它们传递给<code>--hosts</code>选项。例如，此命令将更新主机slave1和slave2的安全领域。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller domaincontroller --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01 --hosts slave1,slave2
</code></pre>

<p>然后，它在域管理的每个配置文件中配置https侦听器。WildFly自带4种配置文件:默认、高可用性、完全和完全高可用性。如果你只想更新特定的配置文件，将它们传递到<code>--profiles</code>选项中。例如，该命令将更新默认配置文件和ha配置文件中的https-listener。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller domaincontroller --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01 --profiles ha,default
</code></pre>

<h2 id="securing-the-domain-management-interface">保护域管理界面</h2>

<p>保护域管理接口的命令几乎与保护独立管理接口的命令相同。惟一的变化是添加了<code>--management-port</code>参数，该参数定义了管理控制台将暴露的https端口。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller domaincontroller --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01 --management-interface --management-port 9993
</code></pre>

<p>这将在套接字接口上设置<code>secure-port</code>属性。</p>

<pre><code class="language-xml">&lt;management&gt;
   &lt;management-interfaces&gt;
      &lt;native-interface security-realm="ManagementRealm"&gt;
         &lt;socket interface="management" port="${jboss.management.native.port:19999}" /&gt;
      &lt;/native-interface&gt;
      &lt;http-interface security-realm="ManagementRealm"&gt;
         &lt;http-upgrade enabled="true" /&gt;
         &lt;socket interface="management" port="${jboss.management.http.port:9990}" secure-port="9993" /&gt;
      &lt;/http-interface&gt;
   &lt;/management-interfaces&gt;
   ...
&lt;/management&gt;
</code></pre>

<h2 id="using-the-https-management-interface">使用HTTPS管理界面</h2>

<p>一旦使用HTTPS保护了管理接口，您就需要在运行脚本时指定<code>remote+https</code>协议，这是通过<code>--protocol</code>参数完成的。例如，此命令在具有HTTPS安全管理界面的域控制器上配置ha和默认配置文件。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller domaincontroller --port 9993 --protocol remote+https --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01 --profiles ha,default
</code></pre>

<h2 id="known-issues">已知问题</h2>

<p>似乎偶尔域控制器主机不会正常重新启动。更多详情见<a href="https://issues.jboss.org/browse/WFLY-8975" rel="nofollow">https://issues.jboss.org/browse/WFLY-8975</a>。</p>

<p>您可以使用<code>--no-restart</code>选项阻止重启。</p>

<pre><code class="language-bash">groovy deploy-certificate.groovy --controller domaincontroller --port 9990 --user admin --password password --keystore-file C:\keystore.jks --keystore-password Password01 --management-interface --management-port 9993 --no-restart
</code></pre>

<h2 id="next-steps">后续步骤</h2>

<p>这些Groovy脚本正在被开发，作为最终将被移植到Octopus Deploy中直接提供的步骤中的概念验证。</p>

<p>如果你对剧本有任何问题，请留下评论。如果有一些Java特性你希望Octopus在未来部署支持，请加入<a href="https://octopus.com/blog/java-rfc"> Java RFC帖子</a>的讨论。</p>

                    
                    
</body>
</html>