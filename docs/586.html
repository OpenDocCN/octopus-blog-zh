<html>
<head>
<title>Lessons learned building a Raspberry Pi cluster - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>构建Raspberry Pi集群的经验教训——Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/raspberry-pi-cluster-lessons-learned#2021-08-12">https://octopus.com/blog/raspberry-pi-cluster-lessons-learned#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/raspberry-pi-cluster-lessons-learned/raspberry-pi-cluster.png" class="zoom" data-title=""><img src="../Images/8ab7a9f277bb6b91a982b311e71129e3.png" class="img-fluid center" alt="Lessons learned building a Raspberry Pi cluster" data-original-src="https://i.octopus.com/blog/2020-06/raspberry-pi-cluster-lessons-learned/raspberry-pi-cluster.png"/>T2】</a></p>

<p>像许多其他人一样，在新冠肺炎危机期间，我不得不呆在家里，所以我决定构建一个Raspberry PI集群，用Docker Swarm探索在其上运行应用程序。在这篇文章中，我分享了我在使用Docker Swarm的集群中运行新的Raspberry Pi 4时学到的一些经验。</p>

<h2 id="why">为什么</h2>

<p>我是一名开发人员，我对启动一个Raspberry PI项目感兴趣有一段时间了。我也对集群计算感兴趣，但是从来没有一个创建集群的好理由。后来，我读到有人在使用Docker Swarm的集群中运行新的Raspberry Pi 4取得了巨大成功，所以我认为这是了解更多信息的大好时机。</p>

<p>我带着几个目标开始了这个项目:</p>

<ul>
<li>玩得开心，因为树莓皮是非常酷的硬件。</li>
<li>将一些计算资源从运行虚拟机的家庭虚拟机管理程序服务器转移到运行容器的小型节能Raspberry PI集群。</li>
<li>了解更多关于Docker Swarm的信息。</li>
</ul>

<h2 id="raspberry-pi-hardware">Raspberry Pi硬件</h2>

<p>这些是我在项目中使用的部件:</p>



<p>我选择C4Labs Cloudlet案例，因为它允许我访问单个Pi，而不必像可堆叠的案例那样拆卸整个案例。Cloudlet机箱的原始设计是由Pi驱动风扇。如果我需要移除一个Pi，我不想担心断开电缆，所以我用以下部件为风扇供电:</p>



<p>Cloudlet案例为这些额外的部分提供了足够的空间。</p>

<p>最后，我需要一个网络交换机来连接Pi设备，但是我有一个备用的8端口，所以我不需要再买一个。Raspberry Pi 4带有内置的无线适配器，所以你也可以利用它。</p>

<h2 id="creating-the-cluster">创建集群</h2>

<p>有大量的博客文章向你展示了如何用Docker Swarm创建一个Raspberry Pi集群。我发现<a href="https://howchoo.com/g/njy4zdm3mwy/how-to-run-a-raspberry-pi-cluster-with-docker-swarm" rel="nofollow">如何用Docker Swarm </a>运行一个Raspberry Pi集群很清楚，也很容易理解。你需要的所有细节都在那个帖子里。</p>

<h2 id="operating-the-swarm">操作蜂群</h2>

<p>通过工作，我已经有了一些使用Docker和Kubernetes (K8s)的经验，但是，我从来没有运行过Docker Swarm。与独立的Docker实例相比，在Docker群体模式下运行时需要学习一些新概念。例如，在您通常使用<code>docker run</code>语句的地方，您可以在swarm中创建一个服务来使用<code>docker service create</code>运行容器。折腾了一段时间后，我有了一个完全可操作的虫群:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/raspberry-pi-cluster-lessons-learned/docker-swarm.png" class="zoom" data-title=""><img src="../Images/39e178ef397b5345f9332bd083512d18.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/raspberry-pi-cluster-lessons-learned/docker-swarm.png"/>T2】</a></p>

<h2 id="lesson-1-not-all-containers-run-on-arm">第1课:不是所有的容器都在ARM上运行</h2>

<p>我做这个项目的初衷是通过运行容器来减轻我的虚拟机管理程序的负担。在搜索<a href="https://hub.docker.com" rel="nofollow"> Docker Hub </a>时，我发现很少有官方镜像会运行在ARM架构上。我通常可以找到某人制作的运行在Raspberry Pi上的图像，但它们通常是旧的，而不是当前的版本。</p>

<p>在某些情况下，您可以使用一种变通方法，告诉Docker不要将图像解析为架构:</p>

<ul>
<li><code>docker service create --name &lt;somename&gt; --no-resolve-image &lt;image&gt;</code></li>
<li><code>docker stack deploy --name &lt;somename&gt; --compose-file &lt;somefile&gt; --resolve-image never</code></li>
</ul>

<h2 id="lesson-2-stacks">第二课:堆栈</h2>

<p>栈是Docker群使用<a href="https://docs.docker.com/compose/" rel="nofollow"> docker-compose </a>的方式。事实上，它使用一个合成文件作为它的参数之一。就像docker-compose一样，您可以在一个文件中定义多个容器。默认情况下，<a href="https://docs.docker.com/engine/reference/commandline/stack_deploy/" rel="nofollow">堆栈部署</a>会为堆栈创建一个网络，这样它们就可以互相通信。这使得仅通过名称就可以很容易地将一个容器引用到另一个容器。例如，下面是在我的docker swarm上运行<a href="https://www.home-assistant.io/" rel="nofollow">家庭助手</a>的合成文件。这个堆栈由一个MQTT服务容器、一个家庭助理容器和一个MySQL数据库服务器容器组成。出于我将在后面介绍的原因，我将Home Assistant配置为对记录器使用MySQL后端:</p>

<pre><code>version: "3.3"

services:

  mqtt:
    image: eclipse-mosquitto
    networks:
      - hass
    ports:
      - 1883:1883
    volumes:
      - /mnt/clusterpi/mqtt/db:/db
      - /etc/localtime:/etc/localtime:ro

  home-assistant:
    image: homeassistant/home-assistant
    networks:
      - hass
    ports:
      - 8123:8123
    volumes:
      - /mnt/clusterpi/home-assistant:/config
      - /etc/localtime:/etc/localtime:ro

  mysqldb:
    image: hypriot/rpi-mysql
    networks:
      - hass
    ports:
      - 3350:3306
    environment:
      MYSQL_ROOT_PASSWORD: "MySuperSecretPassword"
      MYSQL_DATABASE: "homeassistant"
      MYSQL_USER: "hassio"
      MYSQL_PASSWORD: "AnotherSuperSecretPassword"
    volumes:
      - /mnt/clusterpi/mysql:/var/lib/mysql

networks:
  hass:
</code></pre>

<p>在Home Assistant的<code>configuration.yaml</code>文件中，你可以看到我在哪里创建了到mysqldb容器的连接:</p>

<pre><code>
# Configure a default setup of Home Assistant (frontend, api, etc)
default_config:

# Uncomment this if you are using SSL/TLS, running in Docker container, etc.
# http:
#   base_url: example.duckdns.org:8123

# Text to speech
tts:
  - platform: google_translate

group: !include groups.yaml
automation: !include automations.yaml
script: !include scripts.yaml
scene: !include scenes.yaml
recorder:
  db_url: mysql://root:MySuperSecretPassword@mysqldb/homeassistant?charset=utf8
</code></pre>

<h2 id="lesson-3-swarm-members-act-as-one">第三课:群体成员行动一致</h2>

<p>当与docker群组一起工作时，群组的所有成员都像一个整体一样行动。看上面的图，我们可以看到所有的容器都分布在群体的成员中。</p>

<p>当通过公开的端口连接到容器时，没有必要引用当前托管容器的节点。我们可以看到，<code>clusterpi-1</code>托管了名为<code>viz</code>的容器(这是图形的网页，<code>visualizer</code>)。<code>viz</code>容器端口被映射到主机端口80，因此我可以通过http://clusterpi-1访问<code>visualizer</code>容器网页。也可以通过http://clusterpi-4访问它，即使<code>clusterpi-4</code>不是容器的当前主机。这也意味着任何被映射的端口都不能被另一个容器使用。<code>mysql_dev</code>容器是唯一可以映射到3306的东西，所有其他MySQL容器(除非它们是<code>mysql_dev</code>的复制品)都必须使用不同的端口。</p>

<h2 id="lesson-4-persistent-storage-woes">第4课:持续的存储灾难</h2>

<p>您从容器中学到的第一个教训是，当容器被销毁时，数据不会持久。为了防止这种情况，您需要配置容器，将它通常存储在内部的内容映射到外部卷。在docker主机上创建卷相当容易。使用<code>-v</code>开关:<code>-v /my/local/folder:/var/lib/data</code>指定本地文件夹到包含文件夹的映射。然而，这在docker swarm中出现了一个问题，因为无法保证每次运行时相同的主机都会运行相同的容器(好吧，从技术上来说，你可以通过约束来实现，但是这违背了swarm的目的)。为了解决这个问题，我们需要一个群体的所有成员都可以访问的东西，比如一个网络位置。</p>

<h3 id="network-storage-options">网络存储选项</h3>

<p>有两种方法可以实现这一点；网络文件系统(NFS)或通用互联网文件系统(CIFS)。</p>

<p>NFS通常用于Linux/Unix系统，CIFS通常用于Windows系统，尽管Windows确实有NFS实现。在我的家庭环境中，我有一个用于文件服务器的Windows服务器，所以我选择使用CIFS。</p>

<h3 id="configuring-cifs">配置CIFS</h3>

<p>这篇文章很好地解释了如何在Linux上使用CIFS，包括如何挂载Windows共享。我使用CIFS和<code>/etc/fstab</code>中的一个条目将我的Pi设备连接到我的文件服务器，尽管我确实有一个副作用。当我重新启动集群时，它们都可以访问文件共享，但是我的所有容器都在Manager节点上结束。从我的一个工人的<code>/etc/fstab</code>中删除条目证实了这确实是导致问题的原因。</p>

<h4 id="wait-for-network-connectivity">等待网络连接</h4>

<p>所有容器都在Manager节点上结束的问题困扰了我一段时间。最终，我通过在<code>/etc/fstab</code>的CIFS线中添加另一个选项解决了这个问题；<code>_netdev</code>。<code>_netdev</code>开关延迟安装，直到联网被启用。在将它添加到所有Pi设备之后，管理器再次能够分发容器。</p>

<h4 id="bypass-permissions-checking">绕过权限检查</h4>

<p>有些容器在启动时会改变文件系统和文件系统权限，比如Postgres。当完全在容器或本地文件系统挂载中执行时，这通常不是问题。然而，当通过CIFS使用Windows共享时，这通常会使容器崩溃，表明该操作不受支持。为了绕过这一点，我为CIFS找到了<code>noperm</code>选项，它跳过了权限检查，直接向前移动。这使得我可以通过Postgres解决这个问题，但是我从来没有能够获得一个Windows CIFS共享来使用Postgres容器(但这并不意味着这是不可能的)。</p>

<h4 id="cifs-and-sqllite-are-not-friends">CIFS和斯格利特不是朋友</h4>

<p>为我的HomeAssistant容器成功配置了一个CIFS共享后，我发现它默认使用的SqlLite数据库有问题，它一直报告数据库被锁定。在遇到pgAdmin (Postgres management)容器的同样问题后，我稍微搜索了一下，发现许多帖子描述了同样的行为，几乎所有的帖子都推荐SqlLite以外的东西。这就是我在HomeAssistant堆栈部署中包含记录器服务的MySql容器的原因。</p>

<h2 id="conclusion">结论</h2>

<p>这对我来说是一个非常有趣的项目，我学到了很多关于Docker Swarm的知识。创建一个Raspberry Pi集群对于学习Docker Swarm和Kubernetes这样的概念非常有用。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/raspberry-pi-cluster-lessons-learned/raspberrypi-cluster.jpg" class="zoom" data-title=""><img src="../Images/c7517a6e063243956abcd7f4b4c4c312.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/raspberry-pi-cluster-lessons-learned/raspberrypi-cluster.jpg"/>T2】</a></p>

                    
                    
</body>
</html>