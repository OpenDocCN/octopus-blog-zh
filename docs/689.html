<html>
<head>
<title>Selenium series: A sample web page - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:样本web页面——Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/5-a-sample-web-page/a-sample-web-page#2021-07-07">https://octopus.com/blog/selenium/5-a-sample-web-page/a-sample-web-page#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>既然我们已经有了用于编写WebDriver测试的框架的基础，是时候开始与网页交互了。</p>

<p>为了展示WebDriver的强大功能，我们将首先创建一个简单的web页面，其中包含常见的表单元素，以及其他常见的HTML元素，如images和div。</p>

<p>完整的网页如下所示:</p>

<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;A sample web site&lt;/title&gt;
    &lt;style&gt;
        form &gt; * {
            display: block;
        }

    &lt;/style&gt;
    &lt;script&gt;
        /*
            Print a message to the page
        */
        function interactionMessage(message) {
            document.getElementById('message').textContent = message;
        }

        /*
            Create a new element on the page after 5 seconds
        */
        setTimeout(function() {
            var newDiv = document.createElement("div");
            newDiv.setAttribute("id", "newdiv_element");
            newDiv.textContent = "I am a newly created div";
            document.body.appendChild(newDiv);
            document.getElementById("div3_element").style.display = "";
        }, 5000);

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="message"&gt;&lt;/div&gt;
&lt;form id="form_element" onsubmit="interactionMessage('Form Submitted'); return false"&gt;
    &lt;button name="button_element" id="button_element" type="button" onclick="interactionMessage('Button Clicked')"&gt;Form Button&lt;/button&gt;
    &lt;input name="text_element" id="text_element" type="text" oninput="interactionMessage('Text Input Changed')"&gt;
    &lt;select name="select_element" id="select_element" onchange="interactionMessage('Select Changed')"&gt;
        &lt;optgroup label="Group 1"&gt;
            &lt;option id="option1.1_element"&gt;Option 1.1&lt;/option&gt;
        &lt;/optgroup&gt;
        &lt;optgroup label="Group 2"&gt;
            &lt;option id="option2.1_element"&gt;Option 2.1&lt;/option&gt;
            &lt;option id="option2.2_element"&gt;Option 2.2&lt;/option&gt;
        &lt;/optgroup&gt;
        &lt;optgroup label="Group 3" disabled&gt;
            &lt;option id="option3.1_element"&gt;Option 3.1&lt;/option&gt;
            &lt;option id="option3.2_element"&gt;Option 3.2&lt;/option&gt;
            &lt;option id="option3.3_element"&gt;Option 3.3&lt;/option&gt;
        &lt;/optgroup&gt;
    &lt;/select&gt;
    &lt;textarea name="textarea_element" id="textarea_element" name="textarea" rows="10" cols="50"
              oninput="interactionMessage('Text Area Changed')"&gt;&lt;/textarea&gt;
    &lt;div&gt;&lt;input name="radio_group" id="radio1_element" type="radio" name="color" value="blue"
                onchange="interactionMessage('Radio Button Changed')"&gt; Blue
    &lt;/div&gt;
    &lt;div&gt;&lt;input name="radio_group" id="radio2_element" type="radio" name="color" value="green"
                onchange="interactionMessage('Radio Button Changed')"&gt; Green
    &lt;/div&gt;
    &lt;div&gt;&lt;input name="radio_group" id="radio3_element" type="radio" name="color" value="red"
                onchange="interactionMessage('Radio Button Changed')"&gt; Red
    &lt;/div&gt;
    &lt;div&gt;&lt;input name="checkbox1_element" id="checkbox1_element" type="checkbox" name="vehicle" value="Bike"
                onchange="interactionMessage('Checkbox Changed')"&gt; I have a bike
    &lt;/div&gt;
    &lt;div&gt;&lt;input name="checkbox2_element" id="checkbox2_element" type="checkbox" name="vehicle" value="Car" checked
                onchange="interactionMessage('Checkbox Changed')"&gt; I have a car
    &lt;/div&gt;
    &lt;input id="submit_element" type="submit"&gt;
&lt;/form&gt;
&lt;img id="image_element" src="java.png" width="128" height="128" onclick="interactionMessage('Image Clicked')"&gt;
&lt;div id="div_element" onclick="interactionMessage('Div Clicked')"&gt;I am a div&lt;/div&gt;
&lt;div id="div2_element" onclick="interactionMessage('Div 2 Clicked')"&gt;I am a div too&lt;/div&gt;
&lt;div id="div3_element" style="display: none" onclick="interactionMessage('Div 3 Clicked')"&gt;I am a hidden div&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>让我们来看看这个网页的一些有趣的方面。</p>

<p>我们有一个名为<code>interactionMessage()</code>的JavaScript函数，它在页面上显示一些文本。我们将通过WebDriver与之交互的HTML元素将使用像<code>onclick</code>、<code>onchange</code>或<code>oninput</code>这样的事件将消息打印到页面上。然后，我们可以验证该消息的存在，以确保WebDriver确实如我们所期望的那样与元素进行了交互。</p>

<pre><code class="language-JavaScript">function interactionMessage(message) {
  document.getElementById('message').textContent = message;
}
</code></pre>

<p>第二个JavaScript函数使用<code>setTimeout()</code>函数等待5秒钟，然后向页面追加一个新的<code>&lt;div&gt;</code>元素。它还重置了ID为<code>div3_element</code>的div的样式，这将具有显示隐藏元素的效果。</p>

<p>在以后的文章中，我们将使用这两种对网页的动态更新来演示如何使用隐式和显式等待:</p>

<pre><code class="language-JavaScript">setTimeout(function() {
  var newDiv = document.createElement("div");
  newDiv.setAttribute("id", "newdiv_element");
  newDiv.textContent = "I am a newly created div";
  document.body.appendChild(newDiv);
  document.getElementById("div3_element").style.display = "";
}, 5000);
</code></pre>

<p>我们有一个<code>&lt;form&gt;</code>元素，它将保存一组常见的HTML表单元素，如按钮、文本框、单选按钮等。当表单提交时，<code>onsubmit</code>事件调用<code>interactionMessage()</code>方法显示一条消息。通过返回<code>false</code>阻止表单在提交时尝试重新加载页面:</p>

<pre><code class="language-HTML">&lt;form id="form_element" onsubmit="interactionMessage('Form Submitted'); return false"&gt;
</code></pre>

<p>表单内部是文本框、文本区域、按钮、单选按钮、复选框和选择元素的集合。像父元素<code>&lt;form&gt;</code>一样，大多数子元素调用<code>interactionMessage()</code>方法来响应事件:</p>

<pre><code class="language-html">&lt;button name="button_element" id="button_element" type="button" onclick="interactionMessage('Button Clicked')"&gt;Form Button&lt;/button&gt;
&lt;input name="text_element" id="text_element" type="text" oninput="interactionMessage('Text Input Changed')"&gt;
&lt;select name="select_element" id="select_element" onchange="interactionMessage('Select Changed')"&gt;
    &lt;optgroup label="Group 1"&gt;
        &lt;option id="option1.1_element"&gt;Option 1.1&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label="Group 2"&gt;
        &lt;option id="option2.1_element"&gt;Option 2.1&lt;/option&gt;
        &lt;option id="option2.2_element"&gt;Option 2.2&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label="Group 3" disabled&gt;
        &lt;option id="option3.1_element"&gt;Option 3.1&lt;/option&gt;
        &lt;option id="option3.2_element"&gt;Option 3.2&lt;/option&gt;
        &lt;option id="option3.3_element"&gt;Option 3.3&lt;/option&gt;
    &lt;/optgroup&gt;
&lt;/select&gt;
&lt;textarea name="textarea_element" id="textarea_element" name="textarea" rows="10" cols="50"
          oninput="interactionMessage('Text Area Changed')"&gt;&lt;/textarea&gt;
&lt;div&gt;&lt;input name="radio_group" id="radio1_element" type="radio" name="color" value="blue"
            onchange="interactionMessage('Radio Button Changed')"&gt; Blue
&lt;/div&gt;
&lt;div&gt;&lt;input name="radio_group" id="radio2_element" type="radio" name="color" value="green"
            onchange="interactionMessage('Radio Button Changed')"&gt; Green
&lt;/div&gt;
&lt;div&gt;&lt;input name="radio_group" id="radio3_element" type="radio" name="color" value="red"
            onchange="interactionMessage('Radio Button Changed')"&gt; Red
&lt;/div&gt;
&lt;div&gt;&lt;input name="checkbox1_element" id="checkbox1_element" type="checkbox" name="vehicle" value="Bike"
            onchange="interactionMessage('Checkbox Changed')"&gt; I have a bike
&lt;/div&gt;
&lt;div&gt;&lt;input name="checkbox2_element" id="checkbox2_element" type="checkbox" name="vehicle" value="Car" checked
            onchange="interactionMessage('Checkbox Changed')"&gt; I have a car
&lt;/div&gt;
&lt;input id="submit_element" type="submit"&gt;
</code></pre>

<p>在<code>&lt;form&gt;</code>之外，我们有一些image和div元素:</p>

<pre><code class="language-html">&lt;img id="image_element" src="java.png" width="128" height="128" onclick="interactionMessage('Image Clicked')"&gt;
&lt;div id="div_element" onclick="interactionMessage('Div Clicked')"&gt;I am a div&lt;/div&gt;
&lt;div id="div2_element" onclick="interactionMessage('Div 2 Clicked')"&gt;I am a div too&lt;/div&gt;
</code></pre>

<p>最后一个div元素的<code>display</code>样式设置为<code>none</code>，实际上在页面上隐藏了它。这个元素将在5秒钟后由<code>setTimeout()</code>方法调用的JavaScript显示:</p>

<pre><code class="language-HTML">&lt;div id="div3_element" style="display: none" onclick="interactionMessage('Div 3 Clicked')"&gt;I am a hidden div&lt;/div&gt;
</code></pre>

<p>最终结果是这样的。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image1.png" class="zoom" data-title=""><img src="../Images/949de41fbddac5911e73d02fcf66ea75.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image1.png"/>T2】</a></p>

<p>为了在Java测试中使用这个页面，我们需要将它保存在<code>src/test/resources</code>目录中。这是找到资源文件的标准Maven目录。</p>

<p>这个目录还不存在，所以我们通过右击测试目录并选择<span class="path">新➜目录</span>来创建它。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image2.png" class="zoom" data-title=""><img src="../Images/3c8037730096e9fc6b0d78e9890039fa.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image2.png"/>T2】</a></p>

<p>输入名称resources，然后单击<code>OK</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image3.png" class="zoom" data-title=""><img src="../Images/6cd5247b29efa5350cc74af46441a6b2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image3.png"/>T2】</a></p>

<p>正如我们已经多次看到的，在Maven项目中创建一个具有特殊意义的目录并不会自动更新IntelliJ项目。我们可以在下面的截图中看到,<code>resources</code>目录现在已经存在，但是在我们的项目中它看起来像一个普通的目录。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image4.png" class="zoom" data-title=""><img src="../Images/723b54fe4b8efefe785bb4d542d8a633.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image4.png"/>T2】</a></p>

<p>要更新IntelliJ项目，打开<code>Maven Projects</code>工具窗口并点击<code>Reimport All Maven Projects</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image5.png" class="zoom" data-title=""><img src="../Images/8baee8374969fb66a1dca64142d501ff.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image5.png"/>T2】</a></p>

<p>目录的图标被更新，以反映这样一个事实，即它将保存像我们的示例web页面这样的文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image6.png" class="zoom" data-title=""><img src="../Images/7ab67241d0ebfef922d67bff46eb04ec.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image6.png"/>T2】</a></p>

<p>一旦配置了<code>resources</code>文件夹，将HTML代码保存到一个名为<code>form.html</code>的文件中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image7.png" class="zoom" data-title=""> <img src="../Images/3e5fc18a22ca3fc5f58608a9aaa56bc7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image7.png"/> </a></p>

<p>我们现在已经完成了拼图的两个重要部分。首先，我们已经有了框架的雏形，它将允许我们创建灵活的<code>AutomatedBrowser</code>对象，通过这些对象我们可以与网页进行交互。第二，我们有一个样例web页面，其中包含了我们在编写WebDriver测试时可能会遇到的大多数元素。现在是时候写一些真正的WebDriver测试了。</p>

<p>让我们在类<code>FormTest</code>中创建一个测试方法<code>formTestByID()</code>，它将打开浏览器，打开我们的测试网页，然后再次关闭浏览器:</p>

<pre><code class="language-java">package com.octopus;

import org.junit.Test;
import java.net.URISyntaxException;

public class FormTest {

  private static final AutomatedBrowserFactory AUTOMATED_BROWSER_FACTORY = new AutomatedBrowserFactory();

  @Test
  public void formTestByID() throws URISyntaxException {
    final AutomatedBrowser automatedBrowser =
      AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Chrome");

    try {
      automatedBrowser.init();
      automatedBrowser.goTo(FormTest.class.getResource("/form.html").toURI().toString());
    } finally {
      automatedBrowser.destroy();
    }
  }
}
</code></pre>

<p>注意，我们可以通过调用<code>FormTest.class.getResource()</code>来访问样本HTML文件。因为我们将这个文件保存在标准目录<code>src/test/resources</code>下，Maven(以及通过扩展IntelliJ)允许我们通过Java代码访问这个文件。以下代码返回样本HTML文件的完整URL:</p>

<pre><code class="language-java">FormTest.class.getResource("/form.html").toURI().toString()
</code></pre>

<p>现在让我们手动打开同一个网页。IntelliJ为本地托管网页提供了便利的服务。当HTML文件在编辑器中打开时，可以通过单击屏幕右上角的快捷方式来访问它。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image8.png" class="zoom" data-title=""><img src="../Images/c42aa9113a6d7cef6b8ce0aba84df284.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image8.png"/>T2】</a></p>

<p>点击Chrome浏览器图标会打开Chrome到一个类似<a href="http://localhost:63342/webdrivertraining/form.html?_ijt=2r0gmmveunmkptr759pintjfe5" rel="nofollow">http://localhost:63342/web driver training/form . html？_ ijt = 2r 0 gmmveunmkptr 759 pintjfe 5</a>。这是一种快速简单的方法来查看我们的样本网页。</p>

<p>IntelliJ生成的URL不是我们通过调用<code>FormTest.class.getResource()</code>得到的URL。使用IntelliJ来托管web页面只是为了方便我们作为最终用户，但是我们在测试中不使用这个URL。事实上，我们不能使用这个URL，因为最后的查询字符串是随机生成的，会阻止任何其他用户或进程访问IntelliJ托管的页面。</p>


<p>我们要测试的第一件事是使用WebDriver点击页面顶部的按钮。</p>

<p>要与按钮交互，我们需要知道它的ID。我们知道这个按钮的ID是<code>button_element</code>，因为我们编写了HTML。但是，并不总是能够访问您将要测试的web应用程序的源代码。因此，我们将假设我们无法访问HTML源代码，而是使用Chrome提供的工具来查找这些信息。</p>

<p>在Chrome中加载页面后，右键单击按钮元素并单击<code>Inspect</code>选项。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image9.png" class="zoom" data-title=""><img src="../Images/c45a380184ca2b0e06857db487ea481d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image9.png"/>T2】</a></p>

<p>这将打开Chrome的开发者工具，并高亮显示<code>Elements</code>标签中的按钮HTML元素。</p>

<p>当JavaScript调用添加、删除和更改元素时，显示在开发工具<code>Elements</code>选项卡中的HTML元素会实时更新。这意味着您将经常从开发人员工具中获得比仅仅查看HTML源代码更多的信息。</p>

<p>您可以通过右击显示<code>I am a newly created div</code>的文本并选择<code>Inspect</code>选项来亲自查看。这将显示作为<code>setTimeout()</code>方法调用的结果而创建的<code>&lt;div&gt;</code>元素。您将不会在HTML源代码中看到那个<code>&lt;div&gt;</code>元素，因为它是在运行时动态生成的。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image10.png" class="zoom" data-title=""><img src="../Images/6dbf849c221e288f58f6685c3785e185.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image10.png"/>T2】</a></p>

<p>回到<code>&lt;button&gt;</code>元素，我们可以看到ID属性确实是<code>button_element</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image11.png" class="zoom" data-title=""><img src="../Images/0365bb89d992486c676244da1e462d93.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image11.png"/>T2】</a></p>

<p>既然我们知道了想要与之交互的元素的ID，我们就可以开始构建我们的测试了。我们首先调用<code>clickElementWithId()</code>，传入我们想要点击的元素的ID:</p>

<pre><code class="language-java">@Test
public void formTestByID() throws URISyntaxException {
  final AutomatedBrowser automatedBrowser = AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Chrome");

  try {
    automatedBrowser.init();
    automatedBrowser.goTo(FormTest.class.getResource("/form.html").toURI().toString());
    automatedBrowser.clickElementWithId("button_element");
  } finally {
    automatedBrowser.destroy();
  }
}
</code></pre>

<p>接下来，在<code>WebDriverDecorator</code>类中，我们需要添加一个<code>clickElementWithId()</code>方法的实现:</p>

<pre><code class="language-java">@Override
public void clickElementWithId(final String id) {
  webDriver.findElement(By.id(id)).click();
}
</code></pre>

<p>当您将这段代码粘贴到<code>WebDriverDecorator</code>类中时，ItelliJ将以红色显示<code>By</code>类。这是因为我们没有导入包含<code>By</code>类的包。</p>

<p>要解决这个问题，请将鼠标光标放在红色文本上，然后单击ALT + Enter。这将显示一个带有<code>Import class</code>选项的上下文菜单。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image12.png" class="zoom" data-title=""><img src="../Images/ad7f3976b4592cb4acee393d50befce1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image12.png"/>T2】</a></p>

<p>IntelliJ通常很擅长根据类的上下文来决定导入哪个包，在这种情况下，它会将<code>import org.openqa.selenium.By;</code>语句添加到类的顶部。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image13.png" class="zoom" data-title=""><img src="../Images/051e35d53d9303ddec03d62b7ee0a6b5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/5-a-sample-web-page/image13.png"/>T2】</a></p>

<p><code>clickElementWithId()</code>方法做了三件重要的事情。</p>

<p>首先，它通过调用<code>By.id(id)</code>找到我们希望与之交互的元素。<code>By</code>类用于查找网页中的元素，并提供一系列方法来执行搜索。因为我们通过ID搜索元素，所以我们称之为<code>By.id()</code>。</p>

<p>其次，我们调用web驱动程序类上的<code>findElement()</code>方法来查找元素。</p>

<p>第三，我们获取由<code>findElement()</code>返回的元素并调用<code>click()</code>方法来模拟终端用户点击该元素。</p>

<p>定义如何用<code>By</code>类搜索元素，用<code>findElement()</code>方法找到元素，并调用类似<code>click()</code>的方法来模拟一个动作，这个过程是我们在构建测试框架时要反复重复的。</p>

<p>但是我们如何确定WebDriver真的点击了按钮呢？如果您回头看一下<code>form.html</code>页面的源代码，您会看到<code>&lt;button&gt;</code>元素具有属性<code>onclick="interactionMessage('Button Clicked')"</code>。这意味着当点击按钮时，用<code>'Button Clicked'</code>调用<code>interactionMessage()</code>方法，这又会在页面上显示文本<code>Button Clicked</code>。</p>

<p>然后，我们可以从保存消息<code>Button Clicked</code>的元素中提取文本，并验证它是否表达了我们期望它表达的内容。</p>

<p>为此，我们调用<code>getTextFromElementWithId()</code>方法，传入包含我们希望返回的文本的元素的ID，在我们的例子中是保存我们希望验证的消息文本的<code>&lt;div&gt;</code>元素的ID。然后，我们使用JUnit提供的<code>assertEquals()</code>来验证这个方法调用的结果:</p>

<pre><code class="language-java">@Test
public void formTestByID() throws URISyntaxException {
  final AutomatedBrowser automatedBrowser =
  AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Chrome");

  try {
    automatedBrowser.init();
    automatedBrowser.goTo(FormTest.class.getResource("/form.html").toURI().toString());

    automatedBrowser.clickElementWithId("button_element");
    assertEquals("Button Clicked", automatedBrowser.getTextFromElementWithId("message"));
  } finally {
    automatedBrowser.destroy();
  }
}
</code></pre>

<p>然后，<code>getTextFromElementWithId()</code>方法需要在<code>WebDriverDecorator</code>类中实现。</p>

<p>注意，<code>getTextFromElementWithId()</code>方法遵循与<code>clickElementWithId()</code>相同的模式。事实上，唯一的区别是我们在结果元素上调用了<code>getText()</code>，而不是<code>click()</code>:</p>

<pre><code class="language-java">@Override
public String getTextFromElementWithId(final String id) {
  return webDriver.findElement(By.id(id)).getText();
}
</code></pre>

<p>这样，我们就成功地用WebDriver点击了一个元素，并验证了页面的响应符合我们的预期。</p>

<p>让我们继续用文本填充文本框和文本区域，并验证这些字段上的事件处理程序将预期的消息打印到页面上:</p>

<pre><code class="language-Java">automatedBrowser.populateElementWithId("text_element", "test text");
assertEquals("Text Input Changed", automatedBrowser.getTextFromElementWithId("message"));

automatedBrowser.populateElementWithId("textarea_element", "test text");
assertEquals("Text Area Changed", automatedBrowser.getTextFromElementWithId("message"));
</code></pre>

<p>然后，<code>populateElementWithId()</code>方法需要在<code>WebDriverDecorator</code>类中实现。在这种情况下，我们对返回的元素使用<code>sendKeys()</code>方法来填充文本:</p>

<pre><code class="language-Java">@Override
public void populateElementWithId(String id, String text) {
  webDriver.findElement(By.id(id)).sendKeys(text);
}
</code></pre>

<p>接下来，我们将从下拉列表中选择一个选项:</p>

<pre><code class="language-Java">automatedBrowser.selectOptionByTextFromSelectWithId("Option 2.1", "select_element");
assertEquals("Select Changed", automatedBrowser.getTextFromElementWithId("message"));
</code></pre>

<p><code>selectOptionByTextFromSelectWithId()</code>方法与我们之前看到的模式略有不同。</p>

<p><code>findElement()</code>方法返回<code>WebElement</code>接口的一个实例。<code>WebElement</code>接口反过来通过如下方法公开了一些常见的动作:</p>

<ul>
<li><code>click()</code></li>
<li><code>sendKeys()</code></li>
<li><code>clear()</code></li>
<li><code>submit()</code></li>
<li><code>getText()</code></li>
</ul>

<p>您可以通过查看Javadoc API文档获得这些方法的完整列表。</p>

<p>值得注意的是，这个动作列表中没有从下拉列表中选择选项的功能。为了与一个<code>&lt;select&gt;</code>元素交互，我们需要创建一个<code>Select</code>类的实例，它的构造函数接受由<code>findElement()</code>返回的<code>WebElement</code>。然后我们可以使用<code>selectByVisibleText()</code>方法，该方法选择带有相应文本的选项:</p>

<pre><code class="language-java">@Override
public void selectOptionByTextFromSelectWithId(String optionText, String selectId) {
  new Select(webDriver.findElement(By.id(selectId))).selectByVisibleText(optionText);
}
</code></pre>

<p>点击单选按钮和复选框的方法与我们点击按钮的方法相同:</p>

<pre><code class="language-Java">automatedBrowser.clickElementWithId("radio3_element");
assertEquals("Radio Button Changed", automatedBrowser.getTextFromElementWithId("message"));

automatedBrowser.clickElementWithId("checkbox2_element");
assertEquals("Checkbox Changed", automatedBrowser.getTextFromElementWithId("message"));
</code></pre>

<p>我们不局限于与表单元素交互。<code>clickElementWithId()</code>方法同样适用于图像和普通旧div等元素:</p>

<pre><code class="language-Java">automatedBrowser.clickElementWithId("image_element");
assertEquals("Image Clicked", automatedBrowser.getTextFromElementWithId("message"));

automatedBrowser.clickElementWithId("div_element");
assertEquals("Div Clicked", automatedBrowser.getTextFromElementWithId("message"));
</code></pre>

<p>通过<code>formTestByID()</code>测试，我们已经成功地点击、检查、输入和选择了一个实时的交互式网页的选项，并验证了结果。简而言之，这就是编写WebDrivers测试的全部内容。然而，我们并不总是能够根据ID属性来定位元素。在这些情况下，WebDriver提供了许多其他方法来定位web页面中的元素，接下来我们将讨论这些方法。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>