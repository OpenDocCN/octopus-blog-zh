<html>
<head>
<title>Kubernetes RFC - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kubernetes RFC - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/kubernetes-rfc#2022-07-05">https://octopus.com/blog/kubernetes-rfc#2022-07-05</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/kubernetes-rfc/blogimage-kubernetes-rfc.png" class="zoom" data-title=""><img src="../Images/330e117becb6692c9626137bcb87addc.png" class="img-fluid center" alt="Octopus sailing Kubernetes" data-original-src="https://i.octopus.com/blog/2018-02/kubernetes-rfc/blogimage-kubernetes-rfc.png"/>T2】</a></p>

<p>Kubernetes赢得了容器编排之战(至少在本周)。也许不出所料，<a href="https://octopusdeploy.uservoice.com/forums/170787-general/suggestions/17930755-support-for-kubernetes" rel="nofollow"> Kubernetes在我们的顶级用户声音建议列表中飙升至第7位</a>。</p>

<p>我们一直在思考Kubernetes在Octopus中的支持可能会是什么样子，我们很想听听你的想法。通常当我们在设计功能时，我们想知道一个典型的用户是什么样子，我们只需要照照镜子。对于Kubernetes，情况并非如此。我们目前没有在内部使用k8s(虽然随着我们构建托管产品，这种情况可能会改变)，所以我们肯定需要你的帮助。</p>

<p>我们目前的想法是Kubernetes的支持将采取以下形式:</p>



<h2 id="kubernetes-cluster-target">Kubernetes集群目标</h2>

<p>我们将引入一个新的<em> Kubernetes集群</em>目标类型，来表示新的Kubernetes步骤将执行的集群。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-cluster-target-option.png" class="zoom" data-title=""><img src="../Images/3da620af53591d57e111f7761adae67c.png" class="img-fluid center" alt="Kubernetes Cluster Target Option" data-original-src="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-cluster-target-option.png"/>T2】</a></p>

<p>该目标将允许您配置Kubernetes集群的URL和身份验证细节。</p>

<p>我们可能会支持以下认证方法:</p>

<ul>
<li>用户名+密码</li>
<li>证书</li>
<li>API令牌</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-cluster-target.png" class="zoom" data-title=""><img src="../Images/146dd2f86b6caaf8a4cf9082fbef573f.png" class="img-fluid center" alt="Kubernetes Cluster Target Details" data-original-src="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-cluster-target.png"/>T2】</a></p>

<h2 id="kubernetes-apply-step">忽必烈应用步骤</h2>

<p>Kubernetes支持对象管理的声明性和命令性模式。</p>

<p>对于Octopus来说，支持声明性方法似乎是一种自然的选择。这是通过<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply" rel="nofollow"> Kubernetes应用命令</a>实现的。我们将通过专门的<em> Kubernetes应用</em>步骤来揭示这一点。</p>

<p>【T2 <img src="../Images/07aac0ada195f58b3c951789dad16125.png" class="img-fluid center" alt="Kubernetes Apply Step" data-original-src="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-apply-step.png"/></p>

<p>Apply命令接受一个模板(JSON或YAML)。这在概念上类似于Octopus中的<a href="https://octopus.com/docs/deployments/aws/cloudformation"> AWS CloudFormation </a>或<a href="https://octopus.com/docs/runbooks/runbook-examples/azure/resource-groups"> Azure Resource Group </a>步骤的工作方式。k8s模板可以来自一个包，也可以直接在Octopus UI中配置。</p>

<h3 id="container-images">容器图像</h3>

<p>k8s模板指定容器图像。例如，下面的模板指定了nginx映像的版本1.7.9。</p>

<pre><code>apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  minReadySeconds: 5
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
</code></pre>

<p>当创建一个包含Kubernetes应用步骤的项目发布时，我们将允许您指定您希望使用的容器映像的版本。</p>

<p>当您部署该版本时，我们会在将它发送到Kubernetes集群之前，将容器映像的正确版本替换到您的模板中。</p>

<p>这是章鱼特制酱。它允许您对容器映像版本的特定组合进行快照，并在您的环境中进行处理。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-create-release.png" class="zoom" data-title=""><img src="../Images/33d11f9229c9fa8494991d3b2a153fec.png" class="img-fluid center" alt="Create Release with Container Images" data-original-src="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubernetes-create-release.png"/>T2】</a></p>

<p>您可以在上面的UI模型中看到，您选择了两个版本:</p>

<ul>
<li>包含Kubernetes模板的包的版本(上面例子中的<code>AcmeWebApp</code>)。</li>
<li>模板中容器图像<em>的版本(在本例中为<code>nginx</code>)。</em></li>
</ul>

<h3 id="variable-substitution">变量替换</h3>

<p>我们将在Kubernetes模板上执行<a href="https://octopus.com/docs/projects/variables/variable-substitutions">变量替换</a>。所以你可以直接在里面使用章鱼变量，它们会被替换掉。</p>

<p>不幸的是，Kubernetes不支持模板的参数文件(例如<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html" rel="nofollow"> CloudFormation </a>和<a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-templates-parameters" rel="nofollow"> Azure RM </a>模板支持)。这很不幸，因为参数文件似乎是模板作者告诉Octopus这样的工具哪些值应该作为参数提供的理想方式。</p>

<p>您希望如何向Kubernetes Apply命令提供变量？</p>

<p>一些选项可能是:</p>

<ol>
<li><p><strong>直接在模板</strong>上替换变量:例如，您可以在模板中包含<code>#{Octopus.Environment}</code>，它在部署时会被适当的值替换。这与像<a href="https://helm.sh/" rel="nofollow"> helm </a>这样的工具的方法是一致的，但是也有不利的一面，你的模板在Octopus之外是无效的(甚至可能是无效的JSON或YAML)。</p>
</li>
<li><p><strong>转换文件</strong>:与<a href="https://msdn.microsoft.com/library/dd465326.aspx" rel="nofollow"> Microsoft web.config转换</a>类似，您可以在模板旁边放置一个转换文件。然后，转换文件可以包含被替换的Octopus变量，然后转换将被应用到模板。这种方法的优点是您的模板可以保持有效，并且您的转换可以存在于您的模板旁边(例如，在您的git repo中)。对于JSON模板，有<a href="https://github.com/Microsoft/json-document-transforms/wiki" rel="nofollow">现有的实现</a>。对于YAML，我们找不到太多...</p>
</li>
<li><p><strong>显式配置的替换</strong>:我们还可以允许在步骤UI中提供键值对，这将指定模板中的属性被替换。我们可以支持嵌套属性(见下面的例子)。这样做的缺点是，如果您的模板结构发生变化，您必须更新Octopus中的部署步骤。</p>
</li>
</ol>

<table class="table" foo="">
<thead>
<tr>
<th>钥匙</th>
<th>价值</th>
<th>评论</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>foo</code></td>
<td><code>#{Foo}</code></td>
<td>顶级属性<code>foo</code>将被替换为#的值。</td>
</tr>
<tr>
<td><code>foo::bar</code></td>
<td><code>#{AnotherVariable}</code></td>
<td>嵌套属性<code>foo.bar</code>将被替换。</td>
</tr>
</tbody>
</table>

<p>如前所述，我们肯定会实现选项#1(如果你的模板中没有任何Octopus变量占位符，那么它不会做任何事情)。但是如果你更喜欢其他提供变量的方法(包括上面没有提到的)，请留下你的评论。</p>

<h2 id="kubectl-script-step">kubectl脚本步骤</h2>

<p>除了<code>apply</code>之外，还有许多其他的<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands" rel="nofollow"> Kubernetes命令</a>你可能希望执行。比如:<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete" rel="nofollow">删除资源</a>、<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#scale" rel="nofollow">缩放</a>等。</p>

<p>我们将通过添加一个新的Run a Script步骤来实现这些功能:<em> Run a kubectl Script </em>。</p>

<p>这一步将允许您编写自己的脚本，我们确保<code>kubectl</code>命令行是可用的，并且针对该步骤所针对的Kubernetes集群进行了验证。这在概念上类似于我们的<a href="https://octopus.com/docs/deployments/custom-scripts/aws-cli-scripts">运行AWS CLI脚本</a>或<a href="https://octopus.com/docs/deployments/azure/running-azure-powershell">运行Azure PowerShell脚本</a>步骤，它们分别针对AWS和Azure进行身份验证并提供SDK。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubectl-script-step.png" class="zoom" data-title=""><img src="../Images/79bbf7b4b195b42b0e192c85b39e5add.png" class="img-fluid center" alt="kubectl Script Step" data-original-src="https://i.octopus.com/blog/2018-02/kubernetes-rfc/kubectl-script-step.png"/>T2】</a></p>

<h2 id="we-need-your-help">我们需要你的帮助</h2>

<p>我们认为这将很好地符合现有的Octopus概念和架构，但我们需要你告诉我们这是否符合你期望与Kubernetes交互的方式。</p>

<p>如果您目前正在使用Kubernetes(或者正计划使用),我们很想听听您的情况。帮我们把k8s带到o5s。</p>

                    
                    
</body>
</html>