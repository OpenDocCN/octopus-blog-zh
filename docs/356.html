<html>
<head>
<title>Java CI/CD: From release management to operations - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Java CI/CD:从发布管理到运营——Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/java-ci-cd-co/from-cd-to-co#2022-12-23">https://octopus.com/blog/java-ci-cd-co/from-cd-to-co#2022-12-23</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/blogimage-java-blog-series-6.png" class="zoom" data-title=""><img src="../Images/bbd941e5cb9a1b53226b3bcf1fd6f923.png" class="img-fluid center" alt="Java CI/CD: From release management to operations" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/blogimage-java-blog-series-6.png"/>T2】</a></p>

<p>本文是展示Jenkins、Docker和Octopus示例部署管道系列的一部分:</p>



<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/operate.svg" class="zoom" data-title=""><img src="../Images/9100a933cfab77a81f4bc4543d3fc486.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/operate.svg"/>T2】</a></p>

<p><a href="/blog/java-ci-cd-co/from-ci-to-cd">在之前的博文</a>中，我们集成了Jenkins和Octopus，在Docker映像被推送到Docker Hub后触发了对Kubernetes的部署。我们还在Octopus中添加了额外的环境来表示规范的<span class="path">开发➜测试➜生产</span>进程。这给我们留下了一个在环境之间自动(如果不一定是自动的)发布管理的部署管道。</p>

<p>虽然传统的部署渠道以生产部署结束，但Octopus通过runbooks为DevOps生命周期的运营阶段提供了解决方案。通过使用runbooks自动执行数据库备份、日志收集和服务重启等常见任务，Jenkins和Octopus的结合提供了一个完整的部署和运营管道，涵盖了应用程序的整个生命周期。</p>

<h2 id="add-a-database">添加数据库</h2>

<p>在为数据库备份创建操作手册之前，我们需要一个数据库。</p>

<p>您通常会在生产环境中使用RDS之类的托管服务。RDS提供了现成的高可用性、备份、维护窗口、安全性等，所有这些都需要花费大量精力来使用本地数据库进行复制。然而，出于本博客的演示目的，我们将把MySQL部署到EKS，并将我们的PetClinic应用程序指向它。然后，我们可以针对数据库编写常见管理任务的脚本，以演示保持生产部署运行的连续操作。</p>

<p>我们将使用官方的<a href="https://hub.docker.com/_/mysql" rel="nofollow"> MySQL </a> Docker映像，但是我们还需要一些额外的工具来将备份转移到第二个位置。因为我们使用AWS来托管我们的Kubernetes集群，所以我们将把数据库备份到S3。这意味着我们需要MySQL Docker映像中包含的AWS CLI来传输数据库备份。</p>

<p>向图像添加新工具很容易。我们获取基本的<strong> mysql </strong>映像，并运行安装AWS CLI所需的命令。我们的<a href="https://github.com/mcasperson/mysqlwithawscli/blob/master/Dockerfile" rel="nofollow"> Dockerfile </a>看起来像这样:</p>

<pre><code class="language-dockerfile">FROM mysql
RUN apt-get update; apt-get install python python-pip -y
RUN pip install awscli
</code></pre>

<p>然后，我们构建这个映像，将其推送到Docker Hub，并使用下面的<a href="https://github.com/mcasperson/mysqlwithawscli/blob/master/Jenkinsfile" rel="nofollow"> Jenkinsfile </a>在Octopus中创建和部署一个版本。您会注意到，这个<code>Jenkinsfile</code>几乎是前一个的一个精确副本，对Docker映像和部署的Octopus项目的名称进行了更改:</p>

<pre><code class="language-groovy">pipeline {
    agent {
        label 'docker'
    }
    //  parameters here provide the shared values used with each of the Octopus pipeline steps.
    parameters {
        // The space ID that we will be working with. The default space is typically Spaces-1.
        string(defaultValue: 'Spaces-1', description: '', name: 'SpaceId', trim: true)
        // The Octopus project we will be deploying.
        string(defaultValue: 'MySQL', description: '', name: 'ProjectName', trim: true)
        // The environment we will be deploying to.
        string(defaultValue: 'Dev', description: '', name: 'EnvironmentName', trim: true)
        // The name of the Octopus instance in Jenkins that we will be working with. This is set in:
        // Manage Jenkins -&gt; Configure System -&gt; Octopus Deploy Plugin
        string(defaultValue: 'Octopus', description: '', name: 'ServerId', trim: true)
    }
    stages {
        stage ('Add tools') {
            steps {
                tool('OctoCLI')
            }
        }
        stage('Building our image') {
            steps {
                script {
                    dockerImage = docker.build "mcasperson/mysqlwithawscli:$BUILD_NUMBER"
                }
            }
        }
        stage('Deploy our image') {
            steps {
                script {
                    // Assume the Docker Hub registry by passing an empty string as the first parameter
                    docker.withRegistry('' , 'dockerhub') {
                        dockerImage.push()
                    }
                }
            }
        }
        stage('deploy') {
            steps {                                
                octopusCreateRelease deployThisRelease: true, environment: "${EnvironmentName}", project: "${ProjectName}", releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default', waitForDeployment: true                
            }
        }
    }
}
</code></pre>

<p>MySQL Kubernetes部署YAML也与我们的<a href="/blog/java-ci-cd-co/from-ci-to-cloud">之前的示例</a>非常相似，使用了新的映像名称，并添加了两个环境变量来配置数据库凭证和创建初始数据库:</p>

<pre><code class="language-YAML">apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
spec:
  replicas: 1
  strategy:
    type: Recreate
  template:
    spec:
      containers:
        - name: mysql
          image: mcasperson/mysqlwithawscli
          ports:
            - name: sql
              containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: Password01!
            - name: MYSQL_DATABASE
              value: petclinic
</code></pre>

<p>因为我们不需要公开访问数据库，所以我们使用集群IP服务公开MySQL实例，这允许其他pods访问数据库，但不会创建公共负载平衡器:</p>

<pre><code class="language-YAML">apiVersion: v1
kind: Service
metadata:
  name: mysql
spec:
  type: ClusterIP
  ports:
    - name: sql
      port: 3306
      protocol: TCP
</code></pre>

<p>部署由上面的YAML创建的资源会导致可以使用主机名<code>mysql</code>从集群中的其他pods访问MySQL实例。</p>

<p>为了配置PetClinic使用MySQL数据库，我们需要定义四个环境变量。这些变量用于配置<a href="https://github.com/mcasperson/spring-petclinic/blob/main/src/main/resources/application-mysql.properties" rel="nofollow">应用程序-mysql.properties </a>配置文件中的设置:</p>

<ul>
<li><code>MYSQL_URL</code>，这是MySQL数据库的JDBC URL。</li>
<li><code>MYSQL_USER</code>，作为MySQL用户连接，设置为<code>root</code>。</li>
<li><code>MYSQL_PASS</code>，这是MySQL密码，设置为我们在MySQL pod上的<code>MYSQL_ROOT_PASSWORD</code>环境变量中定义的密码。</li>
<li><code>SPRING_PROFILES_ACTIVE</code>，它定义了Spring将用来配置应用程序的概要文件，设置为mysql来加载<a href="https://github.com/mcasperson/spring-petclinic/blob/main/src/main/resources/application-mysql.properties" rel="nofollow">应用程序-mysql.properties </a>配置文件。</li>
</ul>

<p>我们新PetClinic部署的YAML如下所示:</p>

<pre><code class="language-YAML">apiVersion: apps/v1
kind: Deployment
metadata:
  name: petclinic
spec:
  replicas: 1
  template:
    spec:
      containers:
        - name: petclinic
          image: mcasperson/petclinic
          ports:
            - name: web
              containerPort: 8080
          env:
            - name: MYSQL_URL
              value: 'jdbc:mysql://mysql/petclinic'
            - name: SPRING_PROFILES_ACTIVE
              value: mysql
            - name: MYSQL_USER
              value: root
            - name: MYSQL_PASS
              value: Password01!
</code></pre>

<p>我们现在有了一个MySQL数据库，并配置了PetClinic将其用作数据存储。</p>

<h2 id="backup-the-database">备份数据库</h2>

<p>在开发运维生命周期的持续运营阶段，最明显的任务之一可能就是备份数据库。</p>

<p><a href="https://hub.docker.com/_/mysql" rel="nofollow"> MySQL Docker image </a>文档提供了一个使用<code>mysqldump</code>在活动容器内运行<code>docker exe</code>来备份数据库的示例命令。我们将以那个例子为例，将其重写为对<code>kubectl exe</code>的调用，以在一个正在运行的pod上执行备份。</p>

<p>下面的PowerShell脚本找到了MySQL pod的名称(由于该pod是作为部署的一部分创建的，所以它的名称是随机的)，调用<code>mysqldump</code>创建数据库的备份，然后调用<code>aws s3 cp</code>将备份上传到S3:</p>

<pre><code class="language-powershell"># Get the list of pods in JSON format
kubectl get pods -o json |
# Convert the output to an object
ConvertFrom-Json |
# Get the items property
Select -ExpandProperty items |
# Limit the items to those with the name starting with "mysql"
? {$_.metadata.name -like "mysql*"} |
# We only expect to find 1 such pod
Select -First 1 |
# Execute mysqldump on the pod to perform a backup
% {
    Write-Host "Performing backup on pod $($_.metadata.name)"
    kubectl exec $_.metadata.name -- /bin/sh -c 'mysqldump -u root -p#{MySQL Password} petclinic &gt; /tmp/dump.sql 2&gt; /dev/null'
    kubectl exec $_.metadata.name -- /bin/sh -c 'AWS_DEFAULT_REGION=us-east-1 AWS_ACCESS_KEY_ID=#{AWS.AccessKey} AWS_SECRET_ACCESS_KEY=#{AWS.SecretKey} aws s3 cp /tmp/dump.sql s3://mattc-deployment-backup/dump.sql'    
}
</code></pre>

<p>该脚本在添加到runbook的<strong>运行kubectl CLI脚本</strong>步骤中执行:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/mysqldump.png" class="zoom" data-title=""> <img src="../Images/588010ec0ea90730f32c3e4a92770303.png" class="img-fluid center" alt="The kubectl script performing the database backup" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/mysqldump.png"/> </a> <em>执行数据库备份的kubectl脚本。</em></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/backuplogs.png" class="zoom" data-title=""> <img src="../Images/7dc7d7bce128ff4c180cf4b893d8fe4e.png" class="img-fluid center" alt="The result of executing the database backup" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/backuplogs.png"/> </a> <em>执行数据库备份的结果。</em></p>

<p>我们不想手动备份数据库，所以Octopus允许安排runbooks。这里我们有一个执行每日备份的触发器:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/backuptrigger.png" class="zoom" data-title=""> <img src="../Images/6551daef57584e9f4b96821a4c8eb2e4.png" class="img-fluid center" alt="A scheduled backup" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/backuptrigger.png"/> </a> <em>定时备份。</em></p>

<p>虽然找到执行备份的pod的名称需要一些处理，但是这个脚本并不特别复杂，经验丰富的系统管理员无疑见过比这复杂得多的管理脚本。按计划运行脚本的能力也不是什么突破性的东西。</p>

<p>当您考虑到在应用程序的生命周期中需要与这个基础设施进行交互的不同团队时，这种方法的真正优势就变得很明显了。</p>

<p>因为Octopus已经部署到我们的基础设施中，所以我们不需要复制凭证或其他设置(如URL)来管理基础设施。都已经在章鱼里了。</p>

<p>操作手册消除了对额外工具和配置设置的需要，否则这些工具和配置设置可能需要在专门的支持笔记本电脑上维护，这意味着电话支持人员只需点击一个按钮，就可以从网络浏览器(如有必要，在他们的电话上)执行这些操作手册。因为这些操作手册的执行是在审计日志中捕获的，并且这些步骤的输出是在操作手册运行的历史中捕获的，所以在发现问题的根本原因时，您不会遇到同样的困难，如果运营团队必须从他们自己的工作站运行临时脚本，您就会遇到同样的困难。</p>

<p>一个额外的好处是，run book知道我们的多种环境，所以正如我们的应用程序代码必须通过多种环境才能被认为已准备好用于生产发布，我们的run book也可以在非生产环境中进行测试和验证，以确保它们在生产中可以被信任。</p>

<p>所有这一切意味着支持生产系统所需的业务知识现在可以在可测试和可重复的操作手册中获取，使得支持移交更加容易，因为所有团队都共享相同的工具箱。</p>

<p>当保存在操作手册中时，这十几行PowerShell代表了一个共享的、可验证的、可审计的、易于访问的集中式业务知识单元，旨在保持您的系统以最佳状态运行。</p>

<h2 id="restarting-pods">重启pod</h2>

<p>让我们看另一个例子，这次是重新启动PetClinic应用程序。</p>

<p>下面的脚本找到名称以<strong> petclinic </strong>开头的pod并删除它们。因为这些pod是由Kubernetes部署创建的，所以它们将被自动重新创建，实质上是执行pod重启:</p>

<pre><code class="language-powershell"># Get the list of pods in JSON format
kubectl get pods -o json |
# Convert the output to an object
ConvertFrom-Json |
# Get the items property
Select -ExpandProperty items |
# Limit the items to those with the name starting with "mysql"
? {$_.metadata.name -like "petclinic*"} |
# Delete the pod to have the deployment recreate it
% { kubectl delete pod $_.metadata.name}
</code></pre>

<p>如果你不熟悉Kubernetes，像<code>kubectl delete</code>这样的命令可能会让人望而生畏。碰巧的是，由于我们的应用程序的部署方式，该操作将重启pod，而不是永久删除它们。但是DevOps团队的新成员如何知道这个命令是安全的呢？</p>

<p>通过向运行手册添加描述，我们可以提供运行手册何时何地可以运行的指导。在下面的截图中，您可以看到对<strong> Restart PetClinic </strong> runbook的描述，它清楚地表明这是可以在生产中运行的东西:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/restartpods.png" class="zoom" data-title=""> <img src="../Images/c365dd89eab10ae85b6e24666f1fa4ec.png" class="img-fluid center" alt="Runbooks with a description" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-cd-to-co/restartpods.png"/> </a> <em>带有描述的运行手册，帮助运营团队了解何时何地运行它们。</em></p>

<p>更进一步，我们可以使用Octopus中的权限来限制对运行手册的访问，这可能需要更深入地了解基础架构才能安全运行，或者在采取任何行动之前使用手动干预来获得批准。</p>

<p>同样，这是一个将业务知识封装在操作手册中以减轻基础设施支持负担的例子。</p>

<h2 id="conclusion">结论</h2>

<p>传统的部署管道以部署结束，但实际上，部署之后发生的事情与部署本身一样重要。这就是连续作战思想的由来。Runbooks为您的团队提供了从第一次代码提交到产品部署后数周、数月或数年支持应用程序所需的工具。因为Octopus已经了解了您的基础架构以及如何部署到基础架构，所以runbooks可以轻松利用现有的凭证、目标和环境来实现DevOps生命周期的运营阶段。</p>

<p>基本上，操作手册将保持部署运行的脚本和工作流本身视为一种有价值的产品。从持续交付中获取<a href="https://octopus.com/devops/continuous-delivery/">最佳实践，并将其扩展到运营任务中，可确保整个应用生命周期由您的开发运维团队以连贯的方式进行管理。</a></p>

<p>通过这篇博文，我们结束了从本地构建的遗留Java应用程序到集成了Jenkins、Octopus、Docker和AWS EKS的完整<a href="https://octopus.com/devops/continuous-delivery/what-is-a-deployment-pipeline/">部署管道</a>的旅程。我希望示例管道为在您的组织中实现持续集成(CI)、发布管理和持续操作提供了一个基础。</p>

<p>浏览<a href="https://octopus.com/devops/"> DevOps工程师手册</a>了解更多关于DevOps和持续交付的信息。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>