<html>
<head>
<title>Deploying AWS SAM templates with Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Octopus - Octopus Deploy部署AWS SAM模板</h1>
<blockquote>原文：<a href="https://octopus.com/blog/aws-sam-and-octopus#2021-11-23">https://octopus.com/blog/aws-sam-and-octopus#2021-11-23</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/blogimage_deploy_aws_sam_apps.png" class="zoom" data-title=""><img src="../Images/159c330c1f134a961f2a0714b6765621.png" class="img-fluid center" alt="Illustration showing an AWS SAM deployment with Octopus Deploy" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/blogimage_deploy_aws_sam_apps.png"/>T2】</a></p>

<p>随着微服务等开发模式越来越受欢迎，云提供商正在大力投资无服务器计算平台，作为管理和执行许多小型独立应用程序的一种方式。</p>

<p>AWS无服务器应用程序模型(AWS SAM)将部署无服务器应用程序时常用的AWS服务联系在一起。AWS SAM构建在CloudFormation之上，删除了许多常见的样板代码，使得无服务器应用程序的部署变得快速而简单。</p>

<p>在这篇博客文章中，我们将探讨如何从AWS SAM提供的简单部署流程过渡到Octopus中跨多个环境的可重复部署。</p>

<p>这篇博文的源代码是<a href="https://github.com/OctopusDeploy/AWSSamExample" rel="nofollow">这里</a>。</p>

<h2 id="the-hello-world-app">Hello World应用程序</h2>

<p>我们将从使用SAM CLI工具创建的Python Hello World应用程序开始。创建该应用程序的过程记录在<a href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-getting-started-hello-world.html#serverless-getting-started-hello-world-initialize" rel="nofollow">这里</a>。</p>

<p>由SAM CLI命令<code>sam init --runtime python3.7</code>和<code>sam build</code>生成的样本代码已经提交给了一个<a href="https://github.com/OctopusDeploy/AWSSamExample" rel="nofollow"> GitHub repo </a>，我们将使用这个repo作为我们部署过程的起点。</p>

<h2 id="building-the-application-with-github-actions">用Github动作构建应用程序</h2>

<p>如果您遵循典型的AWS SAM工作流，在运行了<code>sam init</code>和<code>sam build</code>之后，您将运行类似于<code>sam package --s3-bucket &lt;yourbucket&gt;</code>的命令，这将:</p>

<ul>
<li>将您的源代码与任何依赖项捆绑在一起。</li>
<li>将包上传到S3。</li>
<li>将SAM模板中的<code>CoreUri</code>字段替换为文件在S3的位置。</li>
</ul>

<p>值得注意的是，CloudFormation和SAM不会从您的本地PC部署代码；一切都必须上传到S3。<code>sam package</code>命令的好处是它为您自动完成工作，产生一个经过处理的模板，然后您可以用CloudFormation部署它。</p>

<p>然而，当您需要跨多个环境实现可重复的部署时,<code>sam package</code>命令可能有点笨拙。上传的S3文件有一个类似于<code>fecddec7c6c40bd9de28f1775cd11e0e</code>的随机生成的名字，这使得几乎不可能找出哪个代码包是为给定版本部署的。您还负责保存一份处理过的模板文件的副本(也就是更新了<code>CoreUri</code>字段的那个)，这样您就可以跟踪哪个模板与哪个代码相关联。</p>

<p>或者<a href="https://github.com/awslabs/aws-sam-cli/issues/648#issuecomment-419538378" rel="nofollow">引用SAM开发者自己的话</a>:</p>

<blockquote class="blockquote">
<p>是的，“山姆包”是初步的。真正的解决方案是创建一个更好的包命令，更好地进行内容寻址(可以使用git sha、content sha或客户提供的命名函数)。</p>
</blockquote>

<p>我们将采用稍微不同的方法，管理打包和上传包，并创建一个通用模板文件，可以在部署期间由Octopus更新。这将为我们提供合理的文件名，并创建可重用的模板。</p>

<p>我们将通过GitHub操作实现这一点，工作流YAML如下:</p>

<pre><code class="language-yaml">name: Python package

on: [push]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Get Git Version
      uses: docker://mcasperson/gitversion:5.0.2-linux-centos-7-netcoreapp2.2
      with:
        args: /github/workspace /nofetch /exec /bin/sh /execargs "-c \"echo $GitVersion_FullSemVer &gt; /github/workspace/version.txt\""
    - name: Set up Python 3.7
      uses: actions/setup-python@v1
      with:
        python-version: 3.7
    - name: Package dependencies
      # Permissions are documented at
      # https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html
      run: |
        python -m pip install --upgrade pip
        cd hello_world
        pip download -r requirements.txt
        unzip \*.whl
        rm *.whl
        chmod 644 $(find . -type f)
        chmod 755 $(find . -type d)
    - name: Extract Octopus Tools
      run: |
        mkdir /opt/octo
        cd /opt/octo
        wget -O /opt/octo/octopus.zip https://download.octopusdeploy.com/octopus-tools/6.12.0/OctopusTools.6.12.0.portable.zip
        unzip /opt/octo/octopus.zip
        chmod +x /opt/octo/Octo
    - name: Pack Application
      run: |
        cd /home/runner/work/AWSSamExample/AWSSamExample/hello_world
        zip -r /home/runner/work/AWSSamExample/AWSSamExample/AwsSamLambda.$(cat /home/runner/work/AWSSamExample/AWSSamExample/version.txt).zip *
    - name: Push to Octopus
      run: &gt;-
        /opt/octo/Octo push
        --server ${{ secrets.MATTC_URL }}
        --apiKey ${{ secrets.MATTC_API_KEY }}
        --package /home/runner/work/AWSSamExample/AWSSamExample/AwsSamLambda.$(cat /home/runner/work/AWSSamExample/AWSSamExample/version.txt).zip
        --overwrite-mode IgnoreIfExists
        --space Lambda
    - name: Pack Templates
      run: &gt;-
        /opt/octo/Octo pack
        --outFolder /home/runner/work/AWSSamExample/AWSSamExample
        --basePath /home/runner/work/AWSSamExample/AWSSamExample
        --id AwsSamLambdaTemplates
        --version $(cat /home/runner/work/AWSSamExample/AWSSamExample/version.txt)
        --include s3bucket.yaml
        --include template.yaml
        --format zip
    - name: Push to Octopus
      run: &gt;-
        /opt/octo/Octo push
        --server ${{ secrets.MATTC_URL }}
        --apiKey ${{ secrets.MATTC_API_KEY }}
        --package /home/runner/work/AWSSamExample/AWSSamExample/AwsSamLambdaTemplates.$(cat /home/runner/work/AWSSamExample/AWSSamExample/version.txt).zip
        --overwrite-mode IgnoreIfExists
        --space Lambda
</code></pre>

<p>这个工作流程有两个部分，允许我们复制由<code>sam package</code>命令提供的功能。</p>

<p>第一部分是下载Python依赖项，提取它们，并在文件上设置<a href="https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html" rel="nofollow">权限。我们使用<code>pip</code>命令下载依赖项并提取下载的车轮文件(或<code>whl</code>文件，它们是具有不同扩展名的ZIP文件)，其中包含依赖项代码:</a></p>

<pre><code>- name: Package dependencies
  # Permissions are documented at
  # https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html
  run: |
    python -m pip install --upgrade pip
    cd hello_world
    pip download -r requirements.txt
    unzip \*.whl
    rm *.whl
    chmod 644 $(find . -type f)
    chmod 755 $(find . -type d)
</code></pre>

<p>第二部分是我们创建带有有意义的版本号的zip文件。如果你回头看看工作流YAML，你会看到我们已经使用GitVersion生成了这个版本号。博客文章<a href="https://octopus.com/blog/versioning-with-github-actions">向你的GitHub动作添加版本</a>更详细地介绍了版本控制是如何工作的。</p>

<p>我们使用<code>zip</code>工具打包Python代码，而不是<code>octo</code> cli，因为AWS对zip文件中文件的<a href="https://docs.aws.amazon.com/lambda/latest/dg/deployment-package-v2.html" class="alert-link" rel="nofollow">权限</a>非常挑剔。<code>zip</code>工具创建正确的权限，而<code>octo pack</code>命令会产生一个无法部署的ZIP文件。</p>


<pre><code class="language-yaml">- name: Pack Application
  run: |
    cd /home/runner/work/AWSSamExample/AWSSamExample/hello_world
    zip -r /home/runner/work/AWSSamExample/AWSSamExample/AwsSamLambda.$(cat /home/runner/work/AWSSamExample/AWSSamExample/version.txt).zip *
</code></pre>

<p>我们创建第二个包来保存模板。我们这里有两个模板(<code>s3bucket.yaml</code>和<code>template.yaml</code>)。稍后将更详细地介绍这些模板:</p>

<pre><code class="language-yaml">- name: Pack Templates
  run: &gt;-
    /opt/octo/Octo pack
    --outFolder /home/runner/work/AWSSamExample/AWSSamExample
    --basePath /home/runner/work/AWSSamExample/AWSSamExample
    --id AwsSamLambdaTemplates
    --version $(cat /home/runner/work/AWSSamExample/AWSSamExample/version.txt)
    --include s3bucket.yaml
    --include template.yaml
    --format zip
</code></pre>

<p>然后这些包通过任务调用<code>octo push</code>被推送到Octopus服务器。</p>

<p>至此，我们已经将应用程序代码和模板上传到Octopus服务器，准备进行部署。我们已经复制了<code>sam package</code>命令的捆绑功能，下一步是复制到S3的推送。</p>

<h2 id="uploading-the-package-with-octopus">用八达通上传包裹</h2>

<p>在我们推进到S3之前，我们将创建S3桶。这将通过标准的云形成模板来实现。在此模板中，我们将指定在一定时间后删除此S3存储桶中的文件。</p>

<p>通常情况下，<code>sam package</code>命令会将文件推送到S3，并永久保存在那里。然而，一旦该文件被用于完成部署，它就不再是必需的了，并且由于这些文件花费了我们的钱，所以在一段时间后清理它们是有意义的。</p>

<p>如果我们需要重新部署某个版本的应用程序，Octopus会重新上传文件:</p>

<pre><code class="language-yaml">AWSTemplateFormatVersion: 2010-09-09
Description: Creates an S3 bucket that cleans up old files
Resources:
  CodeBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: "#{S3BucketName}"
      AccessControl: Private
      VersioningConfiguration:
        Status: Enabled
      LifecycleConfiguration:
        Rules:
          - NoncurrentVersionExpirationInDays: 3
            ExpirationInDays: 5
            Status: Enabled
</code></pre>

<p>注意<code>BucketName</code>属性已经被定义为一个章鱼变量。在部署期间，标记<code>#{S3BucketName}</code>将被替换为<code>S3BucketName</code>章鱼变量的值。</p>

<p>该模板与<code>Deploy an AWS CloudFormation template</code>步骤一起部署。</p>

<p>CloudFormation设置将区域和堆栈名称定义为变量。随着我们转向跨多个环境的部署，这一点将非常重要:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-bucket-cloudformation-settings.png" class="zoom" data-title=""><img src="../Images/e742661d6f40547dc0ec377c55e0a71a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-bucket-cloudformation-settings.png"/>T2】</a></p>

<p>CloudFormation模板来自名为<code>AwsSamLambdaTemplates</code>的包，包中有一个名为<code>s3bucket.yaml</code>的文件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-bucket-package-settings.png" class="zoom" data-title=""><img src="../Images/797a33c55df1bf6f987776cbc2284581.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-bucket-package-settings.png"/>T2】</a></p>

<p>创建了bucket之后，应用程序包将通过<code>Upload a package to an AWS S3 bucket</code>步骤上传。</p>

<p>在这一步中唯一需要注意的是，我们再次为时段名称和AWS区域使用了一个变量:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-upload.png" class="zoom" data-title=""><img src="../Images/a55e44f867f7cfb9feb563b40d8e7624.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-upload.png"/>T2】</a></p>

<p>至此，我们已经复制了<code>sam package</code>命令的功能，使用GitHub Actions捆绑了一个自包含的应用程序包，并使用Octopus将其推送到S3。</p>

<p>我们还确保了我们上传的包有像<code>AwsSamLambda.0.1.0+71.zip</code>这样易读的名字，这清楚地表明了它们包含的应用程序和版本。从下面的截图可以看出，我们(<code>AwsSamLambda.0.1.0+xx.zip</code>)上传的包比<code>sam package</code> ( <code>fecddec7c6c40bd9de28f1775cd11e0e</code>)上传的包提供了更多的上下文:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-console.png" class="zoom" data-title=""><img src="../Images/f06904e509717fe3742ce0e8baf7d7c4.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/s3-console.png"/>T2】</a></p>

<h2 id="deploying-the-template-with-octopus">用Octopus部署模板</h2>

<p>最后一步是将SAM模板部署为CloudFormation模板。</p>

<p>这个模板几乎是由<code>sam init --runtime python3.7</code>命令生成的模板的翻版。</p>

<p>第一个区别是我们将<code>OpenApiVersion</code>的值设置为<code>2.0</code>。这修复了这里描述的<a href="https://github.com/awslabs/serverless-application-model/issues/191" rel="nofollow">问题</a>，SAM创建了第二个不需要的API网关阶段<code>Staging</code>。</p>

<p>第二个区别是我们将<code>CodeUri</code>属性设置为<code>"s3://#{Octopus.Action[Upload Lambda to S3].Aws.S3.BucketName}/#{Octopus.Action[Upload Lambda to S3].Output.Package.FileName}"</code>。这些变量替换组合起来为我们提供了在前面的<code>Upload Lambda to S3</code>步骤中上传到S3的文件的名称。</p>

<pre><code class="language-yaml">AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Example SAM application

# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst
Globals:
  Api:
    OpenApiVersion: '2.0'
  Function:
    Timeout: 3

Resources:
  HelloWorldFunction:
    Type: AWS::Serverless::Function # More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction
    Properties:
      CodeUri: "s3://#{Octopus.Action[Upload Lambda to S3].Aws.S3.BucketName}/#{Octopus.Action[Upload Lambda to S3].Output.Package.FileName}"
      Handler: app.lambda_handler
      Runtime: python3.7
      Events:
        HelloWorld:
          Type: Api # More info about API Event Source: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#api
          Properties:
            Path: /hello
            Method: get

Outputs:
  # ServerlessRestApi is an implicit API created out of Events key under Serverless::Function
  # Find out more about other implicit resources you can reference within SAM
  # https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api
  HelloWorldApi:
    Description: "API Gateway endpoint URL for Prod stage for Hello World function"
    Value: !Sub "https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/hello/"
  HelloWorldFunction:
    Description: "Hello World Lambda Function ARN"
    Value: !GetAtt HelloWorldFunction.Arn
  HelloWorldFunctionIamRole:
    Description: "Implicit IAM Role created for Hello World function"
    Value: !GetAtt HelloWorldFunctionRole.Arn

</code></pre>

<p>和以前一样，这个模板是通过<code>Deploy an AWS CloudFormation template</code>步骤部署的。然而，我们需要启用<code>CAPABILITY_IAM</code>的附加功能，因为该模板创建IAM资源，而<code>CAPABILITY_AUTO_EXPAND</code>是因为CloudFormation需要将SAM模板转换成标准的CloudFormation模板。</p>

<p>因为我们已经为<code>CodeUri</code>字段使用了变量，Octopus会将模板指向正确的S3文件。这样，我们复制了由<code>sam package</code>命令提供的第二部分功能，它通常会生成一个处理过的YAML文件，其中包含更新后的S3位置。</p>

<p>SAM模板不需要任何特殊的工具来部署。标准的CloudFormation工具可以部署SAM模板，只要定义了<code>CAPABILITY_AUTO_EXPAND</code>功能。</p>


<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/sam-cloudformation-settings.png" class="zoom" data-title=""><img src="../Images/4e23d15d7060d51d78b64973f57e2664.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/sam-cloudformation-settings.png"/>T2】</a></p>

<p>和以前一样，CloudFormation模板将从一个文件部署。同样，我们使用了<code>AwsSamLambdaTemplates</code>包，但是这一次，我们部署了<code>template.yaml</code>文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/sam-cloudformation-package.png" class="zoom" data-title=""><img src="../Images/7cbea1d235384d8dbf8d2ab42dd234bd.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/sam-cloudformation-package.png"/>T2】</a></p>

<h2 id="octopus-variables">章鱼变量</h2>

<p>在整个模板和步骤中，我们使用了变量来定义AWS区域、S3桶名称和云形成堆栈名称:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/octopus-variables-3.png" class="zoom" data-title=""><img src="../Images/590635fd0b92c7ce53bbf953150c7d93.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/octopus-variables-3.png"/>T2】</a></p>

<p>下表描述了这些变量。</p>

<table class="table">
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AWSRegion</td>
<td>AWS区域。</td>
</tr>
<tr>
<td>CloudFormationStackS3Bucket桶</td>
<td>用于创建S3桶的云生成堆栈的名称。</td>
</tr>
<tr>
<td>云格式堆栈Sam</td>
<td>将部署SAM应用程序的CloudFormation堆栈的名称。</td>
</tr>
<tr>
<td>S3BucketName</td>
<td>将上载应用程序的S3存储桶的名称。</td>
</tr>
</tbody>
</table>

<h2 id="deploying-to-a-single-environment">部署到单一环境</h2>

<p>现在我们已经拥有了使用Octopus将SAM应用程序部署到一个环境(称为<code>UAT</code>)所需的一切。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/deployment-uat.png" class="zoom" data-title=""><img src="../Images/cbb6843035c38d65155fbf2ee18c2c86.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/deployment-uat.png"/>T2】</a></p>

<p>我们已经在Octopus中成功创建了一个部署流程，该流程复制了SAM CLI工具的功能。</p>

<p>能够在单个环境中执行可重复的部署是很棒的，但是Octopus的真正优势是可以扩展到多个环境。</p>

<h2 id="deploying-to-a-second-environment">部署到第二个环境</h2>

<p>因为我们已经将所有特定于环境的配置转移到Octopus变量中，所以更新我们的项目以部署到第二个环境就像将变量值作用于新环境一样简单。</p>

<p>在这种情况下，我们为下一个名为<code>Prod</code>的环境中的<code>CloudFormationStackS3Bucket</code>、<code>CloudFormationStackSam</code>和<code>S3BucketName</code>变量添加新值。</p>

<p>这意味着新的<code>Prod</code>环境将创建其自己的特定云形成堆栈，以创建新的S3桶，并为SAM应用程序创建第二个特定于环境的云形成堆栈:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/octopus-variables-multiple.png" class="zoom" data-title=""><img src="../Images/077577fd3f04eece1ad66d198a46a5f0.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/octopus-variables-multiple.png"/>T2】</a></p>

<p>通过这些少量的更改，我们能够将应用程序的独立副本部署到两个不同的环境中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/uat-prod-dashboard.png" class="zoom" data-title=""><img src="../Images/f71e628eb4febe1e1c570abe2b96797e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-09/aws-sam-and-octopus/uat-prod-dashboard.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>SAM CLI工具是引导和部署无服务器应用程序堆栈的便捷方式。通过简化部署无服务器应用程序的常见任务，您可以使用以下命令部署“hello world”应用程序:</p>

<ul>
<li><code>sam init --runtime python3.7</code></li>
<li><code>sam build</code></li>
<li><code>sam package --output-template packaged.yaml --s3-bucket bucketname</code></li>
<li><code>sam deploy --template-file packaged.yaml --region region --capabilities CAPABILITY_IAM --stack-name aws-sam-getting-started</code></li>
</ul>

<p>在这篇博文中，我们已经看到了如何使用由<code>sam init</code>和<code>sam build</code>生成的代码和模板，并用GitHub Actions和Octopus Deploy替换<code>sam package</code>和<code>sam deploy</code>命令。</p>

<p>最终结果是一个CI/CD管道，它创建了跨多个环境的版本化、可重复的部署。然后，可以轻松扩展该管道，以满足生产环境的需求。</p>

                    
                    
</body>
</html>