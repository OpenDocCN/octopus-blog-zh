<html>
<head>
<title>OctoPack 3.0 - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>OctoPack 3.0 - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octopack-3.0#2022-07-20">https://octopus.com/blog/octopack-3.0#2022-07-20</a></blockquote>
                        <p>我们刚刚发布了OctoPack的新版本，有一些大的变化。如此之大，事实上，我们称之为OctoPack 3.0！</p>

<p>第一个变化是，在打包二进制文件时，我们习惯于将所有文件放在<code>$(OutDir)</code>下。默认情况下，TFS将所有项目的输出发送到同一个目录，这意味着OctoPack无法判断哪个文件是哪个项目的。由于马克斯·马卢克的<a href="https://github.com/OctopusDeploy/OctoPack/pull/12">拉请求，我们已经改为使用<code>@(FileWrites)</code>和<code>@(FileWritesShareable)</code>。你可以</a><a href="http://msdn.microsoft.com/en-us/magazine/dd419659.aspx">在MSDN </a>上了解更多关于这些房产的信息。最终的结果是，OctoPack应该更适合TFS用户。</p>

<p><img src="../Images/555893a380839bd905c683762af9e320.png" alt="Messy TFS drop folder, but clean NuGet packages" data-original-src="https://i.octopus.com/blog/migrated/2014-02-14_11_29_08-Source_Control_Explorer_-_Microsoft_Visual_Studio_ifu7vq.png"/></p>

<p>第二个主要变化是OctoPack不再需要签入版本控制。也就是说不再有<strong>了。使用NuGet包还原时的octopack </strong>文件夹！我们正在使用与微软<a href="https://www.nuget.org/packages/Microsoft.Bcl.Build/">相同的方法。Bcl.Build </a>用途。当你安装OctoPack时，你会得到下面的<code>&lt;Import&gt;</code>:</p>

<pre><code>&lt;Import Project="..\packages\OctoPack.3.0.19\tools\OctoPack.targets" Condition="Exists('..\packages\OctoPack.3.0.19\tools\OctoPack.targets')" /&gt;
</code></pre>

<p>这样，当NuGet package restore尚未运行而目标丢失时，您仍然可以加载项目。</p>

<p>但是，<em>如果</em>调用了OctoPack，而<strong>还没有</strong>运行NuGet包恢复，那么显然我们什么也包不了。所以我们还添加了一个<code>&lt;Target&gt;</code>,它将导致构建失败，除非您首先运行NuGet package restore:</p>

<pre><code>&lt;Target Name="EnsureOctoPackImported" BeforeTargets="BeforeBuild" Condition="'$(OctoPackImported)' == ''"&gt;
  &lt;Error Condition="!Exists('..\packages\OctoPack.3.0.19\tools\OctoPack.targets') And ('$(RunOctoPack)' != '' And $(RunOctoPack))" Text="You are trying to build with OctoPack, but the NuGet targets file that OctoPack depends on is not available on this computer. This is probably because the OctoPack package has not been committed to source control, or NuGet Package Restore is not enabled. Please enable NuGet Package Restore to download them. For more information, see http://go.microsoft.com/fwlink/?LinkID=317567." HelpKeyword="BCLBUILD2001" /&gt;
  &lt;Error Condition="Exists('..\packages\OctoPack.3.0.19\tools\OctoPack.targets') And ('$(RunOctoPack)' != '' And $(RunOctoPack))" Text="OctoPack cannot be run because NuGet packages were restored prior to the build running, and the targets file was unavailable when the build started. Please build the project again to include these packages in the build. You may also need to make sure that your build server does not delete packages prior to each build. For more information, see http://go.microsoft.com/fwlink/?LinkID=317568." HelpKeyword="BCLBUILD2002" /&gt;
&lt;/Target&gt;
</code></pre>

<p>现在，当在Team Build或另一个CI工具下运行OctoPack时，这会带来一些问题，特别是如果构建服务器被配置为在构建开始之前清理所有文件(包括NuGet包)的话。它还会影响使用虚拟生成代理的Team Foundation服务。但这不仅仅是OctoPack的问题；也影响到了<code>Microsoft.Bcl.Build</code>用户。最佳解决方案是在构建解决方案之前运行NuGet包恢复。对于TFS用户，NuGet团队的这篇文章展示了如何在构建之前运行NuGet包恢复。TeamCity客户可以使用内置的<a href="http://blog.jetbrains.com/teamcity/2013/08/nuget-package-restore-with-teamcity/"> NuGet安装程序</a> runner。</p>

<p>最后，修复了许多小错误，并添加了一些其他功能:</p>

<ul>
<li><a href="https://github.com/OctopusDeploy/OctoPack/pull/34">34</a>——我们现在读<code>AssemblyInformationalVersion</code>，回到<code>AssemblyVersion</code>，当决定一个包使用什么版本的时候(如果你没有通过<code>/p:OctoPackPackageVersion=XYZ</code>)</li>
<li>你现在可以将自定义的<code>&lt;files&gt;</code>与我们自动检测和添加的文件结合使用，而不是选择任何一个</li>
<li>你现在可以在打包时将自定义属性传递给NuGet</li>
</ul>

<p>这些变化大部分来自社区的拉请求，其中一些已经等待了相当长的时间。感谢每一个为OctoPack提交PR的人；从现在开始，我们会更加积极地复习它们。</p>

                    
                    
</body>
</html>