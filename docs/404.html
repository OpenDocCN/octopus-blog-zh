<html>
<head>
<title>Linux worker for PowerShell templates - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>PowerShell模板的Linux worker-Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/linux-worker-powershell-core#2021-08-12">https://octopus.com/blog/linux-worker-powershell-core#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/powershell-linux.png" class="zoom" data-title=""><img src="../Images/d492211cadfbb82c7e46389ad2055062.png" class="img-fluid center" alt="Linux worker for PowerShell templates" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/powershell-linux.png"/>T2】</a></p>

<p>Octopus Deploy有400多个步骤模板，您可以在部署中使用。这些模板中有许多是用PowerShell编写的，随着<a href="https://octopus.com/docs/infrastructure/deployment-targets/linux/tentacle"> Linux触手</a>的引入，一些step模板已经被转换成Bash版本，然而，使用PowerShell Core，将现有模板转换成Bash是不必要的。</p>

<p>在本文中，我演示了如何在带有PowerShell Core的Linux Worker上使用现有的Octopus Deploy步骤模板。</p>

<h2 id="creating-the-arm-template">创建手臂模板</h2>

<p>为此，我首先需要一台Linux机器。我在Azure中使用的是从Runbook升级而来的Ubuntu Linux虚拟机。</p>

<h3 id="azure-resource-manager-arm-template">Azure资源管理器(ARM)模板</h3>

<p>使用ARM模板在Azure中创建VM非常简单。微软做了一件了不起的工作，让这一代ARM模板变得快速而简单。完成定义虚拟机配置方式的过程，并在完成后导出模板。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/azure-arm-template-export.png" class="zoom" data-title=""><img src="../Images/b0944d486d00b636d924f67df984e810.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/azure-arm-template-export.png"/>T2】</a></p>

<h3 id="arm-template-parameters">ARM模板参数</h3>

<p>您在生成ARM模板时所做的具体选择并不重要，因为您可以参数化一切并使用Octopus Deploy变量来控制它们。在上图中，像<code>Virtual machine name</code>、<code>Username</code>和<code>OS disk type</code>这样的项目都将是我们模板中的参数，以使它更加通用。这在创建我们的Runbook时更有意义。</p>

<h2 id="octopus-deploy-runbook">八达通部署手册</h2>

<p><a href="https://octopus.com/docs/operations-runbooks">操作手册</a>是Octopus部署的最新功能之一。Runbooks允许您利用Octopus Deploy的强大功能来执行操作任务，如恢复数据库或回收IIS应用程序池。与部署不同，runbooks被设计为可以在任何时间任何环境中运行，并且不受生命周期的限制(除了它们只能在您的应用程序使用的环境中执行之外)。在这种情况下，我们将使用runbooks来加速我们的Linux虚拟机。</p>

<h3 id="create-the-runbook">创建操作手册</h3>

<p>在您的Octopus Deploy项目中有一个操作手册，位于Operations:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-project-runbook.png" class="zoom" data-title=""><img src="../Images/b693c788a5a88b5e62475c395fe6246b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-project-runbook.png"/></a>T2】</p>

<p>点击<strong> Runbooks </strong>，然后点击<strong>添加RUNBOOK </strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-project-add-runbook.png" class="zoom" data-title=""><img src="../Images/2587745e1b9a3bef50b688c2de608df7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-project-add-runbook.png"/>T2】</a></p>

<p>为了加速我们的Linux Worker VM，我们的Runbook将包括:</p>

<ul>
<li>创建新的Azure资源组</li>
<li>将我们的云初始化脚本转换为Base64字符串(稍后将详细介绍)</li>
<li>运行ARM模板</li>
<li>等待虚拟机可用</li>
<li>执行健康检查</li>
</ul>

<p>这篇文章更侧重于演示带有PowerShell core的Linux，所以我们不会对runbooks进行过多的描述。</p>

<h4 id="create-a-resource-group">创建资源组</h4>

<p>创建一个新的资源组是可选的，主要是为了整洁和方便删除在执行ARM模板时创建的资源。使用现有的资源组完全没问题。使用一个<strong>运行一个Azure脚本</strong>的步骤，你可以用一个脚本快速创建一个资源组:</p>

<pre><code class="language-PS">$resourceGroupName = $OctopusParameters["Azure.Worker.ResourceGroup.Name"]
$resourceGroupLocation = $OctopusParameters["Azure.Location.Abbr"]

Try {
    Get-AzureRmResourceGroup -Name $resourceGroupName
    $createResourceGroup = $false
} Catch {
    $createResourceGroup = $true
}

if ($createResourceGroup -eq $true){
    New-AzureRmResourceGroup -Name $resourceGroupName -Location $resourceGroupLocation
}
</code></pre>

<h4 id="convert-the-cloud-init-script-to-a-base64-string">将云初始化脚本转换为Base64字符串</h4>

<p>ARM模板有两种不同的方式来执行init脚本:</p>

<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/custom-script-windows" rel="nofollow">自定义脚本扩展</a>:使用自定义脚本扩展，您可以为包含脚本的文件(如<a href="https://gist.github.com/discover" rel="nofollow"> Gist </a>)提供一个URI。这种方法的优点是对脚本文件使用源代码控制。</li>
<li>CustomData参数(本文使用该方法):CustomData参数允许我们将脚本作为字符串包含进来，并作为参数传递。调配Windows虚拟机时，该值可以是一个字符串。对于Linux，这个值必须首先经过Base64编码，这可以在运行脚本任务中轻松完成</li>
</ul>

<p>对于本例，我希望我的init脚本执行以下操作:</p>

<ul>
<li>安装Linux触手</li>
<li>安装PowerShell核心</li>
<li>配置触手并将其自身注册到我的云实例</li>
</ul>

<h5 id="install-linux-tentacle">安装Linux触手</h5>

<p>脚本的这一部分将涵盖触手的安装。如果你读过我们关于Linux触手的其他博客文章，它应该看起来很熟悉:</p>

<pre><code class="language-bash">serverUrl="#{Global.Base.Url}"   # The url of your Octous server
thumbprint="#{Global.Server.Thumbprint}"       # The thumbprint of your Octopus Server
apiKey="#{Global.Api.Key}"           # An Octopus Server api key with permission to add machines
name="#{Octopus.Space.Name}-#{Octopus.Environment.Name}"      # The name of the Tentacle at is will appear in the Octopus portal
publicHostName="#{Azure.Worker.DNS.Prefix}.centralus.cloudapp.azure.com"      # The url to the tentacle
workerPoolName="#{Azure.Worker.Pool.Name}"
configFilePath="/etc/octopus/default/tentacle-default.config"
applicationPath="/home/Octopus/Applications/"
spaceName="#{Octopus.Space.Name}"

sudo apt install --no-install-recommends gnupg curl ca-certificates apt-transport-https &amp;&amp; \
curl -sSfL https://apt.octopus.com/public.key | sudo apt-key add - &amp;&amp; \
sudo sh -c "echo deb https://apt.octopus.com/ stable main &gt; /etc/apt/sources.list.d/octopus.com.list" &amp;&amp; \
sudo apt update &amp;&amp; sudo apt install tentacle -y
</code></pre>

<h5 id="install-powershell-core">安装PowerShell核心</h5>

<p>这个位将会把PowerShell核心安装到Ubuntu上(更多信息参见<a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7" rel="nofollow">微软的文档</a>):</p>

<pre><code class="language-bash"># Download the Microsoft repository GPG keys
wget -q https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb

# Register the Microsoft repository GPG keys
sudo dpkg -i packages-microsoft-prod.deb

# Update the list of products
sudo apt-get update

# Enable the "universe" repositories
sudo add-apt-repository universe

# Install PowerShell
sudo apt-get install -y powershell
</code></pre>

<h5 id="configure-tentacle-and-register-itself-of-to-my-cloud-instance">配置触手并将其自身注册到我的云实例</h5>

<p>最后，我们需要脚本来配置触手，然后将它注册到我们的实例中。该脚本使用在上面的安装部分中定义的变量:</p>

<pre><code class="language-bash">sudo /opt/octopus/tentacle/Tentacle create-instance --config "$configFilePath"
sudo /opt/octopus/tentacle/Tentacle new-certificate --if-blank
sudo /opt/octopus/tentacle/Tentacle configure --port 10933 --noListen False --reset-trust --app "$applicationPath"
sudo /opt/octopus/tentacle/Tentacle configure --trust $thumbprint
echo "Registering the Tentacle $name as a worker with server $serverUrl in $workerPoolName"
sudo /opt/octopus/tentacle/Tentacle register-worker --server "$serverUrl" --apiKey "$apiKey" --name "$name" --space "$spaceName" --publicHostName "$publicHostName" --workerpool "$workerPoolName"
# Install and start the service
sudo /opt/octopus/tentacle/Tentacle service --install --start
</code></pre>

<p>设置好脚本后，我们需要将它转换为Base64字符串，然后将其分配给一个输出变量，以便可以在ARM模板中使用。下面是在一个<strong>运行脚本</strong>的步骤中调用的<code>Convert cloud init script</code>:</p>

<pre><code class="language-PS"># Define cloud init script
$cloudInitScript = @'
#!/bin/bash

# Install Octopus listening tentacle
serverUrl="#{Global.Base.Url}"   # The URL of your Octopus server
thumbprint="#{Global.Server.Thumbprint}"       # The thumbprint of your Octopus Server
apiKey="#{Global.Api.Key}"           # An Octopus Server api key with permission to add machines
name="#{Octopus.Space.Name}-#{Octopus.Environment.Name}"      # The name of the Tentacle at is will appear in the Octopus portal
publicHostName="#{Azure.Worker.DNS.Prefix}.centralus.cloudapp.azure.com"      # The url to the tentacle
workerPoolName="#{Azure.Worker.Pool.Name}"
configFilePath="/etc/octopus/default/tentacle-default.config"
applicationPath="/home/Octopus/Applications/"
spaceName="#{Octopus.Space.Name}"

sudo apt install --no-install-recommends gnupg curl ca-certificates apt-transport-https &amp;&amp; \
curl -sSfL https://apt.octopus.com/public.key | sudo apt-key add - &amp;&amp; \
sudo sh -c "echo deb https://apt.octopus.com/ stable main &gt; /etc/apt/sources.list.d/octopus.com.list" &amp;&amp; \
sudo apt update &amp;&amp; sudo apt install tentacle -y

sudo /opt/octopus/tentacle/Tentacle create-instance --config "$configFilePath"
sudo /opt/octopus/tentacle/Tentacle new-certificate --if-blank
sudo /opt/octopus/tentacle/Tentacle configure --port 10933 --noListen False --reset-trust --app "$applicationPath"
sudo /opt/octopus/tentacle/Tentacle configure --trust $thumbprint
echo "Registering the Tentacle $name as a worker with server $serverUrl in $workerPoolName"
sudo /opt/octopus/tentacle/Tentacle register-worker --server "$serverUrl" --apiKey "$apiKey" --name "$name" --space "$spaceName" --publicHostName "$publicHostName" --workerpool "$workerPoolName"


# Download the Microsoft repository GPG keys
wget -q https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb

# Register the Microsoft repository GPG keys
sudo dpkg -i packages-microsoft-prod.deb

# Update the list of products
sudo apt-get update

# Enable the "universe" repositories
sudo add-apt-repository universe

# Install PowerShell
sudo apt-get install -y powershell

# Install and start the Tentacle service
sudo /opt/octopus/tentacle/Tentacle service --install --start
'@

Write-Output "Converting cloudInitScript to base64"

# Convert to Base64
$cloudInitScript = [System.Convert]::ToBase64String([system.Text.Encoding]::UTF8.GetBytes($cloudInitScript))

# Set output variable
Set-OctopusVariable -name "CloudInitScript" -value $cloudInitScript
</code></pre>

<p>将我们的脚本转换为Base64字符串后，我们可以将其传递给我们的ARM模板:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-arm-template-custom-data.png" class="zoom" data-title=""><img src="../Images/07378854886906bd36db6d90c11131c7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-arm-template-custom-data.png"/>T2】</a></p>

<h4 id="wait-for-the-vm">等待虚拟机</h4>

<p>这一步是另一个<strong>运行脚本</strong>的步骤，它等待新创建的虚拟机响应，并让我们知道它可供使用。下面是脚本(<code>Test-NetConnect</code>如果目的地不可达则返回警告，这在我们等待虚拟机可用时是正常的):</p>

<pre><code class="language-PS"># Define variables
$publicDNS = "#{Azure.Worker.DNS.Prefix}.#{Azure.Region.Name}.cloudapp.azure.com"

$connectionTest = Test-NetConnection -ComputerName $publicDNS -Port 10933 -WarningAction SilentlyContinue -InformationLevel Quiet

while ($connectionTest -eq $false)
{
  # Give it five seconds
  Start-Sleep -Seconds 5

  # Server not quite ready
  $connectionTest = Test-NetConnection -ComputerName $publicDNS -Port 10933 -WarningAction SilentlyContinue -InformationLevel Quiet
}
</code></pre>

<h4 id="perform-a-health-check">执行健康检查</h4>

<p>我们运行手册的最后一步是对新创建的工人执行健康检查。<strong>健康检查</strong>内置步骤模板在这里对我们不起作用，因为它是针对部署目标而不是工作人员设计的。这个步骤是另一个<strong>运行脚本</strong>的步骤，它调用Octopus Deploy API来启动对一个工人的健康检查:</p>

<pre><code class="language-PS"># Define parameters
$baseUrl = $OctopusParameters['Global.Base.Url']
$apiKey = $OctopusParameters['Global.Api.Key']
$spaceId = $OctopusParameters['Octopus.Space.Id']
$spaceName = $OctopusParameters['Octopus.Space.Name']
$environmentName = $OctopusParameters['Octopus.Environment.Name']

# Get worker pool
$workerPool = (Invoke-RestMethod -Method Get -Uri "$baseUrl/api/$spaceId/workerpools/all" -Headers @{"X-Octopus-ApiKey"="$apiKey"}) | Where-Object {$_.Name -eq "#{PoolName}"}

# Get worker
$worker = (Invoke-RestMethod -Method Get -Uri "$baseUrl/api/$spaceId/workerpools/$($workerPool.Id)/workers" -Headers @{"X-Octopus-ApiKey"="$apiKey"}).Items | Where-Object {$_.Name -eq "$spaceName-$environmentName"}

# Build payload
$jsonPayload = @{
    Name = "Health"
    Description = "Check $spaceName-$environmentName health"
    Arguments = @{
        Timeout = "00:05:00"
        MachineIds = @(
            $worker.Id
        )
    OnlyTestConnection = "false"
    }
    SpaceId = "$spaceId"
}

# Execute health check
Invoke-RestMethod -Method Post -Uri "$baseUrl/api/tasks" -Body ($jsonPayload | ConvertTo-Json -Depth 10) -Headers @{"X-Octopus-ApiKey"="$apiKey"}
</code></pre>

<p>完成后，您的操作手册应该如下所示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-project-create-vm-runbook.png" class="zoom" data-title=""><img src="../Images/1db84403aa880977cbcbae25646815e2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-project-create-vm-runbook.png"/>T2】</a></p>

<h2 id="executing-a-powershell-step-template-on-linux-with-powershell-core">在具有PowerShell核心的Linux上执行PowerShell步骤模板</h2>

<p>现在有趣的部分来了！在这个例子中，我使用了<a href="https://library.octopus.com/step-templates/2bdfe600-e205-43f9-b174-67ee5d36bf5b/actiontemplate-mariadb-create-database-if-not-exists" rel="nofollow"> MariaDB -如果不存在就创建数据库</a>步骤模板。顾名思义，它连接到一个MariaDB服务器并创建一个数据库(如果它不存在的话)。这个步骤模板不仅完全是用PowerShell编写的，它还使用了一个名为<a href="https://www.powershellgallery.com/packages/SimplySql/1.6.2" rel="nofollow"> SimplySql </a>的第三方PowerShell模块。在执行过程中，如果模板检测到没有安装SimplySql，它会将它下载到一个临时文件夹中，并使用<code>Import-Module</code>使它包含在部署中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-mariadb-step-template.png" class="zoom" data-title=""><img src="../Images/e80d524f4072045ce99b4d7860d0a0c7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-mariadb-step-template.png"/>T2】</a></p>

<p>当包含在部署中时，我们可以看到Linux Worker使用PowerShell核心来执行该步骤:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-mariadb-step-template-deployment.png" class="zoom" data-title=""><img src="../Images/3ec69c4700b12075e0dd28b1d6175bbe.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/linux-worker-powershell-core/octopus-mariadb-step-template-deployment.png"/>T2】</a></p>

<p>下面是步骤*的日志输出:</p>

<pre><code>PowerShell module SimplySql is not installed, downloading temporary copy ... 
Installing package 'SimplySql'
Downloaded 0.00 MB out of 6.53 MB.
[                                                                    ]
Installing package 'SimplySql'
Unzipping
[ooooooooooooooooooooooooooooooooooooooooooooooo                     ]
Installing package 'SimplySql'
Process Package Manifest
[oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo    ]
Importing module SimplySql ... 

Database d_petclinic_dbup already exists. 
</code></pre>

<p>*日志已格式化，便于阅读。</p>

<p>如您所见，step模板检测到SimplySql模块没有安装，下载SimplySql并导入它。然后，它连接到MariaDB服务器，发现数据库已经存在，并使用PowerShell完成所有工作。</p>

<h2 id="conclusion">结论</h2>

<p>在Linux世界中采用Octopus Deploy的一个促成因素是可以使用的模板选择有限。有了PowerShell Core，可以在Linux机器上执行的模板的选择就成指数级增加了。</p>

                    
                    
</body>
</html>