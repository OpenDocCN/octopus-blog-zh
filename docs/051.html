<html>
<head>
<title>Automating guided failures with an AWS Lambda and subscriptions - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用AWS Lambda和订阅自动引导故障- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/automate-guided-failure-with-lambda#2021-12-22">https://octopus.com/blog/automate-guided-failure-with-lambda#2021-12-22</a></blockquote>
                        <p><a href="https://octopus.com/docs/projects/built-in-step-templates/manual-intervention-and-approvals">手动干预</a>和<a href="https://octopus.com/docs/releases/guided-failures">引导故障</a>是Octopus Deploy产品的强大功能。这两个功能都暂停部署或运行手册，并等待用户选择一个选项。不利的一面是，需要有人在场做出回应。然而，有了Octopus Deploy written API-first，就有可能自动化这些响应。</p>

<p>这篇文章演示了如何使用<a href="https://octopus.com/docs/administration/managing-infrastructure/subscriptions">订阅</a>特性调用AWS Lambda函数来自动响应引导失败事件。</p>

<h2 id="example-use-cases">示例使用案例</h2>

<p>引导式失败旨在暂停一个动作并等待指导，自动化响应似乎违反直觉。这里有几个自动化响应有意义的用例。</p>

<h3 id="exclude-machine-from-deployment">从部署中排除计算机</h3>

<p>考虑一下，如果您要部署到数千台机器上。在这种规模下，一小部分机器(通常与Octopus无关)的部署失败并不罕见。引导式失败为您提供了从部署中排除一台计算机的选项，这允许部署继续到剩余的目标。您可以自动化<code>Exclude machine from deployment</code>响应，稍后再处理故障机器，而不是照看这个过程。</p>

<h3 id="automatically-retry">自动重试</h3>

<p>我们的团队经历了另一个场景；当<a href="https://samples.octopus.app" rel="nofollow"> Samples </a>实例在夜间拆除资源时，如此多的请求同时被发送到AWS，以至于它经历了请求速率限制并失败。在这种情况下，只需重试runbook。对引导性故障实施自动<code>Retry</code>响应可确保所有资源都被取消供应。</p>

<h2 id="solution">解决办法</h2>

<p>这篇文章向您展示了如何通过使用Octopus的<strong>订阅</strong>特性调用AWS Lambda函数来自动响应引导失败事件。</p>

<p>首先，您需要提供一些AWS资源。</p>

<p><a href="https://github.com/OctopusSamples/OctoSubscriber" rel="nofollow"> OctoSubscriber </a> repo包含了这篇文章中描述的解决方案的源代码。</p>

<h3 id="scaffolding-aws-resources">搭建AWS资源</h3>

<p>本文中的解决方案利用了以下AWS资源:</p>



<p>IAM角色可能拥有较低的权限，但这是测试解决方案所用的权限。</p>

<p>使用AWS资源可能会给您或您的组织带来成本。</p>


<p>使用<a href="https://samples.octopus.app/app#/Spaces-1/projects/aws-octosubscriber/operations/runbooks/Runbooks-1805/process/RunbookProcess-Runbooks-1805" rel="nofollow">操作手册</a>，您可以使用Terraform和AWS CLI提供以下资源:</p>

<ul>
<li>S3水桶</li>
<li>SQS队列</li>
<li>API网关</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-create-aws-resources-runbok.png" class="zoom" data-title=""><img src="../Images/073edde08c2b1b3149441024f0658bc7.png" class="img-fluid center" alt="Octopus UI showing Spin Up Subscriber Infrastructure steps in the Runbooks section" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-create-aws-resources-runbok.png"/>T2】</a></p>

<h4 id="create-s3-bucket-if-not-exists">如果不存在，则创建S3时段</h4>

<p>创建其他AWS资源的Terraform需要一个存储状态的地方。此步骤使用AWS CLI为Terraform步骤创建后端存储位置:</p>

<pre><code class="language-powershell"># Get variables
$bucketName = $OctopusParameters["Project.AWS.Backend.Bucket"]
$bucketRegion = $OctopusParameters["Project.AWS.Backend.Region"]

# Get bucket list
$awsS3BucketList = aws s3api list-buckets --query "Buckets[].Name" --output json

# Convert returned json into an object
$awsS3BucketList = ($awsS3BucketList | ConvertFrom-JSON)

# Check to see if bucket exists
if ($null -eq ($awsS3BucketList | Where-Object {$_ -eq $bucketName}))
{
    # Create the bucket
    Write-Highlight "Bucket $bucketName doesn't exist, creating ..."

    aws s3api create-bucket --bucket $bucketName --region $bucketRegion --create-bucket-configuration LocationConstraint=$bucketRegion
}
else
{
    Write-Highlight "Bucket $bucketName already exists, moving on ..."
}
</code></pre>

<h4 id="plan-to-apply-a-terraform-template">计划应用Terraform模板</h4>

<p>为了帮助您快速启动，<a href="https://github.com/OctopusSamples/OctoSubscriber" rel="nofollow"> OctoSubscriber </a> repo包含Terraform脚本，用于自动创建SQS和API网关资源。这一步输出Terraform将按计划做什么。</p>

<p>main.tf</p>

<pre><code class="language-terraform">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 3.0"
    }
  }

  backend "s3" {
    bucket = "#{Project.AWS.Backend.Bucket}"
    key = "#{Project.AWS.Backend.Key}"
    region = "#{Project.AWS.Backend.Region}"
  }
}

provider "aws" {
    region  = var.region
}

resource "aws_sqs_queue" "subscriber_queue" {
  name                              = var.queue_name
  kms_master_key_id                 = "alias/aws/sqs"
  kms_data_key_reuse_period_seconds = 300
}

resource "aws_apigatewayv2_api" "subscriber_gateway" {
  name                              = var.api_gateway_name
  protocol_type                     = "HTTP"
}
</code></pre>

<p>变量. tf</p>

<pre><code class="language-terraform">variable "region" {
    type = string
}

variable "queue_name" {
    type = string
}

variable "api_gateway_name" {
    type = string
}
</code></pre>

<p>terraform.tfvars</p>

<pre><code class="language-terraform">region = "#{Project.AWS.Region}"
queue_name = "#{Project.AWS.Queue.Name}"
api_gateway_name = "#{Project.AWS.API.Gateway.Name}"
</code></pre>

<h4 id="applying-a-terraform-template">应用Terraform模板</h4>

<p>使用上面的地形，在AWS上创建资源。</p>

<p>创建资源后，您可以关注Lambdas。</p>

<h3 id="aws-lambda-functions">AWS函数</h3>

<p>该解决方案由两个不同的Lambda函数组成:</p>

<ul>
<li>这个函数将包含的有效载荷放到SQS队列中。</li>
<li><code>process-message</code>:该函数处理出现在SQS队列中的消息，并将请求的响应提交给Octopus服务器。</li>
</ul>

<h4 id="accept-message">接受消息</h4>

<p>该函数用NodeJS编写，接受以下querystring参数:</p>

<ul>
<li>类型:已经发生的中断的类型。          <ul>
<li>导向:为<strong>导向故障</strong>提供该值。</li>
<li>结果:为<strong>手动干预</strong>提供该值。</li>
</ul>
</li>
<li>动作:这是对中断的实际响应。该值取决于类型:          <ul>
<li>中止(结果)</li>
<li>继续(结果)</li>
<li>失败(指导)</li>
<li>排除(指导)</li>
<li>忽略(指导)</li>
<li>重试(指导)</li>
</ul>
</li>
<li>MaximumRetry(与重试操作一起使用):指定在放弃之前执行的最大重试次数。默认值为1，<strong>导向故障</strong>功能最多可重试10次，因此任何大于10次的故障都会被忽略。</li>
</ul>

<pre><code class="language-javascript">var AWS = require('aws-sdk');

exports.handler = function(event, context) {
  let QUEUE_URL = process.env.sqsqueue;
  let sqs = new AWS.SQS({region : process.env.sqsregion});
  let maximumretry = "1";

  if (event.queryStringParameters.maximumretry) {
    maximumretry = event.queryStringParameters.maximumretry
  }

  var params = {
    MessageBody: event.body,
    QueueUrl: QUEUE_URL,
    MessageAttributes: {
      "Type": {
        DataType: "String",
        StringValue: event.queryStringParameters.type
      },
      "Action": {
        DataType: "String",
        StringValue: event.queryStringParameters.action
      },
      "MaximumRetry": {
        DataType: "String",
        StringValue: maximumretry
      }
    }
  };

  sqs.sendMessage(params, function(err,data){
    if(err) {
      console.log('error:',"Fail Send Message" + err);
      context.done('error', "ERROR Put SQS");  // ERROR with message
    }else{
      console.log('data:',data.MessageId);
      context.done(null,'');  // SUCCESS 
    }
  });
}
</code></pre>

<p>querystring参数作为MessageAttributes附加到消息中。</p>

<h4 id="process-message">流程消息</h4>

<p>该函数从SQS队列中读取消息，并使用<a href="https://octopus.com/docs/octopus-rest-api/octopus.client"> Octopus。客户端获取包引用</a>以自动响应中断。完整的解决方案可以在<a href="https://github.com/OctopusSamples/OctoSubscriber" rel="nofollow">八月认购</a>回购中找到。</p>

<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Amazon.Lambda.SQSEvents;
using Newtonsoft.Json;
using Octopus.Client;

// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace process_message
{
    public class Function
    {
        public Function()
        {

        }


        /// &lt;summary&gt;
        /// This method is called for every Lambda invocation. This method takes in an SQS event object and can be used 
        /// to respond to SQS messages.
        /// &lt;/summary&gt;
        /// &lt;param name="evnt"&gt;&lt;/param&gt;
        /// &lt;param name="context"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public async Task FunctionHandler(SQSEvent evnt, ILambdaContext context)
        {
            foreach(var message in evnt.Records)
            {
                await ProcessMessageAsync(message, context);
            }
        }

        private async Task ProcessMessageAsync(SQSEvent.SQSMessage message, ILambdaContext context)
        {
            // Log
            LambdaLogger.Log("Begin message processing...");

            // Get environment variables
            string octopusServerUrl = Environment.GetEnvironmentVariable("OCTOPUS_SERVER_URL");
            string octopusApiKey = Environment.GetEnvironmentVariable("OCTOPUS_API_KEY");

            // Check to see if there are message attributes
            if (message.MessageAttributes.Count == 0)
            {
                // Fail
                throw new Exception("MessageAttributes collection is empty, was the queue called with querystring paramters?");
            }

            // Log
            LambdaLogger.Log(string.Format("Retrieved environment variables, Octopus Server Url: {0}...", octopusServerUrl));

            // Deserialize message JSON
            LambdaLogger.Log(string.Format("Parsing message..."));
            dynamic subscriptionEvent = JsonConvert.DeserializeObject(message.Body);
            LambdaLogger.Log("Successfully parsed message JSON...");

            // Create Octopus client object
            LambdaLogger.Log("Creating server endpoint object ...");
            var endpoint = new OctopusServerEndpoint(octopusServerUrl, octopusApiKey);
            LambdaLogger.Log("Creating repository object...");
            var repository = new OctopusRepository(endpoint);
            LambdaLogger.Log("Creating client object ...");
            var client = new OctopusClient(endpoint);

            // Create repository for space
            string spaceId = subscriptionEvent.Payload.Event.SpaceId;
            LambdaLogger.Log(string.Format("Creating repository object for space: {0}...", spaceId));
            var space = repository.Spaces.Get(spaceId);
            Octopus.Client.IOctopusSpaceRepository repositoryForSpace = client.ForSpace(space);

            // Retrieve interruption; first related document is the DeploymentId
            string documentId = subscriptionEvent.Payload.Event.RelatedDocumentIds[0];

            // Check to see if guided failure has already been invoked once, defaults to once if nothing provided
            int maximumRetry = 1;
            if (!string.IsNullOrWhiteSpace(message.MessageAttributes["MaximumRetry"].StringValue))
            {
                // Set to value
                maximumRetry = int.Parse(message.MessageAttributes["MaximumRetry"].StringValue);
            }

            var eventList = repositoryForSpace.Events.List(regarding: documentId);

            if (eventList.Items.Count(x =&gt; x.Category == "GuidedFailureInterruptionRaised") &gt; maximumRetry &amp;&amp; message.MessageAttributes["Action"].StringValue == "Retry")
            {
                LambdaLogger.Log(string.Format("{0} has raised Guided Failure more than {1} time(s), updating Action to Fail to break the infinite loop.", documentId, maximumRetry));
                message.MessageAttributes["Action"].StringValue = "Fail";
            }

            LambdaLogger.Log(string.Format("Processing event for document: {0}...", documentId));
            var interruptionCollection = repositoryForSpace.Interruptions.List(regardingDocumentId: documentId, pendingOnly: true).Items;

            if (interruptionCollection.Count &gt; 0)
            {
                foreach (var interruption in interruptionCollection)
                {
                    // Check to see if responsibility needs to be taken
                    if (interruption.IsPending)
                    {
                        // Take responsibility
                        LambdaLogger.Log(string.Format("Taking responsibility for interruption: {0}...", interruption.Id));
                        repositoryForSpace.Interruptions.TakeResponsibility(interruption);

                        // The message attributes contain the type [Manual Intervention | GuidedFailure] and the desired Action to take for it
                        interruption.Form.Values[message.MessageAttributes["Type"].StringValue] = message.MessageAttributes["Action"].StringValue;

                        // Update Octopus
                        LambdaLogger.Log(string.Format("Submitting {0}:{1} for: {2}...", message.MessageAttributes["Type"].StringValue, message.MessageAttributes["Action"].StringValue, interruption.Id));
                        repositoryForSpace.Interruptions.Submit(interruption);
                    }
                }
            }
            await Task.CompletedTask;
        }
    }
}
</code></pre>

<h2 id="building-and-packaging-the-lambdas">制造和包装兰姆达斯</h2>

<p>只有<code>process-message</code> Lambda需要构建，但是，它们都需要打包以便部署。OctoSubscriber项目使用GitHub动作来完成这些操作。</p>

<pre><code class="language-yaml"># This is a basic workflow to help you get started with Actions

name: AWS Lambda

on:
  push:
    paths:
      - 'aws/accept-message/**'

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: ['3.1.x']

    steps:
      - uses: actions/checkout@v2
      - name: Setup .NET Core SDK ${{ matrix.dotnet-version }}
        uses: actions/setup-dotnet@v1.7.2
        with:
          dotnet-version: ${{ matrix.dotnet-version }}

      - name: Create artifacts folder
        run: |
          mkdir "$GITHUB_WORKSPACE/artifacts"
          mkdir "$GITHUB_WORKSPACE/artifacts/process-message"
      - name: Restore dependencies for process-message
        working-directory: aws/process-message/process-message
        run: dotnet restore

      - name: Build process-message
        working-directory: aws/process-message/process-message
        run: dotnet build --configuration Release --no-restore --output "$GITHUB_WORKSPACE/artifacts/process-message"

      - name: Install Octopus CLI
        uses: OctopusDeploy/install-octopus-cli-action@v1.1.1
        with:
          version: latest

      - name: Pack and Push
        env:
          OCTOPUS_URL: ${{ secrets.OCTOPUS_SERVER }}
          OCTOPUS_API_KEY: ${{ secrets.OCTOPUS_API_KEY }}  
        run: |
          octo pack --id=OctoSubscriber-AcceptMessage-Lambda --format=Zip --version=2021.1.1.$GITHUB_RUN_NUMBER --basePath="aws/accept-message/"
          octo pack --id=OctoSubscriber-ProcessMessage-Lambda --format=Zip --version=2021.1.1.$GITHUB_RUN_NUMBER --basePath="$GITHUB_WORKSPACE/artifacts/process-message"
          octo push --package=OctoSubscriber-AcceptMessage-Lambda.2021.1.1.$GITHUB_RUN_NUMBER.zip --server=$OCTOPUS_URL --apiKey=$OCTOPUS_API_KEY --space="Target - Serverless"
          octo push --package=OctoSubscriber-ProcessMessage-Lambda.2021.1.1.$GITHUB_RUN_NUMBER.zip --server=$OCTOPUS_URL --apiKey=$OCTOPUS_API_KEY --space="Target - Serverless"
</code></pre>

<p>在本例中，GitHub动作将Lambda包直接推送到内置的Octopus Deploy包存储库。</p>

<h2 id="deploying-the-lambdas">部署兰姆达斯</h2>

<p>这篇文章假设你熟悉如何创建一个Octopus Deploy项目，不会涉及这个主题。</p>

<p>Lambdas的部署过程将包括以下步骤:</p>

<ul>
<li><strong> AWS - Deploy接受消息Lamdba函数</strong></li>
<li><strong> AWS -部署流程消息Lamdbda函数</strong></li>
<li><strong> AWS -配置接受消息Lambda别名</strong></li>
<li><strong> AWS -配置流程消息Lambda别名</strong></li>
<li><strong> AWS -配置Lambda API网关集成</strong></li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-deployment-process.png" class="zoom" data-title=""><img src="../Images/a81ebf0f893796b16ba4cbd01e114aaf.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-deployment-process.png"/>T2】</a></p>

<h3 id="aws-deploy-accept-message-lambda-function">AWS -部署接受消息Lambda函数</h3>

<p>向您的部署流程添加一个<strong>AWS-Deploy Lambda Function</strong>步骤。点击<strong>添加步骤</strong>，然后通过<code>aws</code>进行搜索。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-add-aws-deploy-lambda-step.png" class="zoom" data-title=""><img src="../Images/a230884ed060349d83355e4f913de809.png" class="img-fluid center" alt="Octopus UI showing Choose Step Template with aws in search field and AWS - Deploy Lambda Function selected" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-add-aws-deploy-lambda-step.png"/>T2】</a></p>

<p>填写步骤表单字段:</p>

<ul>
<li><strong>功能名称</strong>:要部署的功能的名称</li>
<li><strong> AWS帐户</strong>:用于部署的AWS帐户变量</li>
<li><strong>区域</strong>:Lambda部署的区域</li>
<li><strong>包</strong>:包含Lambda的包</li>
<li><strong>功能角色</strong>:您为Lambdas创建的角色的ARN</li>
<li><strong>运行时</strong>:代码运行时，<code>nodejs14.x</code>为接受消息</li>
<li><strong>处理程序</strong>:Lambda调用来执行你的函数的方法的名字(<em>注意:这将根据运行时选择的</em>而不同)——对于<strong>接受消息</strong>，它是<code>index.handler</code></li>
<li><strong>内存大小</strong>:您的函数可以访问的内存大小，必须是64MB的倍数，<strong>接受消息</strong>的<code>128</code></li>
<li><strong>环境变量</strong>:sqsqsqueue =[队列名称]，SQS Region =[SQS队列区域]</li>
</ul>

<h3 id="aws-deploy-process-message-lambda-function">AWS -部署流程消息Lambda函数</h3>

<p>这使用了与上面相同的步骤模板，所以我只列出不同的字段:</p>

<ul>
<li><strong>函数名</strong>:要部署的函数名</li>
<li><strong>包</strong>:包含Lambda的包</li>
<li><strong>运行时</strong> : <code>dotnetcore 3.1</code></li>
<li><strong>处理程序</strong> : <code>process_message::process_message.Function::FunctionHandler</code></li>
<li><strong>环境变量</strong>:OCTOPUS _ SERVER _ URL =[OCTOPUS服务器URL]，OCTOPUS_API_KEY=[API Key]</li>
<li><strong>超时</strong> : <code>30</code>(默认超时为3秒，不足以让Lambda完全处理)</li>
</ul>

<h3 id="aws-configure-access-message-lambda-alias">AWS -配置访问消息Lambda别名</h3>

<p>AWS支持同时部署Lambda的多个版本。AWS还支持金丝雀式的流程，在这个流程中，您可以为不同版本的Lambda分配一定比例的流量。这是通过为一个版本配置一个别名，并告诉Lambda要路由多少流量给它来实现的。</p>

<p>向您的流程添加一个<strong> AWS配置Lambda别名</strong>步骤。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-add-aws-configure-alias-step.png" class="zoom" data-title=""><img src="../Images/13c69c6e77e2f3d37505491f828c73f1.png" class="img-fluid center" alt="Octopus UI showing Choose Step Template with aws in search field and AWS Configure Lambda Alias selected" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-add-aws-configure-alias-step.png"/>T2】</a></p>

<p>填写步骤表单字段:</p>

<ul>
<li><strong>函数名</strong>:上面的部署步骤将为部署的函数输出ARN，这里使用输出变量- #{Octopus。动作<a href="#aws-deploy-accept-message-lambda-function"> AWS -部署接受消息Lambda函数</a>. output .λarn }</li>
<li><strong> AWS帐户</strong>:用于部署的AWS帐户变量</li>
<li><strong>区域</strong>:Lambda所在的区域</li>
<li><strong>别名</strong>:要使用的别名，本帖使用<code>Live</code></li>
<li><strong>别名版本百分比</strong>:该版本接收流量的百分比，本帖使用100</li>
<li><strong>函数版本</strong>:别名的函数版本，使用部署步骤- <code>#{Octopus.Action[AWS - Deploy Accept Message Lambda Function].Output.PublishedVersion}</code>的输出变量</li>
</ul>

<h3 id="aws-configure-process-message-lambda-alias">AWS -配置流程消息Lambda别名</h3>

<p>这一步与前一步完全一样，只是针对流程消息Lambda进行了配置。</p>

<p>使用<code>#{Octopus.Action[AWS - Deploy Process Message Lambda Function].Output.LambdaArn}</code>将输出变量中的<strong> AWS -部署接受消息Lambda函数</strong>替换为<strong> AWS -部署流程消息Lambda函数</strong>。</p>

<h3 id="aws-configure-lambda-api-gateway-integration">AWS -配置Lambda API网关集成</h3>

<p>这一步配置API v2网关来连接和调用Lambda函数。</p>

<p>向您的流程添加一个<strong>AWS-Configure Lambda API Gateway Integration</strong>步骤:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-add-aws-api-gateway-integration.png" class="zoom" data-title=""><img src="../Images/538fb6e803ebefc2c7f68b162435e705.png" class="img-fluid center" alt="Octopus UI showing Choose Step Template with aws in search field and AWS - Configure Lambda API Gateway Integration selected" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-add-aws-api-gateway-integration.png"/>T2】</a></p>

<p>填写步骤表单字段:</p>

<ul>
<li><strong> API网关名称</strong>:要配置/创建的网关的名称</li>
<li><strong> AWS帐户</strong>:用于部署的AWS帐户变量</li>
<li><strong> AWS区域</strong>:Lambda所在的区域</li>
<li><strong>路线键</strong>:使用/创建路线，本岗位使用<code>/octopus/webhook</code></li>
<li><strong> HTTP方法</strong>:您正在创建的路由和集成的HTTP方法</li>
<li><strong>拉姆达ARN </strong>:拉姆达的ARN，这篇文章使用了创建步骤<code>#{Octopus.Action[AWS - Deploy Accept Message Lambda Function].Output.LambdaArn}</code>的输出变量</li>
<li><strong> Lambda别名:</strong>别名的名称，在本例中为<code>Live</code></li>
<li><strong>净荷格式版本</strong>:API网关发送给Lambda的净荷格式</li>
</ul>

<h3 id="deployment">部署</h3>

<p>如果Lambdas、别名或API网关先前不存在，则首次部署时可能会收到警告。这很正常。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-deployment-complete.png" class="zoom" data-title=""><img src="../Images/8b33635a373a741585cfcbe0252355d7.png" class="img-fluid center" alt="Octopus UI showing Task Summary with warnings" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-deployment-complete.png"/>T2】</a></p>

<h2 id="configuring-remaining-resources">配置剩余资源</h2>

<p>大部分需要完成的工作已经通过使用Terraform的供应流程和使用AWS步骤模板的部署流程自动完成。但是，在解决方案准备好被调用之前，还有两个步骤:</p>

<ul>
<li>创建API网关阶段</li>
<li>将流程消息Lambda连接到SQS队列</li>
</ul>

<h3 id="creating-api-gateway-stage">创建API网关阶段</h3>

<p>创建阶段将为要调用的接受消息Lambda创建URL端点。在AWS中，导航到<strong>网络&amp;内容交付</strong>部分，然后选择<strong> API网关</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-console-api-gateway.png" class="zoom" data-title=""><img src="../Images/382f09a54c494a645d5a3cb61dfb94fe.png" class="img-fluid center" alt="AWS Console showing Networking &amp; Content Delivery section with API Gateways menu item highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-console-api-gateway.png"/>T2】</a></p>

<p>点击您想要配置的<strong> API网关</strong>。加载完成后，点击<strong>创建阶段</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-api-gateway-create-stage.png" class="zoom" data-title=""><img src="../Images/4ebb0b6fb88e661794e8a68f7e1cfe24.png" class="img-fluid center" alt="AWS Console open on API Gateways with Create stage button highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-api-gateway-create-stage.png"/>T2】</a></p>

<p>给这个阶段一个<strong>名称</strong>，打开<strong>启用自动部署</strong>选项，然后点击<strong>创建</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-api-gateway-stage.png" class="zoom" data-title=""><img src="../Images/11f4cf0404568380fc57437dd67de7aa.png" class="img-fluid center" alt="AWS console showing Stage details" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-api-gateway-stage.png"/>T2】</a></p>

<p>创建阶段后，它将显示配置Octopus Deploy订阅webhook所需的<strong>调用URL </strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-api-gateway-stage-created.png" class="zoom" data-title=""><img src="../Images/c51c04585a50760e4bc5a585dfb0c8a7.png" class="img-fluid center" alt="AWS console showing Stage details with Invoke URL highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-api-gateway-stage-created.png"/>T2】</a></p>

<h3 id="connect-process-message-lambda-to-sqs-queue">将流程消息Lambda连接到SQS队列</h3>

<p>现在您需要将流程消息Lambda配置为从SQS队列中触发。</p>

<p>导航到位于<strong>计算</strong>部分下的AWS控制台中的<strong>λ</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-console-lambda.png" class="zoom" data-title=""><img src="../Images/191496036ba4d79d202c6ed5a1c78aee.png" class="img-fluid center" alt="AWS Console showing All services section above Compute section with Lambda menu item highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-console-lambda.png"/>T2】</a></p>

<p>选择<strong>流程消息λ</strong>，然后点击<strong>配置</strong>，然后<strong>触发</strong>，然后点击<strong>添加触发</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-lambda-configuration-triggers.png" class="zoom" data-title=""><img src="../Images/c20368d984614a73fd30a0d29441a4fc.png" class="img-fluid center" alt="AWS console showing Function overview" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-lambda-configuration-triggers.png"/>T2】</a></p>

<p>从下拉菜单中选择<strong> SQS </strong>。点击<strong> SQS队列</strong>框将显示队列列表。您可以从该列表中选择或输入队列的ARN。完成后，点击<strong>添加</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-lambda-create-trigger.png" class="zoom" data-title=""><img src="../Images/9e811beb39f66bd6dac41ac76703c289.png" class="img-fluid center" alt="AWS console showing  Trigger configuration section with SQS section and SQS queue section highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-lambda-create-trigger.png"/>T2】</a></p>

<h2 id="configuring-the-octopus-deploy-subscription">配置Octopus部署订阅</h2>

<p>现在，您已经准备好配置Octopus Deploy，以便在发生引导失败事件时调用您的Lambda。</p>

<p>导航到Octopus Deploy的<strong>配置</strong>选项卡，点击<strong>订阅</strong>，然后<strong>添加订阅</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-subscription.png" class="zoom" data-title=""><img src="../Images/160f9dcfdef87bda915bc899370a6959.png" class="img-fluid center" alt="Octopus dashboard open on the Configuration tab with Subscriptions selected from the menu and ADD SUBSCRIPTION highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-subscription.png"/>T2】</a></p>

<p>为订阅输入以下信息:</p>

<ul>
<li><strong>名称</strong>:给订阅命名</li>
<li><strong>事件类别</strong>:引发引导失败中断</li>
<li><strong>有效载荷URL </strong> : <code>[API Gateway Invoke URL]/octopus/webhook?type=Guidance&amp;action=Fail</code></li>
</ul>

<p>完成后，它看起来会像这样:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-subscription-webhook.png" class="zoom" data-title=""><img src="../Images/9172b52ae8da6d2a6dc8d44e64bab47a.png" class="img-fluid center" alt="Octopus dashboard open on the Configuration tab with Webhook Notifcations section highlighted and Payload URL showing" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-subscription-webhook.png"/>T2】</a></p>

<h2 id="testing-the-solution">测试解决方案</h2>

<p>为了测试这个解决方案，我们需要做两件事:</p>

<ul>
<li>启用引导失败</li>
<li>将部署配置为失败</li>
</ul>

<h3 id="enabling-guided-failure">启用引导式故障</h3>

<p>可以为部署流程或操作手册启用引导式故障。</p>

<p>要启用部署过程，选择<strong>设置</strong>，然后选择<strong>使用引导故障模式</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-enable-guided-failure.png" class="zoom" data-title=""><img src="../Images/af8ea1fe27797c9ca49115daf36b16f1.png" class="img-fluid center" alt="Octopus dashboard showing Settings with Use guided failure mode selected and highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-enable-guided-failure.png"/>T2】</a></p>

<h3 id="configuring-deployment-to-fail">将部署配置为失败</h3>

<p>一种简单的方法是创建一个部署流程，其中有一个<strong>运行脚本</strong>步骤。为脚本输入以下内容:</p>

<pre><code class="language-powershell">Fail-Step "Fail on purpose"
</code></pre>

<h3 id="running-the-deployment">运行部署</h3>

<p>部署将立即进入引导失败并等待引导。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-guided-failure.png" class="zoom" data-title=""><img src="../Images/5a6c31bfe611d30bd40594e90301a745.png" class="img-fluid center" alt="Octopus dashboard open on the Projects tab with Task summary showing an error message about waiting to be assigned" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-guided-failure.png"/>T2】</a></p>

<p>几秒钟后，Octopus Deploy将处理订阅事件，并将使部署失败。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-guidance-received.png" class="zoom" data-title=""><img src="../Images/1dcef22f9e184d00fd752a41434d44b8.png" class="img-fluid center" alt="Task summary with Guidance received: failed highlighted" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/octopus-guidance-received.png"/>T2】</a></p>

<p>在AWS控制台中，您可以查看CloudWatch日志，查看Lambda处理了消息，然后提交给Octopus服务器。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-cloudwatch-logs.png" class="zoom" data-title=""><img src="../Images/9c778d47a5a90df9bbe1391d8656c970.png" class="img-fluid center" alt="AWS Console showing Log events" data-original-src="https://i.octopus.com/blog/2022-01/automate-guided-failure-with-lambda/aws-cloudwatch-logs.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>这篇文章向您展示了如何使用Octopus Deploy <strong>订阅</strong>调用AWS Lambda来自动响应引导失败事件。虽然演示的目标是引导失败，但同样的Lambda也可以用于自动响应<strong>手动干预</strong>。</p>



<p>愉快的部署！</p>

                    
                    
</body>
</html>