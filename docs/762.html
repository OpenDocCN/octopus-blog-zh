<html>
<head>
<title>The ultimate guide to rolling deployments - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>滚动部署的终极指南- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/ultimate-guide-to-rolling-deployments#2021-08-12">https://octopus.com/blog/ultimate-guide-to-rolling-deployments#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deployments.png" class="zoom" data-title=""><img src="../Images/6097274c204c6461a1ce3a3644a10675.png" class="img-fluid center" alt="Rolling Deployments" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deployments.png"/>T2】</a></p>

<p>当部署现代软件的新版本时，比如web应用程序和服务，一些团队在进行部署时关闭整个网站的情况仍然很常见。</p>

<p>如果您的大多数客户只在工作时间使用您的应用程序，那么这种大爆炸式的方法可能是可以接受的，但是如果您的客户全天候使用您的应用程序会怎么样呢？</p>

<p>如今，用户希望应用程序始终可用，有一些部署模式可以用来实现零停机。在这篇文章中，我将更深入地讨论其中一种模式；滚动部署。我还将为您提供一些如何使用不同工具实现滚动部署的实际例子。</p>

<h2>在这篇文章中</h2>



<h2 id="what-are-rolling-deployments">什么是滚动部署？</h2>

<p>滚动部署是一种部署模式(也称为增量部署、批量部署或斜坡部署)，在这种模式下，通常一次向一个或多个部署目标交付新软件，直到所有目标都部署了软件的更新版本。</p>

<p>典型的流程如下所示:</p>

<ol>
<li>在应用程序的两个节点运行<code>v1.0</code>的情况下，清空要更新的第一个节点，将其从负载平衡器池中取出，并让剩余的节点保持在线以服务流量:</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-1.png" class="zoom" data-title=""><img src="../Images/b6931c5ee28e6182c691b4af05f965c1.png" class="img-fluid center" alt="Rolling Deployment: Draining nodes" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-1.png"/>T2】</a></p>

<ol start="2">
<li>停止在耗尽的节点上运行<code>v1.0</code>应用程序，然后部署新的<code>v1.1</code>版本。<em>可选地</em>，通过在新部署的应用程序上运行测试来验证部署是否成功。同时，维护至少一个运行应用程序<code>v1.0</code>的节点:</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-2.png" class="zoom" data-title=""><img src="../Images/23c6ad7c552845b6925e72a88a36a66b.png" class="img-fluid center" alt="Rolling Deployment: Update nodes with new versions" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-2.png"/>T2】</a></p>

<ol start="3">
<li>在第一个节点成功更新后，继续清空仍在运行应用程序<code>v1.0</code>的剩余节点，同时您的新<code>v1.1</code>版本现在在线提供流量:</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-3.png" class="zoom" data-title=""><img src="../Images/c43e700700c219d14ba9a00445e4d9ae.png" class="img-fluid center" alt="Rolling Deployment: Drain remaining nodes in pool" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-3.png"/>T2】</a></p>

<ol start="4">
<li>停止剩余节点上的<code>v1.0</code>应用程序的运行，部署新的<code>v1.1</code>版本。同样，也可以验证部署是否成功:</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-4.png" class="zoom" data-title=""><img src="../Images/ad39ee56e7560f27ff3b065fd1083549.png" class="img-fluid center" alt="Rolling Deployment: Update remaining nodes in pool" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-4.png"/>T2】</a></p>

<ol start="5">
<li>最后，在应用程序的<code>v1.1</code>成功部署到所有节点之后，您的滚动部署就完成了！</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-5.png" class="zoom" data-title=""><img src="../Images/12ce66d3a9ce031de2e9a0ba692c4b88.png" class="img-fluid center" alt="Rolling Deployment: Update remaining nodes in pool" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-5.png"/>T2】</a></p>

<p>如果您想要加速您的滚动部署，并同时向多个节点交付一个新版本，比如说两个节点，那么它看起来应该是这样的:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-multiple.png" class="zoom" data-title=""><img src="../Images/44f6e30059bc412376d75c29b64b347f.png" class="img-fluid center" alt="Rolling Deployment: Update multiple nodes in pool" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/rolling-deploy-multiple.png"/>T2】</a></p>

<p>这种增量方法通常在位于负载平衡器之后的web应用程序中更受青睐，因为大多数负载平衡器支持一种称为<strong>连接排出</strong>的概念。这允许到服务的连接自然完成，并防止建立新的连接。</p>

<p>通过执行该动作，被选择更新的实例可以在它们完成它们的工作之后从可用池中移除，而其他实例保持在线服务流量。</p>

<p>尽管上面的场景描述了web应用程序滚动部署，但是也可以实现其他类型应用程序的滚动部署，只要它们是以支持安全地结束其过程的方式构建的。</p>


<p>例如，Octopus Deploy的<a href="https://octopus.com/docs/administration/high-availability">高可用性</a>配置也有一个<a href="https://octopus.com/docs/administration/high-availability/managing-high-availability-nodes#ManagingHighAvailabilityNodes-Drain">消耗选项</a>，它可以阻止任何新任务的执行，并完成它当前正在执行的任何任务，直到空闲。排水等功能允许安全终止进程，然后可以更新并重新联机。</p>

<h2 id="why-are-they-useful">它们为什么有用？</h2>

<p>那么，为什么要使用滚动部署而不是其他模式，比如canary或blue/green？滚动部署具有以下优势:</p>

<h3 id="incremental-update">增量更新</h3>

<p>应用程序的新版本是逐步推出的。这使您可以验证它的工作，例如，在进行下一批更新之前运行健康检查或测试。</p>

<p>如果您需要启动回滚，您也可以用一种安全且可控的方式来完成。</p>

<h3 id="keeping-the-lights-on">保持灯亮着</h3>

<p>当您着手更新少量的应用程序实例时，其余的继续为请求服务。这意味着您的应用程序不会停机，并且在整个部署过程中您的用户都可以使用它。</p>

<h3 id="parallelism">平行</h3>

<p>您通常可以控制一次部署到的并发实例的数量。在之前的部署完成之前，不会开始进一步的部署。</p>

<p>您可以在Octopus滚动部署中使用<strong>窗口大小</strong>选项来控制一次可以部署多少个部署目标。</p>


<h2 id="rolling-deployment-patterns-in-practice">实践中的滚动部署模式</h2>

<p>为了演示滚动部署的不同方法，我们有一个非常简单的。将显示网页的NET Core 3.1应用程序。</p>

<p>我感兴趣的部分的HTML如下所示:</p>

<pre><code class="language-html">&lt;div class="text-center"&gt;
    &lt;h1 class="display-4"&gt;Welcome&lt;/h1&gt;
    &lt;p&gt;If you are seeing this, then &lt;strong&gt;Congratulations!&lt;/strong&gt; &lt;br/&gt; You've got the example application running. &lt;/p&gt;

    @if(Settings.Value.AppVersion == "0.0.2") {
        &lt;p&gt;v0.0.2 of the application comes with this text &lt;/p&gt;
    }
    @if(Settings.Value.AppVersion == "0.0.3") {
        &lt;p&gt;But don't miss out on v0.0.3 of the application which comes with this text! &lt;/p&gt;
    }
&lt;/div&gt;
</code></pre>

<p>该应用程序的代码可在<a href="https://github.com/OctopusSamples/rolling-deploy-web-example" rel="nofollow"> GitHub </a>上获得，并有一个与三个不同的<code>AppVersion</code>值相对应的<a href="https://github.com/OctopusSamples/rolling-deploy-web-example/releases" rel="nofollow">标签</a>。一张Docker图片也已经发布为<a href="https://hub.docker.com/r/octopusdeploy/rolling-deploy-web-example" rel="nofollow">octopus deploy/rolling-deploy-web-example</a>。</p>

<p>我想看看使用一些流行的技术和工具来执行此应用程序的滚动部署有多简单，因此我将使用以下工具来演示滚动部署:</p>



<h3 id="docker-rolling-application-updates">Docker滚动应用程序更新</h3>

<p>在过去几年中，Docker已经成为事实上的容器技术。因此，它以Docker <a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services" rel="nofollow">服务</a>的概念支持滚动部署也就不足为奇了。通常，服务是更大的架构图中的一小部分，在微服务中很受欢迎。</p>

<p>服务支持许多不同的选项，包括滚动更新策略和回滚能力。</p>

<h4 id="docker-containerized-application">码头集装箱应用</h4>

<p>我在一个<a href="https://ubuntu.com/download/server" rel="nofollow"> Ubuntu </a>服务器上运行Docker，并使用我们预先构建的容器映像。在Ubuntu上安装Docker有几种方法:</p>

<ol>
<li>通过运行<code>sudo apt-get install docker.io</code>来使用Ubuntu存储库。</li>
<li>使用官方的<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/#install-docker-engine---community" rel="nofollow">对接指南</a>。</li>
</ol>

<p>我选择了Ubuntu库，因为它似乎更快更容易，但你的里程可能会有所不同。无论您选择哪种方法，都有必要确保您满足安装的先决条件。</p>

<p>为了简单起见，我将在我的Linux机器的SSH终端会话中与Docker交互。有一些生产就绪的设置可以实现这一点，这些设置的特点是在一个<a href="https://docs.docker.com/compose/compose-file/" rel="nofollow"> Docker Compose </a>文件中定义您的服务，包括控制自动更新和回滚设置的部分。</p>

<p><strong>权限要求:</strong> <br/>本演示中的大多数命令都使用了<a href="https://www.linux.com/tutorials/linux-101-introduction-sudo/" class="alert-link" rel="nofollow"> sudo </a>。默认情况下，Docker守护程序作为根用户运行，需要提升权限才能执行命令。如果你不想在执行命令时使用<code>sudo</code>，请确保遵循Docker <a href="https://docs.docker.com/install/linux/linux-postinstall/" class="alert-link" rel="nofollow">安装后</a>说明。</p>


<p>首先，为了查看这个独立运行的Docker映像，我们将使用以下命令运行它:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker run -d -p 5001:5001 octopusdeploy/rolling-deploy-web-example:0.0.1
</code></pre>

<p>不出所料，运行这个Docker图像会显示网页:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/docker-run.png" class="zoom" data-title=""><img src="../Images/3b2c0344934e51df01186863e78d0efc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/docker-run.png"/>T2】</a></p>

<p>在这篇文章中，我不解释如何建立一个容器图像。如果您是Docker的新手，我的同事Shawn已经写了一个很好的系列文章，介绍如何将一个真实世界的应用程序容器化，而不是另一个“Hello World”的例子。</p>


<p><strong>集装箱清理</strong></p>

<p>接下来需要快速整理。要删除我们使用上面的<code>run</code>命令创建的容器，我们需要停止它，然后使用<code>rm</code>命令删除它。我们可以用简洁的一行程序来实现这一点:</p>

<pre><code class="language-bash">sudo docker rm $(sudo docker stop $(sudo docker ps -a -q --filter ancestor=octopusdeploy/rolling-deploy-web-example:0.0.1 --format="{{.ID}}"))
</code></pre>

<p>这通过图像名<code>octopusdeploy/rolling-deploy-web-example:0.0.1</code>定位我们的容器，并将它传递给<code>stop</code>命令，最后将它传递给<code>rm</code>命令。</p>

<p>为了部署容器的多个实例，我们需要创建Docker服务。这使用<a href="https://docs.docker.com/engine/swarm" rel="nofollow">码头工人群</a>作为其幕后指挥者。</p>

<p><strong>Docker Kubernetes orchestrator</strong><br/>Docker在使用Docker <a href="https://docs.docker.com/engine/reference/commandline/stack" class="alert-link" rel="nofollow"> stack </a>命令部署容器时也支持Kubernetes作为orchestrator，但是在使用<code>service create</code>时无法指定orchestrator。</p>


<p>让我们看看创建服务的命令是什么样子的:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service create --name rolling-deploy-svc --replicas 3 --publish published=5001,target=5001 --update-delay 10s --update-parallelism 1 octopusdeploy/rolling-deploy-web-example:0.0.1
</code></pre>

<p>这个命令中有很多内容，所以让我们来分析一下我们对Docker的要求:</p>

<ul>
<li><code>--name</code>不言自明。</li>
<li><code>--replicas</code>标志控制我们想要的容器数量(3)。</li>
<li><code>--publish published=5001,target=5001</code>使用Swarm的<a href="https://docs.docker.com/engine/swarm/ingress/#publish-a-port-for-a-service" rel="nofollow">路由网格</a>指定要在端口5001上访问的服务，该路由网格本质上就像一个软件负载平衡器。</li>
<li><code>--update-delay</code>配置服务任务更新之间的时间延迟(10秒)。</li>
<li><code>--update-parallelism</code>控制Docker将同时调度的最大任务数(1)。</li>
<li>最后，我们指定要使用的图像:<code>octopusdeploy/rolling-deploy-web-example:0.0.1</code>。</li>
</ul>

<p><strong>提示:</strong> <br/>第一次运行<code>service create</code>时，可能会收到警告，就像我一样:<code>This node is not a swarm manager</code>。要解决此问题，请运行以下命令之一:</p>
<ul>
<li>这将把你当前的节点初始化为群组管理器。</li>
<li><code>sudo docker swarm join</code>:这将把你的本地节点连接到swarm。</li>
</ul>


<p>执行此操作将导致我们的服务被部署到Docker Swarm，其中包含三个实例:</p>

<pre><code>wxi1w4m7crknaz1f800kr9ztt
overall progress: 3 out of 3 tasks
1/3: running   [==================================================&gt;]
2/3: running   [==================================================&gt;]
3/3: running   [==================================================&gt;]
verify: Service converged
</code></pre>

<p>我们还可以通过运行<code>service inspect</code>命令来检查我们的服务是否有正确的更新配置:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service inspect rolling-deploy-svc --pretty

ID:             bh03s0yjzkevzkkwvu8q2h0jj
Name:           rolling-deploy-svc
Service Mode:   Replicated
 Replicas:      3
Placement:
UpdateConfig:
 Parallelism:   1
 Delay:         10s
 On failure:    pause
 Monitoring Period: 5s
 Max failure ratio: 0
 Update order:      stop-first
RollbackConfig:
 Parallelism:   1
 On failure:    pause
 Monitoring Period: 5s
 Max failure ratio: 0
 Rollback order:    stop-first
ContainerSpec:
 Image:         octopusdeploy/rolling-deploy-web-example:0.0.1@sha256:4da10d630025bf268b855b0b4afafa7334769ab6d0b3e75e11a3f11949708552
 Init:          false
Resources:
Endpoint Mode:  vip
Ports:
 PublishedPort = 5001
  Protocol = tcp
  TargetPort = 5001
  PublishMode = ingress
</code></pre>

<p>这个结果表明我们有了我们想要的<code>UpdateConfig</code>，它将一次更新一个任务。</p>

<h4 id="docker-service-update">Docker服务更新</h4>

<p>现在我们可以通过运行<code>service update</code>命令将<code>octopusdeploy/rolling-deploy-web-example</code>的容器图像更新为<code>v0.0.2</code>:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service update rolling-deploy-svc --image octopusdeploy/rolling-deploy-web-example:0.0.2
</code></pre>

<p>Docker对每个容器运行更新，一次一个任务，就像我们配置的那样:</p>

<pre><code>overall progress: 0 out of 3 tasks
1/3: running   [=============================================&gt;     ]
2/3:
3/3:
</code></pre>

<p>第一个任务完成后，它进入第二个任务:</p>

<pre><code>overall progress: 1 out of 3 tasks
1/3: starting  [==================================================&gt;]
2/3: ready     [=====================================&gt;             ]
3/3:
</code></pre>

<p>直到更新容器到<code>v0.0.2</code>的所有任务完成:</p>

<pre><code>overall progress: 3 out of 3 tasks
1/3: running   [==================================================&gt;]
2/3: running   [==================================================&gt;]
3/3: running   [==================================================&gt;]
verify: Service converged
</code></pre>

<p>现在浏览网站显示申请<code>v0.0.2</code>的文本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/docker-service-v0.0.2.png" class="zoom" data-title=""><img src="../Images/02915f4ee938eed21520d40a2268b6fb.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/docker-service-v0.0.2.png"/>T2】</a></p>

<h4 id="docker-service-rollback">Docker服务回滚</h4>

<p>正如直接推出一样，也可以在Docker中用一个简单的命令手动回滚。</p>

<p>首先，我们将通过运行以下命令来更新应用程序的最终版本<code>v0.0.3</code>:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service update rolling-deploy-svc --image octopusdeploy/rolling-deploy-web-example:0.0.3
</code></pre>

<p>我们通过运行<code>service inspect</code>命令来验证新的<code>v0.0.3</code>版本，只为我们希望看到的输出传入一个<code>--format</code>参数:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service inspect --format='{.Spec.TaskTemplate.ContainerSpec.Image}}' rolling-deploy-svc

octopusdeploy/rolling-deploy-web-example:0.0.3@sha256:151a8f2aaed0192bf9f22eaeff487d546e6ff8fec4d0691e6697dede743b187c
</code></pre>

<p>因为Docker Swarm知道我们部署的版本，所以我们可以使用<code>rollback</code>命令恢复到之前的版本(<code>v0.0.2</code>):</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service rollback rolling-deploy-svc

rolling-deploy-svc
rollback: manually requested rollback
overall progress: rolling back update: 3 out of 3 tasks
1/3: running   [&gt;                                                  ]
2/3: running   [&gt;                                                  ]
3/3: running   [&gt;                                                  ]
verify: Service converged
</code></pre>

<p>一旦成功回滚，它就确认服务正在运行。</p>

<p><strong>提示:</strong> <br/>由于我没有给<code>rollback</code>命令指定任何参数，Docker将默认一次回滚一个任务，每个任务之间没有延迟。您可以通过将以下内容传递给命令来指定不同的值:</p>
<ul>
<li><code>--rollback-parallelism</code></li>
<li><code>--rollback-delay</code></li>
</ul>
<p>Docker <a href="https://docs.docker.com/engine/reference/commandline/create/#options" class="alert-link" rel="nofollow">文档</a>中有您可以使用的参数的完整列表。</p>


<p>我们可以使用与之前相同的命令来检查服务，以验证回滚是否成功:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo docker service inspect --format='{.Spec.TaskTemplate.ContainerSpec.Image}}' rolling-deploy-svc

octopusdeploy/rolling-deploy-web-example:0.0.2@sha256:4843a91ba84ace97cb11a6e3f68827a8c28a628d509159910c868f9ad02c3053
</code></pre>

<p>这导致输出中出现预期的<code>v0.0.2</code>版本。</p>

<p><strong>数据库回滚</strong> <br/>当Docker中的服务利用数据库进行存储时，有一个适当的策略来处理服务回滚是很重要的，特别是当数据库在一个容器中时。Docker不会自动回滚数据库更改，这可能会使您的数据库和应用程序处于不兼容状态。Docker <a href="https://docs.docker.com/storage/" class="alert-link" rel="nofollow">存储</a>文档提供了一些关于在容器中存储不同选项的指导。</p>


<h4 id="docker-service-clean-up">码头服务清理</h4>

<p>最后，要删除Docker服务，我们只需运行<code>rm</code>命令:</p>

<pre><code>markh@ubuntu01:~$ sudo docker service rm rolling-deploy-svc
</code></pre>

<h4 id="docker-summary">Docker摘要</h4>

<p>如您所见，在Docker中进行滚动部署并不需要太多的设置。加上它对回滚的支持，使它成为一个值得考虑的有吸引力的选择。</p>

<h3 id="kubernetes-rolling-updates">Kubernetes滚动更新</h3>

<p>Kubernetes中的滚动部署被称为<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rolling-update" rel="nofollow">滚动更新</a>。</p>

<p>pod的实例将使用新实例进行增量更新。它支持在更新期间不可用的pod的最大数量或百分比，以及可以创建的新pod的最大数量。除此之外，Kubernetes还有一个方便的内置特性，允许更新恢复到以前的版本。</p>

<p>为了找到更多关于Kubernetes的信息，我的同事Shawn继续他的容器系列，主要关注Kubernetes。</p>


<p>Kubernetes <a href="https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/" rel="nofollow">关于更新的教程</a>包括一个展示其工作原理的漂亮图表:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/k8s-rolling-update.png" class="zoom" data-title=""><img src="../Images/37f03813a131baa594f17120ac01eb0c.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/k8s-rolling-update.png"/>T2】</a></p>

<h4 id="kubernetes-cluster-setup">Kubernetes集群设置</h4>

<p>和以前一样，我将在这个演示中重用我们预先构建的容器映像，这次使用的是<a href="https://microk8s.io/" rel="nofollow"> MicroK8s </a>。我还将主要在SSH终端会话中与它进行交互。</p>

<p>作者Canonical将MicroK8s描述为:</p>

<blockquote class="blockquote">
<p>适用于42种Linux的k8s软件包。专为开发人员打造，非常适合edge、IoT和设备。</p>
</blockquote>

<p>对于像我这样想尝试Kubernetes或者用它做一些开发的人来说，这很有用。</p>

<p>MicroK8s的一个好处是它不像其他Kubernetes选择的那样需要任何类型的虚拟机(比如<a href="https://minikube.sigs.k8s.io/" rel="nofollow"> Minikube </a>)。</p>

<p>在安装MicroK8s之前，值得注意的是有一些先决条件:</p>

<ul>
<li>Ubuntu 18.04 LTS或16.04 LTS(或其他支持<code>snapd</code>的OS)。</li>
<li>至少20G可用磁盘空间。</li>
<li>4GB内存。</li>
<li>互联网连接。</li>
</ul>

<p>为了安装MicroK8s，我们运行<a href="https://docs.snapcraft.io/installing-snapd" rel="nofollow">snap</a>T0】命令:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo snap install microk8s --classic

microk8s v1.17.0 from Canonical✓ installed
</code></pre>

<p><strong>完整安装输出</strong> <br/>如果您想查看来自<code>snap</code>的完整安装输出，运行<code>snap changes</code>命令:</p>
<pre><code class="language-bash">markh@ubuntu01:~$ snap changes

ID   Status  Spawn               Ready               Summary
1    Done    today at 10:17 UTC  today at 10:17 UTC  Initialize system state
2    Done    today at 10:17 UTC  today at 10:17 UTC  Initialize device
3    Done    today at 14:38 UTC  today at 14:38 UTC  Install "microk8s" snap
</code></pre>
<p>由此，您可以运行命令<code>snap change 3</code>，其中<code>3</code>是上面<code>ID</code>列中用于安装MicroK8s的值。这将为您提供安装步骤的明细行。</p>


<p><strong> Kubernetes部署</strong></p>

<p>现在我们已经安装并运行了MicroK8s，让我们继续使用我们现有的映像<code>rolling-deploy-web-example</code>创建一个Kubernetes部署，并将其设置为在端口5001上侦听。</p>

<p>Google将Kubernetes <a href="https://cloud.google.com/kubernetes-engine/docs/concepts/deployment" rel="nofollow">部署</a>描述为:</p>

<blockquote class="blockquote">
<p>表示一组没有唯一标识的多个相同的pod。部署运行应用程序的多个副本，并自动替换任何失败或无响应的实例。通过这种方式，部署有助于确保应用程序的一个或多个实例可用于服务用户请求。部署由Kubernetes部署控制器管理。</p>
</blockquote>

<p>这听起来非常适合滚动部署。</p>

<h4 id="kubernetes-containerized-application-setup">Kubernetes容器化应用程序设置</h4>

<p>为了设置我们的应用程序的部署，我们将使用与MicroK8s打包在一起的<a href="https://kubernetes.io/docs/reference/kubectl/kubectl/" rel="nofollow"> kubectl </a>二进制文件。这是用于管理Kubernetes的命令行界面(CLI)。它特别添加了前缀<code>microk8s.</code>，以避免与您可能运行的任何其他Kubernetes实例发生命名冲突。如果我们运行<code>create deployment</code>命令:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl create deployment rollingdeploy-microk8s --image=octopusdeploy/rolling-deploy-web-example:0.0.1

deployment.apps/rollingdeploy-microk8s created
</code></pre>

<p>MicroK8s将创建我们的部署，并确认它已经成功创建。</p>

<p>接下来，我们将设置应用程序窗格监听端口<code>5001</code>。为此，我们运行<a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#expose" rel="nofollow"> expose </a>命令:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl expose deployment rollingdeploy-microk8s --type=NodePort --port=5001

service/rollingdeploy-microk8s exposed
</code></pre>

<h5 id="kubernetes-dashboard">Kubernetes仪表板</h5>

<p>虽然已经创建了<code>rollingdeploy-microk8s</code> pod，但它可能不会立即可用。我们可以通过使用Kubernetes <a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" rel="nofollow">仪表板</a>查看我们的服务来检查它的状态，该仪表板作为<a href="https://microk8s.io/docs/addon-dashboard" rel="nofollow">插件</a>包含在MicroK8s中。</p>

<p>试图远程访问仪表板需要您经历一些困难。启用附加组件后，我发现最简单的方法是通过运行<code>kubectl proxy</code>命令创建一个从我的机器到服务器的代理:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl proxy --accept-hosts=.* --address=0.0.0.0

Starting to serve on [::]:8001
</code></pre>

<p>从那里你可以访问端口<code>8001</code>上的仪表板，但是你需要一个<code>Kubeconfig</code>文件或者<code>Token</code>来登录。更多详情请参见MicroK8s <a href="https://microk8s.io/docs/addon-dashboard" rel="nofollow">仪表板附件</a>。</p>

<p>注意:您可以通过为仪表板容器设置<code>--enable-skip-login</code>参数来跳过登录，但是不建议这样做，因为这违反了安全性最佳实践。</p>


<p>一旦打开，您就可以使用仪表板部署容器化的应用程序，管理集群资源并与之交互。</p>

<p>为了执行滚动更新，首先我们需要应用程序的多个副本。我们可以通过单击<strong>部署</strong>部分右侧的三个省略号，直接从仪表板扩展我们的部署:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-dashboard-scale-ellipsis.png" class="zoom" data-title=""><img src="../Images/f0c8c31e8b05fe06e650cd75d7c4cf59.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-dashboard-scale-ellipsis.png"/>T2】</a></p>

<p>对于我们的Kubernetes部署，我将<strong>所需副本</strong>更新为3，这样我就可以执行滚动更新，然后点击<strong>缩放</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-dashboard-scale.png" class="zoom" data-title=""><img src="../Images/def8586b00aa671cfaa0ba2074455c2a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-dashboard-scale.png"/>T2】</a></p>

<p><strong>等价的kubectl命令</strong> <br/>您可能已经注意到仪表板为我们的操作提供了运行的等价命令。来扩展我们的资源，那就是:</p>
<pre><code class="language-bash">sudo microk8s.kubectl scale -n default deployment rollingdeploy-microk8s --replicas=3
</code></pre>


<p>配置完pod后，我们可以通过运行<code>get pod</code>命令(名称可能不同)直接查询pod的状态来确认这一点:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl get pod

NAME                                      READY   STATUS    RESTARTS   AGE
rollingdeploy-microk8s-794bdc64c4-fv7zt   1/1     Running   0          76s
rollingdeploy-microk8s-794bdc64c4-t6mh5   1/1     Running   0          76s
rollingdeploy-microk8s-794bdc64c4-trr6f   1/1     Running   0          76s
</code></pre>

<p>为了验证我们的应用程序正在工作，我们需要通过运行<code>get service</code>找到Kubernetes向我们在开始时创建的部署公开的端口:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl get service rollingdeploy-microk8s

NAME                     TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
rollingdeploy-microk8s   NodePort   10.152.183.39   &lt;none&gt;        5001:32334/TCP   1m
</code></pre>

<p>在我的例子中，端口是<code>32334</code>,所以我访问服务的URL是:</p>

<pre><code>http://ubuntu01.octopusdemos.com:32334
</code></pre>

<p><strong>注意:</strong> <br/>在您自己的机器上运行时，端口可能会有所不同。Kubernetes将在30000-32767(默认)范围内随机分配一个端口，因为我们在前面运行<code>expose</code>命令时选择了<code>NodePort</code>类型。</p>


<p>在浏览器中打开URL，我们可以看到在Microk8s中运行的应用程序有<code>v0.0.1</code>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-v0.0.1.png" class="zoom" data-title=""><img src="../Images/c137dd8611eceab59c99d5fdadf73450.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-v0.0.1.png"/>T2】</a></p>

<h4 id="kubernetes-rolling-update">Kubernetes滚动更新</h4>

<p>让我们继续，通过运行<code>set image</code>命令，指示Kubernetes用我们的图像<code>octopusdeploy/rolling-deploy-web-example</code>的<code>v0.0.2</code>更新我们的三个pod:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl set image deployment/rollingdeploy-microk8s rolling-deploy-web-example=octopusdeploy/rolling-deploy-web-example:0.0.2 --record

deployment.apps/rollingdeploy-microk8s image updated
</code></pre>

<p>接下来，我们可以通过运行<code>rollout status</code>命令来观察我们的首次展示的实时进度，直到它完成:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl rollout status deployment.v1.apps/rollingdeploy-microk8s

Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 1 out of 3 new replicas have been updated...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 1 out of 3 new replicas have been updated...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 1 out of 3 new replicas have been updated...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 2 out of 3 new replicas have been updated...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 2 out of 3 new replicas have been updated...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 2 out of 3 new replicas have been updated...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 1 old replicas are pending termination...
Waiting for deployment "rollingdeploy-microk8s" rollout to finish: 1 old replicas are pending termination...
deployment "rollingdeploy-microk8s" successfully rolled out
</code></pre>

<p>您可以看到它表示一次更新一个Pod。</p>

<p>Kubernetes部署确保只有一定数量的pod在更新时关闭。它通过创建一个新的pod并在完成后销毁旧的pod来实现这一点。</p>

<p><strong>默认pod更新控制</strong></p>
<p>默认情况下，Kubernetes确保至少有75%的期望数量的pod可用。此外，另一个默认情况是创建不超过25%的总体期望数量的pod。</p>


<p>在浏览器中打开URL，我们可以看到我们的应用程序的<code>v0.0.2</code>在Microk8s中运行:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-v0.0.2.png" class="zoom" data-title=""><img src="../Images/473d827b2311a0c53b9c8ffc256bd8f7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/microk8s-v0.0.2.png"/>T2】</a></p>

<p>这里触发了部署的首次展示，因为<code>set image</code>导致了对底层部署pod的<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/#pod-templates" rel="nofollow">模板</a>的更新。模板是描述<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/" rel="nofollow">复制控制器</a>创建实际pod的方式的规范文档。</p>

<p>通过运行<code>edit</code>，我们可以看到我们的应用程序的模板是什么样子的:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl edit deployment.v1.apps/rollingdeploy-microk8s
</code></pre>

<p>这将在文本编辑器中打开模板文件。对我来说，那是在终端本身。您可以交互编辑该文件。更改部署窗格的模板(<code>.spec.template</code>中的部分)将导致触发部署的首次展示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/kubectl-edit-deployment.png" class="zoom" data-title=""><img src="../Images/31ed00c9c18df68dc801936b94d8ec05.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/kubectl-edit-deployment.png"/>T2】</a></p>

<p><strong>提示:</strong> <br/>对部署的其他更新，如我们之前所做的缩放，不会导致部署被触发。</p>


<h4 id="kubernetes-deployment-rollback">Kubernetes部署回滚</h4>

<p>成功的滚动部署显然是我们所有人都希望的，但是不可避免的是，在某个时候，您需要启动回滚，要么是在部署过程的一部分，要么是在一段时间之后。</p>

<p>使用Kubernetes，默认情况下，所有部署的部署历史都保存在系统中。这意味着，您可以随时回滚。</p>

<p><strong>注意:</strong> <br/>可以更改为部署的首次部署存储的历史量(通过修改修订历史限制)，但通常不建议这样做，因为这会限制您回滚部署的能力。</p>


<p>为了查看我们部署的首次展示历史，我们运行<code>rollout history</code>命令:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl rollout history deployment.v1.apps/rollingdeploy-microk8s

deployment.apps/rollingdeploy-microk8s
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         kubectl set image deployment/rollingdeploy-microk8s rolling-deploy-web-example=octopusdeploy/rolling-deploy-web-example:0.0.2 --kubeconfig=/var/snap/microk8s/1107/credentials/client.config --record=true
</code></pre>

<p>我们可以选择通过运行<code>rollout undo</code>恢复到之前部署的<code>v0.0.1</code>版本:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl rollout undo deployment.v1.apps/rollingdeploy-microk8s

deployment.apps/rollingdeploy-microk8s rolled back
</code></pre>

<p><strong>提示:</strong></p>
<pre><code>markh@ubuntu01:~$ sudo microk8s.kubectl rollout undo deployment.v1.apps/rollingdeploy-microk8s --to-revision=1
</code></pre>
<p>其中<code>--to-revision</code>参数包含您希望返回的版本。</p>
<p>Kubernetes <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-em-undo-em-" class="alert-link" rel="nofollow">文档</a>中有您可以使用的参数的完整列表。</p>


<p>我们可以确认我们已经回滚，或者通过查看仪表板，在浏览器中查看应用程序，或者通过运行<code>describe</code>命令:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl describe deployment

Name:                   rollingdeploy-microk8s
Namespace:              default
CreationTimestamp:      Wed, 22 Jan 2020 13:19:30 +0000
Labels:                 app=rollingdeploy-microk8s
Annotations:            deployment.kubernetes.io/revision: 3
Selector:               app=rollingdeploy-microk8s
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=rollingdeploy-microk8s
  Containers:
   rolling-deploy-web-example:
    Image:        octopusdeploy/rolling-deploy-web-example:0.0.1
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   rollingdeploy-microk8s-794bdc64c4 (3/3 replicas created)
Events:
</code></pre>

<p>这表明<code>Image</code>被设置为<code>octopusdeploy/rolling-deploy-web-example:0.0.1</code>，正如我们所预期的。</p>

<p><strong>数据库回滚</strong> <br/>与Docker一样，重要的是要了解当您启动Kubernetes回滚时，您拥有的任何数据库将会发生什么。谷歌有一篇很棒的<a href="https://cloud.google.com/blog/products/databases/to-run-or-not-to-run-a-database-on-kubernetes-what-to-consider" class="alert-link" rel="nofollow">文章</a>更深入地讨论了在Kubernetes上运行数据库。</p>


<h4 id="kubernetes-deployment-clean-up">Kubernetes部署清理</h4>

<p>为了删除与我们的Kubernetes部署相关的所有资源，我们使用<code>delete</code>命令:</p>

<pre><code class="language-bash">markh@ubuntu01:~$ sudo microk8s.kubectl delete services,deployment rollingdeploy-microk8s -n default

service "rollingdeploy-microk8s" deleted
deployment.apps "rollingdeploy-microk8s" deleted
</code></pre>

<h4 id="kubernetes-summary">Kubernetes摘要</h4>

<p>与Docker相比，Kubernetes的滚动部署设置似乎要多一点，特别是在访问仪表板方面，但是在完成所有配置之后，它运行得非常好。</p>

<h3 id="rolling-deployments-with-octopus">使用Octopus进行滚动部署</h3>

<p>Octopus从Octopus 2.0 开始就支持滚动部署的概念。</p>

<p>通过使用子步骤，我们可以为Octopus中的<code>rolling-deploy-web-example</code>应用程序设置部署流程。</p>

<p>创建新项目后，我们通过三个步骤配置滚动部署:</p>

<ul>
<li>从负载平衡器中删除节点的脚本。</li>
<li>web应用程序的部署。</li>
<li>将节点添加回负载平衡器的脚本。</li>
</ul>

<p>为了在Octopus中实现增量发布，我们需要使我们的<strong>窗口大小</strong>低于部署目标的总数。在我的例子中，我将其设置为<code>1</code>，如下所示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/od-rolling-win-size.png" class="zoom" data-title=""><img src="../Images/d4366449e701db1bf5ae30571bc96a08.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/od-rolling-win-size.png"/>T2】</a></p>

<p>我有两个配置了<a href="https://octopus.com/docs/octopus-concepts/target-roles">目标角色</a> : <code>rolling-deploy-webapp</code>的部署目标。</p>

<p>当我将这个版本部署到<code>Test</code>环境时，Octopus一次部署到一个部署目标，正如我在前面的部署过程中配置的那样:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/od-0.0.1-test.png" class="zoom" data-title=""><img src="../Images/668254e32a67fb3355dc75e1390408e8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-01/ultimate-guide-to-rolling-deployments/od-0.0.1-test.png"/>T2】</a></p>

<p>这就是全部了！查看我们的<a href="https://octopus.com/docs/deployment-patterns/rolling-deployments">文档</a>以获得关于Octopus中滚动部署的完整参考。</p>

<p><strong>样本Octopus项目</strong> <br/>您可以在我们的<a href="https://g.octopushq.com/PatternRollingSampleAzureWebApp" class="alert-link" rel="nofollow">样本</a>实例中查看这个Octopus项目设置。</p>


<h2 id="a-word-on-databases">关于数据库的一句话</h2>

<p>通常滚动部署的主要症结之一是数据库。执行涉及某种持久存储的滚动部署可能很棘手，但并非不可能。魔鬼总是在细节中。</p>

<p>如果您希望执行包含数据库更改的滚动部署，我建议首先部署数据库。您还希望确保对数据库所做的任何更改都与您已部署的代码的以前版本向后兼容。</p>

<p>最后，经常测试你的回滚策略绝对是个好主意<em/>。</p>



<h2 id="conclusion">结论</h2>

<p>无论您使用哪种工具，滚动部署只是优化软件部署的一种模式。但是使用增量方法，它允许您保持应用程序在线，同时以受控的方式推出软件的新版本，通常具有对回滚的本机支持，这使它成为我最喜欢的最小化中断的方法。</p>

<p><strong> CI/CD管道指南</strong> <br/>如果您需要任何其他帮助来配置您的CI/CD管道，我们已经创建了<a href="https://octopus.com/docs/guides" class="alert-link"> Octopus指南</a>，其中包含为各种技术堆栈(包括Docker和Kubernetes)设置CI/CD管道的分步说明。</p>


<p>欢迎发表评论，让我们知道您对滚动部署的想法！</p>

                    
                    
</body>
</html>