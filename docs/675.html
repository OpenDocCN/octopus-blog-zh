<html>
<head>
<title>Selenium series: Reusing POM classes - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:重用POM类- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/24-reusing-pom-classes/reusing-pom-classes#2021-07-07">https://octopus.com/blog/selenium/24-reusing-pom-classes/reusing-pom-classes#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>既然我们已经使用POM设计模式重写了测试，那么让我们继续添加我们前面提到的第二个测试，验证不同部分的价格。</p>

<p>对于这个测试，我们需要进入结帐屏幕，但不是真正进行结帐。相反，我们希望遍历每个部分选项，并获得它们的票价。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/24-reusing-pom-classes/image1.png" class="zoom" data-title=""><img src="../Images/455caf6afd58a2a57605fe2a86227d62.png" class="img-fluid center" alt="C:\9c18ad03019ca85e0721a66947cd11ef" data-original-src="https://i.octopus.com/blog/2018-10/selenium/24-reusing-pom-classes/image1.png"/>T2】</a></p>

<p>为了支持这个新的测试，我们需要向<code>CheckoutPage</code>类添加一些额外的方法:</p>

<pre><code class="language-java">public class CheckoutPage extends BasePage {
  private static final Pattern TICKET_PRICE_REGEX = Pattern.compile("@ \\$(\\d+\\.\\d+)");
  private static final String ADULT_TICKET_PRICE = ".input-group-addon";

  // ...

  public CheckoutPage selectSection(final String section) {
      automatedBrowser.selectOptionByTextFromSelect(section, SECTION_DROP_DOWN_LIST, WAIT_TIME);
      return this;
  }

  public float getSectionAdultPrices() {
      final String price = automatedBrowser.getTextFromElement(ADULT_TICKET_PRICE);
      return getPriceFromTicketPriceString(price);
  }

  // ...

  private float getPriceFromTicketPriceString(final String input) {
    final Matcher matcher = TICKET_PRICE_REGEX.matcher(input);
    if (matcher.matches()) {
      final String priceString = matcher.group(1);
      return Float.parseFloat(priceString);
    }

    throw new IllegalArgumentException("String " + input + " does not match the regex");
  }
}
</code></pre>

<p>首先，我们定义一个正则表达式<code>Pattern</code>，它匹配应用程序显示的价格字符串。价格显示为类似于<code>@ $219.5</code>、<code>@ $149.5</code>的字符串(末尾缺少的零可能是Ticketmonster中的一个错误，但我们现在忽略它)。我们希望将美元金额从at和美元符号中分离出来，因此我们将字符串的这一部分捕获到一个组中:</p>

<pre><code class="language-java">private static final Pattern TICKET_PRICE_REGEX = Pattern.compile("@ \\$(\\d+\\.\\d+)");
</code></pre>

<p>新方法<code>selectSection()</code>允许我们从下拉列表中选择一个事件部分。这将更新显示票价的元素:</p>

<pre><code class="language-java">public CheckoutPage selectSection(final String section) {
  automatedBrowser.selectOptionByTextFromSelect(section, SECTION_DROP_DOWN_LIST, WAIT_TIME);
  return this;
}
</code></pre>

<p>新的<code>getSectionAdultPrices()</code>方法首先从显示价格的元素中获取原始文本。这个原始文本看起来像是<code>@ $219.5</code>或<code>@ $149.5</code>。</p>

<p>然后，它将该文本传递给方法<code>getPriceFromTicketPriceString()</code>，该方法将它转换成一个<code>float</code>值:</p>

<pre><code class="language-java">public float getSectionAdultPrices() {
  final String price = automatedBrowser.getTextFromElement(ADULT_TICKET_PRICE);
  return getPriceFromTicketPriceString(price);
}
</code></pre>

<p>最后添加的是<code>getPriceFromTicketPriceString()</code>方法。这个方法的存在是为了支持<code>getSectionAdultPrices()</code>方法，所以它是<code>private</code>。</p>

<p>在这个方法中，我们试图将输入与之前定义的正则表达式<code>Pattern</code>进行匹配。如果匹配成功，我们提取组1，它将包含类似于<code>219.5</code>或<code>149.5</code>的字符串。这些字符串然后被转换成<code>float</code>值并返回。</p>

<p>如果输入与正则表达式不匹配，则会引发异常:</p>

<pre><code class="language-java">  private float getPriceFromTicketPriceString(String input) {
    final Matcher matcher = TICKET_PRICE_REGEX.matcher(input);
    if (matcher.matches()) {
      final String priceString = matcher.group(1);
      return Float.parseFloat(priceString);
  }

  throw new IllegalArgumentException("String " + input + " does not match the regex");
}
</code></pre>

<p>有了对<code>CheckoutPage</code>的这些更改，我们现在可以编写测试了:</p>

<pre><code class="language-java">@Test
public void verifyPricesPageObjectModel() {

  final AutomatedBrowser automatedBrowser =
    AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("ChromeNoImplicitWait");

  try {
    automatedBrowser.init();

    final EventsPage eventsPage = new MainPage(automatedBrowser)
      .openPage()
      .buyTickets();

    final VenuePage venuePage = eventsPage
      .selectEvent("Theatre", "Shane's Sock Puppets");

    final CheckoutPage checkoutPage = venuePage
      .selectVenue("Toronto : Roy Thomson Hall")
      .book();

    checkoutPage.selectSection("A - Premier platinum reserve");

    final float platinumAdultPrices = checkoutPage.getSectionAdultPrices();
    Assert.assertTrue(platinumAdultPrices &gt; 10);
    Assert.assertTrue(platinumAdultPrices &lt; 1000);

    checkoutPage.selectSection("B - Premier gold reserve");

    final float goldAdultPrices = checkoutPage.getSectionAdultPrices();
    Assert.assertTrue(goldAdultPrices &gt; 10);
    Assert.assertTrue(goldAdultPrices &lt; 1000);

    checkoutPage.selectSection("C - Premier silver reserve");

    final float silverAdultPrices = checkoutPage.getSectionAdultPrices();
    Assert.assertTrue(silverAdultPrices &gt; 10);
    Assert.assertTrue(silverAdultPrices &lt; 1000);

    checkoutPage.selectSection("D - General");

    final float generalAdultPrices = checkoutPage.getSectionAdultPrices();
    Assert.assertTrue(generalAdultPrices &gt; 10);
    Assert.assertTrue(generalAdultPrices &lt; 1000);
  } finally {
    automatedBrowser.destroy();
  }
}
</code></pre>

<p>为了让web应用程序能够找到票价，我们重用了<code>MainPage</code>、<code>EventsPage</code>和<code>VenuePage</code> POM类。这里的代码与之前的测试几乎相同，但是在这个例子中，我们选择了一个不同的事件，称为<code>Shane's Sock Puppets</code>:</p>

<pre><code class="language-java">@Test
public void verifyPricesPageObjectModel() {
final AutomatedBrowser automatedBrowser =
  AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("ChromeNoImplicitWait");

try {

  automatedBrowser.init();

  final EventsPage eventsPage = new MainPage(automatedBrowser)
    .openPage()
    .buyTickets();

  final VenuePage venuePage = eventsPage
    .selectEvent("Theatre", "Shane's Sock Puppets");

  final CheckoutPage checkoutPage = venuePage
    .selectVenue("Toronto : Roy Thomson Hall")
    .book();
</code></pre>

<p>现在，我们开始骑自行车通过部分，以获得他们的票价。</p>

<p>我们调用<code>selectSection()</code>来改变当前选择的部分。对<code>getSectionAdultPrices()</code>的调用然后获得显示的票价作为<code>float</code>。然后，两条<code>Assert</code>语句验证价格在下限和上限之间:</p>

<pre><code class="language-java">checkoutPage.selectSection("A - Premier platinum reserve");

final float platinumAdultPrices = checkoutPage.getSectionAdultPrices();

Assert.assertTrue(platinumAdultPrices &gt; 10);
Assert.assertTrue(platinumAdultPrices &lt; 1000);
</code></pre>

<p>对其他3个部分重复这些检查:</p>

<pre><code class="language-java">checkoutPage.selectSection("B - Premier gold reserve");

final float goldAdultPrices = checkoutPage.getSectionAdultPrices();

Assert.assertTrue(goldAdultPrices &gt; 10);
Assert.assertTrue(goldAdultPrices &lt; 1000);

checkoutPage.selectSection("C - Premier silver reserve");

final float silverAdultPrices = checkoutPage.getSectionAdultPrices();

Assert.assertTrue(silverAdultPrices &gt; 10);
Assert.assertTrue(silverAdultPrices &lt; 1000);

checkoutPage.selectSection("D - General");

final float generalAdultPrices = checkoutPage.getSectionAdultPrices();

Assert.assertTrue(generalAdultPrices &gt; 10);
Assert.assertTrue(generalAdultPrices &lt; 1000);
</code></pre>

<p>然后，我们完成了清理<code>finally</code>块中的资源的测试:</p>

<pre><code class="language-java">  } finally {
    automatedBrowser.destroy();
    }
}
</code></pre>

<p>我们用POM类<code>MainPage</code>、<code>EventsPage</code>和<code>VenuePage</code>创建的公共API使得编写这个测试变得快速而简单。让web应用程序显示票价所需的大部分逻辑已经实现，只剩下一些新方法要添加到<code>CheckoutPage</code>类中。</p>

<p>这就是POM设计模式的强大之处。它将实现细节封装到Java对象中，让测试自由地描述他们在测试什么，而不是如何测试。如果TicketMonster将来要更新新的元素id、名称属性或重新排列的屏幕，我们有一个集中的重用API，可以在那里进行更新，而不是通过复制和粘贴代码进行多次测试。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>