<html>
<head>
<title>Deploying a JavaScript library project with Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Octopus - Octopus Deploy部署JavaScript库项目</h1>
<blockquote>原文：<a href="https://octopus.com/blog/deploying-javascript-library-project-with-octopus#2021-12-16">https://octopus.com/blog/deploying-javascript-library-project-with-octopus#2021-12-16</a></blockquote>
                        <p>有一种常见的前端开发模式，它以最好的意图开始，但如果不小心处理，可能会导致痛苦。您看到了跨多个项目重用前端代码的需要，这些项目由使用不同技术的不同团队维护。您创建一个共享的JavaScript库项目，它有自己的repo和release过程。这是一个明智的想法，但提出了一些需要好答案的问题，以阻止我们的快乐成长为一个怪物。</p>

<p>在这篇文章中，我解释了如何管理一个共享JavaScript项目的部署过程，这个项目很容易从其他Octopus项目中引用。我的例子使用了部署到亚马逊S3的Vue JS包，但是同样的原则可以应用到前端框架和托管提供商的任何组合。</p>

<h2 id="the-process">该过程</h2>

<p>我们在Octopus中完成的部署过程如下所示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/aws_bundle_process.png" class="zoom" data-title=""><img src="../Images/bd111d776a4abc0d9cf7d1c7c488a684.png" class="img-fluid center" alt="four step finished deployment process in Octopus" data-original-src="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/aws_bundle_process.png"/>T2】</a></p>

<p>我解释了每一步的原因以及它们是如何工作的。</p>

<h2 id="creating-an-s3-bucket-if-it-doesnt-exist">如果S3存储桶不存在，则创建一个</h2>

<p>本着把服务器当成牛而不是宠物的精神，除了拥有一个具有适当权限的AWS帐户之外，我对我们的部署目标不做太多假设。在一个具体的例子中，我有专门的存储桶用于区域和测试、阶段和生产环境的组合，所以我喜欢这样一个构建过程，它只需要我在限定了作用域的变量中命名存储桶和区域，并在需要时正确地设置它。这是通过运行以下PowerShell脚本的<a href="https://octopus.com/docs/deployments/custom-scripts/aws-cli-scripts"> AWS CLI步骤</a>实现的，该脚本使用AWS CLI来查看您在尝试列出bucket的内容时是否获得了非错误结果。否则，它会创建bucket，然后在步骤完成之前轮询以确认bucket是否存在。</p>

<pre><code class="language-ps">$bucket = $OctopusParameters["s3-bucket-name"]
$region = $OctopusParameters["s3-region"]
$found = aws s3 ls s3://$bucket/ --recursive --summarize | Select-String -Pattern 'Total Objects:'
if ([string]::IsNullOrWhiteSpace($found)) {
    aws s3api create-bucket --bucket $bucket --region $region
    aws s3api wait bucket-exists --bucket $bucket
}
</code></pre>

<h2 id="setting-s3-cors-policy">制定S3 CORS政策</h2>

<p>这是另一个AWS CLI脚本，内嵌以下PowerShell:</p>

<pre><code class="language-ps">echo '{"CORSRules": [ { "AllowedOrigins": ["*"], "AllowedHeaders": [],"AllowedMethods": ["GET"] } ] }' | out-file -encoding ASCII cors.json
aws s3api put-bucket-cors --bucket bundle-s3 --cors-configuration file://cors.json
</code></pre>

<p>您可以根据需要更复杂地使用CORS，但是在我的例子中，我假设我们的包存在于它们自己的专用桶中，所以简单的<code>allow all GET requests</code>是有意义的。</p>

<p>编码步骤很重要，而不是直接回显到文件。我不确定为什么设置CORS的<a href="https://docs.aws.amazon.com/cli/latest/reference/s3api/put-bucket-cors.html" rel="nofollow"> CLI命令</a>坚持从文件中读取，并且不让你通过命令行传递JSON。如果您需要更复杂的CORS策略，那么选择包中的<strong>脚本文件，并在您的bundle repo中控制. ps1和cors.json文件的源代码，这比我在这里使用的内联选项更干净。</strong></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/cors_script.png" class="zoom" data-title=""><img src="../Images/f1cd01868c4da0dd81de1222e2aff2df.png" class="img-fluid center" alt="script options" data-original-src="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/cors_script.png"/>T2】</a></p>

<h2 id="uploading-bundle-to-s3">将包上传到S3</h2>

<p>下一个<strong> AWS CLI步骤</strong>有几个先决条件，在展示如何在Octopus中设置之前我会解释一下。我演示了它是如何在Vue中实现的。对于其他框架，步骤会有所不同，但是解释会为您指出正确的方向。</p>

<h3 id="one-javascript-file-to-rule-them-all">一个JavaScript文件来管理它们</h3>

<p>默认情况下，Vue会创建一个单独的CSS文件、一个生产源映射文件和一个供应商库文件。这是webpack执行的一个优化，用于更好地缓存不经常改变的公共依赖项。</p>

<p>这些都是合理的默认设置，但是对于一个不太大的共享JS包，您可以从允许消费者引用一个JS文件开始，以获得所有的样式和行为。如果需要，您可以在以后引入对优化、源映射和外部CSS的支持。</p>

<p>要指示vue只构建一个JavaScript文件，您可以将以下vue.config.js添加到Vue项目的根目录下，紧挨着package.json:</p>

<pre><code class="language-js"> module.exports = {
  configureWebpack: {
    optimization: {
      splitChunks: false
    }
  },
  css: {
    extract: false,
  },
  productionSourceMap: false
}
</code></pre>

<h3 id="a-separate-config.json-file">单独的config.json文件</h3>

<p><a href="https://octopus.com/docs/projects/variables/variable-substitutions">章鱼变量替换</a>功能强大。为了在您的前端项目中利用它们，您需要告诉Octopus我们的包旁边有一个config.json文件。</p>

<p>为了让Vue CLI将文件包含在其dist文件夹中，该文件夹将被压缩以创建发送到Octopus的包，您需要在Vue启动新项目时生成的public文件夹中创建<code>js\config.json</code>。</p>

<p>这与针对<a href="https://octopus.com/blog/javascript-configuration"> React和Angular </a>显示的配置示例类似，只是在完整部署流程的环境中针对Vue实施。</p>

<p>现在，您需要运行以下命令:</p>

<pre><code class="language-console">npm run build      
</code></pre>

<p>您可以看到Vue已经将config.json作为一个单独的文件复制到输出文件夹中。要告诉Vue使用它，创建以下助手模块:</p>

<pre><code class="language-js">const configUrl = document.currentScript.src.substring(0, document.currentScript.src.lastIndexOf('/')) + '/config.json'

module.exports = async function() {
    const response = await fetch(configUrl);
    return await response.json();
};
</code></pre>

<p>现在，当您调用这个函数时，这个包将获取它部署到的S3文件夹中的相邻config.json。</p>

<p>下面是如何在Vue组件中使用它:</p>

<pre><code class="language-html">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;img alt="Vue logo" :src="`${config.bucketUrl}/assets/logo.png`"&gt;
    &lt;HelloWorld msg="Welcome to Your Vue.js App"/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import HelloWorld from './components/HelloWorld.vue'
import getConfig from './config.js'

export default {
  name: 'App',
  components: {
    HelloWorld
  },
  data() {
    return { config: { } }
  },
  async created () {
    this.config = await getConfig();
  },
}
&lt;/script&gt;
</code></pre>

<p>您需要给任何图像或其他外部资产的引用一个基本URL，类似于<strong> bucketUrl </strong>设置。这是因为Vue默认产生的相对路径对S3资产的消费者不起作用。</p>


<p>要告诉Octopus替换config.json文件中的变量，点击<strong>配置特性</strong>，勾选<strong>结构化配置变量</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/config_variables.png" class="zoom" data-title=""><img src="../Images/8fa5bb2c058241428996f710aebc1261.png" class="img-fluid center" alt="config variables" data-original-src="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/config_variables.png"/>T2】</a></p>

<p>告诉Octopus替换<code>MyBundle\js\config.json</code>中的变量，其中<code>MyBundle</code>是您的包的ID。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/config_variables_2.png" class="zoom" data-title=""><img src="../Images/fd1ebd26bee309775c32f8825baf3881.png" class="img-fluid center" alt="config variables 2" data-original-src="https://i.octopus.com/blog/2021-10/deploying-javascript-library-project-with-octopus/config_variables_2.png"/>T2】</a></p>

<h3 id="uploading-your-bundle">上传您的包</h3>

<p>最后，向步骤提供CLI命令，将您的包、config.json和资产上传到以当前版本命名的文件夹中。</p>

<pre><code class="language-ps">aws s3 cp MyBundle s3://#{s3-bucket-name}/release_#{Octopus.Release.Number} --recursive --exclude index.html --acl public-read
</code></pre>

<p>我跳过上传Vue CLI生成的index.html文件，因为您的捆绑包的传统消费者不能使用该index.html，而是需要唯一命名的捆绑包文件的URL。</p>

<p>下一步也是最后一步的重点是向任何需要的项目提供环境的最新包的URL。</p>

<h2 id="updating-the-bundle-url-in-a-variable-set">更新变量集中的包URL</h2>

<p>能够通过自动填充的配置设置告诉其他项目从哪里获得缓存不足的共享包是为这种类型的JavaScript项目构建Octopus流程的一个优势。</p>

<p>破坏缓存的策略多得惊人，根据我的经验，很多都会带来痛苦。对我来说，这种痛苦要么源于消费者对捆绑过程了解太多，要么源于捆绑商对消费者了解太多。理想情况下，任何使用该包的项目只读取带有该包URL的配置设置。幸运的是，Octopus让您在部署时无需太多定制代码就能实现这一点。</p>

<p>部署之后，这个定制脚本步骤更新了其他项目可以引用的<a href="https://octopus.com/docs/projects/variables/library-variable-sets">库变量集</a>中作用域<code>BundleUrl</code>变量的包URL。要做到这一点，参考章鱼。客户端在我们的文档中的<a href="https://octopus.com/docs/octopus-rest-api/octopus.client/using-client-in-octopus">步骤中获取包。</a></p>

<p>该步骤还需要对您部署的包的引用，以找到您上传的JavaScript文件的名称。然后，它可以运行以下PowerShell:</p>

<pre><code class="language-ps">Add-Type -Path 'Octopus.Client/lib/net452/Octopus.Client.dll'

$bundle = Get-ChildItem -Path MyBundle/js/*.js | Select-Object -First 1

$endpoint = new-object Octopus.Client.OctopusServerEndpoint $octopusURI,$octopusApiKey
$repository = new-object Octopus.Client.OctopusRepository $endpoint

$scope = New-Object Octopus.Client.Model.ScopeSpecification
$enviornmentName = $OctopusParameters["Octopus.Environment.Name"]
$envID = $repository.Environments.FindByName($enviornmentName).Id
$scope.Add([Octopus.Client.Model.Scopefield]::Environment,(New-Object Octopus.Client.Model.ScopeValue($envID)))

$libraryVariableSetId = $repository.LibraryVariableSets.FindByName('BundleVariables').Id
$libraryVariableSet = $repository.LibraryVariableSets.Get($libraryVariableSetId);
$variables = $repository.VariableSets.Get($libraryVariableSet.VariableSetId);
$releaseId = $OctopusParameters["Octopus.Release.Number"]
$variables.AddOrUpdateVariableValue("BundleUrl", $bucketUrl + 'release_' + $releaseId + '/js/' + $bundle.Name,$scope)
$repository.VariableSets.Modify($variables)
</code></pre>

<p>就是这样！现在，任何数量的其他项目都可以通过包含<code>BundleVariables</code>库变量集来引用您的共享JavaScript包，并且可以使用<code>BundleUrl</code>变量。</p>

<h2 id="conclusion">结论</h2>

<p>这篇文章解释了如何应用限定了作用域的变量、作为牲口的服务器和变量集的概念来实现对共享JavaScript项目的合理管理。</p>

<p>与管理JavaScript项目的其他解决方案相比，我在生产中遵循这一策略取得了良好的结果。我确实发现自己向前端专家解释说，他们需要重新发布消费者项目，以使它自己升级到软件包的最新版本，但在人们掌握了它之后，这是合乎逻辑的。我的团队中的前端专家对这个部署过程模式的工作方式给了我很好的反馈。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>