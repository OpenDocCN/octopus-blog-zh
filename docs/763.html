<html>
<head>
<title>The ultimate guide to Tomcat deployments - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Tomcat部署的最终指南- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/ultimate-guide-to-tomcat-deployments#2021-08-12">https://octopus.com/blog/ultimate-guide-to-tomcat-deployments#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/blogimage-tomcatcontainer.png" class="zoom" data-title=""><img src="../Images/bea3d31fa0f2cce5ac960d3dd5cf5e9f.png" class="img-fluid center" alt="The ultimate guide to Tomcat deployments" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/blogimage-tomcatcontainer.png"/>T2】</a></p>

<p>持续集成和交付(CI/CD)是DevOps团队降低成本和增加软件团队敏捷性的共同目标。但是CI/CD管道不仅仅是测试、编译和部署应用程序。强大的CI/CD渠道解决了许多问题，例如:</p>

<ul>
<li>高可用性(HA)</li>
<li>多重环境</li>
<li>零停机部署</li>
<li>数据库迁移</li>
<li>负载平衡器</li>
<li>HTTPS和证书管理</li>
<li>功能分支部署</li>
<li>烟雾测试</li>
<li>回滚策略</li>
</ul>

<p>如何实现这些目标取决于所部署的软件类型。在本文中，我将介绍如何通过将Java应用程序部署到Tomcat来创建CI/CD管道的持续交付(或部署)部分。然后，我构建了一个支持性的基础设施栈，其中包括用于负载平衡的Apache web服务器、用于数据库的PostgreSQL、用于高可用性负载平衡器的Keepalived和用于协调部署的Octopus。</p>

<h2 id="a-note-on-the-postgresql-server">关于PostgreSQL服务器的说明</h2>

<p>本文假设PostgreSQL数据库已经部署在高可用性配置中。有关如何部署PostgreSQL的更多信息，请参考<a href="https://www.postgresql.org/docs/current/high-availability.html" rel="nofollow">文档</a>。</p>

<p>本文中的说明可用于单个PostgreSQL实例，理解数据库代表单点故障。</p>

<h2 id="how-to-implement-ha-in-tomcat">如何在Tomcat中实现HA</h2>

<p>当谈到HA时，重要的是要准确理解需要管理平台的哪些组件来解决单个Tomcat实例的不可用性，例如，当一个实例由于日常维护或硬件故障而不可用时。</p>

<p>出于本文的目的，我创建了一个基础设施，允许传统的有状态Java servlet应用程序在单个Tomcat服务器不再可用时继续运行。实际上，这意味着当最初托管会话的服务器不再可用时，应用程序会话状态将持续存在并被分发到集群中的其他Tomcat实例。</p>

<p>简单回顾一下，Java servlet应用程序可以根据一个<code>HttpSession</code>实例保存数据，然后可以跨请求使用。在下面的(天真的，因为它不处理竞争条件)例子中，我们有一个简单的计数器变量，它随着对页面的每个请求而递增。这演示了如何在web浏览器发出的单个请求中保存信息:</p>

<pre><code class="language-Java">@RequestMapping("/pageCount")
public String index(final HttpSession httpSession) {
    httpSession.setAttribute("pageCount", ObjectUtils.defaultIfNull((Integer)httpSession.getAttribute("pageCount"), 0) + 1);
    return (Integer)httpSession.getAttribute("pageCount");
}
</code></pre>

<p>会话状态保存在单个服务器的内存中。默认情况下，如果该服务器不再可用，会话数据也会丢失。对于像页面计数这样的小例子来说，这并不重要，但是对于更关键的功能来说，依赖于会话状态的情况并不少见。例如，购物车可能在会话状态中保存了要购买的商品列表，丢失该信息可能会导致销售失败。</p>

<p>为了保持高可用性，需要复制会话状态，以便在服务器脱机时可以共享。</p>

<p>Tomcat提供了三种实现会话复制的解决方案:</p>

<ol>
<li>使用会话持久性并将会话保存到共享文件系统(PersistenceManager + FileStore)。</li>
<li>使用会话持久性并将会话保存到共享数据库(PersistenceManager + JDBCStore)。</li>
<li>使用内存复制，并使用Tomcat附带的SimpleTcpCluster(<code>lib/catalina-tribes.jar</code>+<code>lib/catalina-ha.jar</code>)。</li>
</ol>

<p>因为我们的基础设施堆栈已经假设了一个高度可用的数据库，所以我将实现选项二。对我们来说，这可能是最简单的解决方案，因为我们不需要实现任何特殊的网络，并且我们可以重用现有的数据库。但是，这种解决方案确实会在会话状态被修改和被保存到数据库之间引入延迟。这种延迟会产生一个窗口，在此期间，如果硬件或网络出现故障，数据可能会丢失。尽管支持计划的维护任务，因为当Tomcat关闭时，任何会话数据都将被写入数据库，这允许我们安全地修补操作系统或更新Tomcat本身。</p>

<p>我们注意到上面的示例代码很简单，因为它没有处理会话缓存不是线程安全的事实。即使是这个简单的例子也会受到可能导致页面计数不正确的竞争条件的影响。这个问题的解决方案是使用Java中可用的传统线程锁和同步特性，但是这些特性只在单个JVM中有效。这意味着我们必须确保客户端请求总是指向单个Tomcat实例，这又意味着只有一个Tomcat实例包含会话状态的单个权威副本，这可以通过线程锁和同步来确保一致性。这是通过粘性会话实现的。</p>

<p>粘性会话提供了一种方法，让负载平衡器检查客户端请求，然后将其定向到集群中的一个web服务器。默认情况下，在Java servlet应用程序中，客户端由web浏览器发送的<code>JSESSIONID</code> cookie来标识，负载平衡器检查该cookie以标识持有会话的Tomcat实例，然后Tomcat服务器将请求与现有会话相关联。</p>

<p>总之，我们的HA Tomcat解决方案:</p>

<ul>
<li>将会话状态保存到共享数据库中。</li>
<li>依靠粘性会话将客户端请求定向到单个Tomcat实例。</li>
<li>当Tomcat关闭时，通过保持会话状态来支持日常维护。</li>
<li>有一个小窗口，在此期间，硬件或网络故障可能会导致数据丢失。</li>
</ul>

<h2 id="keepalived-for-ha-load-balancers">为HA负载平衡器保持活动状态</h2>

<p>为了确保网络请求分布在多个Tomcat实例中，而不是指向一个脱机实例，我们需要实现一个负载平衡解决方案。这些负载平衡器位于Tomcat实例的前面，将网络请求导向那些可用的实例。</p>

<p>有许多负载平衡解决方案可以完成这个任务，但是在这篇文章中，我们使用带有mod_jk插件的Apache web服务器。Apache将提供网络功能，而mod_jk将把流量分配给多个Tomcat实例，实现粘性会话，为每个请求将客户机定向到同一个后端服务器。</p>

<p>为了保持高可用性，我们至少需要两个负载平衡器。但是，我们如何以一种可靠的方式在两个负载平衡器之间分割一个单一的传入网络连接呢？这就是Keepalived的用武之地。</p>

<p>Keepalived是一个跨多个实例运行的Linux服务，它从健康实例池中挑选一个主实例。在确定主实例做什么时，Keepalived非常灵活，但是在我们的场景中，我们将使用Keepalived为承担主角色的实例分配一个虚拟的浮动IP地址。这意味着我们的传入网络流量将被发送到一个分配给健康负载平衡器的浮动IP地址，然后负载平衡器将流量转发给Tomcat实例。如果其中一个负载平衡器脱机，Keepalived将确保为剩余的负载平衡器分配浮动IP地址。</p>

<p>总之，我们的高可用性负载平衡解决方案:</p>

<ul>
<li>使用mod_jk插件实现Apache，将流量定向到Tomcat实例。</li>
<li>实施Keepalived以确保一个负载平衡器分配有虚拟IP地址。</li>
</ul>

<h2 id="the-network-diagram">网络图</h2>

<p>这是我们将要创建的网络图:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/network_diagram.png" class="zoom" data-title=""><img src="../Images/f50944100097bae74d718f48987502ca.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/network_diagram.png"/>T2】</a></p>

<h2 id="zero-downtime-deployments-and-rollbacks">零停机部署和回滚</h2>

<p>持续交付的一个目标是始终处于可以部署的状态(即使您选择不部署)。这意味着放弃要求人们在午夜醒来，在客户睡觉时执行部署的计划。</p>

<p>零停机部署要求达到可以随时无中断完成部署的程度。在我们的示例基础架构中，为了实现零停机部署，我们需要考虑两点:</p>

<ul>
<li>客户能够使用现有版本的应用程序来完成他们的会话，即使在部署了新版本的应用程序之后。</li>
<li>任何数据库更改的向前和向后兼容性。</li>
</ul>

<p>在推出新的应用程序版本时，确保数据库更改向后和向前兼容需要一些设计工作和规则。幸运的是，有可用的工具，包括<a href="https://flywaydb.org/" rel="nofollow"> Flyway </a>和<a href="https://www.liquibase.org/" rel="nofollow"> Liquidbase </a>，它们提供了一种通过应用程序本身推出数据库更改的方法，负责对更改进行版本控制，并在所需的事务中包装任何迁移。我们将在本文后面的示例应用程序中看到Flyway的实现。</p>

<p>只要共享数据库在应用程序的当前版本和新版本之间保持兼容，Tomcat就会提供一个名为<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/context.html#Parallel_deployment" rel="nofollow">并行部署</a>的特性，允许客户端继续访问应用程序的先前版本，直到它们的会话到期，同时针对应用程序的新版本创建新的会话。并行部署允许在不中断任何现有客户端的情况下部署新版本的应用程序。</p>

<p>Tomcat能够自动清理不再有任何会话的旧版本。但是我们不会启用这个特性，因为它可能会阻止旧版本的会话迁移到另一个Tomcat实例。</p>


<p>确保数据库更改在应用程序的当前版本和新版本之间兼容，意味着我们可以轻松回滚应用程序部署。如果新版本引入了任何错误，重新部署应用程序的先前版本可以提供快速的后备。</p>

<p>总之，我们的零停机部署解决方案:</p>

<ul>
<li>依赖于向前和向后兼容的数据库更改(至少在应用程序的新版本和当前版本之间)。</li>
<li>使用并行部署来允许现有会话不间断地完成。</li>
<li>通过恢复到以前安装的应用程序版本来提供应用程序回滚。</li>
</ul>

<h2 id="build-the-infrastructure">建设基础设施</h2>

<p>此处显示的示例基础架构部署在Ubuntu 18.04虚拟机上。尽管一些包名和文件位置可能会改变，但大多数指令都与发行版无关。</p>

<h3 id="configure-the-tomcat-instances">配置Tomcat实例</h3>

<h4 id="install-the-packages">安装软件包</h4>

<p>我们从安装Tomcat和管理器应用程序开始:</p>

<pre><code>apt-get install tomcat tomcat-admin
</code></pre>

<h4 id="add-the-ajp-connector">添加AJP连接器</h4>

<p>Apache web服务器和Tomcat之间的通信是通过AJP连接器执行的。AJP是一个优化的二进制HTTP协议，Apache和Tomcat的mod_jk插件都理解它。连接器被添加到<code>/etc/tomcat9/server.xml</code>文件中的<code>Service</code>元素:</p>

<pre><code class="language-xml">&lt;Server&gt;
  &lt;!-- ... --&gt;
  &lt;Service name="Catalina"&gt;
    &lt;!-- ... --&gt;
    &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443"&gt;&lt;/Connector&gt;
  &lt;/Service&gt;
&lt;/Server&gt;
</code></pre>

<h4 id="define-the-tomcat-instance-names">定义Tomcat实例名</h4>

<p>每个Tomcat实例都需要在<code>/etc/tomcat9/server.xml</code>文件的<code>Engine</code>元素中添加一个惟一的名称。默认的<code>Engine</code>元素如下所示:</p>

<pre><code class="language-xml">&lt;Engine name="Catalina" defaultHost="localhost"&gt;
</code></pre>

<p>Tomcat实例的名称在<code>jvmRoute</code>属性中定义。我将调用第一个Tomcat实例<code>worker1</code>:</p>

<pre><code class="language-xml">&lt;Engine defaultHost="localhost" name="Catalina" jvmRoute="worker1"&gt;
</code></pre>

<p>第二个Tomcat实例被称为<code>worker2</code>:</p>

<pre><code class="language-xml">&lt;Engine defaultHost="localhost" name="Catalina" jvmRoute="worker2"&gt;
</code></pre>

<h4 id="add-a-manager-user">添加经理用户</h4>

<p>Octopus通过管理器应用程序向Tomcat执行部署。这是我们之前用<code>tomcat-admin</code>包安装的。</p>

<p>为了对管理应用程序进行认证，需要在<code>/etc/tomcat9/tomcat-users.xml</code>文件中定义一个新用户。我将用密码<code>Password01!</code>调用这个用户<code>tomcat</code>，它将属于<code>manager-script</code>和<code>manager-gui</code>角色。</p>

<p><code>manager-script</code>角色授予对管理器API的访问权限，而<code>manager-gui</code>角色授予对管理器web控制台的访问权限。</p>

<p>这里是用户定义的<code>tomcat</code>文件的副本:</p>

<pre><code class="language-xml">&lt;tomcat-users 
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd"
              version="1.0"&gt;
  &lt;role rolename="manager-gui"/&gt;
  &lt;role rolename="manager-script"/&gt;
  &lt;user username="tomcat" password="Password01!" roles="manager-script,manager-gui"/&gt;
&lt;/tomcat-users&gt;
</code></pre>

<h4 id="add-the-postgresql-jdbc-driver-jar">添加PostgreSQL JDBC驱动程序jar</h4>

<p>每个Tomcat实例将与PostgreSQL数据库通信，以持久化会话数据。为了让Tomcat与PostgreSQL数据库通信，我们需要安装PostgreSQL JDBC驱动程序JAR文件。这是通过将文件<code>https://jdbc.postgresql.org/download/postgresql-42.2.11.jar</code>保存为<code>/var/lib/tomcat9/lib/postgresql-42.2.11.jar</code>来完成的。</p>

<h4 id="enable-session-replication">启用会话复制</h4>

<p>为了支持数据库的会话持久性，我们在文件<code>/etc/tomcat9/context.xml</code>中添加了一个新的<code>Manager</code>定义。这个管理器使用<code>org.apache.catalina.session.PersistentManager</code>将会话细节保存到嵌套的<code>Store</code>元素中定义的数据库中。</p>

<p>元素反过来定义了会话信息将被保存到的数据库。</p>

<p>我们还需要添加一个装载<code>org.apache.catalina.ha.session.JvmRouteBinderValve</code>类的<code>Valve</code>。当客户机从一个Tomcat实例重定向到集群中的另一个Tomcat实例时，这个阀门非常重要。在部署我们的示例应用程序后，我们将看到这个阀门的运行。</p>

<p>这里是定义了<code>Manager</code>、<code>Store</code>和<code>Valve</code>元素的<code>/etc/tomcat9/context.xml</code>文件的副本:</p>

<pre><code class="language-xml">&lt;Context&gt;
  &lt;Manager
    className="org.apache.catalina.session.PersistentManager"
    processExpiresFrequency="3"
    maxIdleBackup="1" &gt;
      &lt;Store
        className="org.apache.catalina.session.JDBCStore"
        driverName="org.postgresql.Driver"
        connectionURL="jdbc:postgresql://postgresserver:5432/tomcat?currentSchema=session"
        connectionName="postgres"
        connectionPassword="passwordgoeshere"
        sessionAppCol="app_name"
        sessionDataCol="session_data"
        sessionIdCol="session_id"
        sessionLastAccessedCol="last_access"
        sessionMaxInactiveCol="max_inactive"
        sessionTable="session.tomcat_sessions"
        sessionValidCol="valid_session" /&gt;
  &lt;/Manager&gt;
  &lt;Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/&gt;
  &lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;
  &lt;WatchedResource&gt;WEB-INF/tomcat-web.xml&lt;/WatchedResource&gt;
  &lt;WatchedResource&gt;${catalina.base}/conf/web.xml&lt;/WatchedResource&gt;
&lt;/Context&gt;
</code></pre>

<h3 id="configure-the-postgresql-database">配置PostgreSQL数据库</h3>

<h4 id="install-the-packages-1">安装软件包</h4>

<p>我们需要用新的数据库、模式和表来初始化PostgreSQL。为此，我们使用<code>psql</code>命令行工具，该工具随以下软件一起安装:</p>

<pre><code>apt-get install postgresql-client
</code></pre>

<h4 id="add-the-database-schema-and-table">添加数据库、模式和表</h4>

<p>如果您查看上面定义的<code>/etc/tomcat9/context.xml</code>文件中的<code>connectionURL</code>属性，您会看到我们正在将会话信息保存到:</p>

<ul>
<li>这个数据库叫做<code>tomcat</code>。</li>
<li>这个模式叫做<code>session</code>。</li>
<li>一个叫<code>tomcat_sessions</code>的桌子。</li>
</ul>

<p>为了在PostgreSQL服务器中创建这些资源，我们运行了许多SQL命令。</p>

<p>首先，将以下文本保存到一个名为<code>createdb.sql</code>的文件中。如果数据库不存在，该命令将创建数据库(关于语法的更多信息，请参见<a href="https://stackoverflow.com/a/18389184/157605" rel="nofollow"> this StackOverflow </a>帖子):</p>

<pre><code>SELECT 'CREATE DATABASE tomcat' WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'tomcat')\gexec
</code></pre>

<p>然后用下面的命令执行SQL，用PostgreSQL服务器的主机名替换<code>postgresserver</code>:</p>

<pre><code>cat createdb.sql | /usr/bin/psql -a -U postgres -h postgresserver
</code></pre>

<p>接下来，我们创建模式和表。将以下文本保存到名为<code>createschema.sql</code>的文件中。注意<code>tomcat_sessions</code>表的列匹配<code>/etc/tomcat9/context.xml</code>文件中<code>Store</code>元素的属性:</p>

<pre><code>CREATE SCHEMA IF NOT EXISTS session;

CREATE TABLE IF NOT EXISTS session.tomcat_sessions
(
  session_id character varying(100) NOT NULL,
  valid_session character(1) NOT NULL,
  max_inactive integer NOT NULL,
  last_access bigint NOT NULL,
  app_name character varying(255),
  session_data bytea,
  CONSTRAINT tomcat_sessions_pkey PRIMARY KEY (session_id)
);

CREATE INDEX IF NOT EXISTS app_name_index
  ON session.tomcat_sessions
  USING btree
  (app_name);
</code></pre>

<p>然后使用以下命令执行SQL，用PostgreSQL服务器的主机名替换<code>postgresserver</code>:</p>

<pre><code>psql -a -d tomcat -U postgres -h postgresserver -f /root/createschema.sql
</code></pre>

<p>我们现在在PostgreSQL中有了一个表，可以保存Tomcat会话。</p>

<h3 id="configure-the-load-balancers">配置负载平衡器</h3>

<h4 id="install-the-packages-2">安装软件包</h4>

<p>我们需要安装Apache web服务器、mod_jk插件和Keepalived服务:</p>

<pre><code>apt-get install apache2 libapache2-mod-jk keepalived
</code></pre>

<h4 id="configure-the-load-balancer">配置负载平衡器</h4>

<p>mod_jk插件通过文件<code>/etc/libapache2-mod-jk/workers.properties</code>进行配置。在这个文件中，我们定义了流量可以被定向到的工作线程的数量。该文件中的字段记录在<a href="https://tomcat.apache.org/connectors-doc/reference/workers.html" rel="nofollow">这里</a>。</p>

<p>我们首先定义一个名为<code>loadbalancer</code>的工作者，它将接收所有的流量:</p>

<pre><code>worker.list=loadbalancer
</code></pre>

<p>然后，我们定义前面创建的两个Tomcat实例。确保用匹配的Tomcat实例的IP地址替换<code>worker1_ip</code>和<code>worker2_ip</code>。</p>

<p>注意，这里定义为<code>worker1</code>和<code>worker2</code>的工人的名字与<code>/etc/tomcat9/server.xml</code>文件中<code>Engine</code>元素的<code>jvmRoute</code>属性值相匹配。这些名称必须匹配，因为mod_jk使用它们来实现粘性会话:</p>

<pre><code>worker.worker1.type=ajp13
worker.worker1.host=worker1_ip
worker.worker1.port=8009

worker.worker2.type=ajp13
worker.worker2.host=worker2_ip
worker.worker2.port=8009
</code></pre>

<p>最后，我们将<code>loadbalancer</code>工作线程定义为负载平衡器，它将流量导向启用了粘性会话的<code>worker1</code>和<code>worker2</code>工作线程:</p>

<pre><code>worker.loadbalancer.type=lb
worker.loadbalancer.balance_workers=worker1,worker2
worker.loadbalancer.sticky_session=1
</code></pre>

<p>以下是<code>/etc/libapache2-mod-jk/workers.properties</code>文件的完整副本:</p>

<pre><code># All traffic is directed to the load balancer
worker.list=loadbalancer

# Set properties for workers (ajp13)
worker.worker1.type=ajp13
worker.worker1.host=worker1_ip
worker.worker1.port=8009

worker.worker2.type=ajp13
worker.worker2.host=worker2_ip
worker.worker2.port=8009

# Load-balancing behaviour
worker.loadbalancer.type=lb
worker.loadbalancer.balance_workers=worker1,worker2
worker.loadbalancer.sticky_session=1
</code></pre>

<h4 id="add-an-apache-virtualhost">添加Apache虚拟主机</h4>

<p>为了让Apache接受流量，我们需要定义一个<code>VirtualHost</code>，我们在文件<code>/etc/apache2/sites-enabled/000-default.conf</code>中创建它。这个虚拟主机将接受端口80上的HTTP流量，定义一些日志文件，并使用<code>JkMount</code>指令将流量转发给名为<code>loadbalancer</code>的工作器:</p>

<pre><code class="language-xml">&lt;VirtualHost *:80&gt;
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined
  JkMount /* loadbalancer
&lt;/VirtualHost&gt;
</code></pre>

<h4 id="configure-keepalived">配置保持活动状态</h4>

<p>我们有两个负载平衡器，以确保在任何给定时间都可以让其中一个脱机进行维护。Keepalived是我们用来将虚拟IP地址分配给一个负载平衡器服务的服务，Keepalived称为主服务。</p>

<p>Keepalived是通过<code>/etc/keepalived/keepalived.conf</code>文件配置的。</p>

<p>我们从命名负载平衡器实例开始。第一个负载均衡器叫做<code>loadbalancer1</code>:</p>

<pre><code>vrrp_instance loadbalancer1 {
</code></pre>

<p><code>state</code>主机指定活动服务器:</p>

<pre><code>state MASTER
</code></pre>

<p><code>interface</code>参数将物理接口名称分配给这个特定的虚拟IP实例:</p>

<p>运行<code>ifconfig</code>可以找到接口名。</p>


<pre><code>interface ens5
</code></pre>

<p><code>virtual_router_id</code>是虚拟路由器实例的数字标识符。它必须在参与此虚拟路由器的所有LVS路由器系统上相同。它用于区分在同一网络接口上运行的多个Keepalived实例:</p>

<pre><code>virtual_router_id 101
</code></pre>

<p><code>priority</code>指定分配的接口在故障转移中接管的顺序；数字越大，优先级越高。该优先级值必须在0到255的范围内，并且配置为状态<code>MASTER</code>的负载均衡服务器的优先级值应该设置为比配置为状态<code>BACKUP</code>的服务器的优先级值更高的数字:</p>

<pre><code>priority 101
</code></pre>

<p><code>advert_int</code>定义发送VRRP广告的频率:</p>

<pre><code>advert_int 1
</code></pre>

<p><code>authentication</code>块指定用于验证服务器故障转移同步的验证类型(<code>auth_type</code>和密码(<code>auth_pass</code>)。<code>PASS</code>指定密码验证:</p>

<pre><code>authentication {
    auth_type PASS
    auth_pass passwordgoeshere
}
</code></pre>

<p><code>unicast_src_ip</code>是此负载平衡器的IP地址:</p>

<pre><code>unicast_src_ip 10.0.0.20
</code></pre>

<p><code>unicast_peer</code>列出其他负载平衡器的IP地址。因为我们总共有两个负载平衡器，所以这里只列出了另一个负载平衡器:</p>

<pre><code>unicast_peer {
  10.0.0.21
}
</code></pre>

<p><code>virtual_ipaddress</code>定义Keepalived分配给主节点的虚拟或浮动IP地址:</p>

<pre><code>virtual_ipaddress {
    10.0.0.30
}
</code></pre>

<p>这里是第一个负载平衡器的<code>/etc/keepalived/keepalived.conf</code>文件的完整副本:</p>

<pre><code>vrrp_instance loadbalancer1 {
    state MASTER
    interface ens5
    virtual_router_id 101
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass passwordgoeshere
    }
    # Replace unicast_src_ip and unicast_peer with your load balancer IP addresses
    unicast_src_ip 10.0.0.20
    unicast_peer {
      10.0.0.21
    }
    virtual_ipaddress {
        10.0.0.30
    }
}
</code></pre>

<p>这里是第二个负载平衡器的<code>/etc/keepalived/keepalived.conf</code>文件的完整副本。</p>

<p>注意，名称已被设置为<code>loadbalancer2</code>,<code>state</code>已被设置为<code>BACKUP</code>,<code>priority</code>比<code>100</code>低，并且<code>unicast_src_ip</code>和<code>unicast_peer</code> IP地址已被翻转:</p>

<pre><code>vrrp_instance loadbalancer2 {
    state BACKUP
    interface ens5
    virtual_router_id 101
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass passwordgoeshere
    }
    # Replace unicast_src_ip and unicast_peer with your load balancer IP addresses
    unicast_src_ip 10.0.0.21
    unicast_peer {
      10.0.0.20
    }
    virtual_ipaddress {
        10.0.0.30
    }
}
</code></pre>

<p>使用以下命令在两个负载平衡器上重新启动<code>keepalived</code>服务:</p>

<pre><code>systemctl restart keepalived
</code></pre>

<p>在第一个负载平衡器上，运行命令<code>ip addr</code>。这将显示分配给接口的虚拟IP地址，Keepalived被配置为使用输出<code>inet 10.0.0.30/32 scope global ens5</code>进行管理:</p>

<pre><code>$ ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP group default qlen 1000
    link/ether 0e:2b:f9:2a:fa:a7 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.21/24 brd 10.0.0.255 scope global dynamic ens5
       valid_lft 3238sec preferred_lft 3238sec
    inet 10.0.0.30/32 scope global ens5
       valid_lft forever preferred_lft forever
    inet6 fe80::c2b:f9ff:fe2a:faa7/64 scope link
       valid_lft forever preferred_lft forever
</code></pre>

<p>如果第一个负载平衡器关闭，第二个负载平衡器将采用虚拟IP地址，第二个Apache web服务器将充当负载平衡器。</p>

<h2 id="build-the-deployment-pipeline">构建部署管道</h2>

<p>我们的部署管道将包括部署<a href="https://github.com/OctopusSamples/RandomQuotes-Java" rel="nofollow">随机报价</a>示例应用程序。这是一个简单的有状态Spring Boot应用程序，利用Flyway来管理数据库迁移。</p>

<p>当您单击<strong>刷新</strong>按钮时，一个新的报价从数据库中加载，一个计数器在会话中递增，并且计数器在页面上显示为<strong>报价计数</strong>字段。应用程序版本显示在<strong>版本</strong>字段中。</p>

<p>我们可以使用<strong>引用计数</strong>和<strong>版本</strong>信息来验证在执行新部署或Tomcat实例离线时，现有会话是否被保留。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/random_quotes.png" class="zoom" data-title=""><img src="../Images/7f4a6ea67f0c64a6e6fa2128d853dfb6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/random_quotes.png"/>T2】</a></p>

<h3 id="get-an-octopus-instance">获取一个Octopus实例</h3>

<p>如果你还没有安装Octopus，获得Octopus实例最简单的方法是<a href="https://octopus.com/start/cloud">注册一个云账户</a>。这些实例对多达10个目标是免费的。</p>

<h3 id="create-the-environments">创造环境</h3>

<p>我们将为这个例子创建两个环境:<strong> Dev </strong>和<strong> Prod </strong>。这意味着我们将总共配置八个目标:四个负载平衡器和四个Tomcat实例。</p>

<h3 id="deploy-the-tentacle">展开触手</h3>

<p>我们将在我们的每个虚拟机上安装一个触手，以允许我们执行部署、更新和系统维护任务。安装触手软件的说明可以在<a href="https://octopus.com/downloads/tentacle#linux"> Octopus下载页面</a>上找到。由于本例使用Ubuntu作为基本操作系统，我们用以下命令安装了触手:</p>

<pre><code>apt-key adv --fetch-keys https://apt.octopus.com/public.key
add-apt-repository "deb https://apt.octopus.com/ stretch main"
apt-get update
apt-get install tentacle
</code></pre>

<p>在安装了触手之后，我们用以下命令配置一个实例:</p>

<pre><code>/opt/octopus/tentacle/configure-tentacle.sh
</code></pre>

<p>该安装让你在<a href="https://octopus.com/docs/infrastructure/deployment-targets/windows-targets/tentacle-communication">轮询或监听触角</a>之间做出选择。您选择哪个选项通常取决于您的网络限制。轮询触角要求托管触角的虚拟机能够到达Octopus服务器，而监听触角要求Octopus服务器能够到达虚拟机。通信方式的选择取决于Octopus服务器或VMs是否有固定的IP地址，以及防火墙中是否打开了正确的端口。任一选项都是有效的选择，不会影响部署过程。</p>

<p>这里是一个<strong> Dev </strong>环境的截图，带有Tomcat和负载平衡器实例的触角。Tomcat实例的角色是<strong> tomcat </strong>，负载平衡器实例的角色是<strong>负载平衡器</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/targets.png" class="zoom" data-title=""><img src="../Images/36499e8db030f1d67a530f984629a7ab.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/targets.png"/>T2】</a></p>

<h3 id="create-the-external-feed">创建外部提要</h3>

<p>随机报价示例应用程序已经作为WAR文件推送到<a href="https://repo.maven.apache.org/maven2/com/octopus/randomquotes/" rel="nofollow">Maven Central</a>。这意味着我们可以直接从Maven提要部署应用程序。</p>

<p>创建一个指向<code>https://repo.maven.apache.org/maven2/</code>的新Maven提要。此提要的屏幕截图如下所示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/maven_feed.png" class="zoom" data-title=""><img src="../Images/74439a22aeb6c877902797cc92136911.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/maven_feed.png"/>T2】</a></p>

<p>通过搜索<strong>com . octopus:random quotes</strong>来测试提要。在这里，我们可以看到我们的应用程序位于存储库中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/test_feed.png" class="zoom" data-title=""><img src="../Images/76773d44d60d71cba26734a4fc8d41c3.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/test_feed.png"/>T2】</a></p>

<h3 id="create-the-deployment-process">创建部署流程</h3>

<h4 id="generate-a-timestamp">生成时间戳</h4>

<p>为了支持零停机部署，我们希望利用Tomcat中的<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/context.html#Parallel_deployment" rel="nofollow">并行部署</a>特性。通过在部署每个应用程序时对其进行版本控制，可以实现并行部署。</p>

<p>此版本号使用字符串比较来确定最新版本。典型的版本化方案，比如SemVer，使用一种<em> major.minor.patch </em>格式，比如<em> 1.23.4 </em>，来标识版本。在很多情况下，这些传统的版本化方案可以作为字符串来比较，以确定它们的顺序。</p>

<p>但是，填充会带来一些问题。比如版本<em> 1.23.40 </em>比<em> 01.23.41 </em>低，但是直接字符串比较会返回相反的结果。</p>

<p>出于这个原因，我们使用部署时间作为Tomcat版本。因为版本需要跨目标保持一致，所以我们从一个脚本步骤开始，该步骤生成一个时间戳，并将其保存到一个输出变量中，代码如下:</p>

<pre><code class="language-PowerShell">$timestamp = Get-Date -Format "yyMMddHHmmss"
Set-OctopusVariable -name "TimeStamp" -value $timestamp
</code></pre>

<h4 id="the-tomcat-deployment">Tomcat部署</h4>

<p>我们的部署流程从使用<strong>Deploy to Tomcat via Manager</strong>步骤将应用程序部署到每个Tomcat实例开始。我们将这个步骤称为<strong>随机报价</strong>，并在<strong> tomcat </strong>目标上运行它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_1.png" class="zoom" data-title=""><img src="../Images/18cefa4c2b3384d60e0bd21692203a79.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_1.png"/>T2】</a></p>

<p>我们从之前设置的Maven提要中部署<strong>com . octopus:random quotes</strong>包:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_2.png" class="zoom" data-title=""><img src="../Images/d9af3a45f06a4aa5a00d327a5487d3ef.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_2.png"/>T2】</a></p>

<p>因为触手位于托管Tomcat的VM上，所以管理器API的位置是<strong>http://localhost:8080/Manager</strong>。然后我们提供管理器凭证，这是我们配置Tomcat时输入到<code>tomcat-users.xml</code>文件中的详细信息:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_3.png" class="zoom" data-title=""><img src="../Images/e0055675237b685887f129d63fe31492.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_3.png"/>T2】</a></p>

<p>上下文路径构成了URL中可访问已部署应用程序的路径。这里我们公开了路径<strong> /randomquotes </strong>上的应用程序:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_4.png" class="zoom" data-title=""> T31 </a></p>

<p>通过引用输出变量<strong> #{Octopus，部署版本被设置为上一步生成的时间戳。动作[获取时间戳].输出.时间戳} </strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_5.png" class="zoom" data-title=""><img src="../Images/b13b97e52c7a9dead364570ef8e4578d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_step_5.png"/>T2】</a></p>

<h4 id="smoke-test-the-deployment">对部署进行冒烟测试</h4>

<p>为了验证我们的部署是否成功，我们发出一个HTTP请求并检查响应代码。为此，我们使用一个名为<strong> HTTP - Test URL (Bash) </strong>的社区步骤模板。</p>

<p>和以前一样，这个步骤将在Tomcat实例上运行:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/http_step_1.png" class="zoom" data-title=""><img src="../Images/0a5c1006aa07910fa58c67a966f5b776.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/http_step_1.png"/>T2】</a></p>

<p>该步骤将尝试从新部署的应用程序中打开<code>index.html</code>页面，预期HTTP响应代码为<strong> 200 </strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/http_step_2.png" class="zoom" data-title=""><img src="../Images/f1d79643e44b0c9563c78ebb29531cc8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/http_step_2.png"/>T2】</a></p>

<h4 id="perform-the-initial-deployment">执行初始部署</h4>

<p>让我们继续执行初始部署。对于这个部署，我们将特别选择以前版本的随机报价应用程序。版本<strong> 0.1.6.1 </strong>在这种情况下，是我们的倒数第二个工件版本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/deployment_step_1.png" class="zoom" data-title=""><img src="../Images/293273a7a390c4efe6d4f460f2531e80.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/deployment_step_1.png"/>T2】</a></p>

<p>Octopus然后从Maven存储库中下载WAR文件，将其推送到Tomcat实例，并通过管理器部署到Tomcat。完成后，运行冒烟测试以确保应用程序可以成功打开:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/deployment_result.png" class="zoom" data-title=""><img src="../Images/4439010a075edb25dc8bfb386cc782f8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/deployment_result.png"/>T2】</a></p>

<h2 id="inspect-a-request-through-the-stack">通过堆栈检查请求</h2>

<p>部署完成后，我们可以通过负载平衡器访问它。</p>

<p>在前面的配置示例中，我们有一个浮动IP地址10.0.0.30，但是对于这些截图，我使用Keepalived为负载平衡器分配一个公共IP地址。</p>


<p>下面是用Chrome开发工具打开的应用程序的屏幕截图:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/app_1.png" class="zoom" data-title=""><img src="../Images/528e6edd63f70362142c8e778e19c855.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/app_1.png"/></a>T2】</p>

<p>这张截图有三点需要注意:</p>

<ol>
<li>用一个随机的会话ID和响应请求的Tomcat实例的名称来设置JSESSIONID  cookie。在这个例子中，其<strong> jvmRoute </strong>被设置为<strong> worker1 </strong>的Tomcat实例响应了请求。</li>
<li>我们已经打开了应用程序的0.1.6.1版本。</li>
<li><strong>报价计数</strong>设置为1，但当我们点击<strong>刷新</strong>按钮时，报价计数将会增加。</li>
</ol>

<p>让我们通过单击<strong>刷新</strong>按钮来增加<strong>报价计数</strong>。该值保存在Tomcat服务器上与<strong> JSESSIONID </strong> cookie相关联的会话中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/app_2.png" class="zoom" data-title=""><img src="../Images/75f2de5bbfe80e4c244bbafd6d65a964.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/app_2.png"/>T2】</a></p>

<p>现在让我们关闭<strong> worker1 </strong> Tomcat实例。关机后，我们再次点击<strong>刷新</strong>按钮:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/app_3.png" class="zoom" data-title=""><img src="../Images/7079894dea7f50caa59d7b9ead97699a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/app_3.png"/>T2】</a></p>

<p>这张截图有三点需要注意:</p>

<ol>
<li><strong> JSESSIONID </strong> cookie上的后缀从<strong> worker1 </strong>更改为<strong> worker2 </strong>。</li>
<li><strong> JSESSIONID </strong> cookie会话ID保持不变。</li>
<li><strong>报价计数</strong>增加到6。</li>
</ol>

<p>当Tomcat正常关闭时，它会将所有会话的内容写到数据库中。然后因为<strong> worker1 </strong> Tomcat实例不再可用，请求被定向到<strong> worker2 </strong> Tomcat实例。<strong> worker2 </strong> Tomcat实例从数据库加载会话信息，并增加计数器。jvmroutebendervalve阀重写了会话cookie，将当前的Tomcat实例名附加到末尾，并且将响应返回给浏览器。</p>

<p>我们现在可以看到，负载平衡器<code>/etc/libapache2-mod-jk/workers.properties</code>文件中的工作者名称与分配给<code>/etc/tomcat9/server.xml</code>文件中的<strong> jvmRoute </strong>的名称相匹配是很重要的，因为匹配这些名称可以实现粘性会话。</p>

<p>因为<strong>引用计数</strong>没有重置回1，所以我们知道会话被保存到数据库中，并被复制到集群中的其他Tomcat实例。我们还知道该请求是由另一个Tomcat实例处理的，因为<strong> JSESSIONID </strong> cookie显示了一个新的worker名称。</p>

<p>即使我们让<strong> worker1 </strong>重新联机，这个浏览器会话也将继续由<strong> worker2 </strong>处理，因为负载平衡器通过检查<strong> JSESSIONID </strong> cookie来实现粘性会话。这也意味着负载平衡器不需要共享状态，因为它们只需要cookie值来引导流量。</p>

<p>我们现在已经展示了Tomcat实例支持会话复制和故障转移，使它们高度可用。</p>

<p>为了演示负载平衡器的故障转移，我们只需要重新启动Keepalived指定为主服务器的实例。然后，我们可以使用以下命令查看备份实例上的事件:</p>

<pre><code>journalctl -u keepalived -f
</code></pre>

<p>很快，我们将看到这些消息出现在备份上，因为它承担了主角色:</p>

<pre><code>Apr 01 03:15:00 ip-10-0-0-21 Keepalived_vrrp[32485]: VRRP_Instance(loadbalancer2) Transition to MASTER STATE
Apr 01 03:15:01 ip-10-0-0-21 Keepalived_vrrp[32485]: VRRP_Instance(loadbalancer2) Entering MASTER STATE
</code></pre>

<p>承担主服务器角色后，负载平衡器将被分配虚拟IP地址，并像前一个主服务器一样分配流量。</p>

<p>在之前的主实例重新启动后，它将重新承担主角色，因为它配置了更高的优先级，并且虚拟IP地址将被分配回去。</p>

<p>整个过程是无缝的，上游客户端永远不需要知道发生了故障转移和故障恢复。因此，我们已经演示了负载平衡器可以进行故障转移，从而使它们高度可用。</p>

<p>总而言之:</p>

<ul>
<li>JSESSIONID cookie包含会话ID和处理请求的Tomcat实例的名称。</li>
<li>负载平衡器基于附加到<strong> JSESSIONID </strong> cookie的工作者名称来实现粘性会话。</li>
<li>当一个Tomcat实例接收到它原本不负责的会话的流量时，<code>JvmRouteBinderValve</code> valve重写<strong> JSESSIONID </strong> cookie。</li>
<li>如果主负载平衡器脱机，Keepalived会将一个虚拟IP分配给备用负载平衡器。</li>
<li>当主负载平衡器重新联机时，它会重新承担虚拟IP。</li>
<li>基础设施栈可以在失去一个Tomcat实例和一个负载平衡器的情况下生存，并且仍然保持可用性。</li>
</ul>

<h2 id="zero-downtime-deployments">零停机部署</h2>

<p>我们现在已经成功地将web应用程序的版本<em> 0.1.6.1 </em>部署到Tomcat。这个版本的应用程序使用一个非常简单的表结构来保存引用者的姓名，将名字和姓氏放在一个名为<code>AUTHOR</code>的列中。</p>

<p>该表结构最初是由Flyway数据库脚本使用以下SQL创建的:</p>

<pre><code class="language-sql">create table AUTHOR
(
    ID INT auto_increment,
    AUTHOR VARCHAR(64) not null
);
</code></pre>

<p>我们应用程序的下一个版本将把名字分成<code>FIRSTNAME</code>和<code>LASTNAME</code>列。我们使用包含以下SQL的新Flyway脚本添加这些列:</p>

<pre><code class="language-sql">ALTER TABLE AUTHOR
ADD FIRSTNAME varchar(64);

ALTER TABLE AUTHOR
ADD LASTNAME varchar(64);
</code></pre>

<p>此时，我们必须考虑如何以向后兼容的方式进行这些更改。零停机部署策略的基石要求共享数据库同时支持应用程序的当前版本和新版本。不幸的是，没有提供这种兼容性的灵丹妙药，作为开发人员，我们有责任确保我们的更改不会破坏任何现有的会话。</p>

<p>在这个场景中，我们必须保留旧的<code>AUTHOR</code>列，并将它保存的数据复制到新的<code>FIRSTNAME</code>和<code>LASTNAME</code>列中:</p>

<pre><code class="language-sql">UPDATE AUTHOR SET FIRSTNAME = 'Rob', LASTNAME = 'Siltanen' WHERE ID = 1;
UPDATE AUTHOR SET FIRSTNAME = 'Albert', LASTNAME = 'Einstein' WHERE ID = 2;
UPDATE AUTHOR SET FIRSTNAME = 'Charles', LASTNAME = 'Eames' WHERE ID = 3;
UPDATE AUTHOR SET FIRSTNAME = 'Henry', LASTNAME = 'Ford' WHERE ID = 4;
UPDATE AUTHOR SET FIRSTNAME = 'Antoine', LASTNAME = 'de Saint-Exupery' WHERE ID = 5;
UPDATE AUTHOR SET FIRSTNAME = 'Salvador', LASTNAME = 'Dali' WHERE ID = 6;
UPDATE AUTHOR SET FIRSTNAME = 'M.C.', LASTNAME = 'Escher' WHERE ID = 7;
UPDATE AUTHOR SET FIRSTNAME = 'Paul', LASTNAME = 'Rand' WHERE ID = 8;
UPDATE AUTHOR SET FIRSTNAME = 'Elon', LASTNAME = 'Musk' WHERE ID = 9;
UPDATE AUTHOR SET FIRSTNAME = 'Jessica', LASTNAME = 'Hische' WHERE ID = 10;
UPDATE AUTHOR SET FIRSTNAME = 'Paul', LASTNAME = 'Rand' WHERE ID = 11;
UPDATE AUTHOR SET FIRSTNAME = 'Mark', LASTNAME = 'Weiser' WHERE ID = 12;
UPDATE AUTHOR SET FIRSTNAME = 'Pablo', LASTNAME = 'Picasso' WHERE ID = 13;
UPDATE AUTHOR SET FIRSTNAME = 'Charles', LASTNAME = 'Mingus' WHERE ID = 14;
</code></pre>

<p>此外，新的JPA实体类需要忽略旧的<code>AUTHOR</code>列(通过<code>@Transient</code>注释)。然后，<code>getAuthor()</code>方法返回<code>getFirstName()</code>和<code>getLastName()</code>方法的组合值:</p>

<pre><code class="language-Java">@Entity
public class Author {
    @Id
    @GeneratedValue(strategy= GenerationType.AUTO)
    private Integer id;
    @Column(name = "FIRSTNAME")
    private String firstName;
    @Column(name = "LASTNAME")
    private String lastName;

    @OneToMany(
            mappedBy = "author",
            cascade = CascadeType.ALL,
            orphanRemoval = true
    )
    private List&lt;Quote&gt; quotes = new ArrayList&lt;&gt;();

    protected Author() {

    }

    public Integer getId() {
        return id;
    }

    @Transient
    public String getAuthor() {
        return getFirstName() + " " + getLastName();
    }

    public List&lt;Quote&gt; getQuotes() {
        return quotes;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }
}
</code></pre>

<p>虽然这是一个简单的例子，但由于<code>AUTHOR</code>表是只读的，所以很容易实现，它演示了如何以向后兼容的方式实现数据库更改。有可能就维护向后兼容性的策略写一整本书，但是出于本文的目的，我们将把这个讨论留在这里。</p>

<p>在我们执行下一次部署之前，请重新打开现有应用程序并刷新一些报价。这将针对现有的<em> 0.1.6.1 </em>版本创建一个会话，我们将使用它来测试我们的零停机部署策略。</p>

<p>通过以向后兼容的方式编写迁移脚本，我们可以部署应用程序的新版本。为了方便起见，这个新版本已经作为版本<em> 0.1.7 </em>推送到Maven Central:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/deployment_two.png" class="zoom" data-title=""><img src="../Images/d2ed88d0ca33b601a46d60803114c4c9.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/deployment_two.png"/>T2】</a></p>

<p>部署完成后，在<code>http://tomcatip:8080/manager/html</code>打开管理器应用程序。注意，虽然您可以通过负载平衡器访问管理器，但是您不能选择要管理哪个Tomcat实例，因为负载平衡器会为您选择一个Tomcat实例。这意味着最好直接连接到Tomcat实例，绕过负载平衡器:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/manager_one.png" class="zoom" data-title=""><img src="../Images/b28c68904ebb7f4dd6156dd598b9c633.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/manager_one.png"/>T2】</a></p>

<p>这张截图有两点需要注意:</p>

<ol>
<li>我们在路径<code>/randomquotes</code>下有两个应用程序，每个都有一个唯一的版本。</li>
<li>早期版本的应用程序有一个与之关联的会话。这是我们在部署版本<em> 0.1.7 </em>之前通过访问版本<em> 0.1.6.1 </em>创建的会话。</li>
</ol>

<p>如果我们回到打开应用程序版本<em> 0.1.6.1 </em>的浏览器，我们可以继续刷新报价。计数器如我们预期的那样增加，页脚中显示的版本号仍然是版本<em> 0.1.6.1 </em>。</p>

<p>如果我们在私人浏览窗口中重新打开应用程序，我们可以保证不会重用旧的会话cookie，并且我们会被定向到应用程序的版本<em> 0.1.7 </em>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/private_window.png" class="zoom" data-title=""><img src="../Images/0c2ace3e751863609a4be63ef3c8e9f0.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/private_window.png"/>T2】</a></p>

<p>因此，我们展示了零停机部署。因为我们的数据库迁移被设计成向后兼容的，所以应用程序的版本<em> 0.1.6.1 </em>和版本<em> 0.1.7 </em>可以使用Tomcat并行部署并行运行。最重要的是，旧部署的会话仍然可以在Tomcat实例之间转移，因此我们可以在并行部署的同时保持高可用性。</p>

<h2 id="rollback-strategies">回滚策略</h2>

<p>只要应用程序的最新版本和当前版本(在本例中是版本<code>0.1.6.1</code>和<code>0.1.7</code>)之间保持了数据库兼容性，回滚就像用应用程序的先前版本创建一个新部署一样简单。</p>

<p>因为Tomcat版本有一个在部署时计算的时间戳，部署应用程序的版本<code>0.1.6.1</code>再次导致它处理任何新的流量，因为它有一个更高的版本。</p>

<p>注意，由于Tomcat的并行部署，版本<code>0.1.7</code>的任何现有会话都将自然终止。如果这个版本必须离线(例如，如果有一个关键问题，它不能继续使用)，我们可以使用Tomcat 步骤中的<strong>开始/停止应用程序来停止一个已部署的应用程序。</strong></p>

<p>我们将创建一个运行手册来运行这一步骤，因为这是一个维护任务，可能需要应用于任何环境来推出一个坏版本。</p>

<p>我们首先添加一个提示变量，该变量将填充与我们想要关闭的部署相对应的Tomcat版本时间戳:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_version.png" class="zoom" data-title=""><img src="../Images/48e4b8e195e2ba6b72b2aeb7cf171b1d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_version.png"/></a>T2】</p>

<p>然后，使用Tomcat 步骤中的<strong>启动/停止应用程序配置运行手册。<strong>部署版本</strong>设置为提示变量的值:</strong></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_stop.png" class="zoom" data-title=""><img src="../Images/ddd1c55f254109e8d016503490d923af.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_stop.png"/>T2】</a></p>

<p>运行runbook时，系统会提示我们输入要停止的应用程序的时间戳版本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/stop_app_runbook_1.png" class="zoom" data-title=""><img src="../Images/b2a9edf29aba3aebe966d0fc02882829.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/stop_app_runbook_1.png"/>T2】</a></p>

<p>运行手册完成后，我们可以通过打开管理器控制台来验证应用程序是否已停止。在下面的截图中，你可以看到版本<strong> 200401140129 </strong>没有运行。此版本不再响应请求，所有将来的请求将被定向到应用程序的最新版本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/stopped_application.png" class="zoom" data-title=""><img src="../Images/93c28244aa9791a68c8ebcb3ffc70127.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/stopped_application.png"/>T2】</a></p>

<h2 id="feature-branch-deployments">功能分支部署</h2>

<p>一个常见的开发实践是在一个单独的SCM分支中完成一个特性，称为特性分支。</p>

<p>CI服务器通常会观察特性分支的存在，并根据提交的代码创建一个可部署的工件。</p>

<p>这些特性分支工件然后被版本化，以指示它们是从哪个分支构建的。GitVersion是一个流行的工具，用于生成版本以匹配Git中的提交和分支，他们提供了这个示例，展示了作为GitHub流的一部分而创建的<a href="https://gitversion.net/docs/git-branching-strategies/githubflow-examples" rel="nofollow">版本:</a></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/githubflow_feature_branch.png" class="zoom" data-title=""><img src="../Images/2275fec2b790406b90c40ddfb2e2573b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/githubflow_feature_branch.png"/>T2】</a></p>

<p>从上图可以看出，对一个名为<strong> myfeature </strong>的特性分支的提交生成了一个类似于<strong> 1.2.1-myfeature.1+1 </strong>的版本。这又会产生一个文件名类似于<code>myapp.1.2.1-myfeature.1+1.zip</code>的工件。</p>

<p>尽管像GitVersion这样的工具会生成SemVer版本字符串，但同样的格式也可以用于Maven工件。然而，有一个问题。</p>

<p>SemVer将订购一个功能分支低于没有任何预发布组件的版本。例如，<strong> 1.2.1 </strong>被认为是比<strong> 1.2.1-myfeature </strong>更高的版本号。这是预期的顺序，因为功能分支最终将合并回主分支。</p>

<p>当一个特性分支被附加到Maven版本时，它被认为是一个限定符。Maven允许任何限定符，但也识别一些特殊的限定符，如<strong>快照</strong>、<strong>最终</strong>、<strong> ga </strong>等。完整的列表可以在博文<a href="https://octopus.com/blog/maven-versioning-explained"> Maven版本解释</a>中找到。带有无法识别的限定符的Maven版本(特性分支名称是无法识别的限定符)被视为比未限定版本更高的版本。</p>

<p>这意味着Maven认为版本<strong> 1.2.1-myfeature </strong>将比<strong> 1.2.1 </strong>更晚发布，而这显然不是特性分支的意图。您可以在一个托管在<a href="https://github.com/mcasperson/MavenVersionTest/blob/master/src/test/java/org/apache/maven/artifact/versioning/VersionTest.java#L122" rel="nofollow"> GitHub </a>上的项目中通过下面的测试来验证这种行为。</p>

<p>然而，由于Octopus中的通道功能，我们可以确保SemVer预发布和Maven限定符都按照预期的方式进行过滤。</p>

<p>这是我们应用程序部署的默认通道。注意，<strong>预发布标签</strong>字段的正则表达式<strong> ^$ </strong>。这个正则表达式只匹配空字符串，这意味着默认通道将只部署没有预发布或限定符字符串的工件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/default_channel.png" class="zoom" data-title=""> T31 </a></p>

<p>接下来，我们有特征分支通道，它定义了一个正则表达式<strong>。+ </strong>用于<strong>预发布标签</strong>字段。这个正则表达式只匹配非空字符串，这意味着功能分支通道将只部署带有预发布或限定符字符串的工件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/feature_branch_channel.png" class="zoom" data-title=""><img src="../Images/dddd6b13da88d03d06a800c03895fac9.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/feature_branch_channel.png"/>T2】</a></p>

<p>以下是Octopus允许在默认频道中发布的版本列表。注意，显示的唯一版本没有限定符，这意味着它是主版本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/default_channel_deployment.png" class="zoom" data-title=""><img src="../Images/620b91dd2e899525ea8e8fe5adf5ce46.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/default_channel_deployment.png"/>T2】</a></p>

<p>以下是Octopus允许使用功能分支通道创建的版本列表。所有这些版本都有一个嵌入特性分支名称的限定符:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/feature_branch_channel_deployment.png" class="zoom" data-title=""><img src="../Images/e825b8e10ec02ae7d1c63de1a30d85fb.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/feature_branch_channel_deployment.png"/>T2】</a></p>

<p>这些渠道的最终结果是，像<strong> 1.2.1-myfeature </strong>这样的版本将永远不会与像<strong> 1.2.1 </strong>这样的版本进行比较，这消除了功能分支版本号被认为是后续版本的模糊性。</p>

<p>最后一步是将这些特性分支包部署到唯一的上下文中，这样就可以在单个Tomcat实例上并排访问它们。为此，我们将<strong>上下文路径</strong>修改为:</p>

<pre><code>/randomquotes#{Octopus.Action.Package.PackageVersion | Replace "^([0-9\.]+)((?:-[A-Za-z0-9]+)?)(.*)$" "$2"}
</code></pre>

<p>在版本<code>1.2.1-myfeature.1+1</code>上使用上面的正则表达式将执行以下操作:</p>

<ul>
<li><code>^([0-9\.]+)</code>将版本开头的所有数字和句点分组为第1组，与<code>1.2.1</code>匹配。</li>
<li><code>((?:-[A-Za-z0-9]+)?)</code>将前导破折号和任何后续字母数字字符(如有)分组为第2组，匹配<code>-myfeature</code>。</li>
<li><code>(.*)$</code>将任何后续字符(如果有)分组为组3，它匹配<code>.1+1</code>。</li>
</ul>

<p>这个变量过滤器将导致完整的预发布或限定符字符串被正则表达式中的第二组替换。这会产生以下上下文路径:</p>

<ul>
<li>版本<code>1.2.1-myfeature.1+1</code>生成<code>/randomquotes-myfeature</code>的上下文路径。</li>
<li>版本<code>1.2.1</code>生成<code>/randomquotes</code>的上下文路径。</li>
</ul>

<p>下面是应用了新上下文路径的Tomcat部署步骤的屏幕截图:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/context_path.png" class="zoom" data-title=""><img src="../Images/64957b678b9b29e9d16f759669db1e5f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/context_path.png"/>T2】</a></p>

<p>SemVer项目提供了一个更加健壮的正则表达式<a href="https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string" class="alert-link" rel="nofollow">来可靠地捕获SemVer版本中的组。</a></p>
<p>带有命名捕获组的正则表达式为:</p>
<pre><code>^(?P&lt;major&gt;0|[1-9]\d*)\.(?P&lt;minor&gt;0|[1-9]\d*)\.(?P&lt;patch&gt;0|[1-9]\d*)(?:-(?P&lt;prerelease&gt;(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P&lt;buildmetadata&gt;[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
</code></pre>
<p>没有命名组的正则表达式是:</p>
<pre><code>^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
</code></pre>


<h2 id="public-certificate-management">公共证书管理</h2>

<p>为了完成基础设施的配置，我们将通过负载平衡器启用HTTPS访问。我们可以编辑Apache web服务器虚拟主机配置来启用SSL，并指向我们为我们的域获得的密钥和证书。</p>

<h3 id="obtain-a-certificate">获得证书</h3>

<p>在这篇文章中，我获得了一个由我们的DNS提供商生成的加密证书。生成HTTPS证书的确切过程不是我们在这里要讨论的，但是您可以参考您的DNS或证书提供商以获得具体的指导。</p>

<p>在下面的截图中，您可以看到下载证书的各种选项。注意，虽然为Apache提供了说明和下载，但我们下载的是IIS说明下提供的PFX文件。PFX文件在一个文件中包含公钥、私钥和证书链。我们需要这个文件将证书上传到Octopus。在这里，我们下载了<code>octopus.tech</code>域名的PFX文件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/dns_1.png" class="zoom" data-title=""><img src="../Images/5b7336179d55ae29f2db1b0ebaa44d51.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/dns_1.png"/>T2】</a></p>

<h3 id="create-the-certificate-in-octopus">在Octopus中创建证书</h3>

<p>部署证书是一项持续的操作。特别是，Let's Encrypt提供的证书每三个月就会过期，因此需要经常刷新。</p>

<p>这使得部署证书成为runbooks的一个很好的用例。与常规部署不同，runbooks不需要在环境中进行，您也不需要创建部署。我们将创建一个runbook来将证书部署到Apache负载平衡器。</p>

<p>首先，我们需要上传由DNS提供商生成的PFX证书。在下面的截图中，您可以看到上传到八达通证书商店的加密证书:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/certificate.png" class="zoom" data-title=""><img src="../Images/e74d7a831cb1e43060f133c21dfb0fff.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/certificate.png"/>T2】</a></p>

<h3 id="deploy-the-certificate">部署证书</h3>

<p>在Octopus中创建一个新项目，并添加我们刚刚上传的证书作为变量:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/cert_deploy_1.png" class="zoom" data-title=""><img src="../Images/1541b607b599f751eafcca14347cc147.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/cert_deploy_1.png"/>T2】</a></p>

<p>接下来，创建一个包含单个<strong>运行脚本</strong>步骤的运行手册。</p>

<p>脚本的第一步是使用命令启用<strong> mod_ssl </strong>:</p>

<pre><code class="language-bash">a2enmod ssl
</code></pre>

<p>然后创建一些目录来保存证书、证书链和私钥:</p>

<pre><code class="language-bash">[ ! -d "/etc/apache2/ssl" ] &amp;&amp; mkdir /etc/apache2/ssl
[ ! -d "/etc/apache2/ssl/private" ] &amp;&amp; mkdir /etc/apache2/ssl/private
</code></pre>

<p>然后，证书变量的内容作为文件保存到上述目录中。证书是一种特殊的变量，它通过扩展属性公开组成证书的各个组件。我们需要访问三个属性:</p>

<ul>
<li><code>Certificate.CertificatePem</code>，也就是公证。</li>
<li><code>Certificate.PrivateKeyPem</code>，也就是私钥。</li>
<li><code>Certificate.ChainPem</code>，也就是证书链。</li>
</ul>

<p>我们将这些变量的内容打印到三个文件中:</p>

<pre><code class="language-bash">get_octopusvariable "Certificate.CertificatePem" &gt; /etc/apache2/ssl/octopus_tech.crt
get_octopusvariable "Certificate.PrivateKeyPem" &gt; /etc/apache2/ssl/private/octopus_tech.key
get_octopusvariable "Certificate.ChainPem" &gt; /etc/apache2/ssl/octopus_tech_bundle.pem
</code></pre>

<p>如果你还记得，在这篇文章的前面，我们用以下内容创建了文件<code>/etc/apache2/sites-enabled/000-default.conf</code>:</p>

<pre><code class="language-xml">&lt;VirtualHost *:80&gt;
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined
  JkMount /* loadbalancer
&lt;/VirtualHost&gt;
</code></pre>

<p>我们想修改这个文件，就像这样:</p>

<pre><code class="language-xml">&lt;VirtualHost *:443&gt;
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined
  JkMount /* loadbalancer
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/octopus_tech.crt
  SSLCertificateKeyFile /etc/apache2/ssl/private/octopus_tech.key
  SSLCertificateChainFile /etc/apache2/ssl/octopus_tech_bundle.pem
&lt;/VirtualHost&gt;
</code></pre>

<p>这是通过将所需的文本回显到文件<code>/etc/apache2/sites-enabled/000-default.conf</code>中来实现的:</p>

<pre><code class="language-bash">{
cat &lt;&lt; EOF
&lt;VirtualHost *:443&gt;
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined
  JkMount /* loadbalancer
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/octopus_tech.crt
  SSLCertificateKeyFile /etc/apache2/ssl/private/octopus_tech.key
  SSLCertificateChainFile /etc/apache2/ssl/octopus_tech_bundle.pem
&lt;/VirtualHost&gt;
EOF
} &gt; /etc/apache2/sites-enabled/000-default.conf
</code></pre>

<p>最后一步是重启<code>apache2</code>服务来加载变更:</p>

<pre><code class="language-bash">systemctl restart apache2
</code></pre>

<p>以下是完整的脚本供参考:</p>

<pre><code class="language-bash">a2enmod ssl

[ ! -d "/etc/apache2/ssl" ] &amp;&amp; mkdir /etc/apache2/ssl
[ ! -d "/etc/apache2/ssl/private" ] &amp;&amp; mkdir /etc/apache2/ssl/private
get_octopusvariable "Certificate.CertificatePem" &gt; /etc/apache2/ssl/octopus_tech.crt
get_octopusvariable "Certificate.PrivateKeyPem" &gt; /etc/apache2/ssl/private/octopus_tech.key
get_octopusvariable "Certificate.ChainPem" &gt; /etc/apache2/ssl/octopus_tech_bundle.pem

{
cat &lt;&lt; EOF
&lt;VirtualHost *:443&gt;
  ErrorLog ${APACHE_LOG_DIR}/error.log
  CustomLog ${APACHE_LOG_DIR}/access.log combined
  JkMount /* loadbalancer
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/octopus_tech.crt
  SSLCertificateKeyFile /etc/apache2/ssl/private/octopus_tech.key
  SSLCertificateChainFile /etc/apache2/ssl/octopus_tech_bundle.pem
&lt;/VirtualHost&gt;
EOF
} &gt; /etc/apache2/sites-enabled/000-default.conf
systemctl restart apache2
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/runbook.png" class="zoom" data-title=""><img src="../Images/84053fb58f71bfa70157a36dfbebc13a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/runbook.png"/>T2】</a></p>

<p>运行手册完成后，我们可以验证应用是否通过HTTPS公开:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/firefox.png" class="zoom" data-title=""><img src="../Images/3e1a4f5be31dffcad9774598a23cc557.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/firefox.png"/>T2】</a></p>

<h2 id="internal-certificate-management">内部证书管理</h2>

<p>正如我们所看到的，在使用管理器控制台时，直接连接到Tomcat实例是非常有用的。此连接传输凭据，应该通过安全连接完成。为了支持这一点，我们为Tomcat配置了自签名证书。</p>

<h3 id="create-self-signed-certificates">创建自签名证书</h3>

<p>因为我们的Tomcat实例不是通过主机名<a href="https://cabforum.org/internal-names/" rel="nofollow">公开的，所以我们没有为它们获取证书的选项</a>。要启用HTTPS，我们需要创建自签名证书，这可以通过OpenSSL来实现:</p>

<pre><code>openssl genrsa 2048 &gt; private.pem
openssl req -x509 -new -key private.pem -out public.pem -days 3650
openssl pkcs12 -export -in public.pem -inkey private.pem -out mycert.pfx
</code></pre>

<h3 id="add-the-certificate-to-tomcat">将证书添加到Tomcat</h3>

<p>使用<strong>Deploy a certificate to Tomcat</strong>步骤在Tomcat中配置证书。</p>

<p><strong> Tomcat CATALINA_HOME路径</strong>被设置为<code>/usr/share/tomcat9</code>，而<strong> Tomcat CATALINA_BASE路径</strong>被设置为<code>/var/lib/tomcat9</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_paths.png" class="zoom" data-title=""><img src="../Images/b113a35a0590d13b616f7148f0072c6d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_paths.png"/>T2】</a></p>

<p>我们为<strong>选择证书变量</strong>字段引用一个证书变量。<strong> Catalina </strong>的缺省值对于<strong> Tomcat服务名</strong>是合适的。</p>

<p>对于Tomcat如何处理证书，我们有几个选择。一般来说，<strong>阻塞IO </strong>、<strong>非阻塞IO </strong>、<strong>非阻塞IO 2 </strong>和<strong> Apache Portable Runtime </strong>选项的性能越来越高。Apache Portable Runtime 是Tomcat可以利用的一个额外的库，它是由我们和<code>apt-get</code>一起安装的Tomcat包提供的，所以使用这个选项是有意义的。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/tomcat_cert.png" class="zoom" data-title=""> T32 </a></p>

<p>为了允许Tomcat使用新的配置，我们需要使用以下命令通过脚本步骤重新启动服务:</p>

<pre><code>systemctl restart tomcat9
</code></pre>

<p>我们现在可以从<code>https://tomcatip:8443/manager/html</code>加载管理器控制台。</p>

<h2 id="scale-up-to-multiple-environments">纵向扩展到多个环境</h2>

<p>到目前为止，我们创建的基础设施现在可以用作其他测试或生产环境的模板。我们在此展示的内容都不是特定于环境的，这意味着所有流程和基础架构都可以根据需要扩展到任意多个环境。</p>

<p>通过将分配给新Tomcat和负载平衡器实例的触角与Octopus中的其他环境相关联，我们获得了将部署推向生产的能力:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/multiple_environments.png" class="zoom" data-title=""><img src="../Images/6b60d17a50fe89fe4e7e82d44bffa2a2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-04/ultimate-guide-to-tomcat-deployments/multiple_environments.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>如果你已经到了这一步，恭喜你！建立一个零停机部署、分支、回滚和HTTPS的高可用性Tomcat集群并不适合胆小的人。最终用户仍然需要结合多种技术来实现这一结果，但是我希望这篇博客文章中的说明能够揭示出现实世界中Java部署的一些神奇之处。</p>

<p>总而言之，在这篇文章中，我们:</p>

<ul>
<li>配置了带有PostgreSQL数据库的Tomcat会话复制和带有<code>JvmRouteBinderValve</code>阀的会话cookie重写。</li>
<li>使用mod_jk插件配置Apache web服务器作为负载平衡器。</li>
<li>通过Keepalived在负载平衡器之间实现高可用性。</li>
<li>利用Tomcat的并行部署特性和Flyway执行向后兼容的数据库迁移，执行零停机部署。</li>
<li>Smoke用Octopus中的社区步骤测试了部署。</li>
<li>实现了特性分支部署，考虑到了使用Octopus通道的Maven版本控制策略的局限性。</li>
<li>了解了如何回滚应用程序或使其退出服务。</li>
<li>向Apache添加了HTTPS证书。</li>
<li>对多种环境重复该过程。</li>
</ul>

                    
                    
</body>
</html>