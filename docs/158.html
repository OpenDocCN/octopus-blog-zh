<html>
<head>
<title>Database Deployments with Redgate SQL Change Automation, GitHub Actions, and Octopus Deploy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Redgate SQL变更自动化、GitHub Actions和Octopus Deploy - Octopus Deploy进行数据库部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/database-deployments-with-github-actions-and-redgate#2021-08-12">https://octopus.com/blog/database-deployments-with-github-actions-and-redgate#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/github-actions.png" class="zoom" data-title=""><img src="../Images/edd7370c85fa5e5d169c3afbad188956.png" class="img-fluid center" alt="Database Deployments with Redgate SQL Change Automation, GitHub Actions, and Octopus Deploy" data-original-src="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/github-actions.png"/>T2】</a></p>

<p>在本文中，我将向您展示如何使用GitHub Actions构建一个Redgate SQL变更自动化包，并将其推送到Octopus Deploy进行部署。</p>

<p>我一直在准备一个关于数据库部署的网络研讨会。我的示例应用程序已经准备好了，我的部署服务器也准备好了(毫无疑问应该是哪个)，但是我应该使用哪个构建服务器呢？构建服务器只是网上研讨会的一小部分，我不喜欢在Azure DevOps中构建整个项目或建立一个示例Jenkins实例。Ryan最近写道<a href="https://octopus.com/blog/publishing-a-package-to-octopus-with-github-actions">用GitHub Actions </a>发布了一个包给Octopus，所以我决定尝试一下。这种方法带来了几个额外的挑战:</p>

<ul>
<li>安装Redgate的SQL变更自动化来构建数据库包。</li>
<li>Redgate的SQL变更自动化只能在Windows上运行(它需要。NET框架)。</li>
<li>构建Redgate SQL变更自动化包需要创建一个临时数据库，以确保所提议的变更在语法上是正确的。</li>
<li>我还需要安装Octopus CLI，但是Windows没有内置软件包管理器。</li>
<li>我认为有一种更简单的方法来定义版本号。</li>
</ul>

<p>多亏了GitHub Action的优秀文档、一些例子和一些尝试和错误，我克服了所有这些挑战。请继续阅读，看看我是如何做到的。</p>



<h2 id="getting-started">入门指南</h2>

<p>我选择从头开始创建GitHub动作工作流文件。名字之后的第一个决定是监视什么。监控的可能性<a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows#webhook-events" rel="nofollow">相当惊人</a>。这是我的第一个行动，我想在变复杂之前先从简单开始。监控主分支变化的GitHub操作如下所示:</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master
</code></pre>

<h2 id="configuring-to-run-on-windows">配置为在Windows上运行</h2>

<p>定义触发器后，就该定义作业和各个步骤了。我查看的样本被配置为<code>run on</code> Ubuntu:</p>

<pre><code class="language-YAML">jobs:
  build:

    runs-on: ubuntu-latest
</code></pre>

<p>Redgate SQL变更自动化需要在Windows上运行。我并不热衷于站在我自己的服务器上，GitHub称之为runners，这样才能工作，但谢天谢地我不需要这么做。查看<a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on" rel="nofollow"> GitHub动作</a>的文档，GitHub动作可以运行在:</p>



<p>关于托管跑步者的文档提供了更多的见解。点击足够多的链接，你会看到一个页面，上面列出了安装在提供的跑步者上的<a href="https://help.github.com/en/actions/reference/software-installed-on-github-hosted-runners" rel="nofollow">软件。</a></p>

<p>在Windows runner的<a href="https://github.com/actions/virtual-environments/blob/master/images/win/Windows2019-Readme.md" rel="nofollow">安装软件</a>的最顶端是我最喜欢的Windows包管理器，Chocolatey。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/installed-apps-windows-github-action-runner.png" class="zoom" data-title=""><img src="../Images/53854fd3b496b73b4710c4aea9f1c6ae.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/installed-apps-windows-github-action-runner.png"/>T2】</a></p>

<p>现在我们在做饭。我对我需要的Windows版本并不挑剔，所以我选择了<code>windows-latest</code>。</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master

jobs:
  build:
    name: Build and Push Database

    runs-on: windows-latest
</code></pre>

<h2 id="installing-the-octopus-cli">安装Octopus CLI</h2>

<p>我发现的大多数GitHub动作示例都使用了bash脚本。Redgate的SQL变更自动化使用PowerShell cmdlets。好消息是我有一个选择。我的选择是:</p>

<ul>
<li>Bash(所有平台)</li>
<li>PowerShell核心(所有平台)</li>
<li>Python(所有平台)</li>
<li>Sh (Linux/MacOS)</li>
<li>PowerShell (Windows)</li>
<li>批处理或cmd (Windows)</li>
</ul>

<p>这意味着我可以使用Chocolatey来安装包含Octopus CLI的<a href="https://chocolatey.org/packages/OctopusTools" rel="nofollow"> Octopus Tools </a>包:</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master      

jobs:
  build:
    name: Build and Push Database

    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v2

    - name: Install Octopus Tooling
      run: choco install octopustools -y
      shell: powershell
</code></pre>

<h2 id="installing-redgate-sql-change-automation">安装Redgate SQL变更自动化</h2>

<p>这很好，但是SQL变更自动化呢？很长一段时间以来，SQL变更自动化一直是PowerShell的一个模块。PowerShell模块有点独特；您可以将它们安装到中央静态位置或指定的文件夹中。我不确定这方面的最佳实践/建议，所以我将SQL变更自动化包安装到工作目录下的子文件夹中。</p>

<p>我使用GitHub actions的<a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#env" rel="nofollow">环境变量</a>特性为子文件夹名设置一个静态值，这样如果我重命名子文件夹，就不必在多个地方更改它。我添加了创建该文件夹的步骤，然后是将PowerShell模块安装到新文件夹的步骤:</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master   

env:  
  PACKAGES_FOLDER: Modules    

jobs:
  build:
    name: Build and Push Database

    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v2

    - name: Install Octopus Tooling
      run: choco install octopustools -y
      shell: powershell

    - name: Make Install Modules Folder
      run: New-Item "$PSScriptRoot\${env:PACKAGES_FOLDER}" -ItemType Directory -Force
      shell: powershell    

    - name: Install Redgate Tooling
      run: |
        $LocalModules = "$PSScriptRoot\${env:PACKAGES_FOLDER}"

        Get-PackageProvider NuGet -ForceBootstrap | Out-Null
        Import-PackageProvider PowerShellGet 
        Save-Module -Name PowerShellGet -Path $LocalModules -MinimumVersion 1.6 -Force -ErrorAction SilentlyContinue

        Save-Module -Name SqlChangeAutomation -Path $LocalModules -Force -ErrorAction Stop -AcceptLicense        
      shell: powershell  
</code></pre>

<h2 id="building-the-redgate-sql-change-automation-package">构建Redgate SQL变更自动化包</h2>

<p>构建Redgate SQL变更自动化包涉及许多小决策:</p>

<ul>
<li><strong>输出文件夹</strong>:包将要保存到的地方。</li>
<li><strong>包名</strong>:应用程序的包名。</li>
<li><strong>版本号</strong>:包的版本号，对于Octopus Deploy应该是自动递增的。</li>
<li><strong>临时数据库</strong> : Redgate SQL Change Automation将创建一个临时数据库，并尝试运行源代码控制中存储的所有脚本。这样做是为了确保数据库语法正确。</li>
</ul>

<p>对于这一部分，我不会展示整个YAML文件(这将是相当长的)，而是其中的一部分，以突出重点。</p>

<h3 id="output-folder">输出文件夹</h3>

<p>我在这里使用了另一个环境变量，并基于它创建了一个新的输出目录:</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master   

env:  
  PACKAGES_FOLDER: Modules
  OUTPUT_FOLDER: PackagesOutput

jobs:
  build:
    name: Build and Push Database

    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v2        

    - name: Make Packages Output Folder
      run: New-Item "${env:OUTPUT_FOLDER}" -ItemType Directory
      shell: powershell    
</code></pre>

<h3 id="package-name">包名</h3>

<p>构建过程应该是定义包名的过程，我不希望包名改变，所以我为包名设置了一个环境变量:</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master

env:  
  PACKAGES_FOLDER: Modules
  OUTPUT_FOLDER: PackagesOutput
  PACKAGE_NAME: MySampleApplication  
</code></pre>

<h3 id="version-number">版本号</h3>

<p>我遵循以下经验法则来设置版本号:</p>

<ul>
<li>为整个应用程序定义一次</li>
<li>跨应用保持一致</li>
<li>易于维护和更新</li>
</ul>

<p>我个人认为设置版本号应该在GitHub操作或任何构建服务器之外进行。通过将它放在GitHub动作中，意味着只有开发人员可以更改它。太隐蔽了。也就是说，大多数时候，开发人员是唯一改变它的人。</p>

<p>我认为GitHub动作中应该有计算版本号的必要逻辑。你可以让它看看分行名称。或者，在我的例子中，从源代码控制的文件中提取版本前缀。GitHub动作提供了许多预定义的环境变量。我感兴趣的是GITHUB_RUN_NUMBER，因为它总是在增加。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/version-prefix-file.png" class="zoom" data-title=""><img src="../Images/c9e9d87db90af9a989d5436d6fc9b8ff.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/version-prefix-file.png"/>T2】</a></p>

<p>GitHub Actions现在能够设置工作流中其他步骤可以使用的环境变量。语法有点...有趣的是:</p>

<pre><code>echo "::set-env name=[VARIABLE NAME]::[VARIABLE VALUE]
</code></pre>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master      

env:  
  PACKAGES_FOLDER: Modules
  OUTPUT_FOLDER: PackagesOutput
  PACKAGE_NAME: OctopusTrident.Redgate.Database  

jobs:
  build:
    name: Build and Push Database

    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set environment variables      
      run: |        
        $versionFromFile = Get-Content versionprefix.md 
        Write-Host "Found $versionFromFile in versionprefix.md"
        $versionNumber = "$versionfromFile.${env:GITHUB_RUN_NUMBER}"
        Write-Host "Setting environment version number to: $versionNumber"        

        echo "::set-env name=PACKAGE_VERSION::$versionNumber"                
      shell: powershell
</code></pre>

<h3 id="temporary-database">临时数据库</h3>

<p>这个问题难倒我的时间比我愿意承认的要长。我走上了建立一个Azure SQL服务器的道路，使用一个永久的<em>构建</em>数据库。与传统的SQL服务器不同，Azure SQL Server不提供使用<code>Create Database</code> T-SQL命令创建数据库的能力。你必须使用<a href="https://docs.microsoft.com/en-us/azure/sql-database/sql-database-single-database-get-started?tabs=azure-portal" rel="nofollow">门户、ARM模板</a>、TerraForm或Azure CLI。基本上除了T-SQL什么都有。但是我对Azure SQL Server的默认设置有点太严格了。</p>

<p>构建数据库包cmdlet 的<a href="https://documentation.red-gate.com/sca/reference/powershell-cmdlets/new-databasebuildartifact" rel="nofollow">文档说它使用LocalDB作为默认数据库。一时兴起，我在已安装应用列表上做了一个快速查找。你瞧，<code>localdb</code>是预装应用的一部分:</a></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/installed-apps-github-action-runner-localdb.png" class="zoom" data-title=""><img src="../Images/2af9e74bb6517e9e92cae76ac5200f71.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/installed-apps-github-action-runner-localdb.png"/>T2】</a></p>

<h2 id="sensitive-variables-and-invoking-the-octopus-cli">敏感变量和调用Octopus CLI</h2>

<p>您可以使用secrets功能存储GitHub操作的敏感变量。这可以通过访问GitHub UI中的存储库，点击<span class="path">设置➜机密</span>来访问:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/github-actions-secrets.png" class="zoom" data-title=""><img src="../Images/b2d04dfeec24bbdbba63502dc2cddd70.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/database-deployments-with-github-actions-and-redgate/github-actions-secrets.png"/>T2】</a></p>

<p>关于GitHub秘密的几点观察。</p>

<ul>
<li>一个秘密只能写一次。如果您需要更新一个密码，您必须删除该密码，然后重新创建它。</li>
<li>GitHub Actions会竭尽全力阻止你将秘密写入日志。</li>
<li>在PowerShell步骤中访问秘密不像bash那样简单。</li>
</ul>

<p>我被最后一个要点绊倒了。语法最终看起来是这样的:</p>

<pre><code class="language-YAML"> - name: Handoff to Octopus Deploy
      env:
        OCTOPUS_URL: ${{ secrets.OCTOPUS_SERVER_URL }}
        OCTOPUS_API_KEY: ${{ secrets.OCTOPUS_API_KEY }}        
      run: |        
        octo push --package="${env:OUTPUT_FOLDER}\${env:PACKAGE_NAME}.${env:PACKAGE_VERSION}.nupkg" --server="${env:OCTOPUS_URL}" --apiKey="${env:OCTOPUS_API_KEY}" --space="${env:OCTOPUS_SPACE_NAME}"

        octo create-release --project="${env:OCTOPUS_PROJECT_NAME}" --packageVersion="${env:PACKAGE_VERSION}" --releaseNumber="${env:PACKAGE_VERSION}" --server="${env:OCTOPUS_URL}" --apiKey="${env:OCTOPUS_API_KEY}" --space="${env:OCTOPUS_SPACE_NAME}" --deployTo="${env:ENVIRONMENT_NAME}"
</code></pre>

<h2 id="putting-it-all-together">把所有的放在一起</h2>

<p>我已经准备好了构建Redgate SQL变更自动化包、将它推送到Octopus Deploy并创建一个版本所需的所有细节:</p>

<pre><code class="language-YAML">name: Package Database

on:
  push:
    branches: 
      - master   

env:  
  PACKAGES_FOLDER: Modules
  OUTPUT_FOLDER: PackagesOutput
  PACKAGE_NAME: OctopusTrident.Redgate.Database
  OCTOPUS_PROJECT_NAME: Redgate - Feature Branch Example  
  OCTOPUS_SPACE_NAME: Target - SQL Server
  ENVIRONMENT_NAME: Dev

jobs:
  build:
    name: Build and Push Database

    runs-on: windows-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set environment variables      
      run: |        
        $versionFromFile = Get-Content versionprefix.md 
        Write-Host "Found $versionFromFile in versionprefix.md"
        $versionNumber = "$versionfromFile.${env:GITHUB_RUN_NUMBER}"
        Write-Host "Setting environment version number to: $versionNumber"

        echo "::set-env name=PACKAGE_VERSION::$versionNumber"        
      shell: powershell

    - name: Install Octopus Tooling
      run: choco install octopustools -y
      shell: powershell

    - name: Make Install Modules Folder
      run: New-Item "$PSScriptRoot\${env:PACKAGES_FOLDER}" -ItemType Directory -Force
      shell: powershell

    - name: Make Packages Output Folder
      run: New-Item "${env:OUTPUT_FOLDER}" -ItemType Directory
      shell: powershell

    - name: Install Redgate Tooling
      run: |
        $LocalModules = "$PSScriptRoot\${env:PACKAGES_FOLDER}"

        Get-PackageProvider NuGet -ForceBootstrap | Out-Null
        Import-PackageProvider PowerShellGet 
        Save-Module -Name PowerShellGet -Path $LocalModules -MinimumVersion 1.6 -Force -ErrorAction SilentlyContinue

        Save-Module -Name SqlChangeAutomation -Path $LocalModules -Force -ErrorAction Stop -AcceptLicense        
      shell: powershell    

    - name: Build Redgate Packages      
      run: |
        $LocalModules = "$PSScriptRoot\${env:PACKAGES_FOLDER}"
        $env:PSModulePath = "$LocalModules;$env:PSModulePath"

        Import-Module SqlChangeAutomation

        $project = "db/src"
        $validatedProject = $project | Invoke-DatabaseBuild        

        $buildArtifact = New-DatabaseBuildArtifact $validatedProject -PackageId "${env:PACKAGE_NAME}" -PackageVersion "${env:PACKAGE_VERSION}"
        Export-DatabaseBuildArtifact $buildArtifact -Path "${env:OUTPUT_FOLDER}" 
      shell: powershell   

    - name: Handoff to Octopus Deploy
      env:
        OCTOPUS_URL: ${{ secrets.OCTOPUS_SERVER_URL }}
        OCTOPUS_API_KEY: ${{ secrets.OCTOPUS_API_KEY }}        
      run: |        
        octo push --package="${env:OUTPUT_FOLDER}\${env:PACKAGE_NAME}.${env:PACKAGE_VERSION}.nupkg" --server="${env:OCTOPUS_URL}" --apiKey="${env:OCTOPUS_API_KEY}" --space="${env:OCTOPUS_SPACE_NAME}"

        octo create-release --project="${env:OCTOPUS_PROJECT_NAME}" --packageVersion="${env:PACKAGE_VERSION}" --releaseNumber="${env:PACKAGE_VERSION}" --server="${env:OCTOPUS_URL}" --apiKey="${env:OCTOPUS_API_KEY}" --space="${env:OCTOPUS_SPACE_NAME}" --deployTo="${env:ENVIRONMENT_NAME}"

      shell: powershell        
</code></pre>

<h2 id="why-handover-to-octopus-deploy">为什么移交给Octopus Deploy？</h2>

<p>DBA是一群挑剔的人。我曾经和一个DBA一起工作，他反复告诉我，“我想要的只是简单愚蠢的东西。”接下来，他说，“我还想确保开发人员不会向数据库管理员扔垃圾。我们需要知道什么样的变化被部署到生产中。如果有些东西看起来不对劲，我需要阻止它出去。”最后，他告诉我，“当我们部署到生产时，我不希望出现任何意外。我已经厌倦了这种狂野西部的东西，你给我一个你几个小时前写的剧本。”</p>

<p>我相信在工作中使用正确的工具。必要时，我可以用磁铁钉钉子。但是磁石不是锤子。这同样适用于车间工具、开发工具或CI/CD工具。我可能会使用GitHub Actions拼凑一些东西来满足这些需求，但这不是它的设计目的。有了Octopus Deploy，我可以满足所有这些需求。</p>

<p>我将GitHub动作视为任何CI工具。它做什么，它做得很好。但是不要试图强迫它成为它不是的东西。</p>

<h2 id="conclusion">结论</h2>

<p>总而言之，我对GitHub操作的整合程度印象深刻。我能够使用他们的文档、一些例子和几个小时内的一点点尝试和错误，将整个GitHub操作放在一起。此后，我扩展了这个操作来处理特性分支和其他逻辑。但那是以后的事了。</p>

<p>下次再见，愉快的部署！</p>

<p>数据库部署自动化系列文章:</p>



                    
                    
</body>
</html>