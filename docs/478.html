<html>
<head>
<title>Running Octopus Deploy inside a container - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在容器中运行Octopus Deploy-Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octopuscontainer#2022-07-15">https://octopus.com/blog/octopuscontainer#2022-07-15</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-04/octopuscontainer/blogimage-dockercontainer.png" class="zoom" data-title=""><img src="../Images/fb2831595404d05adaf1510c82db6137.png" class="img-fluid center" alt="Octopus Docker Container Banner" data-original-src="https://i.octopus.com/blog/2018-04/octopuscontainer/blogimage-dockercontainer.png"/>T2】</a></p>

<p>在当今快节奏的世界中，我们中的一些人真正需要的是一种更快的下载和运行Octopus Deploy的方法。谢天谢地，Octopus Deploy容器现在已经可以使用了，它允许用户直接从Docker容器内部运行Octopus服务器或触手。<a href="https://hub.docker.com/r/octopusdeploy/octopusdeploy/" rel="nofollow">Octopus deploy/Octopus deploy</a>和<a href="https://hub.docker.com/r/octopusdeploy/tentacle/" rel="nofollow">Octopus deploy/触手</a>映像是在我们的标准Octopus服务器和触手构建过程中构建的，因此您可以始终确保有最新版本可用(升级过程非常简单<em/>，您很快就会看到)。</p>

<h2 id="running-octopus-server-in-a-container">在容器中运行Octopus服务器</h2>

<p>假设您手边有一个SQL数据库(我们将很快演示它本身甚至不是必需的),以最简单的方式启动Octopus服务器容器:</p>

<pre><code class="language-shell">docker run -i --env sqlDbConnectionString=&lt;MyConnectionString&gt; octopusdeploy/octopusdeploy
</code></pre>

<p>在这篇文章中，我不打算深入剖析Docker命令，而是鼓励你查看<a href="https://docs.docker.com/engine/reference/run/" rel="nofollow"> Docker文档</a>以获得更详细的解释。</p>

<p>作为优秀的容器拥护者，我们都知道应该把容器视为不可变的，并且可以在任何时候被拆除。为了解决这个问题，我们应该确保实例使用的服务器文件被写入更持久的内容。Octopus服务器容器提供了几个挂载点，使维护这些文件变得更加容易。此外，尽管容器在端口<code>81</code>上公开了Octopus Web门户，但我们可能希望将其映射到主机上的特定端口。总的来说，上面的命令很好也很简单，但是提供我们自己的管理员凭证来访问新创建的实例可能比依赖缺省值更理想。</p>

<p>让我们为这个命令添加一些配置:</p>

<pre><code class="language-PowerShell">docker run --interactive --detach `
    --name OctopusServer `
    --publish "8081:80" `
    --volume "E:/Octopus/Repository:C:/Repository" `
    --volume "E:/Octopus/Artifacts:C:/Artifacts" `
    --volume "E:/Octopus/TaskLogs:C:/TaskLogs" `
    --env sqlDbConnectionString="Server=172.23.192.1,1433;Initial Catalog=Octopus;Persist Security Info=False;User ID=sa;Password=P@ssw0rdz;MultipleActiveResultSets=False;Connection Timeout=30;" `
    --env OctopusAdminUsername=Mario `
    --env OctopusAdminPassword=ItsAMe! `
    octopusdeploy/octopusdeploy:2018.4.0
</code></pre>

<p>现在一切都已经从容器中具体化了，当我们期待已久的热门新Octopus特性可用时，我们可以轻松地升级Octopus服务器实例。首先，我们需要从最初的Octopus实例中获取主密钥。作为该容器启动过程的一部分，主密钥被写入日志，因此可以通过运行<code>docker logs OctopusServer</code>找到它。有了密钥，我们可以停止原来的容器，并使用新的主密钥环境变量和新的版本标记重新运行上面的运行命令:</p>

<pre><code class="language-PowerShell">docker run --interactive --detach `
    ...
    ...
    --env masterKey=7dnak8asdn23hjasd== `
     octopusdeploy/octopusdeploy:2018.4.1
</code></pre>

<p>嘣，新版本将下载，执行任何必要的数据库迁移，并开始运行。<em>告诉你这是疯狂的简单。</em>查看Octopus服务器映像上的<a href="https://octopus.com/docs/installation/octopus-in-container/octopus-server-container">我们的文档</a>以了解关于可用配置的更多详细信息。</p>

<h2 id="running-tentacle-in-a-container">在容器中运行触手</h2>

<p>Octopus触手容器也是可用的，但是由于Octopus中任何针对触手运行的部署任务都将在容器本身中运行，所以您不太可能使用它来更新IIS网站或部署NodeJS应用程序。这将开始提供更多的价值，当触手可执行程序将能够运行目前局限于“在服务器上运行”的任务。</p>

<p>当一个触手容器启动时，它用提供的服务器细节注册自己。随着未来的变化，触手也将在关闭时重新注册自己，但是该功能仅在最近的Windows容器版本中可用，因此在当前版本中尚未考虑side。</p>

<pre><code class="language-PowerShell">docker run --interactive --detach  `
    --name MyTentacle `
    --env ServerApiKey=API-48AC758FF8912B `
    --env ServerUrl=http://myoctopus.acme.com `
    --env TargetEnvironment=Development `
    --env TargetRole=InnerContainer `
    octopusdeploy/octopusdeploy:2018.4.1
</code></pre>

<p>触手可以配置为轮询或监听模式，同样，查看<a href="https://octopus.com/docs/installation/octopus-in-container/octopus-tentacle-container">我们的文档</a>了解更多关于可用设置的详细信息。</p>

<h2 id="no-sql-no-worries">没有SQL？别担心</h2>

<p>“可是抢！”我听到你说，“我没有一个SQL服务器可以运行Octopus。”嗯，这很好，因为我们可以利用<a href="https://docs.docker.com/compose/overview/" rel="nofollow"> Docker Compose </a>在我们的Octopus服务器旁边构建一个SQL数据库容器。(<em>注意:围绕在容器中运行数据库以用于生产目的，有很多观点。我们倾向于同意。接下来的这些例子可能最好留给测试和实验。</em></p>

<p>使用下面的<code>docker-compose.yml</code>文件:</p>

<pre><code class="language-YAML">version: '2.1'
services:
  db:
    image: microsoft/mssql-server-windows-express
    environment:
      sa_password: "${SA_PASSWORD}"
      ACCEPT_EULA: "Y"
    healthcheck:
      test: [ "CMD", "sqlcmd", "-U", "sa", "-P", "${SA_PASSWORD}", "-Q", "select 1" ]
      interval: 10s
      retries: 10
  octopus:
    image: octopusdeploy/octopusdeploy:${OCTOPUS_VERSION}
    environment:
      OctopusAdminUsername: "${OCTOPUS_ADMIN_USERNAME}"
      OctopusAdminPassword: "${OCTOPUS_ADMIN_PASSWORD}"
      sqlDbConnectionString: "Server=db,1433;Initial Catalog=Octopus;Persist Security Info=False;User ID=sa;Password=${SA_PASSWORD};MultipleActiveResultSets=False;Connection Timeout=30;"
    ports:
     - "8081:81"
    depends_on:
      db:
        condition: service_healthy
    stdin_open: true
    volumes:
      - "E:/Octopus/Repository:C:/Repository"
      - "E:/Octopus/TaskLogs:C:/TaskLogs"
networks:
  default:
    external:
      name: nat
</code></pre>

<p>以及附带的<code>.env</code>文件:</p>

<pre><code>SA_PASSWORD=P@ssw0rd!
OCTOPUS_VERSION=2018.3.13
OCTOPUS_ADMIN_USERNAME=admin
OCTOPUS_ADMIN_PASSWORD=SecreTP@ass
</code></pre>

<p>只需运行:</p>

<pre><code class="language-shell">docker-compose --project-name Octopus up -d
</code></pre>

<p>在短暂的等待之后，您将拥有一个自包含的SQL Server和Octopus Server实例，可以为您的应用程序执行部署了。</p>

<p>在<a href="https://octopus.com/docs/installation/octopus-in-container/docker-compose#octopus-server-and-tentacle">我们的文档</a>中，我们还指出了如何利用Octopus服务器映像上的<code>C:\Import</code>卷挂载来提供初始化数据以预填充数据库，然后在同一个<code>docker-compose</code>脚本中包含多个触角。</p>

<h2 id="octopus-and-containers">章鱼和容器</h2>

<p>这种在容器内运行Octopus的最新能力进一步巩固了Octopus Deploy的承诺，即为希望在其环境中更好地利用容器的用户提供改进的解决方案。目前正在开发中的Kubernetes特性将允许在您的部署中与容器进行更深入的集成，而与平台无关。让我们知道您对我们未来方向的想法，看看我们的<a href="https://octopus.com/docs/deployments/docker">现有的</a> Docker产品和快乐(集装箱化)部署！</p>

                    
                    
</body>
</html>