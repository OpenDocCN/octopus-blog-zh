<html>
<head>
<title>Trying Raw Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>尝试生章鱼-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/trying-raw-octopus#2022-07-20">https://octopus.com/blog/trying-raw-octopus#2022-07-20</a></blockquote>
                        <p>卡拉马里&amp;为你的SSH目标部署Mono-free。</p>

<h2>原始脚本</h2>

<p>如果你已经阅读了一些我们很棒的<a href="http://docs.octopusdeploy.com/">文档</a>，你可能会遇到下面这个简单的架构图。</p>

<p><img src="../Images/c8196abfa29b15d582908e62249f10d0.png" alt="Halibut" data-original-src="https://i.octopus.com/blog/201702-halibut-9GY6.png"/></p>

<p>这描述了一个标准的Windows安装，其中Octopus服务器使用<a href="https://octopus.com/docs/api-and-integration/calamari"> Calamari </a>通过安装的<a href="https://octopus.com/docs/infrastructure/deployment-targets/windows-targets/tentacle-communication">触手</a>执行部署，触手提供通信通道。有了<a href="https://octopus.com/docs/infrastructure/deployment-targets/linux/ssh-target"> SSH </a>部署，SSH连接消除了对触手的需求，因此Octopus可以直接向远程目标上的Calamari发出命令</p>

<p><img src="../Images/7a4bcfc81531f5d845bd9afe721a9e7e.png" alt="SSH" data-original-src="https://i.octopus.com/blog/201702-ssh-B2BL.png"/></p>

<p>对于某些场景，这似乎还不够远。甚至运行Calamari(及其核心依赖<a href="http://www.mono-project.com/"> mono </a>)的需求有时也是用户没有或不想要的奢侈品。也许你正试图在无法安装mono的硬件负载平衡器或IOT设备上简单地执行一些脚本。也许mono在80年代被分回来的那个不知名的Unix发行版上不被支持，bash shell也还没有被移植。出于这个原因，我们已经发布了一个隐藏的特性，叫做<a href="https://octopus.com/docs/deploying-applications/custom-scripts/raw-scripting">原始脚本</a>，它通过一个特殊的项目变量，允许你的脚本步骤通过打开的SSH连接直接执行<em>，而不需要Octopus进行任何额外的包装或引导。结合3.7.12中新的<a href="https://octopus.com/docs/deployments/packages/transfer-package">传输包</a>步骤，您现在可以将您的应用程序部署到您的Linux服务器上，甚至不知道什么是mono！</em></p>

<p><img src="../Images/3de8a2e37f02b305a4bcb0ac85057c4a.png" alt="Raw" data-original-src="https://i.octopus.com/blog/201702-naked-ERBJ.png"/></p>

<blockquote>
  <p>我们真的只是打开一个SSH连接，按原样传递您的脚本。</p>
</blockquote>

<h2>转移包裹</h2>

<p><img src="../Images/50fb6fc3cf89b12820b8866548184ab1.png" data-original-src="https://i.octopus.com/blog/201702-transfer-2C42.png"/>对于某些部署，您可能只是希望将包传输到远程目标，而不是实际解压缩。也许它需要通过脚本进一步处理或上传到另一个服务器。新的<code>Transfer A Package</code>步骤的工作方式与普通的<code>Deploy A Package</code>步骤非常相似，除了没有真正提取包内容，也没有任何额外的脚本可以作为该步骤的一部分运行。在正常部署(非原始)中使用时，获取阶段可以利用<a href="https://octopus.com/docs/deployments/packages/delta-compression-for-package-transfers">增量压缩</a>和<a href="https://octopus.com/docs/administration/retention-policies">保留策略</a>，然后将包从其暂存位置复制到您提供的目标路径。如果在原始脚本编写期间发生包传输，则上述采集优化都不会发生(因为它们是由Calamari执行的),而是将包从上传暂存位置<em>移动</em>到目的地。<br/></p>

<h2>设置它</h2>

<p>为原始脚本设置您的项目只是配置一个标准的<a href="https://octopus.com/docs/infrastructure/deployment-targets/linux/ssh-target"> SSH目标</a>，然后添加项目级变量<code>OctopusUseRawScript</code>。这个标志只对项目中的包传输和脚本步骤有影响。<img src="../Images/459120fa6a9651c615f03fbb4ca5bba9.png" data-original-src="https://i.octopus.com/blog/201702-variable-5MTU.png"/></p>

<p>我们在文档中包含了一个<a href="https://octopus.com/docs/deployments/custom-scripts/raw-scripting">指南，概述了部署和运行一个简单打包脚本的简短步骤，而无需在目标上做任何额外的工作。</a></p>

<p>关于原始脚本，有一件事怎么强调都不为过，那就是我们实际上只是打开了一个SSH连接，并按原样传递您的脚本。这意味着您需要了解与典型SSH部署的一些行为差异:</p>

<ul>
<li>标准的SSH健康检查测试各种依赖项的存在，比如Mono和Calamari。如果打算在原始脚本中专门使用端点，您可能希望配置它们的<a href="https://octopus.com/docs/infrastructure/deployment-targets/machine-policies">机器策略</a>来仅执行连接性测试，以避免它们的健康检查失败。该设置现在从版本<code>3.10.1</code>开始可用。</li>
</ul>

<p><img src="../Images/1b4c8637b212acd03f70c2f0ed9c1a82.png" data-original-src="https://i.octopus.com/blog/201702-machinepolicy-23V9.png"/></p>

<ul>
<li><p>如果您的默认shell不是bash，那么您的脚本将不会在bash中运行。确保您相应地配置了您的登录shell或编写了您的脚本。</p></li>
<li><p><code>get_octopusvariable</code>函数在你的脚本中将不再可用，因为它是由一个Calamari引导程序脚本提供的。相反，您可以编写脚本来利用<a href="https://octopus.com/docs/projects/variables/variable-substitutions">变量替换语法</a> ( <code>#{MyVariable}</code>)，该语法将在传递给远程目标并被远程目标调用之前被替换。这显然排除了只能在远程目标上解析的环境变量。</p></li>
<li><p><code>set_outputvariable</code>和<code>new_artifact</code>功能也不可用。因为Octopus Deploy仍然会监听和响应这些服务消息，所以您可以自己编写这些服务消息来解决这个问题。查看Calamari <a href="https://github.com/OctopusDeploy/Calamari/blob/master/source/Calamari/Integration/Scripting/Bash/Bootstrap.sh#L62">源代码</a>中的引导脚本以获取详细信息。</p></li>
</ul>

<h2>生吃</h2>

<p>最终，这个特性为那些无法安装Octopus在SSH端点上运行Calamari所需的元素的用户提供了一种机制。虽然我们可以为Windows机器上的原始脚本提供额外的支持(默认情况下在PowerShell会话中运行，sans-Calamari ),但我们认为这是一个不太可能需要的场景，因为存在安装和运行整个触手服务的不可避免的需求。对于那些有这种需求的人(或者只是想在SSH上获得更简洁、更快速的部署体验)，我们鼓励您尝试一下，并让我们知道您认为哪里有改进的空间。</p>

                    
                    
</body>
</html>