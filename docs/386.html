<html>
<head>
<title>Kubernetes 1.20 is deprecating Docker Runtime: What does this mean? - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Kubernetes 1.20正在贬低Docker运行时:这是什么意思？-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/kubernetes-1-20-deprecating-docker-runtime#2021-08-12">https://octopus.com/blog/kubernetes-1-20-deprecating-docker-runtime#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/kubernetes-1-20-deprecating-docker-runtime/kubernetes-1-20-deprecating-docker-runtime.png" class="zoom" data-title=""><img src="../Images/469877ca752ae8f7d6a2b482e7ae3743.png" class="img-fluid center" alt="Kubernetes 1.20 is deprecating Docker Runtime: What does this mean?" data-original-src="https://i.octopus.com/blog/2020-12/kubernetes-1-20-deprecating-docker-runtime/kubernetes-1-20-deprecating-docker-runtime.png"/>T2】</a></p>

<p>在11月11日至12月4日的一周时间里，有很多关于Kubernetes放弃支持Docker的问题和担忧。</p>

<p>问题是，事实并非如此。Kubernetes不会放弃对Docker的支持。他们放弃了对Docker运行时的运行时支持。你要记住，Docker是一个完整的栈，而不仅仅是一个容器或者一个容器运行时。Docker包含几个组件。</p>

<h2 id="dont-panic">不要惊慌</h2>

<p>我向你保证这并不像听起来那么疯狂。事实上，这整件事已经计划了好几年了。如果你是Kubernetes的用户，比如Azure Kubernetes Service (AKS)或Elastic Kubernetes Service (EKS ),对你来说没什么变化。这几乎会像以前一样继续下去。例如，如果您将AKS中的Kubernetes API版本升级到1.19，您已经在运行<a href="https://containerd.io/" rel="nofollow"> Containerd </a>，这是一个运行时，就像Docker运行时一样。</p>

<p>您当前用来构建容器和映像的所有东西都将继续工作，包括:</p>

<ul>
<li><a href="https://docs.docker.com/engine/reference/builder/" rel="nofollow"> Dockerfiles </a>:你仍然可以在Kubernetes中构建<strong> Docker </strong>映像并运行容器。</li>
<li>Docker编写:它仍然可以在你的本地Docker实例上工作。</li>
<li><a href="https://hub.docker.com/" rel="nofollow"> Dockerhub </a> : Dockerhub还会存在。记住，Docker是一个巨大的堆栈。Docker图像只是该堆栈的一部分。</li>
<li>其他Docker注册表:它们仍然可以工作。构建、存储和维护Docker映像的方式保持不变。</li>
</ul>

<h2 id="kubernetes-1.20-is-deprecating-docker-whats-actually-happening">Kubernetes 1.20正在贬低Docker——实际上发生了什么？</h2>

<p>让我们来看看发生了什么，为什么会发生。</p>

<p>Docker是作为一个整体构建的，但事情正在向更现代的应用程序方法转变。运行时由<a href="https://godoc.org/k8s.io/kubernetes/pkg/kubelet/dockershim" rel="nofollow"> Dockershim </a>提供，这是正在改变的事情之一，它导致了许多混乱。</p>

<p>Dockershim使用Kubernetes为Docker集成实现了一个容器运行时接口。然而，远离Dockershim始终是一个目标(因此，名称中有“shim”)。最初创建它是为了帮助实现与Kubernetes的集成，但最终它只是一个额外的跳跃。正因为如此，Docker开始开发Containerd。</p>

<p>Containerd很像<a href="https://www.redhat.com/en/blog/introducing-cri-o-10#:%7E:text=CRI%2DO%3A%20A%20Lightweight%20Container%20Runtime%20for%20Kubernetes&amp;text=The%20name%20derives%20from%20CRI,support%20any%20OCI%2Dconformant%20runtime." rel="nofollow"> CRI-O </a>，是一个容器运行时，是开放容器倡议的一部分(<a href="https://opencontainers.org/" rel="nofollow"> OCI </a>)。</p>

<p>Kubernetes维护Dockershim成为他们肩上的一个巨大负担，因为Dockershim是到达Kubernetes运行时的额外一跳。正因为如此，Kubernetes决定使用CRI，这使得容器运行时的互操作性可以非常平稳地过渡。这意味着，不再需要<em>跳</em>。</p>

<p>现在，问题来了。Docker不实现CRI，这就是Docker运行时被弃用的原因。</p>

<h2 id="kubernetes-is-deprecating-dockershim-this-was-planned">Kubernetes是不赞成Dockershim -这是有计划的</h2>

<p>除掉多克西姆一直是我的计划。因为Dockershim需要额外的一跳，这根本不是有效的，而且在他们开发Containerd时，它实际上只是一个占位符。</p>

<h2 id="what-happens-in-kubernetes-1.20">Kubernetes 1.20中发生了什么</h2>

<p>从Kubernetes API版本1.20开始，Docker运行时将被正式弃用。如果你还有Docker运行时，那也没关系。但是，您应该开始考虑迁移到另一个运行时。</p>

<p>从1.20开始，如果你还在使用Docker运行时，kubelet启动时会打印一个警告日志。仅此而已，只是一个警告信息。</p>

<p>截至目前，Kubernetes不带Dockershim的最早版本是2021年末的1.23版本。简而言之，你大概有一年左右的时间来准备。</p>

<h2 id="whos-impacted">谁受到了影响</h2>

<p>随着所有变革的进行，让我们来分析一下谁受到了影响。</p>

<p>首先，如果你正在编写代码，将代码容器化，然后运输，你不会受到影响。事实上，你可能根本看不出或感觉不到有什么不同。你一切都一帆风顺。</p>

<p>如果您是Kubernetes集群管理员，您会受到影响，但不会很严重。您所要做的就是用CRI-O、Containerd或其他符合CRI的运行时替换Docker运行时。</p>

<p>这里有一个关于如何实现Containerd的很棒的帖子和分解:<a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/#cri-o" rel="nofollow">https://kubernetes . io/docs/setup/production-environment/container-runtimes/# CRI-o</a>。</p>

<h2 id="closing-thoughts">结束语</h2>

<p>幸运的是，这种变化远没有大家最初预期的那么严重。作为一名开发人员，您几乎不会注意到区别。作为一名操作人员，您必须更新到一个容器运行时，而不是Docker运行时。这一改变是朝着正确方向迈出的一步，消除了与Dockershim之间的额外跳跃。现在，Kubernetes少了一件需要维护的事情，而且产品速度也更快了。</p>

                    
                    
</body>
</html>