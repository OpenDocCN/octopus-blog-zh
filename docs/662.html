<html>
<head>
<title>Selenium series: Firefox debugging tricks - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:Firefox调试技巧- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/12-firefox-debugging-tips/firefox-debugging-tips#2021-07-07">https://octopus.com/blog/selenium/12-firefox-debugging-tips/firefox-debugging-tips#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>我在使用代理时多次遇到的一个常见问题是Firefox中一个微妙的错误配置，它会导致抛出错误。</p>

<p>为了模拟这个错误，让我们尝试在<code>BrowserMobDecorator</code>类中配置SOCKS代理。</p>

<p>SOCKS代理用于代理TCP数据包，这意味着它们可以用于HTTP、HTTPS、FTP和一系列其他高级协议。我们不会使用BrowserMob作为SOCKS代理，但是在这里配置它是演示错误配置错误的一个有用的方法。</p>

<p>我们通过调用<code>seleniumProxy.setSocksProxy(proxyStr)</code>来配置SOCKS代理:</p>

<pre><code class="language-java">@Override
public DesiredCapabilities getDesiredCapabilities() {

  proxy = new BrowserMobProxyServer();

  proxy.start(0);

  final Proxy seleniumProxy = new Proxy();
  final String proxyStr = "localhost:" + proxy.getPort();
  seleniumProxy.setHttpProxy(proxyStr);
  seleniumProxy.setSslProxy(proxyStr);
  seleniumProxy.setSocksProxy(proxyStr);

  final DesiredCapabilities desiredCapabilities =
    getAutomatedBrowser().getDesiredCapabilities();

  desiredCapabilities.setCapability(CapabilityType.PROXY, seleniumProxy);

  return desiredCapabilities;
}
</code></pre>

<p>在Firefox中以这种配置运行测试将导致抛出下面的异常:</p>

<pre><code>org.openqa.selenium.SessionNotCreatedException: InvalidArgumentError: Expected [object Undefined] undefined to be an integer
Build info: version: '3.12.0', revision: '7c6e0b3', time: '2018-05-08T14:04:26.12Z'
System info: host: 'Christinas-MBP', ip: '192.168.1.84', os.name:
'Mac OS X', os.arch: 'x86_64', os.version: '10.13.5', java.version: '1.8.0_144'
Driver info: driver.version: FirefoxDriver
remote stacktrace: WebDriverError@chrome://marionette/content/error.js:178:5
InvalidArgumentError@chrome://marionette/content/error.js:305:5
assert.that/&lt;@chrome://marionette/content/assert.js:405:13
assert.integer@chrome://marionette/content/assert.js:256:10
assert.positiveInteger@chrome://marionette/content/assert.js:274:3
fromJSON@chrome://marionette/content/session.js:291:28
match_@chrome://marionette/content/session.js:458:23
fromJSON@chrome://marionette/content/session.js:427:12
GeckoDriver.prototype.newSession@chrome://marionette/content/driver.js:693:25
despatch@chrome://marionette/content/server.js:293:20
execute@chrome://marionette/content/server.js:267:11
onPacket/&lt;@chrome://marionette/content/server.js:242:15
onPacket@chrome://marionette/content/server.js:241:8
_onJSONObjectReady/&lt;@chrome://marionette/content/transport.js:500:9
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/12-firefox-debugging-tips/image1.png" class="zoom" data-title=""><img src="../Images/d208b27ff7ad43c6c790c49e3847c1f6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/12-firefox-debugging-tips/image1.png"/>T2】</a></p>

<p>从异常中的消息来看，似乎某些远程JavaScript代码导致了一个错误。但是这段JavaScript代码在哪里，我们如何调试错误呢？</p>

<p>查看JavaScript堆栈跟踪，错误的来源似乎在这两行代码中。一个名为<code>fromJSON()</code>的方法断言一个整数是正的，这个断言失败了:</p>

<pre><code>assert.positiveInteger@chrome://marionette/content/assert.js:274:3
fromJSON@chrome://marionette/content/session.js:291:28
</code></pre>

<p>调试这个错误的关键是要理解文件<code>chrome://marionette/content/session.js</code>是和Firefox捆绑在一起的。如果你在Firefox中输入这个网址，你可以看到文件的来源。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/12-firefox-debugging-tips/image2.png" class="zoom" data-title=""><img src="../Images/f45d7adabf2f0a5e1889129331e51302.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/12-firefox-debugging-tips/image2.png"/>T2】</a></p>

<p>在这种情况下，有问题的代码行是:</p>

<pre><code>p.socksVersion = assert.positiveInteger(json.socksVersion);
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/12-firefox-debugging-tips/image3.png" class="zoom" data-title=""><img src="../Images/d80139d025350f011224083f850ce86f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/12-firefox-debugging-tips/image3.png"/>T2】</a></p>

<p>从这段代码中，我们可以推断出我们需要定义SOCKS代理的版本。</p>

<p>理论上，您可以用下面的代码在<code>BrowserMobDecorator</code>类中定义SOCKS代理版本:</p>

<pre><code class="language-java">@Override
public DesiredCapabilities getDesiredCapabilities() {
  // ...
  seleniumProxy.setSocksVersion(5);
  // ...
}
</code></pre>

<p>实际上，WebDriver库中的错误仍然会导致代码失败。然而，从这篇文章中得到的重要信息是，当您看到Firefox stack traces带有以<code>chrome://marionette/</code>开头的URL时，您可以通过直接在Firefox中输入URL来访问这些文件的源代码，以便调试根本原因。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>