<html>
<head>
<title>Selenium series: adding the BrowserMob proxy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:添加BrowserMob代理- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/11-adding-the-browsermob-proxy/adding-the-browsermob-proxy#2021-07-07">https://octopus.com/blog/selenium/11-adding-the-browsermob-proxy/adding-the-browsermob-proxy#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>在这篇文章中，我们将添加对BrowserMob代理的支持，这是一个免费的开源Java代理服务器。然后，我们将使用BrowserMob保存一个包含测试期间所有网络请求的报告，并截取一些网络请求。</p>

<p>为了利用BrowserMob库，我们需要将它作为一个依赖项添加到Maven <code>pom.xml</code>文件中:</p>

<pre><code class="language-xml">&lt;project 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;!-- ... --&gt;

  &lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;browsermob.version&gt;2.1.5&lt;/browsermob.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;!-- ... --&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;net.lightbody.bmp&lt;/groupId&gt;
      &lt;artifactId&gt;browsermob-core&lt;/artifactId&gt;
      &lt;version&gt;${browsermob.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

<p>BrowserMob代理的一个实例将被一个名为<code>BrowserMobDecorator</code>的新装饰器创建和销毁:</p>

<pre><code class="language-java">package com.octopus.decorators;

import com.octopus.AutomatedBrowser;
import com.octopus.decoratorbase.AutomatedBrowserBase;
import net.lightbody.bmp.BrowserMobProxy;
import net.lightbody.bmp.BrowserMobProxyServer;
import org.openqa.selenium.Proxy;
import org.openqa.selenium.remote.CapabilityType;
import org.openqa.selenium.remote.DesiredCapabilities;

public class BrowserMobDecorator extends AutomatedBrowserBase {

    private BrowserMobProxy proxy;

    public BrowserMobDecorator(final AutomatedBrowser automatedBrowser) {
        super(automatedBrowser);
    }

    @Override
    public DesiredCapabilities getDesiredCapabilities() {
        proxy = new BrowserMobProxyServer();
        proxy.start(0);

        final DesiredCapabilities desiredCapabilities =
                getAutomatedBrowser().getDesiredCapabilities();

        final Proxy seleniumProxy = new Proxy();
        final String proxyStr = "localhost:" + proxy.getPort();

        seleniumProxy.setHttpProxy(proxyStr);
        seleniumProxy.setSslProxy(proxyStr);
        desiredCapabilities.setCapability(CapabilityType.PROXY, seleniumProxy);
        return desiredCapabilities;
    }

    @Override
    public void destroy() {
        getAutomatedBrowser().destroy();
        if (proxy != null) {
            proxy.stop();
        }
    }
}
</code></pre>

<p>让我们来分解这个类中的代码。</p>

<p>在<code>getDesiredCapabilities()</code>方法中，我们创建了一个<code>BrowserMobProxyServer</code>类的实例，并调用它的<code>start()</code>方法。通过将<code>0</code>传递给<code>start()</code>方法，我们可以在任何可用的端口上公开代理:</p>

<pre><code class="language-java">proxy = new BrowserMobProxyServer();
proxy.start(0);
</code></pre>

<p>WebDriver代理配置信息保存在<code>Proxy</code>类的实例中:</p>

<pre><code class="language-java">final Proxy seleniumProxy = new Proxy();
</code></pre>

<p>然后，我们需要构建一个表示代理网络地址的字符串。因为代理将在本地运行，所以主机名将始终是<code>localhost</code>。</p>

<p>代理暴露的端口可以在每次测试运行时改变，因为我们用<code>0</code>调用了<code>start()</code>方法，表明BrowserMob代理应该使用一个可用的端口。我们可以通过调用<code>proxy</code>上的<code>getPort()</code>方法来获取被占用的端口。</p>

<p>这两个字符串组合在一起形成一个类似于<code>localhost:57470</code>的字符串:</p>

<pre><code class="language-java">final String proxyStr = "localhost:" + proxy.getPort();
</code></pre>

<p>然后我们配置<code>Proxy</code>对象将HTTP和HTTPS流量定向到本地代理:</p>

<pre><code class="language-java">seleniumProxy.setHttpProxy(proxyStr);
seleniumProxy.setSslProxy(proxyStr);
</code></pre>

<p>接下来，我们得到一个<code>DesiredCapabilities</code>对象的副本。如果您还记得上一篇文章，该对象用于配置可应用于任何由WebDriver启动的浏览器的设置:</p>

<pre><code class="language-java">final DesiredCapabilities desiredCapabilities =
  getAutomatedBrowser().getDesiredCapabilities();
</code></pre>

<p>然后用<code>Proxy</code>实例配置<code>DesiredCapabilities</code>实例。</p>

<p>在之前的文章中，我们注意到<code>DesiredCapabilities</code>类本质上是一个键/值存储。现在你可以在实践中看到这一点，因为我们根据<code>CapabilityType.PROXY</code>值保存了<code>Proxy</code>实例。</p>

<p><code>CapabilityType.PROXY</code>是设置为<code>proxy</code>的字符串常量，该值被所有浏览器识别为包含代理配置设置:</p>

<pre><code class="language-java">desiredCapabilities.setCapability(CapabilityType.PROXY, seleniumProxy);
</code></pre>

<p>然后返回<code>DesiredCapabilities</code>实例，以便其他decorators可以添加到它，或者使用它来构建浏览器驱动程序:</p>

<pre><code class="language-java">return desiredCapabilities;
</code></pre>

<p>更新<code>AutomatedBrowserFactory</code>类以创建<code>BrowserMobDecorator</code>类的新实例:</p>

<pre><code class="language-java">private AutomatedBrowser getChromeBrowser(final boolean headless) {
  return new ChromeDecorator(headless,
    new ImplicitWaitDecorator(10,
      new BrowserMobDecorator(
        new WebDriverDecorator()
      )
    )
  );
}

private AutomatedBrowser getFirefoxBrowser(final boolean headless) {
  return new FirefoxDecorator(headless,
    new ImplicitWaitDecorator(10,
      new BrowserMobDecorator(
        new WebDriverDecorator()
      )
    )
  );
}

private AutomatedBrowser getChromeBrowserNoImplicitWait() {
  return new ChromeDecorator(
    new BrowserMobDecorator(
      new WebDriverDecorator()
    )
  );
}

private AutomatedBrowser getFirefoxBrowserNoImplicitWait() {
  return new FirefoxDecorator(
    new BrowserMobDecorator(
      new WebDriverDecorator()
    )
  );
}
</code></pre>

<p>现在我们的<code>AutomatedBrowserFactory</code>正在配置浏览器将流量传递给BrowserMob代理的实例。这不会改变测试的运行方式；代理被设计成对最终用户基本不可见，因此我们的测试将像以前一样运行。然而，如果我们愿意的话，我们现在有办法监控和拦截网络请求。</p>

<p>我们可以通过在测试运行后保持浏览器窗口打开来确认BrowserMob代理正在被创建。Firefox特别容易看到代理设置，所以在下面的测试方法中，我们通过注释掉对<code>finally</code>块中<code>automatedBrowser.destroy()</code>的调用，在测试完成后让浏览器窗口保持打开:</p>

<pre><code class="language-java">@Test
public void formTestByIDFirefox() throws URISyntaxException {

  final AutomatedBrowser automatedBrowser =
    AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Firefox");

  try {
    automatedBrowser.init();

    automatedBrowser.goTo(FormTest.class.getResource("/form.html").toURI().toString());

    automatedBrowser.clickElementWithId("button_element");
    assertEquals("Button Clicked", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.populateElementWithId("text_element", "test text");
    assertEquals("Text Input Changed", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.populateElementWithId("textarea_element", "test text");
    assertEquals("Text Area Changed", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.selectOptionByTextFromSelectWithId("Option 2.1", "select_element");
    assertEquals("Select Changed", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.clickElementWithId("radio3_element");
    assertEquals("Radio Button Changed", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.clickElementWithId("checkbox2_element");
    assertEquals("Checkbox Changed", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.clickElementWithId("image_element");
    assertEquals("Image Clicked", automatedBrowser.getTextFromElementWithId("message"));

    automatedBrowser.clickElementWithId("div_element");
    assertEquals("Div Clicked", automatedBrowser.getTextFromElementWithId("message"));
  } finally {
    //automatedBrowser.destroy();
  }
}
</code></pre>

<p>测试完成后，它启动的Firefox浏览器仍会显示。然后从菜单中，我们可以选择<code>Preferences</code>选项。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/11-adding-the-browsermob-proxy/image1.png" class="zoom" data-title=""><img src="../Images/2453f2b8dd3b5516b5fb4d29e85fead4.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/11-adding-the-browsermob-proxy/image1.png"/>T2】</a></p>

<p>在首选项页面的底部是<code>Network Proxy</code>部分。点击<code>Settings...</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/11-adding-the-browsermob-proxy/image2.png" class="zoom" data-title=""><img src="../Images/e5f03993da50e9b6264093d8fe4f8322.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/11-adding-the-browsermob-proxy/image2.png"/>T2】</a></p>

<p>这里我们可以看到我们在代码中定义的代理设置。这是对我们的代理已经通过WebDriver配置的确认。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/11-adding-the-browsermob-proxy/image3.png" class="zoom" data-title=""><img src="../Images/8047b70e7f38941d5f946660cf479ae1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/11-adding-the-browsermob-proxy/image3.png"/>T2】</a></p>

<p>配置代理服务器使我们能够观察测试过程中的网络请求并与之交互，这是单独使用WebDriver无法做到的。下一步是公开对我们有用的BrowserMob代理的特性。但是在我们这样做之前，我们将看一看在配置代理时可能出现的常见错误配置，并了解如何调试显示的错误。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>