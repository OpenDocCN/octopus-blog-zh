<html>
<head>
<title>Variable specificity and complexity - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>可变特异性和复杂性- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/variable-specificity-and-complexity#2019-02-25">https://octopus.com/blog/variable-specificity-and-complexity#2019-02-25</a></blockquote>
                        <p>Octopus允许变量作用于不同的环境、角色或机器。这很有用的一个简单例子是，根据您是部署到测试环境还是生产环境，数据库连接字符串有不同的值。</p>

<p><img src="../Images/6d9226ab8cf02033c205ec65b34c726b.png" alt="Variable scoping" data-original-src="https://i.octopus.com/docs/images/3048305/3278293.png"/></p>

<p>变量的范围可以是多个值，因此在给定的场景中决定哪个变量是合理的是一个非常棘手的过程。我们称之为<strong>可变特异性</strong>，它的工作原理有点像<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity"> CSS特异性</a>。</p>

<p>例如，假设我们有这组变量:</p>

<pre><code>DatabaseName = DB01 (Environment: Staging, Production)
DatabaseName = DB02 (Environment: Staging)
DatabaseName = DB03 (Environment: Production)
</code></pre>

<p>在这种情况下，如果我们部署到生产环境，要使用的正确值可能是<code>DB01</code>或<code>DB03</code>，因为两者匹配。有时候变量作用域的结果是不确定的，我认为这很直观。</p>

<p>每个范围级别都有不同的优先级:</p>

<ul>
<li>作用域为机器的变量比作用域为角色的变量更具体</li>
<li>...这比环境范围内的变量更具体</li>
<li>...这比没有范围的变量更具体</li>
</ul>

<p>这通常也有直观的意义——机器比环境更细粒度，因此范围应该优先。</p>

<p>在Octopus中计算变量的特异性如下:</p>

<pre><code>public int Rank()
{
    var score = 0;
    score += Score(ScopeField.Private, 10000000);
    score += Score(ScopeField.User, 1000000);
    score += Score(ScopeField.Action, 100000);
    score += Score(ScopeField.Machine, 10000);
    score += Score(ScopeField.TargetRole, 1000);
    score += Score(ScopeField.Role, 100);
    score += Score(ScopeField.Environment, 10);
    score += Score(ScopeField.Project, 1);
    return score;
}
</code></pre>

<p>如果多个变量与一个场景相匹配，我们只需取排名第一的变量。较高优先级的项目在较低优先级的项目之前提高等级。例如，在生产中，我使用一个数据库，但是我的报告服务应该总是使用不同的数据库:</p>

<pre><code>DatabaseName = DB01 (no scope)
DatabaseName = DB02 (Environment: Staging)
DatabaseName = DB03 (Environment: Production)
DatabaseName = DB04 (Role: Reporting)
DatabaseName = DB05 (Role: Reporting; Environment: Production)
</code></pre>

<p>这很有效——我的报告应用程序甚至在准备阶段也会得到<code>DB04</code>,因为角色比环境更具体。但是在生产中，我可以通过在两个层次上界定它来强制它。</p>

<p>容易混淆的一个地方是涉及角色的多个匹配。举第一个例子，但让我们考虑角色，而不是环境:</p>

<pre><code>DatabaseName = DB01 (Role: WebServer, AppServer)
DatabaseName = DB02 (Role: WebServer)
DatabaseName = DB03 (Role: AppServer)
</code></pre>

<p>现在，我不能一次部署到多个环境，所以很明显，在第一个例子中，这两个值都适用。但是我<em>可以</em>拥有一台属于多个角色的机器。在我的开发环境中，也许我的预算仅限于单机，所以它既是一个<code>WebServer</code>又是一个<code>AppServer</code>。</p>

<p>在那个例子中，我的<code>WebServer+AppServer</code>机器应该得到哪个值？如果我调查100个人，我怀疑大多数人会期待<code>DB01</code>。换句话说，当多个值匹配时，他们期望应用一个<strong>和</strong>关系，并且每个匹配都应该有助于排名。</p>

<p>但是在这种情况下会发生什么呢？</p>

<pre><code>DatabaseName = DB01 (Role: WebServer, AppServer)
DatabaseName = DB02 (Role: WebServer)
DatabaseName = DB03 (Role: AppServer; Environment: Production)
</code></pre>

<p>如果我在生产中部署到一台<code>WebServer+AppServer</code>机器上，我应该获得什么价值？如果我对100个人进行民意测验，我会说一半人会期待<code>DB01</code>，一半人会期待<code>DB03</code>。不像前面的例子，没有直观的方法来解释这些。如果你花了几个小时来思考这个问题，它可能对你有意义，但是对下一个必须维护它们的人有意义吗？</p>

<p>像这样的决定是棘手的。我的希望是，不要试图让特殊性规则<em>太过</em>聪明，这只会鼓励人们找到更好的方式来为部署建模(也许环境比角色组合更有意义)，而不是依赖于很少有人一眼就能理解的复杂矩阵。</p>

                    
                    
</body>
</html>