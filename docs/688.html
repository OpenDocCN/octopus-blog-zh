<html>
<head>
<title>Selenium series: Creating the framework - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:创建框架- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/4-creating-the-framework/creating-the-framework#2021-07-07">https://octopus.com/blog/selenium/4-creating-the-framework/creating-the-framework#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>WebDriver API的优势之一是它是浏览器不可知的。你可以从之前的帖子中看到，在我们的测试中，只需要一个新的二进制驱动程序和一个新的驱动程序类就可以启动Firefox，而不是Chrome。</p>

<p>尽管WebDriver允许我们编写测试而不用担心哪个浏览器会运行它们，但我们仍然需要创建和配置各种驱动程序类，如<code>ChromeDriver</code>和<code>FirefoxDriver</code>。为了使这个过程尽可能灵活，我们将创建一个名为<code>AutomatedBrowserFactory</code>的工厂类来为我们配置这些对象。</p>

<p>在创建这个类之前，我们需要在项目中添加一个新目录来保存Java文件。我们在以前的文章中创建的目录<code>src/test/java/com/octopus</code>是只在测试中使用的文件的默认位置。在<code>src/main/java/com/octopus</code>下有第二个目录保存常规的Java类，我们需要创建这个目录结构。</p>

<p>右键点击<code>src</code>目录，选择<span class="path">新➜目录</span>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image1.png" class="zoom" data-title=""><img src="../Images/2420ecf20ef4164e8a9f86e41682f87a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image1.png"/>T2】</a></p>

<p>输入<code>main/java/com/octopus</code>作为目录名，点击<code>OK</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image2.png" class="zoom" data-title=""><img src="../Images/8ce261b4cf6a0c949a0f09708d58eabc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image2.png"/>T2】</a></p>

<p>和以前一样，新的目录结构被创建，但是它还没有被IntelliJ识别为保存Java类的目录。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image3.png" class="zoom" data-title=""><img src="../Images/3b13d0bcdb12fcd9e6036d90d7de17b7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image3.png"/>T2】</a></p>

<p>要解决这个问题，打开<code>Maven Projects</code>工具窗口并点击<code>Reimport All Maven Projects</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image4.png" class="zoom" data-title=""><img src="../Images/e59c9e574bbd18c966a610632baab52f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image4.png"/>T2】</a></p>

<p><code>java</code>目录现在显示为蓝色图标，这表示它将保存Java类。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image5.png" class="zoom" data-title=""><img src="../Images/5079f943d1d8878e26bd78d6826c3362.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image5.png"/>T2】</a></p>

<p>我们现在可以在<code>src/main/java/com/octopus</code>目录中创建类<code>AutomatedBrowserFactory</code>。要创建新类，右击<code>octopus</code>文件夹并选择<span class="path">新➜ Java类</span>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image11.png" class="zoom" data-title=""><img src="../Images/2a8ed7639b4082c836a7a3e06140f687.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image11.png"/>T2】</a></p>

<p>在<code>Name</code>字段输入<code>AutomatedBrowserFactory</code>并点击<code>OK</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image12.png" class="zoom" data-title=""><img src="../Images/36bb2dc58b89a84e84dacee36d62028f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image12.png"/>T2】</a></p>

<p>在下面的代码片段中，我们有一个工厂框架，它包含一个名为<code>getAutomatedBrowser()</code>的方法，该方法接受我们想要测试的浏览器的名称。这个方法返回一个<code>AutomatedBrowser</code>接口的实例:</p>

<pre><code class="language-java">package com.octopus;

public class AutomatedBrowserFactory {

  public AutomatedBrowser getAutomatedBrowser(final String browser) {

    if ("Chrome".equalsIgnoreCase(browser)) {
      return getChromeBrowser();
    }

    if ("Firefox".equalsIgnoreCase(browser)) {
      return getFirefoxBrowser();
    }

    throw new IllegalArgumentException("Unknown browser " + browser);

  }

  private AutomatedBrowser getChromeBrowser() {
    return null;
  }

  private AutomatedBrowser getFirefoxBrowser() {
    return null;
  }
}
</code></pre>

<p>接口公开了我们将对浏览器执行的所有交互。首先，我们将定义一些方法来初始化WebDriver实例，打开一个URL，并与通过ID定位的元素进行交互。</p>

<p>要创建<code>AutomatedBrowser</code>接口，右击<code>octopus</code>目录并选择<span class="path">新➜ Java类</span>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image13.png" class="zoom" data-title=""> T34 </a></p>

<p>在<code>Name</code>字段中输入<code>AutomatedBrowser</code>，从<code>Kind</code>字段中选择<code>Interface</code>选项，点击<code>OK</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image14.png" class="zoom" data-title=""><img src="../Images/3fec9d2ad41bf3ab95eba9a17ee8d1c5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image14.png"/>T2】</a></p>

<p>然后将以下代码粘贴到新文件中:</p>

<pre><code class="language-java">package com.octopus;

import org.openqa.selenium.WebDriver;

public interface AutomatedBrowser {

  WebDriver getWebDriver();

  void setWebDriver(WebDriver webDriver);

  void init();

  void destroy();

  void goTo(String url);

  void clickElementWithId(String id);

  void selectOptionByTextFromSelectWithId(String optionText, String id);

  void populateElementWithId(String id, String text);

  String getTextFromElementWithId(String id);

}
</code></pre>

<p>我们将利用装饰模式来构建<code>AutomatedBrowser</code>接口的实例，我们最终将调用该接口来与浏览器交互。</p>

<p>那么为什么要使用装饰模式而不是直接实现<code>AutomatedBrowser</code>的类层次结构呢？</p>

<p>在实现decorator模式的过程中，我们赋予自己创建一系列独立实现的能力，这些实现具有增强和定制我们与浏览器交互方式的特性，而不需要试图用一个深层次的类来表示这些实现。</p>

<p>两个明显的实现是配置<code>ChromeDriver</code>或<code>FirefoxDriver</code>类的实例，允许我们打开Chrome或Firefox浏览器。但是当我们浏览这个博客系列时，我们将介绍一系列实现代理、移动浏览器不支持的功能的存根方法、远程浏览器等特性的装饰器。</p>

<p>所有这些灵活性的框架从这里开始。</p>

<p>为了让我们更容易创建装饰类，我们将创建一个名为<code>AutomatedBrowserBase</code>的类，它将实现<code>AutomatedBrowser</code>，并将所有方法调用传递给<code>AutomatedBrowser</code>的父实例。</p>

<p>因为<code>AutomatedBrowserBase</code>类提供了<code>AutomatedBrowser</code>接口中每个方法的实现，所以扩展<code>AutomatedBrowserBase</code>的装饰类只能覆盖特定于它们的方法。这大大减少了创建装饰器所需的锅炉板代码的数量。</p>

<p>注意<code>AutomatedBrowserBase</code>类是在<code>com.octopus.decoratorbase</code>包中创建的。将这个类放在它自己的包中是一个重要的设计决策，我们将在后面的课程中研究这些特性。</p>

<p>要创建新的包，右击<code>octopus</code>目录，选择<span class="path">新➜包</span>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image6.png" class="zoom" data-title=""><img src="../Images/7b1b11b7531e3f3e6f7644b251bfe9ff.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image6.png"/>T2】</a></p>

<p>输入名称<code>decoratorbase</code>，点击<code>OK</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image7.png" class="zoom" data-title=""> T32 </a></p>

<p>然后，新的包被添加到目录结构中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image8.png" class="zoom" data-title="">T35【T36】T1】</a></p>

<p>在<code>com.octopus.decoratorbase</code>包中，用下面的代码创建一个名为<code>AutomatedBrowserBase</code>的新类。在<code>AutomatedBrowser</code>接口中定义的每个方法都是通过传递给<code>automatedBrowser</code>实例变量来实现的(如果它不是<code>null</code>):</p>

<pre><code class="language-java">package com.octopus.decoratorbase;

import com.octopus.AutomatedBrowser;
import org.openqa.selenium.WebDriver;

public class AutomatedBrowserBase implements AutomatedBrowser {

  private AutomatedBrowser automatedBrowser;

  public AutomatedBrowserBase() {

  }

  public AutomatedBrowserBase(AutomatedBrowser automatedBrowser) {
    this.automatedBrowser = automatedBrowser;
  }

  public AutomatedBrowser getAutomatedBrowser() {
    return automatedBrowser;
  }

  @Override
  public WebDriver getWebDriver() {
    if (getAutomatedBrowser() != null) {
      return getAutomatedBrowser().getWebDriver();
    }
    return null;
  }

  @Override
  public void setWebDriver(WebDriver webDriver) {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().setWebDriver(webDriver);
    }

  }

  @Override
  public void init() {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().init();
    }
  }

  @Override
  public void destroy() {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().destroy();
    }
  }

  @Override
  public void goTo(String url) {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().goTo(url);
    }
  }

  @Override
  public void clickElementWithId(String id) {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().clickElementWithId(id);
    }
  }

  @Override
  public void selectOptionByTextFromSelectWithId(String optionText, String id) {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().selectOptionByTextFromSelectWithId(optionText, id);
    }
  }

  @Override
  public void populateElementWithId(String id, String text) {
    if (getAutomatedBrowser() != null) {
      getAutomatedBrowser().populateElementWithId(id, text);
    }
  }

  @Override
  public String getTextFromElementWithId(String id) {
    if (getAutomatedBrowser() != null) {
      return getAutomatedBrowser().getTextFromElementWithId(id);
    }

    return null;
  }
}
</code></pre>

<p>现在让我们扩展<code>AutomatedBrowserBase</code>类来创建<code>ChromeDecorator</code>类。<code>ChromeDecorator</code>将覆盖<code>init()</code>方法来创建一个<code>ChromeDriver</code>类的实例。</p>

<p><code>ChromeDecorator</code>类将被放在<code>com.octopus.decorators</code>包中，所以创建新的<code>decorators</code>包，就像你创建<code>decoratorbase</code>包一样。</p>

<p>在<code>com.octopus.decorators</code>包中，用下面的代码创建一个名为<code>ChromeDecorator</code>的类。</p>

<p>注意，<code>ChromeDecorator</code>类只实现了一个方法。这就是扩展<code>AutomatedBrowserBase</code>类而不是<code>AutomatedBrowser</code>接口的好处:</p>

<pre><code class="language-java">package com.octopus.decorators;

import com.octopus.AutomatedBrowser;
import com.octopus.decoratorbase.AutomatedBrowserBase;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;

public class ChromeDecorator extends AutomatedBrowserBase {
    public ChromeDecorator(final AutomatedBrowser automatedBrowser) {
        super(automatedBrowser);
    }

    @Override
    public void init() {
        final WebDriver webDriver = new ChromeDriver();
        getAutomatedBrowser().setWebDriver(webDriver);
        getAutomatedBrowser().init();
    }
}
</code></pre>

<p>我们遵循相同的过程来创建<code>FirefoxDecorator</code>类，它创建了<code>FirefoxDriver</code>类的一个实例:</p>

<pre><code class="language-java">package com.octopus.decorators;

import com.octopus.AutomatedBrowser;
import com.octopus.decoratorbase.AutomatedBrowserBase;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;

public class FirefoxDecorator extends AutomatedBrowserBase {

    public FirefoxDecorator(final AutomatedBrowser automatedBrowser) {
        super(automatedBrowser);
    }

    @Override
    public void init() {
        final WebDriver webDriver = new FirefoxDriver();
        getAutomatedBrowser().setWebDriver(webDriver);
        getAutomatedBrowser().init();
    }
}
</code></pre>

<p><code>ChromeDecorator</code>和<code>FirefoxDecorator</code>类包含我们打开Chrome或Firefox浏览器所需的逻辑，它们通过创建<code>ChromeDriver</code>或<code>FirefoxDriver</code>类的实例来实现这一点。然后这些驱动类被传递给<code>ChromeDecorator</code>和<code>FirefoxDecorator</code>类<em>通过调用<code>getAutomatedBrowser().setWebDriver(webDriver)</code>包装</em>的<code>AutomatedBrowser</code>实例。</p>

<p>最后一步是通过调用<code>getAutomatedBrowser().init()</code>初始化驱动程序。调用<code>init()</code>方法现在没有任何作用，但是我们稍后将使用这个方法来配置驱动程序的一些高级特性。</p>

<p>我们需要的最后一个装饰器是一个使用WebDriver API对由<code>ChromeDecorator</code>或<code>FirefoxDecorator</code>类初始化的浏览器执行操作的装饰器。为此，我们将创建<code>WebDriverDecorator</code>类。</p>

<p><code>WebDriverDecorator</code>类将托管一个<code>WebDriver</code>实例，并通过<code>getWebDriver()</code>和<code>setWebDriver()</code>方法公开它。方法<code>destroy()</code>将关闭web浏览器，方法<code>goTo()</code>打开提供的URL。</p>

<p>注意<code>WebDriverDecorator</code>有一个默认的构造函数。这与<code>ChromeDecorator</code>和<code>FirefoxDecorator</code>不同，它们都提供一个带<code>AutomatedBrowser</code>的构造函数。这种差异的存在是因为<code>WebDriverDecorator</code>旨在成为其他装饰者包装的基础<code>AutomatedBrowser</code>。当我们更新<code>AutomatedBrowserFactory</code>类时，我们将看到这一点。</p>

<p>在上一篇文章中，我们已经看到了许多进入<code>WebDriverDecorator</code>类的代码，其中<code>webDriver.get()</code>方法打开一个URL，而<code>webDriver.quit()</code>方法关闭浏览器:</p>

<pre><code class="language-java">package com.octopus.decorators;

import com.octopus.AutomatedBrowser;
import com.octopus.decoratorbase.AutomatedBrowserBase;
import org.openqa.selenium.WebDriver;

public class WebDriverDecorator extends AutomatedBrowserBase {

  private WebDriver webDriver;

  public WebDriverDecorator() {

  }

  public WebDriverDecorator(final AutomatedBrowser automatedBrowser) {
    super(automatedBrowser);
  }

  @Override
  public WebDriver getWebDriver() {
    return webDriver;
  }

  @Override
  public void setWebDriver(final WebDriver webDriver) {
    this.webDriver = webDriver;
  }

  @Override
  public void destroy() {
    if (webDriver != null) {
      webDriver.quit();
    }
  }

  @Override
  public void goTo(final String url) {
    webDriver.get(url);
  }
}
</code></pre>

<p>装饰器完成后，我们需要更新<code>AutomatedBrowserFactory</code>来使用它们。</p>

<p>先前的<code>getChromeBrowser()</code>和<code>getFirefoxBrowser()</code>方法返回了<code>null</code>。现在我们可以创建装饰类的实例来构建定制的<code>AutomatedBrowser</code>接口实例，以打开Chrome或Firefox。</p>

<p>注意装饰器构造函数是如何包装彼此的。这是decorator模式的关键，意味着我们可以混合和匹配decorator类来构造各种各样的对象，而无需创建具有继承性的深层类层次结构:</p>

<pre><code class="language-java">private AutomatedBrowser getChromeBrowser() {
  return new ChromeDecorator(
    new WebDriverDecorator()
  );
}

private AutomatedBrowser getFirefoxBrowser() {
  return new FirefoxDecorator(
    new WebDriverDecorator()
  );
}
</code></pre>

<p>下图显示了装饰者如何包装彼此，并将方法调用传递给他们装饰的实例。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image9.png" class="zoom" data-title=""><img src="../Images/943cce876f568ede80adae7edd55853a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image9.png"/>T2】</a></p>

<p>让我们创建一个测试，利用我们的工厂和它创建的<code>AutomatedBrowser</code>实例。</p>

<p>因为这是一个测试类，所以它将被创建在<code>src/test/java/com/octopus</code>目录中:</p>

<pre><code class="language-java">package com.octopus;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import java.util.Arrays;

@RunWith(Parameterized.class)
public class FactoryTest {

  private static final AutomatedBrowserFactory AUTOMATED_BROWSER_FACTORY
    = new AutomatedBrowserFactory();

  private String browser;

  public FactoryTest(final String browser) {
    this.browser = browser;
  }

  @Parameterized.Parameters
  public static Iterable data() {
    return Arrays.asList(
      "Chrome",
      "Firefox"
    );
  }

  @Test
  public void openURL() {
    final AutomatedBrowser automatedBrowser =
      AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser(browser);
    automatedBrowser.init();
    automatedBrowser.goTo("https://octopus.com/");
    automatedBrowser.destroy();
  }
}
</code></pre>

<p><code>FactoryTest</code>类利用JUnit参数化，用不同的输入多次运行测试方法。我们将使用这一功能，用一种测试方法对Chrome和Firefox浏览器进行测试。</p>

<p>为了启用参数化，测试类需要注释<code>@RunWith(Parameterized.class)</code>:</p>

<pre><code class="language-java">@RunWith(Parameterized.class)
public class FactoryTest {

}
</code></pre>

<p>然后它需要一个静态方法来返回将被传递给<code>FactoryTest</code>构造函数的值。在我们的例子中，这些值是我们将要测试的浏览器名称的字符串:</p>

<pre><code class="language-java">@Parameterized.Parameters
public static Iterable data() {
  return Arrays.asList(
    "Chrome",
    "Firefox"
  );
}
</code></pre>

<p>最后，<code>FactoryTest()</code>构造函数被配置为接受一个参数，该参数将被设置为由<code>data()</code>方法返回的值之一。在这种情况下，我们将参数保存到<code>browser</code>实例变量:</p>

<pre><code class="language-java">private String browser;

public FactoryTest(final String browser) {
  this.browser = browser;
}
</code></pre>

<p>然后，测试方法可以利用<code>browser</code>实例变量来启动Chrome或Firefox浏览器，作为测试的一部分。</p>

<p>这种在运行时通过<code>AutomatedBrowserFactory</code>选择浏览器的能力将为我们以后的测试提供极大的灵活性:</p>

<pre><code class="language-java">@Test

public void openURL() {
  final AutomatedBrowser automatedBrowser =
    AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser(browser);

  automatedBrowser.init();
  automatedBrowser.goTo("https://octopus.com/");
  automatedBrowser.destroy();
}
</code></pre>

<p>作为这个博客的一部分，我们已经创建了许多新的类，您最终应该会得到一个类似这样的目录结构。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image10.png" class="zoom" data-title=""><img src="../Images/18ea42bf584316022690bc961ec71ba8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image10.png"/>T2】</a></p>

<p>要运行测试，单击<code>FactoryTest</code>类旁边的绿色箭头并选择<code>Run 'FactoryTest'</code>选项。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image15.png" class="zoom" data-title=""><img src="../Images/a1b7338c9f2dfbabaeafb7d9990c3f0e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/4-creating-the-framework/image15.png"/>T2】</a></p>

<p>你会看到Chrome和Firefox都打开，显示<a href="https://octopus.com" rel="nofollow">https://octopus.com</a>，然后再次关闭。</p>

<p>现在我们有了一个简单的框架来运行针对多种浏览器的测试，我们需要一个网页来进行交互，我们将在下一篇文章中创建这个网页。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>