<html>
<head>
<title>Selenium series: Emailing the results - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:通过电子邮件发送结果- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/34-emailing-the-results/emailing-the-results#2021-07-07">https://octopus.com/blog/selenium/34-emailing-the-results/emailing-the-results#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>我们现在能够从转发给AWS Lambda的HTTP POST请求中运行Gherkin特性文件，但是由于API Gateway和Lambda请求的时间限制不同，我们被迫以异步方式运行测试。这意味着我们最初的HTTP请求不再接收测试的输出，所以我们需要另一个返回测试结果的解决方案。</p>

<p>一个简单的解决办法是在测试结果出来后，通过电子邮件发给我们。通过发送电子邮件，<code>runCucumber</code>功能可以使用您已有的通信平台通知我们结果，让我们不必实施定制解决方案。</p>

<p>好消息是AWS提供了发送电子邮件的服务，我们可以很容易地将它绑定到我们的Lambda函数中。这项服务被称为简单电子邮件服务(SES)。</p>

<p>在我们可以使用SES之前，我们需要验证我们将显示的发送电子邮件的电子邮件地址。这个验证过程是亚马逊防止SES被用来发送垃圾邮件的方法之一。</p>

<p>要打开SES控制台，请单击<code>Services</code>链接，然后单击<code>Simple Email Service</code>链接。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image1.png" class="zoom" data-title=""><img src="../Images/9d23ce37e660a81a0060b0486e01e15d.png" class="img-fluid center" alt="C:\e1a769cc26af90404e05f1b3d2a36c04" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image1.png"/>T2】</a></p>

<p>点击左侧菜单中的<code>Email Addresses</code>链接，然后点击<code>Verify a New Email Address</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image2.png" class="zoom" data-title=""><img src="../Images/d5c8e71474596606e0993e394a21a5ea.png" class="img-fluid center" alt="C:\2a4bbabe855a4bd884d5060233d087ce" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image2.png"/>T2】</a></p>

<p>输入您有权访问的电子邮件地址，然后单击<code>Verify This Email Address</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image3.png" class="zoom" data-title=""><img src="../Images/3297eb7586e5602405b79833da3dd79b.png" class="img-fluid center" alt="C:\c20b26b91a93a75d93e9379f556d456f" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image3.png"/>T2】</a></p>

<p>您将看到一个提示，告诉您已经发送了一封验证电子邮件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image4.png" class="zoom" data-title=""><img src="../Images/792c239188bd844531b341f14c046ca7.png" class="img-fluid center" alt="C:\92c9eb3b38fe00a11ffb044cacd67087" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image4.png"/>T2】</a></p>

<p>邮件中会有一个你需要打开的链接。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image5.png" class="zoom" data-title=""><img src="../Images/409a1cfab5de5ab9635fac5db41e0a8f.png" class="img-fluid center" alt="C:\27233411237724a5000019a0818bfcbf" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image5.png"/>T2】</a></p>

<p>单击该链接会将您带到一个页面，告诉您该电子邮件地址已成功验证。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image6.png" class="zoom" data-title=""><img src="../Images/73a55f945dca94c9f08716af06734586.png" class="img-fluid center" alt="C:\efadf80f7a46f630e2d01999fa0b2310" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image6.png"/>T2】</a></p>

<p>回到SES控制台，我们现在可以看到电子邮件地址已经过验证。您可能需要单击“刷新”按钮，将状态更新为“已验证”。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image7.png" class="zoom" data-title=""><img src="../Images/27beeee517f11eb8c4bacf02cce4ab6d.png" class="img-fluid center" alt="C:\2c68f8f83fe44183ee293e5455e8eec1" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image7.png"/>T2】</a></p>

<p>既然我们已经配置了SES，我们需要将它合并到我们的代码中。</p>

<p>在<code>pom.xml</code>文件中，添加<code>com.amazonaws:aws-java-sdk-ses</code>依赖项。这个库包含我们用ses创建和发送电子邮件所需的类:</p>

<pre><code class="language-xml">&lt;project 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;!-- ... --&gt;
  &lt;dependencies&gt;
    &lt;!-- ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;
      &lt;artifactId&gt;aws-java-sdk-ses&lt;/artifactId&gt;
      &lt;version&gt;${aws.sdk.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- ... --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

<p>在<code>LambdaEntry</code>类中，我们将创建一个名为<code>sendEmail()</code>的新方法:</p>

<pre><code class="language-java">package com.octopus;

import com.amazonaws.services.simpleemail.AmazonSimpleEmailService;
import com.amazonaws.services.simpleemail.AmazonSimpleEmailServiceClientBuilder;
import com.amazonaws.services.simpleemail.model.*;
// ...
public class LambdaEntry {
  // ...
  private void sendEmail(final String to, final String results) {
    try {
      final AmazonSimpleEmailService client = AmazonSimpleEmailServiceClientBuilder.standard()
        .withRegion(Regions.US_EAST_1).build();

      final SendEmailRequest request = new SendEmailRequest()
        .withDestination(

      new Destination().withToAddresses(to))
        .withMessage(new Message()
          .withBody(new Body()
            .withText(new Content()
        .withCharset("UTF-8").withData(results)))
        .withSubject(new Content()
          .withCharset("UTF-8").withData("WebDriver Test Results")))
        .withSource("admin@matthewcasperson.com");

      client.sendEmail(request);
    } catch (final Exception ex) {
      System.out.println("The email was not sent. Error message: " + ex.getMessage());
    }
  }
}
</code></pre>

<p>这个方法有两个参数:接收结果的电子邮件地址和结果本身:</p>

<pre><code class="language-java">private void sendEmail(final String to, final String results) {
</code></pre>

<p>然后我们创建一个新的<code>AmazonSimpleEmailService</code>实例，配置为在美国东部1区工作:</p>

<pre><code class="language-java">try {
  final AmazonSimpleEmailService client = AmazonSimpleEmailServiceClientBuilder.standard()
    .withRegion(Regions.US_EAST_1).build();
</code></pre>

<p><code>SendEmailRequest</code>类用于构造电子邮件本身。它有一个流畅的界面，允许我们定义目的地，邮件正文，电子邮件主题和发件人地址。请注意，此处使用的发件人地址必须是ses控制台中已验证的电子邮件地址之一:</p>

<pre><code class="language-java">final SendEmailRequest request = new SendEmailRequest()
  .withDestination(

new Destination().withToAddresses(to))
  .withMessage(new Message()
  .withBody(new Body()
    .withText(new Content()
    .withCharset("UTF-8").withData(results)))
  .withSubject(new Content()
    .withCharset("UTF-8").withData("WebDriver Test Results")))
  .withSource("admin@matthewcasperson.com");
</code></pre>

<p>最后一步是向客户端发送请求:</p>

<pre><code class="language-java">client.sendEmail(request);
</code></pre>

<p>如果出现任何问题，我们会向控制台发送一条消息:</p>

<pre><code class="language-java">  } catch (final Exception ex) {
    System.out.println("The email was not sent. Error message: " + ex.getMessage());
  }
}
</code></pre>

<p>要发送电子邮件，我们需要对<code>runCucumber()</code>方法做一些小的改动:</p>

<pre><code class="language-java">public String runCucumber(String feature) throws Throwable {

  File driverDirectory = null;
  File chromeDirectory = null;
  File outputFile = null;
  File txtOutputFile = null;
  File featureFile = null;

  try {
    driverDirectory = downloadChromeDriver();
    chromeDirectory = downloadChromeHeadless();
    outputFile = Files.createTempFile("output", ".json").toFile();
    txtOutputFile = Files.createTempFile("output", ".txt").toFile();
    featureFile = writeFeatureToFile(feature);

    cucumber.api.cli.Main.run(
      new String[]{
        "--monochrome",
        "--glue", "com.octopus.decoratorbase",
        "--format", "json:" + outputFile.toString(),
        "--format", "pretty:" + txtOutputFile.toString(),
        featureFile.getAbsolutePath()},
      Thread.currentThread().getContextClassLoader());

    sendEmail("admin@matthewcasperson.com", FileUtils.readFileToString(txtOutputFile, Charset.defaultCharset()));

    return FileUtils.readFileToString(outputFile, Charset.defaultCharset());

  } finally {
    FileUtils.deleteQuietly(driverDirectory);
    FileUtils.deleteQuietly(chromeDirectory);
    FileUtils.deleteQuietly(outputFile);
    FileUtils.deleteQuietly(txtOutputFile);
    FileUtils.deleteQuietly(featureFile);
  }
}
</code></pre>

<p>我们创建一个变量来保存测试结果将被写入的临时文件:</p>

<pre><code class="language-java">File txtOutputFile = null;
</code></pre>

<p>该变量由扩展名为<code>.txt</code>的临时文件初始化:</p>

<pre><code class="language-java">txtOutputFile = Files.createTempFile("output", ".txt").toFile();
</code></pre>

<p>然后，我们向<code>cucumber.api.cli.Main.run()</code>方法传递一个额外的参数，将测试结果保存为一个文本文件。Cucumber中漂亮的输出格式会生成漂亮的纯文本日志文件:</p>

<pre><code class="language-java">"--format", "pretty:" + txtOutputFile.toString(),
</code></pre>

<p>就在我们返回JSON响应之前，我们调用<code>sendEmail()</code>方法来发送纯文本结果。这样，即使不再有任何进程监听该方法的返回值，我们也可以得到结果:</p>

<pre><code class="language-java">sendEmail("admin@matthewcasperson.com", FileUtils.readFileToString(txtOutputFile, Charset.defaultCharset()));
</code></pre>

<p>最后的改变是给<code>runCucumber()</code>函数使用SES发送邮件的权限。</p>

<p>身份和访问管理(IAM)服务为AWS中运行的代码和服务提供安全性。我们在前面创建用于无服务器应用程序的访问和密钥时看到了这个服务。</p>

<p>除了管理用户，IAM还管理授予其他AWS服务的权限，包括Lambda。在我们的例子中，我们需要授予Lambda函数用SES发送电子邮件的能力。我们通过在<code>serverless.yml</code>文件的provider部分下添加一个<code>iamRoleStatements</code>部分来授予这个许可。</p>

<p>在这里，我们将<code>Effect</code>设置为<code>Allow</code>,以表明我们正在授予执行某些动作的能力。<code>Resource</code>设置被设置为<code>"*"</code>，这是该选项的唯一有效值。<code>Action</code>设置被设置为<code>ses:SendEmail</code>，这是与在SES中发送电子邮件相关的动作的名称。</p>



<pre><code class="language-yaml">provider:
  name: aws
  runtime: java8
  region: us-east-1
  iamRoleStatements:
    - Effect: Allow
      Resource: "*"
      Action:
        - ses:SendEmail
</code></pre>

<p>用Maven重新编译代码，用Serverless重新部署。然后向<code>runCucumber</code> URL发出另一个请求。</p>

<p>和以前一样，我们得到一个空响应，但是过了一段时间，传递给<code>sendEmail()</code>方法的电子邮件地址将收到一条消息，其中包含测试结果。</p>

<p>如果您没有看到该电子邮件，请检查您的垃圾邮件文件夹。Outlook 365不断将这些电子邮件识别为垃圾邮件，其他提供商可能也会这样做。</p>


<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image8.png" class="zoom" data-title=""><img src="../Images/3b88e5ebdb1a3f540dd6a2398ff5f796.png" class="img-fluid center" alt="C:\64fd79671c78abdc3a4f8f36373ecef3" data-original-src="https://i.octopus.com/blog/2018-10/selenium/34-emailing-the-results/image8.png"/>T2】</a></p>

<p>我们现在有了一个完整的解决方案，可以从HTTP请求启动Lambda中的WebDriver测试，并通过电子邮件接收结果。无论我们启动1次测试还是1000次测试，我们在这里部署的基础设施都将无缝、可靠地扩展，以满足我们的要求。这就是使用AWS这样的云服务的威力。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>