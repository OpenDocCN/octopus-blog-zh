<html>
<head>
<title>Configuring WildFly via XML Templates or CLI Scripts - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过XML模板或CLI脚本配置wild fly-Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/wildfly-cli-vs-xml#2022-08-09">https://octopus.com/blog/wildfly-cli-vs-xml#2022-08-09</a></blockquote>
                        <p>当用像Puppet、Chef、Ansible等自动化工具构建WildFly服务器时，你将面临如何从库存下载到定制服务器的问题。定制的很大一部分是在构建过程中如何编辑配置文件(<code>standalone.xml</code>、<code>domain.xml</code>、<code>host.xml</code>和<code>host-slave.xml</code>)。</p>

<p>编辑这些XML文件时，您有两个主要选择:直接编辑文本，或者使用WildFly CLI进行更改。两者各有利弊，我们将在这篇博文中探讨。</p>

<h2 id="editing-xml-directly">直接编辑XML</h2>

<p>直接编辑XML配置文件可能是最自然的选择。由于XML文件只是纯文本，并且每个部署工具都有某种形式的模板支持，因此在基本模板中进行所需的更改并在部署期间复制定制版本是非常容易的。</p>

<p>这种方法有许多好处。</p>

<p>首先，您不需要WildFly的运行实例来进行配置更改。这消除了您在使用CLI工具时会遇到的一些麻烦，默认情况下，CLI工具需要运行一个实例，并会强制您重新启动服务器以使一些更改生效。</p>

<p>第二，所有的更改本质上都是以“批处理”方式完成的，也就是说所有的更改都是一次性完成的。当您复制一个模板XML文件时，这听起来可能很明显，但是它确实删除了在通过CLI进行更改时必须考虑的一些内容。</p>

<p>但是，直接编辑XML配置文件有一些明显的缺点。</p>

<p>WildFly使用的一些XML文件不是静态的。例如，WildFly将使用当前部署的应用程序的详细信息更新<code>domain.xml</code>和<code>standalone.xml</code>文件。任何部署脚本的目标都是幂等的，但是如果您在每次部署时盲目地将一个新的XML配置文件复制到服务器上，您会发现自己丢失了胡乱做出的运行时更改。此外，您可能会发现带有新XML配置文件的服务器没有部署，这可能会给生产带来巨大的冲击。</p>

<p>如果没有预先考虑，您可能还会发现自己处于这样一种情况，即很难看出对XML文件做了什么更改。这些配置文件相当长，如果没有diff工具，几乎不可能发现定制模板中的更改。</p>

<p>出于同样的原因，在WildFly的新版本中，将您的定制应用到配置文件也是一个挑战。鉴于WildFly大约每年都会发布一个主要版本(从WildFly 12开始，这个发布时间表将会加快)，您真的希望能够轻松地将您的定制应用到下一个版本，即使只是为了利用WildFly后续版本中的安全补丁。</p>

<p>对于那些直接对XML配置文件应用更改的人，我的建议是为每个更改添加清晰的注释。例如，您可以使用如下代码更改配置以绑定到任何网络适配器:</p>

<pre><code class="language-xml">&lt;interfaces&gt;
        &lt;interface name="management"&gt;
            &lt;!-- CHANGE: Bind to any IP address --&gt;
            &lt;any-address/&gt;
        &lt;/interface&gt;
        &lt;interface name="public"&gt;
            &lt;!-- CHANGE: Bind to any IP address --&gt;
            &lt;any-address/&gt;
        &lt;/interface&gt;
&lt;/interfaces&gt;
</code></pre>

<p>WildFly在启动时会丢弃这些注释(WildFly在运行时覆盖XML文件是WildFly运行时无法编辑这些文件的原因)，但通过简单的搜索字符串，您可以找到您在模板中所做的所有更改。这使得将更改移植到新版本变得容易，或者简单地理解您的定制版本与股票下载有何不同。</p>

<h2 id="updating-with-the-cli">使用CLI更新</h2>

<p>使用WildFly CLI工具来应用定制比编辑XML文件更高级，但它确实有许多优点。</p>

<p>您可能会发现，您的CLI脚本将适用于WildFly的新版本，无需任何更改。例如，以下CLI命令将公共接口绑定到任何地址:</p>

<pre><code>/interface=public/:undefine-attribute(name=inet-address)
/interface=public/:write-attribute(name=any-address,value=true)
</code></pre>

<p>我希望这些命令能在WildFly的所有最新版本中工作，也希望它们能在即将发布的版本中工作。这使得升级你的WildFly版本更加容易。</p>

<p>这些CLI命令还提供了一种简洁的方式来理解对股票下载所做的更改。与模板XML文件不同，在模板XML文件中，更改分散在一个大文件中，CLI命令易于查看和理解。</p>

<p>因为您正在对当前配置应用有针对性的更改(而不是覆盖整个XML文件)，CLI命令有可能是等幂的。通过使用CLI流控制语句，可以仅在当前设置不是所需状态时应用更改。</p>

<p>CLI命令提供了一定程度的错误检查。公平地说，WildFly中的XML验证非常严格，所以不太可能有无效的XML和可启动的服务器，但是当您试图做错什么时，CLI会提供更直接的反馈。</p>

<p>对于复杂的环境，您可以利用CLI Java库，用任何JVM语言编写您的更改。Groovy是一个不错的选择。使用<a href="http://docs.groovy-lang.org/latest/html/documentation/grape.html" rel="nofollow"> Grape </a>你可以删除任何需要的依赖项，你的脚本可以像任何其他可执行文件一样在Linux或MacOS环境中运行。</p>

<p>这个示例groovy脚本使用WildFly CLI库来执行所需的CLI命令。虽然这是一个非常简单的例子，但是可以修改它以适应更复杂的需求。</p>

<pre><code class="language-java">#!/usr/bin/env groovy

@Grab(group='org.wildfly.core', module='wildfly-embedded', version='2.2.1.Final')
@Grab(group='org.wildfly.security', module='wildfly-security-manager', version='1.1.2.Final')
@Grab(group='org.wildfly.core', module='wildfly-cli', version='3.0.0.Beta23')
import org.jboss.as.cli.scriptsupport.*

final DEFAULT_HOST = "localhost"
final DEFAULT_PORT = "9990"
final DEFAULT_PROTOCOL = "remote+http"

def cli = new CliBuilder()

cli.with {
    h longOpt: 'help', 'Show usage information'
    c longOpt: 'controller', args: 1, argName: 'controller', 'WildFly controller'
    d longOpt: 'port', args: 1, argName: 'port', type: Number.class, 'Wildfly management port'
    e longOpt: 'protocol', args: 1, argName: 'protocol', 'Wildfly management protocol i.e. remote+https'
    u longOpt: 'user', args: 1, argName: 'username', required: true, 'WildFly management username'
    p longOpt: 'password', args: 1, argName: 'password', required: true, 'WildFly management password'
}

def options = cli.parse(args)

if (!options) {
    return
}

if (options.h) {
    cli.usage()
    return
}

def jbossCli = CLI.newInstance()

jbossCli.connect(
                options.protocol ?: DEFAULT_PROTOCOL,
                options.controller ?: DEFAULT_HOST,
                Integer.parseInt(options.port ?: DEFAULT_PORT),
                options.user,
                options.password.toCharArray())

jbossCli.cmd("/:take-snapshot")
jbossCli.cmd("/interface=public/:undefine-attribute(name=inet-address)")
jbossCli.cmd("/interface=public/:write-attribute(name=any-address,value=true)")

System.exit(0)
</code></pre>

<p>该脚本可以在以下情况下运行:</p>

<pre><code>./script.groovy -u admin -p password01
</code></pre>

<p>不过，运行CLI脚本也有缺点。</p>

<p>通常，您需要有一个正在运行的WildFly实例，以便运行您的CLI脚本。当服务器没有正确配置以便引导，从而可以对其运行CLI脚本时，这可能会很棘手。例如，接口绑定可能不正确，端口可能不正确，或者从属实例可能无法连接到域主节点。</p>

<p>这种情况可以通过运行<a href="http://www.mastertheboss.com/jbossas/wildfly9/configuring-wildfly-9-from-the-cli-in-offline-mode" rel="nofollow">嵌入式服务器</a>来缓解，这是一种“离线”模式，让您无需运行服务器就可以访问CLI。</p>

<p>您还需要知道哪些更改需要重新启动服务器，以及哪些更改需要作为批处理的一部分进行。这是在复制XML文件和启动服务器时不需要担心的两件事。</p>

<h2 id="final-thoughts">最后的想法</h2>

<p>如果需要等幂，CLI脚本是最佳选择。它们允许您只修改不处于所需状态的设置，并且是非破坏性的。CLI脚本往往更容易移植到新的WildFly版本，并提供了您的实例如何不同于股票下载的简明定义。</p>

<p>对于不可变的环境，编辑XML文件的简单性是无法超越的。每个系统管理员都知道如何编辑XML文件(而对于新手来说，CLI可能比较棘手)，每个部署工具都支持某种类型的模板，可以处理XML文件。只要您小心翼翼地清楚识别对股票配置文件所做的更改，将这些更改移植到WildFly的新版本是非常容易的。</p>

<p>如果您对Java应用程序的自动化部署感兴趣，<a href="https://octopus.com/downloads">下载Octopus Deploy </a>的试用版，并查看一下<a href="https://octopus.com/docs/deployments/java/deploying-java-applications">我们的文档</a>。</p>

                    
                    
</body>
</html>