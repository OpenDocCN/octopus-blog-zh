# 什么是 GitOps？-章鱼部署

> 原文：<https://octopus.com/blog/what-is-gitops>

GitOps 是我们行业中不断增长的“Ops”范例列表中的一个相对较新的成员。这一切都是从 DevOps 开始的，虽然 DevOps 这个术语已经存在了很多年，但似乎我们仍然无法就它是一个过程、思维模式、职位名称、一套工具还是它们的组合达成一致。在我们的[DevOps 简介](https://octopus.com/blog/introduction-to-devops)帖子中，我们捕捉到了关于 devo PS 的想法，在我们的 [DevOps 工程师手册](https://octopus.com/devops/)中，我们更深入地探讨了这些想法。

术语 GitOps 也有同样的歧义，所以在本帖中，我们来看看:

*   吉托普的历史
*   GitOps 目标和理想
*   GitOps 的局限性
*   支持 GitOps 的工具
*   在您自己的组织中采用 GitOps 的实际意义

## GitOps 的起源

GitOps 这个术语最初是由 WeaveWorks 在一篇名为[GitOps-Pull Request](https://www.weave.works/blog/gitops-operations-by-pull-request)的博客文章中提出的。这篇文章描述了 WeaveWorks 如何使用 git 作为真理的来源，带来了以下好处:

> 我们的 AWS 资源供应和 k8s 部署是声明性的
> 
> 我们的整个系统状态都在版本控制之下，并在单个 Git 存储库中描述
> 
> 运营变更由拉式请求(加上构建和发布管道)做出
> 
> Diff 工具检测任何差异，并通过松弛警报通知我们；同步工具支持融合
> 
> 回滚和审计日志也通过 Git 提供”

自从那篇博文发表以来，像 [GitOps 工作组](https://github.com/cncf/tag-app-delivery/tree/main/gitops-wg)这样的计划已经被组织起来:

> 清楚地定义 GitOps 的供应商中立的、原则主导的含义，这将为工具、一致性和认证之间的互操作性建立基础。"

该工作组最近发布了其[原则](https://github.com/open-gitops/documents/blob/main/PRINCIPLES.md)的第一个版本，其中指出:

> GitOps 受管系统的理想状态必须是:
> 
> 声明性——由 GitOps 管理的系统必须声明性地表达其期望的状态。
> 
> 版本化和不可变——期望的状态以一种强制不变性、版本化和保留完整版本历史的方式存储。
> 
> 自动提取-软件代理自动从源代码中提取所需的状态声明。
> 
> 持续协调-软件代理持续观察实际的系统状态，并尝试应用期望的状态。"

在大多数博客文章中发现的 GitOps 的低级实现和工作组描述的 GitOps 系统的高级理想之间的对比值得讨论，因为它们之间的差异是许多混乱的来源。

## GitOps 并不意味着使用 Git

围绕 GitOps 的大多数讨论都集中在如何在 Git 上构建过程，从而产生许多归于 GitOps 范例的好处。Git 自然地提供了一个(几乎)不可变的变更历史，通过 pull 请求对变更进行了注释和批准，其中 Git 存储库的当前状态自然地代表了系统的期望状态，因此充当了事实的来源。Git 和 GitOps 之间的重叠是不可否认的。

但是，您可能已经注意到，工作组从未将 Git 作为 GitOps 的一个需求。因此，虽然 Git 是 GitOps 解决方案的一个方便的组件，但 GitOps 本身关注的是系统的功能需求，而不是将声明性模板签入 Git。

这种区别很重要，因为许多团队专注于 GitOps 的“Git”部分。GitOps 这个术语对于它试图表达的概念来说是一个不合适的名字，这导致许多人认为 Git 是 GitOps 的核心方面。但 GitOps 赢得了营销战，并在 IT 部门获得了思想份额。虽然它可能是一个限制性术语，用来描述与 Git 无关的功能需求，但是 GitOps 现在是描述实现一组高级关注点的过程的简写。

## GitOps 并不意味着使用 Kubernetes

Kubernetes 是第一个广泛使用的平台，它将声明性状态和持续协调的思想与执行环境相结合，以实现协调并托管运行的应用程序。看着 Kubernetes 集群重新配置自己以匹配应用于系统的最新模板真是太神奇了。所以毫不奇怪，Kubernetes 是 Flux 和 Argo CD 等 GitOps 工具的基础，而像[30+GitOps 工具列表](https://dzone.com/articles/30-tools-list-for-gitops)这样的帖子提到 Kubernetes 20 次。

虽然持续的和解令人印象深刻，但这并不是真正的魔术。在幕后，Kubernetes 运行许多[操作符](https://octopus.com/blog/operators-with-kotlin)，这些操作符会收到配置更改的通知，并执行定制逻辑以将集群恢复到期望的状态。

持续对账的主要要求是:

*   对以声明方式表达所需状态的配置或模板的访问
*   当配置改变时，执行能够协调系统的过程的能力
*   流程可以运行的环境

Kubernetes 将这些需求烘焙到平台中，很容易实现持续的调和。但这些要求也可以通过一些简单的编排、基础设施即代码(IaC)工具来满足，如 Terraform、Ansible、Puppet、Chef、CloudFormation、Arm 模板以及 CI server 或 Octopus 等执行环境:

*   IaC 模板可以存储在 Git 中，Git 是像 S3 或 Azure Blob 存储这样的文件托管平台，具有不可变的审计历史。
*   CI/CD 系统可以轮询存储，通过 webhooks 获得更改通知，或者通过 GitHub Actions 等平台触发构建或部署。
*   然后执行 IaC 工具，使系统符合期望的状态。

事实上，真实世界中的端到端 GitOps 系统不可避免地会包含 Kubernetes 之外的编排。例如，Kubernetes 不太可能管理您的 DNS 记录、集中式认证平台或 Slack 之类的消息系统。您可能还会发现，至少有一种托管服务比试图在 Kubernetes 集群中复制它们更有吸引力，比如数据库、消息队列、调度和报告。此外，任何已建立的 IT 部门都保证拥有非 Kubernetes 系统，这些系统将受益于 GitOps。

因此，虽然最初选择的专用 GitOps 工具倾向于紧密集成到 Kubernetes 中，但要在已建立的基础设施上实现 GitOps 的功能需求，将不可避免地需要编排一个或多个 IaC 工具。

## 持续的和解是成功的一半

如工作组所述，持续协调描述了对两种系统变化的反应。

第一个是您所期望的，对 Git 或其他版本化存储中的配置的故意更改被检测到并应用到系统。这是配置更改的逻辑流程，代表正确配置的 GitOps 工作流的正常操作。

第二种情况是代理检测到源配置中未描述的不良系统更改。在这种情况下，您的系统不再反映期望的状态，代理需要将系统恢复到 Git 中维护的配置。

这种解决第二种情况的能力是一种很好的技术能力，但是代表了一个不完整的业务流程。

想象一下，前台的保安报告说他们驱逐了一名入侵者。作为一次性事件，该报告可能会引起轻微的关注，但是安全团队完成了他们的工作并解决了问题。但是现在想象一下你每周都收到这些报告。显然，有一个更重要的问题迫使安全团队对每周的入侵做出响应。

同样，一个不断移除不良系统状态的系统对于一个更根本的问题来说是一个不完整的解决方案。真正的问题是谁在做出这些改变，为什么要做出改变，为什么不通过正确的过程做出改变？

您的系统*能够*对不良状态做出响应的事实证明了一个健壮的过程能够适应不可预测的事件，这种能力不应该被低估。团队应该执行他们的恢复过程，这是一个由来已久的最佳实践，因此在发生灾难时，团队能够运行一个排练良好的恢复过程。连续协调可以被视为一种自动恢复过程，允许该过程被轻松地测试和验证。

但是，如果你的系统*必须*对不良状态做出反应，这就是一个有缺陷的过程的证据，在这个过程中，人们可以访问他们不应该或者没有遵循既定的过程。过度依赖一个可以在不良改变发生后将其撤销的系统，可能会掩盖一个更重要的潜在问题。

## GitOps 不是一个完整的解决方案

虽然 GitOps 描述了管理良好的基础设施和部署流程的许多可取特征，但它并不是一个完整的解决方案。除了 GitOps 描述的 4 项功能要求之外，健壮的系统还必须:

*   可验证——基础设施和应用程序一旦部署，就必须是可测试的。
*   可恢复——团队必须能够从不良状态中恢复过来。
*   可见——基础设施和部署到基础设施上的应用程序的状态必须呈现在一个易于使用的摘要中。
*   安全——必须存在关于谁可以对哪些系统进行什么更改的规则。
*   可测量的——必须收集有意义的指标，并以易于使用的格式公开。
*   标准化——必须以一致的方式描述应用程序和基础设施。
*   可维护性——支持团队必须能够查询系统并与之交互，通常是以非声明的方式。
*   协调——应用程序和基础设施的变更必须在团队之间进行协调。

对于在配置提交给 Git repo 或其他版本化且不可变的存储之前会发生什么，GitOps 几乎没有提供任何建议或见解，但它是“repo 的左边”,您的大部分工程流程将在这里定义。

如果您的 Git repo 是您系统的权威表示，那么任何可以编辑 repo 的人本质上都拥有管理权限。然而，Git 回购并没有为您在已建立的基础设施中发现的那种细微的责任分离提供天然的安全边界。这意味着您最终会为每个应用程序、每个环境、每个角色创建一个 repo。获得这些回购的可见性并确保它们拥有正确的权限并非易事。

您还会很快发现，仅仅因为您可以在 Git 中保存任何内容，并不意味着您应该这样做。不难想象这样一条规则:开发团队必须创建 Kubernetes 部署资源，而不是单独的 pods，使用响应非常具体的主机名的入口规则，并始终包括一个标准的安全策略。这种标准化很难通过拉请求来实现，所以一个更好的解决方案是给团队标准的资源模板，他们用自己特定的配置来填充这些模板。但这不是 Git 或 GitOps 固有的特性。

然后，我们有那些“集群的权利”的过程，其中定义了管理和支持任务。

报告 Git 提交的意图几乎是不可能的。如果您查看两次提交之间的差异，发现增加了一个部署映像标记，添加了新的秘密值，删除了一个配置映射，您将如何描述这一变化的意图？简单的答案是读取提交消息，但这对于报告工具来说不是一个可行的选择，这些工具必须将高级事件(如“部署了新的应用程序版本”或“bug 修复发布”)映射到两次提交之间的差异，如果你想根据标准指标(如 [DORA 报告](https://www.devops-research.com/research.html)中提供的指标)来衡量自己，这是至关重要的。即使你能推测出一种理解 Git 提交意图的算法，Git repo 也绝不应该被用作时序数据库。

GitOps 也没有提供在系统处于理想状态后如何执行支持任务的指导。您会对 Git repo 承诺什么来删除行为不当的 pod，以便它们可以被其父部署重新创建？也许一个工作可以做到这一点，但你必须小心，Kubernetes 不会试图申请该工作资源两次。但是，您会向 repo 承诺什么来查看服务的 pod 日志，比如预装在您的集群上的入口控制器？一想到在 GitOps 模型中重建`kubectl logs mypod`需要实现的所有异步消息处理，我就感到困惑。

像这样的即席报告和管理任务在 GitOps 模型中没有自然的解决方案。

这并不是说 GitOps 有缺陷或不完整，而是说它解决了特定的问题，并且必须用其他流程和工具来补充，以满足基本的操作需求。

## Git 是 GitOps 中最没意思的部分

我想向你们展示一个理论和一个思维实验，并将其应用于:

**在任何足够复杂的 GitOps 流程中，您的 Git repo 只是另一个结构化数据库。**

您使用 Git 和 Kubernetes 的常见组合开始您的 GitOps 之旅。所有更改都由 pull request 审查，提交到 Git repo，由 Argo CD 或 Flux 等工具使用，并部署到您的集群。您已经满足了 GitOps 的所有功能需求，并享受到了单一事实来源、不可变的变更历史和持续协调的好处。

但是，每次发布新的图像时，让一个人打开一个 pull 请求来碰撞部署资源中的图像属性会变得很乏味。因此，您指示您的构建服务器获取 Git repo，编辑部署资源 YAML 文件，并提交更改。您现在拥有 GitOps 和 CI/CD。

您现在需要衡量您的工程团队的表现。新版本部署到生产环境的频率如何？您很快意识到从 Git 提交中提取这些信息效率很低，而且 Kubernetes API 不是为频繁和复杂的查询设计的，所以您选择用部署事件填充一个更合适的数据库。

随着集群复杂性的增加，您发现需要实现关于可以部署哪种资源的标准。工程团队只能创建部署、机密和配置映射。部署资源必须包括资源限制、一组标准标签，并且不能授予 pod 特权。事实上，在构成部署到集群的资源的数百条 YAML 线路中，只有大约 10 条应该被定制。正如您对 image 标记更新所做的那样，您将资源的编辑从手动 Git 提交提升到了一个自动化的过程，在这个过程中，模板拥有一个严格控制的属性子集，这些属性随着每次部署而更新。

现在，您的 CI/CD 正在执行 Git 的大部分提交，您意识到您不再需要使用 Git repos 作为实施安全规则的手段。您将为代表单个应用程序和环境而创建的几十个回购整合到一个只有 CI/CD 系统每天与之交互的回购中。

您发现自己不得不回滚失败的部署，却发现恢复 Git 提交的概念过于简单。对您想要恢复的一个应用程序的更改已经与十几个其他部署混合在一起。这并不是说任何人都应该直接接触 Git 回购，因为合并冲突可能会带来灾难性的后果。但是您可以使用 CI/CD 服务器来重新部署旧版本的应用程序，因为 CI/CD 服务器具有组成单个应用程序的上下文，所以重新部署只更改与该应用程序相关的文件。

在这一点上，你承认你的 Git repo 是另一个结构化的数据库，反映了“真理之源”的子集:

*   人类不能碰它。
*   所有的改变都是由自动化工具完成的。
*   自动化工具需要特定位置的特定格式的已知文件。
*   Git 历史显示了由机器人而不是人所做的更改列表。
*   Git 历史现在显示为“Deployment #X.Y.Z”，其他提交信息只在自动化工具的上下文中有意义。
*   不再使用拉请求。
*   “事实的来源”现在可以在 Git repo(显示文件的变更)、CI/CD 平台的历史(显示发起变更的人，以及做出变更的脚本)和度量数据库中找到。
*   您整合了您的 Git repos，这意味着即使您想隔离对人类的访问，您的能力也是有限的。

您还意识到，您的 GitOps 流程中增加独特业务价值的部分是“回购的遗留部分”,包括度量收集、标准化模板、发布编排、回滚和部署自动化；以及带有报告、控制面板和支持脚本的“集群右侧”。Git repo 和集群之间的过程现在是如此自动化和可靠，以至于您不需要考虑它。

## 结论

GitOps 已经封装了一个理想功能需求的子集，这些需求可能会为实现这些需求的任何团队提供大量的好处。虽然 Git 和 Kubernetes 都不是满足 GitOps 所必需的，但它们是开始 GitOps 之旅的逻辑平台，因为它们得到了当今更成熟的 GitOps 工具的良好支持。

但是 GitOps 工具倾向于重点关注 Git repo 的提交和 Kubernetes 集群之间发生的事情。尽管这无疑是任何部署渠道的一个关键组成部分，但要实施强大的 CI/CD 渠道和 DevOps 工作流，在“repo 的左边”和“集群的右边”还有许多工作要做。

GitOps 工具还倾向于假设，因为所有东西都在 Git 中，所以每个更改的意图都用提交消息进行了注释，与作者相关联，经过了审查过程，并且可供将来检查。然而，这过于简单了，因为任何足够先进的团队考虑实现 GitOps 都会通过自动化手动接触点立即开始迭代过程，通常是关于如何将配置添加到 Git repo 中。

当您规划 GitOps 工作流的自然发展时，您可能会得出这样的结论:如此多的自动化流程依赖于特定位置和格式的声明性配置，Git 提交必须以与数据库迁移非常相似的方式来处理。必须管理和协调 GitOps 流程的输入，并且必须测试、测量和维护输出。与此同时，Git repo 和集群之间的处理应该是自动化的，使我们今天谈论的许多 GitOps 只是专门的 CI/CD 管道或 DevOps 工作流中的一个中间步骤。

围绕 GitOps 的最大困惑可能是误解了它代表了一个端到端的解决方案，并且您实现了 GitOps 和以 GitOps 为中心的工具，而排除了替代流程和平台。

实际上，GitOps 封装了基础设施和部署管道中的一个步骤，必须用其他流程和平台来补充，以满足常见的业务需求。

愉快的部署！