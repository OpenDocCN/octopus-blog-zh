<html>
<head>
<title>Octopus Deploy Gradle plugin - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>章鱼部署Gradle插件-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/gradle-plugin#2021-08-12">https://octopus.com/blog/gradle-plugin#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-01/gradle-plugin/gradle-octopus.png" class="zoom" data-title=""><img src="../Images/1cf18d4931f18df39d1f18d47f968b07.png" class="img-fluid center" alt="Octopus Deploy Gradle plugin" data-original-src="https://i.octopus.com/blog/2021-01/gradle-plugin/gradle-octopus.png"/>T2】</a></p>

<p>对于上传到Octopus的包，如果您运行的构建服务器本身不受支持，您可以使用Octopus命令行(CLI)或Octopus REST API。对于Gradle项目，我们(<a href="https://www.liftric.com" rel="nofollow"> Liftric </a>)创建了一个小的Gradle插件来帮助我们获得与官方支持的CI-Servers相似的、没有麻烦的体验:octopus-deploy-plugin。</p>

<p>目前，它支持以下用例:</p>

<ul>
<li>创建并上传包构建信息</li>
<li>上传包</li>
<li>从git历史生成构建信息提交</li>
<li>进展八达通部署释放</li>
</ul>

<h2 id="setup-example-project">设置示例项目</h2>

<p>让我们生成一个Spring Boot启动项目来快速启动一个示例项目:</p>

<p>start.spring.io</p>

<p>示例项目必须是一个Gradle项目，并且该语言必须使用Kotlin在Kotlin(而不是Groovy)中生成Gradle构建文件。octopus- deploy-plugin也可以与Groovy构建文件一起使用，但是所有的例子都使用Gradle Kotlin DSL。</p>

<p>还必须添加弹簧腹板和Spring Boot致动器相关性。这添加了一个最小的web服务和一个健康端点，我们可以打开它来验证项目是否成功运行:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-01/gradle-plugin/spring-initializer.png" class="zoom" data-title=""><img src="../Images/e6d56c5dbc95ba53d6884e2458fe60e3.png" class="img-fluid center" alt="Spring Initializer" data-original-src="https://i.octopus.com/blog/2021-01/gradle-plugin/spring-initializer.png"/>T2】</a></p>

<p>解压缩演示项目后，我们可以构建并运行它来验证它是否按预期工作:</p>

<pre><code>./gradlew build
java -jar build/libs/demo-0.0.1-SNAPSHOT.jar
</code></pre>

<p>现在我们可以通过在<code>http://localhost:8080/actuator/health</code>调用健康端点来验证这一点。</p>

<h2 id="configure-the-octopus-deploy-plugin">配置Octopus部署插件</h2>

<p>接下来，我们将添加Gradle插件并添加基本配置。完整的配置使用Gradle Lazy配置方法(Provider API ),该方法允许我们依赖其他提供者/任务进行配置，而无需在Gradle配置时对值进行硬编码。查看构建生命周期文档，了解为什么惰性配置方法是更好的方法。</p>

<p><code>com.liftric.octopus-deploy-plugin</code>是插件ID，当前版本是<code>1.6.0</code>:</p>

<pre><code>plugins {
        id("org.springframework.boot") version "2.4.0"
        id("io.spring.dependency-management") version "1.0.10.RELEASE"
        kotlin("jvm") version "1.4.10"
        kotlin("plugin.spring") version "1.4.10"
        id("com.liftric.octopus-deploy-plugin") version "1.6.0"
}
</code></pre>

<p>如果我们调用<code>./gradlew</code>任务，我们将看到插件添加的任务:</p>

<pre><code>Octopus tasks
-------------
commitsSinceLastTag - Calls git log to receive all commits since the
previous tag or the first commit of the current history.
createBuildInformation - Creates the octopus build-information file.
firstCommitHash - Calls git log to get the first commit hash of the
current history tree
previousTag - Calls git describe to receive the previous tag name. Will
fail if no tag is found.
uploadBuildInformation - Uploads the created octopus build-information
file.
uploadPackage - Uploads the package to octopus.
</code></pre>

<p>现在我们必须配置插件(顶级扩展):</p>

<pre><code>octopus {
    packageName.set(project.name)
    version.set(project.version.toString())
    serverUrl.set("https://&lt;cloud-instance-name&gt;.octopus.app/")
    apiKey.set("API-XXXXYYYYZZZZZXXXXYYYYYZZZZZ")
    val bootJar by tasks.existing(Jar::class)
    pushPackage.set(bootJar.get().archiveFile)
}
</code></pre>

<p>对于名称(<code>packageName</code>)和<code>version</code>，我们重用了由<code>start.spring.io</code>生成器设置的项目值(插件块下的版本，名称在<code>settings.gradle.kts</code>中配置)。对于自动版本控制，可能会使用类似于<code>researchgate/gradle-release</code>插件的东西，但是静态值对于我们的例子来说是很好的。</p>

<p><code>serverUrl</code>需要您的Octopus Deploy实例的基本URL，该示例使用云实例命名模式。了解如何<a href="https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key">创建API密匙</a>。</p>

<p>在非原型项目中，出于安全原因，建议不要将秘密存储在构建脚本/存储库本身中。在Liftric，我们使用Hashicorp Vault作为我们的秘密管理工具，甚至提供了一个访问它的小Gradle插件:<a href="https://github.com/Liftric/vault-client-plugin" rel="nofollow">https://github.com/Liftric/vault-client-plugin</a>。读取安全/秘密环境变量(如Gitlab的屏蔽变量)，或从repo-external文件(如~ ~/)读取。octopus)可能是成熟的秘密管理解决方案的替代方案。</p>

<p>最后，我们导入<code>bootJar</code>任务提供程序，并将<code>archiveFile</code>文件属性绑定到<code>pushPackage</code>属性，这样插件就知道上传哪个文件。</p>

<h2 id="push-build-information">推送构建信息</h2>

<p><code>uploadBuildInformation</code>任务为<code>package</code> <code>version</code>组合构建并上传<code>build-information</code>:</p>

<pre><code>./gradlew uploadBuildInformation
</code></pre>

<p>如果您想调试生成的构建信息，调用<code>./gradlew createBuildInformation</code>只构建它而不上传。内容将被打印，但也可以在<code>build/octopus/build-information.json</code>处查看。</p>

<h2 id="push-packages">推送包</h2>

<p><code>uploadPackage</code>任务上传目标<code>pushPackage</code>文件:</p>

<pre><code>./gradlew uploadPackage
</code></pre>

<p>Octopus Deploy在包上传期间有一个怪癖:它希望文件的格式是<name>。<version>。<extension>。在Maven和Gradle的世界中，默认的命名是<name> - <version> .extension。如果我们保留我们的引导jar的默认命名，默认名称是<code>demo-0.0.1-SNAPSHOT.jar</code>，它将上传版本为<code>0.1-SNAPSHOT</code>的包<code>demo-0</code>，这意味着我们必须修改我们的引导jar工件的命名:</version> </name> </extension> </version> </name></p>

<pre><code>tasks.withType&lt;Jar&gt; {
    archiveFileName.set("${archiveBaseName.get().removeSuffix("-
")}.${archiveVersion.get()}.${archiveExtension.get()}")
}
</code></pre>

<p>现在创建了正确的jar文件名:<code>demo.0.0.1-SNAPSHOT.jar</code>，它与我们生成的构建信息相匹配。</p>

<h2 id="learn-more">了解更多信息</h2>

<p>octopus-deploy-plugin的完整特性集记录在项目的<a href="https://github.com/Liftric/octopus-deploy-plugin" rel="nofollow">报告</a>中。</p>

                    
                    
</body>
</html>