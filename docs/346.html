<html>
<head>
<title>Introducing slugs in Config as Code - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在配置中引入slugs作为代码- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/introducing-slugs-config-as-code#2022-07-20">https://octopus.com/blog/introducing-slugs-config-as-code#2022-07-20</a></blockquote>
                        <p>当我们开始开发配置为代码特性时，我们决定用Octopus配置语言(OCL)中的名称替换id。然而，这种方法有几个缺点，导致我们在OCL用鼻涕虫代替名字。</p>

<p>这篇文章探讨了在OCL使用名字时的权衡，什么是slugs，以及为什么我们选择在Config as Code中实现它们。</p>

<h2 id="ids-in-ocl">OCL的身份证</h2>

<p>传统上，Octopus使用惟一的id来引用来自部署流程、操作手册和变量等地方的共享资源。</p>

<p>就其本身而言，id不是非常具有描述性的，它们只是由资源类型和一个唯一的数字组成。例如，环境的ID可能类似于<code>Environments-42</code>。</p>

<p>Octopus中的id缺乏上下文。光有一个ID还不足以知道这个ID指的是什么。对于API之类的东西来说，这不是问题，因为API响应通常被设计成由其他程序读取。</p>

<p>然而，OCL是给人写和读的。在OCL使用id会让人一眼难以理解，如下例所示:</p>

<pre><code class="language-ocl">step "Run a Script" {
  action {
    environments = ["Environments-42"]
    worker_pool = "WorkerPools-4"
    ...
  }
}
</code></pre>

<p>断章取义，不清楚这是干什么的。<code>Environments-42</code>是什么环境？<code>WorkerPools-4</code>是哪个工人池？这些id在很多地方都不公开，所以试图弄清楚它们指的是什么可能是一个挑战。</p>

<p>如果你只是想读OCL，这不是一个很好的经历。</p>

<h2 id="names-in-ocl">OCL的名字</h2>

<p>在OCL，我们没有使用IDs，而是决定使用资源的名称。</p>

<p>Octopus中的名字非常独特，我们可以放心地用它们来识别资源。名称也很容易一眼识别，使OCL更具可读性和用户友好性。</p>

<pre><code class="language-ocl">step "Run a Script" {
  action {
    environments = ["Staging"]
    worker_pool = "Hosted Ubuntu"
    ...
  }
}
</code></pre>

<p>看看上面的OCL，与在OCL使用IDs相比，更容易理解发生了什么。</p>

<p>在我们决定在OCL使用名字之后，我们也决定在API和UI中为版本控制的项目使用名字<em>来代替</em>id。</p>

<p>我们这样做是为了改善从UI中查看受版本控制的部署流程时的用户体验。如果OCL中有任何损坏的引用(比如名称中的打字错误)，我们会在发现损坏的引用的地方显示一个警告，并允许从UI或API修复它</p>

<p>虽然这种方法最初奏效，但它存在一些长期的缺点。</p>

<h2 id="the-trade-offs-using-names">使用名称的权衡</h2>

<p>在整个Octopus代码库中，我们通常假设所有对共享资源的引用都是使用IDs进行的。当我们在OCL引入名字时，我们打破了这个假设。</p>

<p>ID属性可以包含一个有效的ID <em>或</em>一个可能存在也可能不存在的资源的名称。</p>

<p>这导致了内部和外部的一些突破性的变化，因为<em>“names as id”</em>方法也影响了我们的API，这意味着API消费者(包括我们自己)也必须知道响应中的名称和id。</p>

<p>因为从技术上讲，id作为名称也是有效的，所以可能不清楚给定的值是ID还是名称，让用户自己去猜测。</p>

<p>看看下面的JSON，有几个问题:</p>

<ul>
<li>属性名称以<code>Id</code>为后缀，但是，名称仍然存在。这是令人困惑和误导的。</li>
<li>不清楚<code>EnvironmentId</code>属性的值指的是什么。          <ul>
<li><code>Environment-1</code>是名字还是ID？</li>
<li>如果我有一个ID为<code>Environment-1</code>的环境和另一个名为<code>Environment-1</code>的环境，这是指哪一个呢？</li>
</ul>
</li>
</ul>

<pre><code class="language-json">{
  "EnvironmentId": "Environment-1",
  "WorkerPoolId": "Hosted Ubuntu"
}
</code></pre>

<p>使用名称作为id还会导致喋喋不休的API客户端，因为消费者需要向API发出额外的请求才能获取名称引用的资源。</p>

<p>需要使用通用列表样式的端点(例如，<code>/environments?partialName=foobar</code>)来查找所有匹配的资源，然后需要消费者手动过滤结果。这些请求可能并不便宜，尤其是在进行分页并且需要对单个资源发出多个请求的情况下。</p>

<p>在OCL，由名称引起的另一个小问题是无法在不破坏引用的情况下重命名资源。这是意料之中的，但仍有改进的余地。</p>

<h2 id="introducing-slugs">介绍鼻涕虫</h2>

<p>考虑到使用名字作为id的缺点，我们考虑使用slugs。</p>

<p>Slugs是人类可读的、URL友好的、唯一的标识符。它们通常用在名称不太合适的地方，比如URL(包括这篇文章的URL)。</p>

<p>Slugs通常是根据名称自动生成的。例如，一个名为<code>Test Environment (AU-EAST)</code>的环境会生成<code>test-environment-au-east</code>，删除任何不友好的字符，同时保持可读性。</p>

<h2 id="slugs-in-octopus">章鱼的鼻涕虫</h2>

<p>为了保持较小的范围，我们首先将<a href="https://octopus.com/docs/projects/version-control/config-as-code-reference#slugs-in-ocl"> slugs </a>添加到可以从部署流程中引用的任何内容中。迄今为止，这包括:</p>

<ul>
<li>帐目</li>
<li>频道</li>
<li>部署行动</li>
<li>部署步骤</li>
<li>部署目标</li>
<li>环境</li>
<li>饲料</li>
<li>生活过程</li>
<li>组</li>
<li>工人池</li>
</ul>

<p>随着需求的增加，我们将为更多的资源类型添加slugs。</p>

<p>项目已经有了slugs的概念，它大多符合我们自己的目标。我们设法重新调整了现有项目slug逻辑的大部分用途，并通过一些调整将其应用于上述资源类型。</p>

<ul>
<li>任何新创建的或现有的资源都会根据它们的名称自动生成它们的slugs。</li>
<li>Slugs可以独立于名称进行修改，允许在不破坏任何引用的情况下重命名资源。<em>这改变了项目段塞的现有行为。</em>          <ul>
<li>通常不建议修改slugs，因为这可能会导致需要手动更新的外部引用被破坏(例如，在OCL定义的部署流程)。</li>
</ul>
</li>
</ul>

<h2 id="slugs-in-ocl">OCL的蛞蝓</h2>

<p>在我们将slugs添加到所有必要的资源之后，我们开始在我们的OCL中使用slugs。</p>

<p>这被证明是相对简单的，因为我们可以重用现有的ID来命名转换代码，并添加一些逻辑来在ID和slugs之间进行转换。</p>

<p>我们还更新了部署步骤和动作的OCL语法，这样slugs可以与名称分开指定。</p>

<pre><code class="language-ocl">step "run-a-script" {
  name = "Run a Script"

  action {
    environments = ["staging-au-east"]
    worker_pool = "hosted-ubuntu"
    ...
  }
}
</code></pre>

<p>现在更容易理解它指的是哪个环境和工人池。我们还受益于这些slugs是独一无二的，可以在项目和空间之间重复使用。</p>

<h2 id="isolating-the-abstraction-leak">隔离抽象泄漏</h2>

<p>在撰写本文时，使用slugs引用共享资源只有在OCL才有意义。我们的前端和后端都没有准备好使用slugs来引用这些资源，更新它们来这样做将是一项重要的任务。</p>

<p>因为slugs可以用作上下文唯一的ID，所以当从Octopus中读取和写入OCL时，我们可以在传统ID和slugs之间进行映射。这允许我们在OCL使用slugs，同时在Octopus服务器、API和前端使用IDs。</p>

<p>如果Octopus遇到一个无法映射到ID的slug，就会返回一个验证错误，而不是允许中断的引用。我们可以保持我们正在处理的数据的有效性。</p>

<p>虽然这牺牲了从UI和API查看和编辑中断的引用的能力，但我们相信这是正确的方向，因为它使我们的API恢复了一致的形状，并提高了Octopus server在与OCL一起工作时的稳定性和可预测性。</p>

<h2 id="the-future-of-slugs">蛞蝓的未来</h2>

<p>随着<a href="https://octopus.com/docs/projects/version-control/config-as-code-reference#slugs-in-ocl"> slugs </a>的大部分基础工作已经完成，我们可以开始向更多的资源类型添加slugs，并开始在Octopus代码库中更多地使用它们。</p>

<p>Config as Code之外的许多其他团队也对在其领域中使用slugs表现出了兴趣，所以请继续关注我们接下来如何使用slugs。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>