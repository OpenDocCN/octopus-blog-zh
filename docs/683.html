<html>
<head>
<title>Selenium series: Deploying a simple Lambda function - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:部署简单的Lambda函数——Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/31-deploying-a-simple-lambda-function/deploying-a-simple-lambda-function#2021-07-07">https://octopus.com/blog/selenium/31-deploying-a-simple-lambda-function/deploying-a-simple-lambda-function#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>在之前的文章中，我们配置了Lambda函数所需的所有先决条件:</p>

<ul>
<li>创建了一个AWS帐户，并在本地配置了凭据。</li>
<li>无服务器应用程序已安装。</li>
<li>Lambda Chrome发行版和二进制驱动程序被上传到S3。</li>
<li>Maven build现在生成了一个UberJAR。</li>
</ul>

<p>我们现在正处于可以开始编写Lambda代码的阶段。为此，我们需要添加三个新的依赖项:</p>

<ul>
<li><code>com.amazonaws:aws-lambda-java-core</code></li>
<li><code>com.amazonaws:aws-java-sdk-lambda</code></li>
<li><code>commons-io:commons-io</code></li>
</ul>

<p>前两个依赖项为我们提供了作为Lambda函数运行所需的库。第三个依赖项在处理文件时提供了一些方便的实用函数:</p>

<pre><code class="language-xml">&lt;project 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;!-- ... --&gt;
  &lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;aws.lambda.version&gt;1.2.0&lt;/aws.lambda.version&gt;
    &lt;aws.sdk.version&gt;1.11.305&lt;/aws.sdk.version&gt;
    &lt;commons.io.version&gt;2.6&lt;/commons.io.version&gt;
  &lt;/properties&gt;
  &lt;!-- ... --&gt;
  &lt;dependencies&gt;
    &lt;!-- ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;
      &lt;artifactId&gt;aws-lambda-java-core&lt;/artifactId&gt;
      &lt;version&gt;${aws.lambda.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;com.amazonaws&lt;/groupId&gt;
      &lt;artifactId&gt;aws-java-sdk-lambda&lt;/artifactId&gt;
      &lt;version&gt;${aws.sdk.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-io&lt;/groupId&gt;
      &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
      &lt;version&gt;${commons.io.version}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

<p>在传统的Java应用程序中，我们以一个<code>static main()</code>方法开始执行。Lambda函数则不同。Lambda函数的入口点可以是任何带有签名的方法:</p>

<pre><code>returntype methodname(inputType input, Context context)
</code></pre>

<p>或者，如果不需要<code>Context</code>(我们的目的也不需要),则该签名也有效:</p>

<pre><code>returntype methodname(inputType input)
</code></pre>

<p>此方法的返回和输入类型可以是任何类型，方法本身可以有任何名称。让我们写一个最简单的Lambda函数。</p>

<p>下面的代码定义了一个Lambda函数，该函数返回一个总是为<code>true</code>的<code>boolean</code>类型。这段代码不是很有用，但足以测试Lambda的工作情况:</p>

<pre><code class="language-java">package com.octopus;

import com.amazonaws.services.lambda.runtime.Context;

public class LambdaEntry {
  public boolean runCucumber(String feature) throws Throwable {
    return true;
  }
}
</code></pre>

<p>为了部署这个Lambda，我们需要在项目的根目录下创建一个名为<code>serverless.yml</code>的文件。无服务器应用程序使用这个配置文件来配置和部署Lambda。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image1.png" class="zoom" data-title=""><img src="../Images/3aba944cd79bbbb56a0084e5a3b3c67e.png" class="img-fluid center" alt="C:\0b4b22e1bd61e3d5249b0db50c8cde7f" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image1.png"/>T2】</a></p>

<pre><code class="language-yaml">service:
  name: cucumber-chrome-aws

provider:
  name: aws
  runtime: java8
  region: us-east-1

package:
  artifact: target/webdrivertraining-1.0-SNAPSHOT.jar

functions:
  runCucumber:
    handler: com.octopus.LambdaEntry::runCucumber
    timeout: 300
    memorySize: 512
</code></pre>

<p>让我们把这个文件分解一下。</p>

<p>我们首先定义服务的名称，它将成为Lambda的名称:</p>

<pre><code class="language-yaml">service:
  name: cucumber-chrome-aws
</code></pre>

<p>然后，我们定义要部署到的云平台的详细信息。该无服务器应用程序与云无关，可用于部署到多个云提供商，如AWS、Azure和Google Cloud。我们使用AWS，因此providers部分将配置AWS Lambda服务的全局属性。</p>

<p><code>name</code>属性是云提供商的名称，在本例中设置为<code>aws</code>。</p>

<p><code>runtime</code>属性定义了编写Lambda函数的语言，即<code>java8</code>。</p>

<p><code>region</code>属性定义了我们将Lambda部署到的AWS区域。AWS在全球有很多地区，你可以在<a href="https://docs.aws.amazon.com/general/latest/gr/rande.html#lambda_region" rel="nofollow">https://docs . AWS . Amazon . com/general/latest/gr/rande . html # Lambda _ region</a>找到支持Lambda的完整地区列表。这里我们将使用<code>us-east-1</code>区域:</p>

<pre><code class="language-yaml">provider:
  name: aws
  runtime: java8
  region: us-east-1
</code></pre>

<p>package部分定义了Lambda代码的位置。在我们的例子中，Lambda代码在文件<code>target/webdrivertraining-1.0-SNAPSHOT.jar</code>中，我们通过<code>artifact</code>属性引用它。请注意，这个文件是UberJAR，它将我们的整个应用程序及其依赖项打包在一个文件中:</p>

<pre><code class="language-yaml">package:
  artifact: target/webdrivertraining-1.0-SNAPSHOT.jar
</code></pre>

<p><code>functions</code>部分是我们定义Lambda函数的地方。</p>

<p><code>runCucumber</code>部分定义了一个单独的功能。这个部分可以有任何名称，为了方便起见，我们使用了与入口点方法相同的名称。</p>

<p>属性定义了入口点方法名。这个方法名由完全限定的类名、两个冒号和方法名组成。值<code>com.octopus.LambdaEntry::runCucumber</code>意味着这个Lambda函数将执行<code>com.octopus</code>包中<code>LambdaEntry</code>类的方法<code>runCucumber()</code>。</p>

<p><code>timeout</code>属性设置该函数可以运行的最长时间。Lambda有一个5分钟的硬限制，我们也将超时设置为5分钟(表示为300秒)。</p>

<p>属性定义了我们的Lambda环境可以使用多少内存。我们已经把自己限制在512MB了。请注意，该值包括外部应用程序(如Chrome)使用的任何内存，以及我们自己的代码。</p>

<p>增加<code>timeout</code>和<code>memorySize</code>会增加每个Lambda执行的成本:</p>

<pre><code class="language-yaml">functions:
  runCucumber:
    handler: com.octopus.LambdaEntry::runCucumber
    timeout: 300
    memorySize: 512
</code></pre>

<p>在部署Lambda函数之前，我们需要确保文件<code>target/webdrivertraining-1.0-SNAPSHOT.jar</code>是最新的。在部署之前，Serverless不会为我们重新构建应用程序，因此由我们手动重新构建。点击Maven <span class="path">项目➜包</span>来重建JAR文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image2.png" class="zoom" data-title=""><img src="../Images/999878b0f152f7dceaad0c09c65e219a.png" class="img-fluid center" alt="C:\929577e8ad0a8809d3e7d19cfcf21570" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image2.png"/>T2】</a></p>

<p>我们现在可以部署Lambda函数了。打开终端、命令提示符或PowerShell窗口，并切换到项目根目录。然后运行命令:</p>

<pre><code>$ serverless deploy
</code></pre>

<p>您将看到如下输出:</p>

<pre><code>Serverless: Packaging service...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (19.78 MB)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
.....................
Serverless: Stack update finished...
Service Information
service: cucumber-chrome-aws
stage: dev
region: us-east-1
stack: cucumber-chrome-aws-dev
api keys:
  None
endpoints:
  None
functions:
  runCucumber: cucumber-chrome-aws-dev-runCucumber
</code></pre>

<p>Serverless在后台做了很多工作来上传我们的JAR文件作为Lambda函数，这是使用Serverless而不是手动上传我们的Lambda函数的好处之一。</p>

<p>如果我们返回AWS Lambda控制台，我们现在可以看到新的Lambda函数已经部署。单击功能链接。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image3.png" class="zoom" data-title=""><img src="../Images/3bc9c8c57356cec27ff29de4dd6d9803.png" class="img-fluid center" alt="C:\30bd315ba4b2ee81f05c718344025294" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image3.png"/>T2】</a></p>

<p>本页向我们展示了Lambda函数的细节。</p>

<p>要测试该功能是否工作，点击<code>Test</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image4.png" class="zoom" data-title=""><img src="../Images/413801e88bd817cef24e2c64d3d57edd.png" class="img-fluid center" alt="C:\b24d832e8c4c491083526bb2ca815e1d" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image4.png"/>T2】</a></p>

<p>用字符串替换测试数据(任何字符串都可以)。因为我们的Lambda函数的第一个参数接受一个字符串，所以我们需要在测试时提供一个字符串。</p>

<p>Lambda函数总是将JSON作为输入，它被转换成一个Java对象。在这种情况下，字符串是一个有效的JSON结构，然后被转换成Java字符串。</p>

<p>Lambda函数也总是将返回的对象转换成JSON。</p>

<p>Lambda函数只接受JSON作为输入，并提供JSON作为输出，这一事实在我们稍后将这个函数链接到HTTP端点时非常重要。</p>


<p>然后填充<code>Event</code>名称字段，并点击<code>Create</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image5.png" class="zoom" data-title=""><img src="../Images/45e9996efe53399c45c66af6074cd97c.png" class="img-fluid center" alt="C:\1d66f3aba2a8529623be190d8215c526" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image5.png"/>T2】</a></p>

<p>现在我们有了一个测试事件，再次点击<code>Test</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image6.png" class="zoom" data-title=""><img src="../Images/e546492b4a090c5962504e99302ed0e7.png" class="img-fluid center" alt="C:\9f1e25d4726ec56aade10c28d902412b" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image6.png"/>T2】</a></p>

<p>我们的测试Lambda函数已经通过返回<code>true</code>成功执行。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image7.png" class="zoom" data-title=""><img src="../Images/a8bcef9d0d24cd6ceb438b05fde17090.png" class="img-fluid center" alt="C:\25e8e70a701bd868bc63f982e0521af0" data-original-src="https://i.octopus.com/blog/2018-10/selenium/31-deploying-a-simple-lambda-function/image7.png"/>T2】</a></p>

<p>尽管这个Lambda函数没有做任何有用的事情，但它确实证明了我们已经编写了一个有效的Lambda函数，并且可以使用无服务器应用程序来部署它。完成这些工作后，我们可以继续编写实际运行WebDriver测试的Lambda函数，这将在下一篇文章中进行。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>