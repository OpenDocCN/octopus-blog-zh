<html>
<head>
<title>Selenium series: capturing HAR files - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>硒系列:捕捉HAR文件-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/13-capturing-har-files/capturing-har-files#2021-07-07">https://octopus.com/blog/selenium/13-capturing-har-files/capturing-har-files#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>HTTP存档(HAR)文件是浏览器与外部web应用程序交互的标准JSON格式日志。</p>

<p>你可以通过打开Chrome开发者工具，点击<code>Network</code>标签，打开一个网站，然后在网络调用列表中右击并选择<code>Save as HAR with content</code>来生成一个HAR文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image1.png" class="zoom" data-title=""><img src="../Images/d530566f4fc6815c124bd1bccd9dd734.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image1.png"/>T2】</a></p>

<p>这将生成一个HAR文件，其中包含开发人员工具捕获的所有网络调用的详细信息。</p>

<p>因为HAR文件具有开放的格式，所以您可以使用许多在线工具来检查其内容。一个这样的工具是<a href="https://toolbox.googleapps.com/apps/har_analyzer/" rel="nofollow"> HAR分析器</a>。该工具允许您上传一个HAR文件，然后通过HTTP响应代码进行过滤，检查与请求相关的内容，并查看每个网络调用的时间。当调试web应用程序的错误或了解站点的响应情况时，这种信息是无价的。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image2.png" class="zoom" data-title=""><img src="../Images/59a3179b778cbb0ce730e9b3c14c4fa1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image2.png"/>T2】</a></p>

<p>BrowserMob中一个有用的特性是能够根据通过它的网络请求生成HAR文件。</p>

<p>为了允许测试捕获HAR文件，我们将向<code>AutomatedBrowser</code>接口添加两个方法:</p>

<pre><code class="language-java">void captureHarFile();

void saveHarFile(String file);
</code></pre>

<p><code>captureHarFile()</code>方法用于指示BrowserMob开始捕获网络流量，而<code>saveHarFile()</code>方法将获取任何捕获的流量并将其保存到指定的文件中。</p>

<p>然后默认方法被添加到<code>AutomatedBrowserBase</code>:</p>

<pre><code class="language-java">@Override
public void captureHarFile() {
  if (getAutomatedBrowser() != null) {
    getAutomatedBrowser().captureHarFile();
  }
}

@Override
public void saveHarFile(final String file) {
  if (getAutomatedBrowser() != null) {
    getAutomatedBrowser().saveHarFile(file);
  }
}
</code></pre>

<p>这些方法是在<code>BrowserMobDecorator</code>类中实现的。</p>

<p>为了开始捕获网络流量，我们调用BrowserMob代理对象上的<code>newHar()</code>:</p>

<pre><code class="language-java">@Override
public void captureHarFile() {
  proxy.newHar();
}
</code></pre>

<p>通过调用<code>getHar().writeTo()</code>保存捕获的流量:</p>

<pre><code class="language-java">@Override
public void saveHarFile(final String file) {
  try {
    proxy.getHar().writeTo(new File(file));
  } catch (final IOException ex) {
    throw new SaveException(ex);
  }
}
</code></pre>

<p>被检查的异常<code>IOException</code>被捕获并作为未检查的异常<code>SaveException</code>被重新抛出。这允许我们匹配接口方法签名，它不指定任何检查的异常。</p>

<p>这里是<code>SaveException</code>的代码。它扩展了<code>RuntimeException</code>类，这意味着它是一个未检查的异常:</p>

<pre><code class="language-java">package com.octopus.exceptions;

public class SaveException extends RuntimeException {

  public SaveException() {

  }

  public SaveException(final String message) {
    super(message);
  }

  public SaveException(final Throwable cause) {
    super(cause);
  }

  public SaveException(final String message, final Throwable cause) {
    super(message, cause);
  }
}
</code></pre>

<p>现在，剩下的就是使用这些方法作为测试的一部分:</p>

<pre><code class="language-java">@Test
public void captureHarFile() throws URISyntaxException {
final AutomatedBrowser automatedBrowser =
  AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Chrome");

  try {
    automatedBrowser.init();
    automatedBrowser.captureHarFile();
    automatedBrowser.goTo("https://octopus.com/");
  } finally {
    try {
      automatedBrowser.saveHarFile("test.har");
    } finally {
      automatedBrowser.destroy();
    }
  }
}
</code></pre>

<p>在打开网页之前，我们先给<code>automatedBrowser.captureHarFile()</code>打了个电话。这可确保我们在测试中捕获所有网络流量。</p>

<p>在<code>finally</code>块中，我们嵌套了一个额外的<code>try</code> / <code>finally</code>块。在嵌套的<code>try</code>块中，我们称之为<code>automatedBrowser.saveHarFile("test.har")</code>，它将任何捕获的流量写入文件<code>test.har</code>。这个调用是在<code>finally</code>块中进行的，因为即使测试失败，我们也想保存这个网络流量。HAR文件通常包含可用于调试失败测试的信息，因此我们希望确保在测试过程中保存该文件，而不考虑错误。</p>

<p>在嵌套的<code>finally</code>块中，我们调用<code>automatedBrowser.destroy()</code>。因为对<code>destroy()</code>的调用释放了资源，所以我们需要确保它在测试失败和保存HAR文件失败的情况下运行。以这种方式嵌套<code>try</code> / <code>finally</code>块保证了<code>destroy()</code>方法被调用，而不管任何其他失败。</p>

<p>生成的<code>test.har</code>文件捕获了由于打开【https://octopus.com/】的<a href="https://octopus.com/">而产生的网络流量。然后可以使用HAR分析器等工具检查该文件，以快速识别任何失败的请求(即4xx或5xx范围内的任何HTTP响应代码)，并提供可视的呼叫时间表。这些信息对于调试web应用程序的错误和理解性能瓶颈是非常宝贵的。</a></p>

<p>要用HAR分析仪打开文件，转到<a href="https://toolbox.googleapps.com/apps/har_analyzer/" rel="nofollow">https://toolbox.googleapps.com/apps/har_analyzer/</a>并点击<code>CHOOSE FILE</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image3.png" class="zoom" data-title=""><img src="../Images/95201b4624c4fa9845641aad6239a33e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image3.png"/>T2】</a></p>

<p>选择<code>test.har</code>文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image4.png" class="zoom" data-title=""><img src="../Images/7630ad1c64da4fc2bc9f1cef2c4a70e6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image4.png"/>T2】</a></p>

<p>然后，您将得到一个表格，显示测试过程中发出的所有网络请求。</p>

<p>【T2 <img src="../Images/ae6adff37cc5f4f3ed6ae18928eb1b96.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image5.png"/></p>

<p>您可以使用这些复选框通过HTTP响应代码过滤结果。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image6.png" class="zoom" data-title=""><img src="../Images/b070c4a50effa64d2c3efd0adf7c8efc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image6.png"/>T2】</a></p>

<p>这些代码是100到599之间的数字，以100为一组。0响应代码是一种特殊情况，表示没有返回响应。</p>

<p>下表显示了响应代码的一般含义。</p>

<table class="table">
<thead>
<tr>
<th>代码范围</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>信息反应</td>
</tr>
<tr>
<td>2xx</td>
<td>成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重寄</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误</td>
</tr>
</tbody>
</table>

<p>该表显示了7列。</p>

<table class="table">
<thead>
<tr>
<th>圆柱</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间</td>
<td>提出请求时的UTC时间。</td>
</tr>
<tr>
<td>反应</td>
<td>HTTP响应代码。这是使用上面的复选框过滤的代码。</td>
</tr>
<tr>
<td>请求。大小</td>
<td>浏览器发送的字节数。</td>
</tr>
<tr>
<td>Resp。大小</td>
<td>浏览器接收的字节数。</td>
</tr>
<tr>
<td>分析</td>
<td>显示代表与请求相关联的数据、请求状态以及请求是否由浏览器缓存提供的图标。</td>
</tr>
<tr>
<td>时机</td>
<td>显示一个图表，显示构成请求的事件以及这些事件花费的时间。</td>
</tr>
</tbody>
</table>

<p>响应时间显示在最后一列的图表中。将光标悬停在每个彩色列上可以显示发生了什么类型的事件，以及花费了多长时间。</p>

<p>如果选择了<code>Relative</code>计时类型，图表显示所有请求所用的总时间，彩色列显示单个请求相对于总时间所用的时间。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image7.png" class="zoom" data-title=""><img src="../Images/aea0270ceabab323613eb081291de9cb.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image7.png"/>T2】</a></p>

<p>如果选择了<code>Independent</code>计时类型，图表只显示每个事件相对于单个请求所花费的时间。</p>

<p>单击任何一行都会在页面右侧显示有关该请求的更多详细信息。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image8.png" class="zoom" data-title=""><img src="../Images/e49037d0183d7dc911d5b0ccbcf56ad1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image8.png"/>T2】</a></p>

<p>您会注意到，当选择一个请求时，许多数据都丢失了。这是因为默认情况下，BrowserMob只捕获一小部分可以保存在HAR文件中的数据。为了获取所有可用的信息，我们在<code>AutomatedBrowser</code>接口中创建了一个名为<code>captureCompleteHarFile()</code>的新方法:</p>

<pre><code class="language-java">void captureCompleteHarFile();
</code></pre>

<p>我们将默认实现添加到<code>AutomatedBrowserBase</code>类中:</p>

<pre><code class="language-java">@Override
public void captureCompleteHarFile() {
  if (getAutomatedBrowser() != null) {
    getAutomatedBrowser().captureCompleteHarFile();
  }
}
</code></pre>

<p>然后我们在<code>BrowserMobDecorator</code>类中实现该方法:</p>

<pre><code class="language-java">@Override
public void captureCompleteHarFile() {
  final EnumSet&lt;CaptureType&gt; captureTypes =
    CaptureType.getAllContentCaptureTypes();
  captureTypes.addAll(CaptureType.getHeaderCaptureTypes());
  captureTypes.addAll(CaptureType.getCookieCaptureTypes());
  proxy.setHarCaptureTypes(captureTypes);
  proxy.newHar();
}
</code></pre>

<p>这里的更改是指示BrowserMob捕获发送和接收的某些附加数据。BrowserMob公开了一个名为<code>CaptureType</code>的枚举，它定义了可以保存在HAR文件中的各种细节。此外，<code>CaptureType</code> enum有一些静态方法，这些方法提供了方便的enum组，这些enum组表示相关种类的细节的集合。</p>

<p>我们从代表内容的一组预定义的<code>CaptureType</code>枚举开始:</p>

<pre><code class="language-java">final EnumSet&lt;CaptureType&gt; captureTypes =
  CaptureType.getAllContentCaptureTypes();
</code></pre>

<p>然后，我们添加代表头部的预定义的<code>CaptureType</code>枚举组:</p>

<pre><code class="language-java">captureTypes.addAll(CaptureType.getHeaderCaptureTypes());
</code></pre>

<p>最后，我们添加代表cookies的一组预定义的<code>CaptureType</code>枚举:</p>

<pre><code class="language-java">captureTypes.addAll(CaptureType.getCookieCaptureTypes());
</code></pre>

<p>然后将这些<code>CaptureType</code>枚举传递给<code>setHarCaptureTypes()</code>方法，以配置BrowserMob将所有这些细节保存到生成的HAR文件中:</p>

<pre><code class="language-java">proxy.setHarCaptureTypes(captureTypes);
</code></pre>

<p>更新测试以调用<code>captureCompleteHarFile()</code>方法，并再次运行它:</p>

<pre><code class="language-java">@Test
public void captureCompleteHarFile() throws URISyntaxException {

  final AutomatedBrowser automatedBrowser =
    AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Chrome");

  try {
    automatedBrowser.init();
    automatedBrowser.captureCompleteHarFile();
    automatedBrowser.goTo("https://octopus.com/");
  } finally {
    try {
      automatedBrowser.saveHarFile("test.har");
    } finally {
      automatedBrowser.destroy();
    }
  }
}
</code></pre>

<p>您会注意到，HAR文件现在有几兆字节大小，这是针对一个相对简单的页面请求的。更完整的测试可能会生成相当大的HAR文件，所以尽量少用<code>captureCompleteHarFile()</code>方法。</p>

<p>当我们分析新的HAR文件时，我们可以看到不再有任何关于丢失信息的警告。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image9.png" class="zoom" data-title=""><img src="../Images/5401e708781433667c1fd29f5e089bca.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/13-capturing-har-files/image9.png"/>T2】</a></p>

<p>HAR文件是记录和分析测试过程中网络迭代的非常有用的方法，而且由于BrowserMob代理，生成HAR文件非常容易。但是BrowserMob可以做的不仅仅是记录流经它的流量，在下一篇文章中，我们将看到BrowserMob如何阻止或修改请求。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>