<html>
<head>
<title>Packaging Node.js applications - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>打包Node.js应用程序- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/packaging-nodejs#2022-08-09">https://octopus.com/blog/packaging-nodejs#2022-08-09</a></blockquote>
                        <p>Node.js已经成为近年来最热门的编程语言之一。JavaScript已经连续几年在<a href="https://insights.stackoverflow.com/survey/2018" rel="nofollow">栈溢出开发者调查</a>中被评为最受欢迎的编程语言，不难看出为什么。</p>

<p>JavaScript作为web前端语言无处不在，这意味着无论开发人员来自Java、C#还是Ruby背景，都可以使用和理解它。已经了解JavaScript的开发人员的数量意味着社区中挤满了各种可能需求的库和框架，因此有理由认为将它用于服务器端项目通常是正确的方法。</p>

<h2 id="things-go-wrong">事情出错了</h2>

<p>出于某种原因，当从编译语言转向脚本语言时，许多程序员似乎把他们的好习惯扔在了门外。在Node.js应用程序(或使用Node.js作为开发环境的纯JavaScript应用程序)中，开发人员将他们的代码提交给GitHub，然后将源代码直接从GitHub拖到他们的生产服务器上，后面跟着一个<code>npm install</code>和<code>&lt;grunt|gulp|webpack&gt; build</code>，这种情况太常见了。通常，他们足够勤奋地编写测试，但决定在每次部署时重新构建应用程序更容易。这可能会导致几个问题。</p>

<h3 id="dependency-versioning">依赖版本控制</h3>

<p>通过在您的<code>packages.json</code>文件中使用semver范围，您可能会遇到这样的情况:您的配置要求某些包依赖项需要与版本<code>~4.17.2</code>匹配，因此您的开发机器关闭了<code>4.17.3</code>，针对<code>4.17.4</code>运行了测试，并且在部署产品时，库作者已经进行了另一次更新，并且您的产品软件正在运行<code>4.17.9</code>。我再说一遍，生产中！有很多这样的例子，库作者偶然地(或者没有意识到他们的改变的影响)用相应的版本碰撞来推动突破性的改变，由于广泛的版本匹配导致消耗代码崩溃。在<code>node_modules</code>中可能出现的复杂依赖链加剧了这个问题。例如，当一个显式依赖的模块A依赖于模块B的某个版本范围时，模块B本身依赖于一堆其他模块的某个版本范围。记住当你运行<code>npm install</code>时，不仅仅是<em>你的</em>模块被动态确定和解析。</p>

<p>npm 5中引入的<a href="https://docs.npmjs.com/files/package-lock.json" rel="nofollow"> <code>package-lock</code> </a>特性在一定程度上缓解了这个问题。<strong>确保将这个文件提交给源代码管理</strong>。</p>

<h3 id="deployment-success-outside-your-control">部署成功在您的控制之外</h3>

<p>每次部署应用程序时，您都在下载新的、潜在的未经测试的依赖项！这是假设一切顺利。尽管npm不再支持将新文件推送到现有版本，但我听说过不止一次生产发布失败的情况，因为由于npm暂时关闭或网络问题，包无法下载。这种安装失败通常伴随着覆盖旧版本，导致服务器在恢复对npm的访问之前实际上毫无价值(或者更糟)。在一个案例中，每当用户的AWS Elastic Beanstalk在现有服务器场负载过重的情况下试图启动新的web服务器时，用户就执行这个<em>全新安装</em>过程。由于npm服务器本身经历了停机，新的服务器无法上线，并且无法处理一些流量，最终导致现有的、以前很好的网站关闭。这是在之后的<em>，最初的部署已经在<em>成功</em>了很多天，并且相同的产品版本被部署到新的服务器上。</em></p>

<h2 id="packaging-your-node.js-app">打包Node.js应用程序</h2>

<p>希望我们都同意JavaScript应用程序应该像其他编译语言一样被对待，并在构建时打包成一个可部署的工件。</p>

<p>假设我们正在开发<a href="https://github.com/OctopusSamples/RandomQuotes-JS" rel="nofollow"> RandomQuote-JS </a>虚拟应用程序，一个简单的构建步骤可能是:</p>

<pre><code>&gt; npm install
&gt; gulp build    # insert build tool of choice
&gt; zip -r ../RandomQuotes.1.0.zip .
# ../RandomQuotes.1.0.zip created (5.2 MB)
</code></pre>

<p>然后，可以在我的生产服务器上提取生成的zip文件，使应用程序可以按原样运行。然而，在本例中，我们压缩了整个应用程序目录，其中大部分包含我用于调试和编译的各种库。一旦所有的东西都构建好并准备好在生产中运行，我就不需要所有的typescript编译器、webpack库和测试框架了，但是我们如何将开发时依赖项与生产依赖项分开呢？</p>

<p>如果您运行<a href="https://docs.npmjs.com/cli/prune" rel="nofollow"> <code>npm prune --production</code> </a>，npm将从<code>node_modules</code>中移除在<code>package.json</code>的<code>devDependencies</code>部分中指定的所有包。即使您不使用我们的工具，我也建议您在将整个项目文件夹压缩到CD系统的归档文件中之前运行这个命令，无论您选择的部署工具是Octopus Deploy、VSTS、Chef还是一些手动过程。</p>

<p>为了使这个过程更简单，Octopus Deploy发布了一个Node.js cli工具octopjs，用于创建zip(或tar.gz)归档文件，而不必执行修剪步骤。默认情况下，使用项目的<code>package.json</code>中的名称和版本来生成包名；但是，这些值都可以被覆盖。<code>Octojs</code>可以通过控制台直接使用，也可以作为构建过程的一部分导入并在代码中使用。</p>

<h3 id="package-via-command-line">通过命令行打包</h3>

<p>使用该工具最简单的方法是全局安装它:</p>

<pre><code>&gt; npm install -g @octopusdeploy/octojs
</code></pre>

<p>现在，从任何项目内部都可以调用<code>octojs</code>来打包应用程序。假设我们的项目刚刚构建并经过测试，打包应用程序就像下面这样简单:</p>

<pre><code>&gt; octojs pack -O C:\Bin --gitignore --dependencies prod

Created package C:\Bin\RandomQuotes.1.0.0.zip (1.66 MB)
</code></pre>

<p>生成的包的大小现在小了很多，包ID和版本是从项目本身生成的。有了现在生成的包，我们可以将它直接推送到Octopus Deploy内置提要进行部署:</p>

<pre><code>&gt; octojs push --package C:\Bin\ramdomquotes.1.0.0.zip --server http://octopusserver.acme.com --apiKey API-F2K29BA08AA123
Push response 201 - Created
</code></pre>

<h3 id="package-via-code">通过代码打包</h3>

<p>或者，您可以使用同一个库来打包您的项目，并一步一步地完成代码:</p>

<pre><code class="language-JavaScript">var octo = require("@octopusdeploy/octojs");
octo.pack({dependencies: 'prod', bypassDisk: true, root: "."},
    (err, data) =&gt; {
            console.log("Uploading package: "+ data.name);
            octo.push(data.stream, {
                apiKey: 'API-F2K29BA08AA123 ',
                server: 'http://octopusserver.acme.com',
                name: data.name
            }, () =&gt; console.log("Uploaded"));
        }
    })
    .append('hello.txt', new Buffer('This Is An Additional File'))
    .finalize(true);
</code></pre>

<h2 id="lets-start-treating-node.js-like-a-serious-language">让我们开始把Node.js当作一门严肃的语言来对待</h2>

<p>Node.js是一门严肃的语言，所以我们需要在我们的CD管道中严肃对待它。这意味着下载依赖项并在构建服务器上构建(或传输)一次，然后将结果和依赖项打包到一个自包含的部署包中。Octopus JS库可以在这方面提供帮助，但最终您使用什么工具来打包和部署您的应用程序并不重要，重要的是它只需构建一次，就可以在您的环境中部署。</p>

<p><em>更新:</em>查看<a href="https://octopus.com/blog/javascript-configuration">最近的一篇文章</a>，在这篇文章中，我提供了一些如何在部署时获得特定于环境的配置的例子。</p>

<h2 id="learn-more">了解更多信息</h2>



                    
                    
</body>
</html>