<html>
<head>
<title>Chaos engineering and runbooks - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>混沌工程和运行手册-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/chaos-engineering-and-runbooks#2021-11-05">https://octopus.com/blog/chaos-engineering-and-runbooks#2021-11-05</a></blockquote>
                        <p>Octopus中的操作手册将Ops置于DevOps中。这篇文章是一系列文章的一部分:</p>



<hr/>

<p>Octopus 2021 Q3包括对Kubernetes部署的更新支持，以及针对Google Cloud、AWS和Azure用户的runbooks。在我们的<a href="https://octopus.com/blog/octopus-release-2021-q3" class="alert-link">发布公告</a>中了解更多信息。</p>


<p>自动将自身重新配置到所需状态的声明式系统的承诺是:</p>

<blockquote class="blockquote">
<p>由停止或毁坏的资源引起的大多数故障将在没有任何人工干预的情况下被纠正。</p>
</blockquote>

<p>Kubernetes就是一个很好的例子，因为当部署将集群恢复到期望的状态时，部署中被删除的单元会被重新创建。</p>

<p>证明一个系统可以容忍单个组件的故障是混沌工程的本质。</p>

<p>在他的演讲<a href="https://youtu.be/Qus15C5vT5Y?list=PLj6h78yzYM2PpmMAnvpvsnR4c27wJePh3&amp;t=1447" rel="nofollow"> BoF深潜:混沌工程</a>中，<a href="https://chaostoolkit.org/" rel="nofollow">混沌工具包</a>的创建者Sylvain Hellegouarch概述了如何将混沌工程应用于Kubernetes。虽然这个演讲的技术细节很有价值，但他关于如何以及何时进行混沌实验的建议是Octopus用户最感兴趣的(这个演讲已经进行了24分钟):</p>

<blockquote class="blockquote">
<p>不要把你的混沌工程和你的部署联系起来。正交运行该部分。</p>
</blockquote>

<blockquote class="blockquote">
<p>你应该总是有持续运行的混沌工程，因为在部署时做[混沌工程]的问题是你的系统存在于你的部署之间。它在进化，所以在你跑步的时候要不断改变系统。</p>
</blockquote>

<p>直到最近，在Octopus中运行任何类型的自动化流程都意味着创建一个部署。有可能破解部署的想法来实现管理任务，但这很尴尬。</p>

<p>有了Octopus Runbooks，Octopus现在可以一流地支持与部署并行运行管理任务。Runbooks可以访问所有现有的环境、变量、目标、步骤、安全性、审计和报告，但不受部署或生命周期概念的约束。</p>

<p>这使得runbooks非常适合运行像混沌工程工具包这样的工具。在这篇文章中，我们创建了一个非常简单的混沌实验作为运行手册，并指出运行手册为这种任务提供的优势。</p>

<h2 id="the-kubernetes-deployment">Kubernetes部署</h2>

<p>我们首先创建一个部署流程，该流程在Kubernetes集群上旋转多个pod。这是通过Octopus中的<em>部署Kubernetes容器</em>步骤实现的。</p>

<p>在下面的截图中，您可以看到我创建了一个部署，它创建了10个NGINX pods。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/k8s-step.png" class="zoom" data-title=""><img src="../Images/23f9cd9050d40a8ef57a44b776808efa.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/k8s-step.png"/></a>T2】</p>

<h2 id="the-chaos-runbook-example">混沌运行手册示例</h2>

<p>除了部署之外，我还有一个runbook，它执行一个简单的Chaos Toolkit实验，删除一个pod，并使用<a href="https://docs.chaostoolkit.org/drivers/kubernetes/#microservice_available_and_healthy" rel="nofollow">微服务_可用_健康</a>功能确保部署是健康的。</p>

<p>测试完成后，生成一份<a href="https://docs.chaostoolkit.org/reference/usage/report/" rel="nofollow"> PDF报告</a>，显示实验结果。由<strong> chaos </strong>工具生成的输出和报告被捕获为工件。</p>

<pre><code class="language-PowerShell">Set-Content -Path experiment.json -Value @"
{
    "title": "Do we remain available in face of pod going down?",
    "description": "We expect Kubernetes to handle the situation gracefully when a pod goes down",
    "tags": ["kubernetes"],
    "steady-state-hypothesis": {
        "title": "Verifying service remains healthy",
        "probes": [
            {
                "name": "all-our-microservices-should-be-healthy",
                "type": "probe",
                "tolerance": true,
                "provider": {
                    "type": "python",
                    "module": "chaosk8s.probes",
                    "func": "microservice_available_and_healthy",
                    "arguments": {
                        "name": "myapp"
                    }
                }
            }
        ]
    },
    "method": [
        {
            "type": "action",
            "name": "terminate-db-pod",
            "provider": {
                "type": "python",
                "module": "chaosk8s.pod.actions",
                "func": "terminate_pods",
                "arguments": {
                    "label_selector": "app=my-app",
                    "name_pattern": "my-app-[0-9]$",
                    "rand": true
                }
            },
            "pauses": {
                "after": 5
            }
        }
    ]
}
"@
chaos run experiment.json
docker run `
    -v "$(Get-Location):/tmp/result" `
    -it `
    chaostoolkit/reporting
New-OctopusArtifact journal.json
New-OctopusArtifact report.pdf
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/chaos-runbook.png" class="zoom" data-title=""><img src="../Images/6c7043542e790a8047bcf922e9865f5b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/chaos-runbook.png"/>T2】</a></p>

<p>下面是runbook执行的结果，输出JSON和报告PDF作为工件提供:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/runbook-results.png" class="zoom" data-title=""><img src="../Images/7c8d0da795840bdc085a3b0393083671.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/runbook-results.png"/>T2】</a></p>

<p>我们已经成功地实现了一个简单的混沌工程实验。</p>

<p>那么runbooks给这个过程带来了什么好处呢？</p>

<h2 id="deployments-and-runbooks-side-by-side">部署和操作手册并行</h2>

<p>通过在单个项目中定义部署和操作手册，我们有一个单一的上下文来捕获部署过程和任何正在进行的测试或部署管理。</p>

<p>从方便的角度来看，这意味着:</p>

<ul>
<li>单一用户界面</li>
<li>一组共享的变量</li>
<li>紧密链接的概览仪表板</li>
<li>合并报告</li>
</ul>

<p>从管理的角度来看，只有一个项目需要配置安全规则和一个整合的审计日志。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/filtered-audit-log.png" class="zoom" data-title=""><img src="../Images/1ea2f5b66001021a387f6e1991a34512.png" class="img-fluid center" alt="Octopus dashboard open on Configuration tab and Audit page showing audit log" data-original-src="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/filtered-audit-log.png"/>T2】</a></p>

<p>Runbooks将针对部署运行的管理任务与部署本身放在一起。这使得运行、检查和跟踪基础设施的状态变得容易。</p>

<h2 id="shared-context">共享上下文</h2>

<p>复杂的Kubernetes部署将实现名称空间来保持资源分离，并对服务帐户进行RBAC控制，以确保流氓部署定义不会干扰集群的其余部分。当这些权限边界在Octopus Kubernetes目标中表示时，它们通过确保管理任务也受到约束而很好地适应了runbooks。</p>

<p>像几乎所有使用Kubernetes的CLI工具一样，Chaos Toolkit可以从Kubernetes <code>config</code>文件的细节中访问集群。Octopus根据部署或runbook执行的目标提供了这个配置文件的本地副本。因此，无论部署使用专门的Kubernetes步骤还是runbook实现通用的Kubernetes脚本，两者都共享一个只定义一次的目标。</p>

<h2 id="independent-execution-workflows">独立的执行工作流程</h2>

<p>虽然共享相同的底层上下文，但runbooks的执行独立于部署。Runbooks定义了自己的计划触发器，也可以在任何环境中手动运行，而不受生命周期的限制。</p>

<p>这是混沌工程的理想选择。正如Sylvain在他的演讲中提到的，应该在部署之间连续运行混沌实验来验证集群。</p>

<p>在下面的截图中，混沌实验每十分钟运行一次，以持续验证集群。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/runbook-trigger.png" class="zoom" data-title=""><img src="../Images/c4077100932d055b0ef0aca90bf9b5ef.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-09/chaos-engineering-and-runbooks/runbook-trigger.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>我惊喜地发现，在Octopus中安装和运行混沌工具包是如此简单。在已经定义了Kubernetes部署的情况下，针对现有目标和环境编写另一个工具几乎不费吹灰之力。</p>

<p>除了简单执行工具的初始能力之外，Octopus Runbook automation还提供了跨领域的功能，如日志记录、审计、安全、用户管理、报告和仪表板，作为一个成熟可靠的基础来扩展组织内的流程，如混沌工程。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>