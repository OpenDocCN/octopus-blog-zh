<html>
<head>
<title>Selenium series: Launching Cucumber tests - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>硒系列:启动黄瓜测试-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/32-launching-cucumber-tests/launching-cucumber-tests#2021-07-07">https://octopus.com/blog/selenium/32-launching-cucumber-tests/launching-cucumber-tests#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>现在我们有了一个可以运行的简单Lambda函数，以及一个部署应用程序的无服务器配置，我们可以创建一个启动WebDriver测试的Lambda函数。</p>

<p>下面是<code>LambdaEntry</code>类的新代码，它将从一个小黄瓜特性文件启动一个WebDriver测试:</p>

<pre><code class="language-java">package com.octopus;

import org.apache.commons.io.FileUtils;
import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class LambdaEntry {
  private static final String CHROME_HEADLESS_PACKAGE =
  "https://s3.amazonaws.com/webdriver-testing-resources/stable-headless-chromium-amazonlinux-2017-03.zip";
  private static final String CHROME_DRIVER =
  "https://s3.amazonaws.com/webdriver-testing-resources/chromedriver_linux64.zip";

  public String runCucumber(final String feature) throws Throwable {

    File driverDirectory = null;
    File chromeDirectory = null;
    File outputFile = null;
    File featureFile = null;

    try {

      driverDirectory = downloadChromeDriver();
      chromeDirectory = downloadChromeHeadless();
      outputFile = Files.createTempFile("output", ".json").toFile();
      featureFile = writeFeatureToFile(feature);

      cucumber.api.cli.Main.run(
        new String[]{
          "--monochrome",
          "--glue", "com.octopus.decoratorbase",
          "--format", "json:" + outputFile.toString(),
          featureFile.getAbsolutePath()},
      Thread.currentThread().getContextClassLoader());

      return FileUtils.readFileToString(outputFile, Charset.defaultCharset());
    } finally {
      FileUtils.deleteQuietly(driverDirectory);
      FileUtils.deleteQuietly(chromeDirectory);
      FileUtils.deleteQuietly(outputFile);
      FileUtils.deleteQuietly(featureFile);
    }
  }

  private File downloadChromeDriver() throws IOException {
    final File extractedDir = downloadAndExtractFile(CHROME_DRIVER, "chrome_driver");
    final String driver = extractedDir.getAbsolutePath() + "/chromedriver";
    System.setProperty("webdriver.chrome.driver", driver);
    new File(driver).setExecutable(true);
    return extractedDir;
  }

  private File downloadChromeHeadless() throws IOException {
    final File extractedDir = downloadAndExtractFile(CHROME_HEADLESS_PACKAGE, "chrome_headless");
    final String chrome = extractedDir.getAbsolutePath() + "/headless-chromium";
    System.setProperty("chrome.binary", chrome);
    new File(chrome).setExecutable(true);
    return extractedDir;
  }

  private File downloadAndExtractFile(final String download, final String tempDirPrefix) throws IOException {
    File downloadedFile = null;
    try {
      downloadedFile = File.createTempFile("download", ".zip");
      FileUtils.copyURLToFile(new URL(download), downloadedFile);
      final File extractedDir = Files.createTempDirectory(tempDirPrefix).toFile();
      unzipFile(downloadedFile.getAbsolutePath(), extractedDir.getAbsolutePath());
      return extractedDir;
    } finally {
      FileUtils.deleteQuietly(downloadedFile);
    }

  }

  private void unzipFile(final String fileZip, final String outputDirectory) throws IOException {

    final byte[] buffer = new byte[1024];

    try (final ZipInputStream zis = new ZipInputStream(new FileInputStream(fileZip))) {
      ZipEntry zipEntry = zis.getNextEntry();
      while (zipEntry != null) {
        final String fileName = zipEntry.getName();
        final File newFile = new File(outputDirectory + "/" + fileName);
        try (final FileOutputStream fos = new FileOutputStream(newFile)) {
          int len;
          while ((len = zis.read(buffer)) &gt; 0) {
            fos.write(buffer, 0, len);
          }
        }
        zipEntry = zis.getNextEntry();
      }
      zis.closeEntry();
    }
  }

  private File writeFeatureToFile(final String feature) throws IOException {
    final File featureFile = File.createTempFile("cucumber", ".feature");
    try {
      final URL url = new URL(feature);
      FileUtils.copyURLToFile(url, featureFile);
    } catch (final MalformedURLException ex) {
      try (PrintWriter out = new PrintWriter(featureFile)) {
        out.println(feature);
      }
    }
    return featureFile;
  }
}
</code></pre>

<p>让我们来分解这个类。</p>

<p>以下常量是我们上传到S3的Chrome Lambda发行版和Linux二进制驱动程序的URL。这些网址对你来说是不同的，因为你将它们上传到一个不同的S3桶。</p>

<p>不要在你自己的测试中使用这些URL，但是总是使用你控制的S3桶的URL。使用指向您自己的S3存储桶的URL可以确保您的代码只依赖于您拥有和管理的资源。</p>


<pre><code class="language-java">private static final String CHROME_HEADLESS_PACKAGE =
"https://s3.amazonaws.com/webdriver-testing-resources/stable-headless-chromium-amazonlinux-2017-03.zip";
private static final String CHROME_DRIVER =
"https://s3.amazonaws.com/webdriver-testing-resources/chromedriver_linux64.zip";
</code></pre>

<p>我们仍然使用<code>runCucumber()</code>方法作为Lambda入口点:</p>

<pre><code class="language-java">public String runCucumber(String feature) throws Throwable {
</code></pre>

<p>这四个文件将在Lambda每次运行时创建。我们需要跟踪我们创建的所有资源，以便它们可以在事后被清理，因为Lambda可能会重用底层的Linux实例来进行连续的函数调用。如果我们要创建文件而不清理它们，我们可能会耗尽分配给Lambda函数的所有可用空间，代码将无法正常工作:</p>

<pre><code class="language-java">File driverDirectory = null;
File chromeDirectory = null;
File outputFile = null;
File featureFile = null;
</code></pre>

<p>每次调用<code>runCucumber()</code>方法时，我们下载Linux二进制驱动程序和Chrome Lambda发行版。这些文件太大，无法与Lambda代码捆绑在一起分发，所以我们必须在运行时下载它们。通过将这些文件上传到S3，我们利用了S3和Lambda都是AWS提供的服务，Lambda可以快速可靠地访问S3的文件:</p>

<pre><code class="language-java">try {
  driverDirectory = downloadChromeDriver();
  chromeDirectory = downloadChromeHeadless();
</code></pre>

<p>Cucumber可以用特性文件执行的结果生成一个JSON报告文件。我们将使用这个文件作为Lambda的返回值。这里我们创建一个临时文件，可以用来保存JSON结果:</p>

<pre><code class="language-java">outputFile = Files.createTempFile("output", ".json").toFile();
</code></pre>

<p>我们创建的最后一个文件是Gherkin特征文件。该文件的内容是在功能参数中传递给方法的字符串:</p>

<pre><code class="language-java">featureFile = writeFeatureToFile(feature);
</code></pre>

<p>现在我们已经有了所有的文件，我们可以运行黄瓜。</p>

<p>以前，我们利用Cucumber提供的JUnit集成来启动特性文件，作为测试类的一部分。但是我们不是从Lambda运行JUnit，所以我们需要一种新的方式来启动Cucumber。</p>

<p>幸运的是，Cucumber还提供了一种在命令行中使用传统的<code>cucumber.api.cli.Main</code>类中的<code>static void main()</code>方法来运行它的方法。这个<code>main()</code>方法然后调用<code>run()</code>方法。我们使用这个<code>run()</code>方法作为启动Cucumber的一种方式，就好像它是从命令行直接运行的一样。</p>

<p>传递给<code>run()</code>方法的第一个参数是一个字符串数组，它保存通常在命令行上提供的参数。我们使用了许多选项来定制输出，链接到我们的glue类，并保存一个报告文件。</p>

<ul>
<li><code>--monochrome</code>选项从打印到控制台的消息中删除彩色文本。在日志文件中查看时，这些彩色消息翻译得不好。</li>
<li><code>--glue</code>选项将Cucumber链接到保存我们的注释类的包。这与我们之前传递给JUnit注释的选项相同。</li>
<li><code>--format</code>选项定义了Cucumber生成的报告文件。它被设置为值<code>json:&lt;output file&gt;</code>，输出文件是我们之前创建的临时文件。</li>
<li>最后一个参数是特征文件本身。</li>
</ul>

<p>第二个参数是Cucumber使用的类加载器。我们传递<code>Thread.currentThread().getContextClassLoader()</code>的值，就像<code>cucumber.api.cli.Main.main()</code>方法一样:</p>

<pre><code class="language-java">cucumber.api.cli.Main.run(
  new String[]{
    "--monochrome",
    "--glue", "com.octopus.decoratorbase",
    "--format", "json:" + outputFile.toString(),
    featureFile.getAbsolutePath()},
  Thread.currentThread().getContextClassLoader());
</code></pre>

<p>一旦运行了Gherkin特征文件，我们就读取报告文件的内容并返回它:</p>

<pre><code class="language-java">return `FileUtils.readFileToString(outputFile, Charset.defaultCharset());`
</code></pre>

<p>我们创建的所有文件都使用<code>FileUtils.deleteQuietly()</code>方法从Apache Commons IO库中删除。这个方法不抛出任何异常，这意味着我们试图删除每个文件，忽略任何错误。</p>

<p>由于运行我们代码的Linux实例最终将被销毁，并为下一次Lambda调用分配一个新的实例，因此无法删除的临时文件可能不会造成任何持久的危害:</p>

<pre><code class="language-java">  } finally {
    FileUtils.deleteQuietly(driverDirectory);
    FileUtils.deleteQuietly(chromeDirectory);
    FileUtils.deleteQuietly(outputFile);
    FileUtils.deleteQuietly(featureFile);
  }
}
</code></pre>

<p><code>downloadChromeDriver()</code>方法是我们下载和配置Linux Chrome二进制驱动程序的地方。</p>

<p>我们首先调用<code>downloadAndExtractFile()</code>方法，传入驱动程序URL和用于存放提取文件的临时目录的前缀:</p>

<pre><code class="language-java">private File downloadChromeDriver() throws IOException {
final File extractedDir = downloadAndExtractFile(CHROME_DRIVER, "chrome_driver");
</code></pre>

<p>然后，我们获取驱动程序的路径，将<code>webdriver.chrome.driver</code>系统属性设置为驱动程序路径，并确保驱动程序文件的可执行标志设置为true。</p>

<p>要在Linux中执行一个文件，该文件必须将可执行标志设置为<code>true</code>。这不同于像Windows这样的操作系统，它使用像<code>.exe</code>这样的扩展名来表示可执行文件。</p>

<pre><code class="language-java">final String driver = extractedDir.getAbsolutePath() + "/chromedriver";
System.setProperty("webdriver.chrome.driver", driver);
new File(driver).setExecutable(true);
</code></pre>

<p>然后返回存放Chrome驱动程序的目录，以便在测试完成后可以清理它:</p>

<pre><code class="language-java">  return extractedDir;
}
</code></pre>

<p><code>downloadChromeHeadless()</code>方法遵循与<code>downloadChromeDriver()</code>方法相同的模式，只是这次我们下载的是Chrome Lambda发行版。</p>

<p>它首先将Chrome发行版下载到一个前缀为<code>chrome_headless</code>的临时目录中:</p>

<pre><code class="language-java">private File downloadChromeHeadless() throws IOException {
  final File extractedDir = downloadAndExtractFile(CHROME_HEADLESS_PACKAGE, "chrome_headless");
</code></pre>

<p>我们获取Chrome可执行文件的路径，将<code>chrome.binary</code>系统属性设置为该路径，并确保该文件启用了可执行标志。</p>

<p><code>chrome.binary</code>系统属性不是一个被WebDriver识别的属性，但它是一个我们将在稍后发布Chrome时访问的属性:</p>

<pre><code class="language-java">final String chrome = extractedDir.getAbsolutePath() + "/headless-chromium";
System.setProperty("chrome.binary", chrome);
new File(chrome).setExecutable(true);
</code></pre>

<p>然后返回临时目录，以便在测试完成后可以清理它:</p>

<pre><code class="language-java">  return extractedDir;
}
</code></pre>

<p>前面的方法都调用了<code>downloadAndExtractFile()</code>方法来下载和解压一个ZIP文件。</p>

<p>我们首先创建一个指向临时文件的变量，我们将把远程文件下载到这个临时文件中:</p>

<pre><code>private File downloadAndExtractFile(final String download, final String tempDirPrefix) throws IOException {
  File downloadedFile = null;
</code></pre>

<p>然后，我们创建临时文件，并使用Apache Commons IO库中的<code>FileUtils.copyURLToFile()</code>方法将远程文件下载到其中:</p>

<pre><code class="language-java">try {
  downloadedFile = File.createTempFile("download", ".zip");
  FileUtils.copyURLToFile(new URL(download), downloadedFile);
</code></pre>

<p>然后，我们创建一个临时目录，将下载的文件提取到该目录中，并将该目录返回给调用方法:</p>

<pre><code class="language-java">final File extractedDir = Files.createTempDirectory(tempDirPrefix).toFile();
unzipFile(downloadedFile.getAbsolutePath(), extractedDir.getAbsolutePath());
return extractedDir;
</code></pre>

<p>不再需要下载的文件，因此将其删除:</p>

<pre><code class="language-java">  } finally {
    FileUtils.deleteQuietly(downloadedFile);
  }
}
</code></pre>

<p>为了提取ZIP文件，我们使用了<code>unzipFile()</code>方法:</p>

<pre><code class="language-java">private void unzipFile(final String fileZip, final String outputDirectory) throws IOException {
</code></pre>

<p>我们首先创建一个可以读取ZIP文件内容的缓冲区:</p>

<pre><code class="language-java">final byte[] buffer = new byte[1024];
</code></pre>

<p>然后，我们从ZIP文件中创建一个<code>ZipInputStream</code>实例。<code>ZipInputStream</code>类是标准Java库的一部分，我们将使用这个类来读取ZIP文件的内容:</p>

<pre><code class="language-java">try (final ZipInputStream zis = new ZipInputStream(new
FileInputStream(fileZip))) {
</code></pre>

<p>ZIP文件中的文件由<code>ZipEntry</code>类表示。这里我们从<code>ZipInputStream</code>得到第一个<code>ZipEntry</code>:</p>

<pre><code class="language-java">ZipEntry zipEntry = zis.getNextEntry();
</code></pre>

<p>然后，当我们有一个<code>ZipEntry</code>对象要处理时，我们进入一个循环:</p>

<pre><code class="language-java">while (zipEntry != null) {
</code></pre>

<p><code>ZipEntry</code>的名称是文件名:</p>

<pre><code class="language-java">final String fileName = zipEntry.getName();
</code></pre>

<p><code>ZipEntry</code>名称与输出目录相结合，创建提取文件的路径:</p>

<pre><code class="language-java">final File newFile = new File(outputDirectory + "/" + fileName);
</code></pre>

<p>然后，我们用提取的文件创建一个输出流:</p>

<pre><code class="language-java">try (final FileOutputStream fos = new FileOutputStream(newFile)) {
</code></pre>

<p>然后将<code>ZipEntry</code>的内容读入我们之前创建的缓冲区，然后将缓冲区写入输出文件。这就是我们如何将<code>ZipEntry</code>文件的压缩内容转换成输出文件的未压缩内容:</p>

<pre><code class="language-java">int len;
while ((len = zis.read(buffer)) &gt; 0) {
  fos.write(buffer, 0, len);
}
</code></pre>

<p>对来自<code>ZipInputStream</code>的每个<code>ZipEntry</code>对象重复该过程:</p>

<pre><code class="language-java">  }
  zipEntry = zis.getNextEntry();
}
</code></pre>

<p>一旦我们完成，关闭<code>ZipInputStream</code>:</p>

<pre><code class="language-java">  zis.closeEntry();
  }
}
</code></pre>

<p>这个类中的最后一个方法是<code>writeFeatureToFile()</code>，我们用它来编写小黄瓜特征文件:</p>

<pre><code class="language-java">private File writeFeatureToFile(final String feature) throws IOException
{
</code></pre>

<p>我们创建一个临时文件来保存特征文件的内容:</p>

<pre><code>final File featureFile = File.createTempFile("cucumber", ".feature");
</code></pre>

<p>然后，我们尝试下载文件，就好像特性参数是一个URL一样:</p>

<pre><code class="language-java">try {
  final URL url = new URL(feature);
  FileUtils.copyURLToFile(url, featureFile);
</code></pre>

<p>如果下载文件失败，我们假设这是因为特征参数不是URL，而是组成特征文件的原始文本。这意味着我们可以向特性参数提供URL或原始文本，而<code>writeFeatureToFile()</code>方法可以检测该做什么:</p>

<pre><code class="language-java">} catch (final MalformedURLException ex) {
  try (PrintWriter out = new PrintWriter(featureFile)) {
    out.println(feature);
  }
}
</code></pre>

<p>然后返回结果文件:</p>

<pre><code class="language-java">  return featureFile;
}
</code></pre>

<p>要在Lambda中运行Chrome，我们需要传递一些参数，允许Chrome在受限的Lambda环境中工作。</p>

<p>为了传递参数，我们将创建一个名为<code>ChromeHeadlessLambdaDecorator</code>的新装饰类:</p>

<pre><code class="language-java">package com.octopus.decorators;

import com.octopus.AutomatedBrowser;
import com.octopus.decoratorbase.AutomatedBrowserBase;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

public class ChromeHeadlessLambdaDecorator extends AutomatedBrowserBase
{
    public ChromeHeadlessLambdaDecorator(final AutomatedBrowser automatedBrowser) {
        super(automatedBrowser);
    }

    @Override
    public void init() {
        final ChromeOptions options = new ChromeOptions();
        options.addArguments("--disable-gpu");
        options.addArguments("--headless");
        options.addArguments("--window-size=1366,768");
        options.addArguments("--single-process");
        options.addArguments("--no-sandbox");
        options.addArguments("--user-data-dir=/tmp/user-data");
        options.addArguments("--data-path=/tmp/data-path");
        options.addArguments("--homedir=/tmp");
        options.addArguments("--disk-cache-dir=/tmp/cache-dir");

        if (System.getProperty("chrome.binary") != null) {
            options.setBinary(System.getProperty("chrome.binary"));
        }

        options.merge(getDesiredCapabilities());
        final WebDriver webDriver = new ChromeDriver(options);
        getAutomatedBrowser().setWebDriver(webDriver);
        getAutomatedBrowser().init();
    }
}
</code></pre>

<p><code>--disable-gpu</code>和<code>--headless</code>参数配置Chrome在无头模式下运行。</p>

<p>我们也可以在<code>ChromeOptions</code>类上调用<code>setHeadless()</code>方法。直接传递参数或调用<code>setHeadless()</code>会获得相同的结果:</p>

<pre><code class="language-java">options.addArguments("--disable-gpu");
options.addArguments("--headless");
</code></pre>

<p><code>--window-size</code>参数定义了浏览器窗口的大小:</p>

<pre><code class="language-java">options.addArguments("--window-size=1366,768");
</code></pre>

<p>在Lambda环境中运行Chrome需要<code>--single-process</code>和<code>--no-sandbox</code>参数。你可以在<a href="https://github.com/adieuadieu/serverless-chrome/issues/15" rel="nofollow">https://github.com/adieuadieu/serverless-chrome/issues/15</a>找到更多关于为什么需要这些论证的信息。</p>

<pre><code class="language-java">options.addArguments("--single-process");
options.addArguments("--no-sandbox");
</code></pre>

<p><code>--user-data-dir</code>、<code>--data-path</code>、<code>--homedir</code>和<code>--disk-cache-dir</code>参数确保Chrome只尝试写入<code>/tmp</code>目录。目录是Lambda环境中少数几个进程可以写文件的地方之一。</p>

<pre><code class="language-java">options.addArguments("--user-data-dir=/tmp/user-data");
options.addArguments("--data-path=/tmp/data-path");
options.addArguments("--homedir=/tmp");
options.addArguments("--disk-cache-dir=/tmp/cache-dir");
</code></pre>

<p>如果定义了<code>chrome.binary</code>系统属性(它是在<code>LambdaEntry.downloadChromeHeadless()</code>方法中设置的)，那么我们获取系统属性的值，并用它来设置Chrome二进制文件的位置。这就是我们的代码如何找到自定义的Chrome可执行文件:</p>

<pre><code class="language-java">if (System.getProperty("chrome.binary") != null) {
  options.setBinary(System.getProperty("chrome.binary"));
}
</code></pre>

<p>为了利用这个新的装饰器，我们通过<code>AutomatedBrowserFactory</code>类公开它。</p>

<p>我们在这里不使用<code>BrowserMobDecorator</code>,因为Chrome 64在无头模式下使用代理有一个已知的问题。你可以在这里找到更多关于这个问题的细节。</p>

<pre><code class="language-java">package com.octopus;

import com.octopus.decorators.*;

public class AutomatedBrowserFactory {
  public AutomatedBrowser getAutomatedBrowser(String browser) {
    // ...
    if ("ChromeNoImplicitWaitLambda".equalsIgnoreCase(browser)) {
      return getChromeBrowserNoImplicitWaitLambda();
    }
    // ...
  }

  // ...

  private AutomatedBrowser getChromeBrowserNoImplicitWaitLambda() {
    return new ChromeHeadlessLambdaDecorator(
      new WebDriverDecorator()
    );
  }

  // ...

}
</code></pre>

<p>要部署新的Lambda功能，运行<code>package</code> Maven生命周期，并运行<code>serverless deploy</code>将代码上传到AWS。</p>

<p>我们现在准备通过传递一个小黄瓜特征文件来测试Lambda函数。然而，如果你还记得在上一篇文章中我们说过Lambda函数的每个输入都必须是有效的JSON。我们的小黄瓜特性文件肯定不是用JSON编写的，所以我们需要某种方法将文本转换成JSON字符串。</p>

<p>下面的web页面提供了一个非常简单的表单，它接受原始文本并将其转换为JSON字符串:</p>

<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
            function convert() {
                var output = document.getElementById("input")
                    .value
                    .replace(/\\/g, "\\\\")
                    .replace(/"/g, "\\\"")
                    .split("\n")
                    .join("\\n");

                document.getElementById("output").value = "\"" + output + "\"";
            }
        &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;textarea id="input" style="width: 100%;" rows="20"&gt;&lt;/textarea&gt;
&lt;br/&gt;
&lt;input type="button" onclick="convert()" value="Convert" style="width: 100%"&gt;
&lt;br/&gt;
&lt;input type="text" id="output" style="width: 100%"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这是进行转换的代码。它取<code>&lt;textarea&gt;</code>中文本的值，并:</p>

<ol>
<li>用双反斜杠替换任何反斜杠(即转义任何反斜杠)。</li>
<li>用反斜杠和双引号替换任何双引号(即转义双引号)。</li>
<li>在换行符上拆分字符串。</li>
<li>用字符串<code>\n</code>重新连接结果数组。</li>
</ol>

<pre><code class="language-javascript">var output = document.getElementById("input")
                    .value
                    .replace(/\\/g, "\\\\")
                    .replace(/"/g, "\\\"")
                    .split("\n")
                    .join("\\n");
</code></pre>

<p>此代码将转换以下文本:</p>

<pre><code class="language-gherkin">Feature: TicketMonster
  Scenario: Purchase Tickets with default wait time and aliases
    Given I open the browser "ChromeNoImplicitWaitLambda"
    And I set the following aliases:
    | Venue | venueSelector |
    | Book | bookButton |
    | Section | sectionSelect |
    | Adult Ticket Count | tickets-1 |
    | Add Tickets | add |
    | Checkout | submit |

    And I set the default explicit wait time to "10" seconds
    When I open the URL "https://ticket-monster.herokuapp.com"
    And I click the "Buy tickets now" button
    And I click the "Concert" link
    And I click the "Rock concert of the decade" link
    And I select the option "Toronto : Roy Thomson Hall" from the "Venue" drop-down list
    And I click the "Book" button
    And I select the option "A - Premier platinum reserve" from the "Section" drop-down list
    And I populate the "Adult Ticket Count" text box with the text "2"
    And I click the "Add Tickets" button
    And I populate the "email" text box with the text "email@example.org"
    And I click the "Checkout" button
    Then I close the browser
</code></pre>

<p>到这个字符串中:</p>

<pre><code class="language-json">"Feature: TicketMonster\n Scenario: Purchase Tickets with default wait
time and aliases\n Given I open the browser
\"ChromeNoImplicitWaitLambda\"\n And I set the following
aliases:\n | Venue | venueSelector |\n | Book | bookButton |\n
| Section | sectionSelect |\n | Adult Ticket Count | tickets-1
|\n | Add Tickets | add |\n | Checkout | submit |\n And I set
the default explicit wait time to \"10\" seconds\n When I open the
URL \"https://ticket-monster.herokuapp.com\"\n And I click the
\"Buy tickets now\" button\n And I click the \"Concert\"
link\n And I click the \"Rock concert of the decade\" link\n And I
select the option \"Toronto : Roy Thomson Hall\" from the
\"Venue\" drop-down list\n And I click the \"Book\" button\n
And I select the option \"A - Premier platinum reserve\" from the
\"Section\" drop-down list\n And I populate the \"Adult Ticket
Count\" text box with the text \"2\"\n And I click the \"Add
Tickets\" button\n And I populate the \"email\" text box with the
text \"email@example.org\"\n And I click the \"Checkout\"
button\n Then I close the browser"
</code></pre>

<p>这是执行转换后的网页截图。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image1.png" class="zoom" data-title=""><img src="../Images/a524e417eda05f0661af379a63523bd1.png" class="img-fluid center" alt="C:\0041c95b938e7b0537ed58a097b82e4f" data-original-src="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image1.png"/>T2】</a></p>

<p>这个JSON字符串可以在测试Lambda时作为输入传递。</p>

<p>打开Lambda控制台，打开<code>cucumber-chrome-aws-dev-runCucumber</code>功能。然后点击下拉列表旁边的<code>Test</code>按钮可以点击<code>Configure</code>测试事件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image2.png" class="zoom" data-title=""><img src="../Images/f8194f1f186f2f351c7f98a45fb34e12.png" class="img-fluid center" alt="C:\4167b39ce53037784b2394d5b10cf3d1" data-original-src="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image2.png"/>T2】</a></p>

<p>给测试事件命名，粘贴JSON字符串，并点击<code>Create</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image3.png" class="zoom" data-title=""><img src="../Images/6d6576f61e4a43cbe1133f0c72ac932b.png" class="img-fluid center" alt="C:\a3ce8e4a0b0cf618269a6113d3085e0b" data-original-src="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image3.png"/>T2】</a></p>

<p>然后点击<code>Test</code>按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image4.png" class="zoom" data-title=""><img src="../Images/15599b6ede9cf8a7da031db7d0a94810.png" class="img-fluid center" alt="C:\33f234d4327eb29ee0448b9da5ae4c80" data-original-src="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image4.png"/>T2】</a></p>

<p>Gherkin特性在没有Lambda函数的情况下运行，结果被传回。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image5.png" class="zoom" data-title=""><img src="../Images/8fe13fcef561203f6f4e8d8bb93478ba.png" class="img-fluid center" alt="C:\934ae5036efaded971794102cb4ea728" data-original-src="https://i.octopus.com/blog/2018-10/selenium/32-launching-cucumber-tests/image5.png"/>T2】</a></p>

<p>我们现在能够在Chrome的一个无头实例中作为Lambda函数运行Cucumber测试，因为Lambda函数将扩展以适应本质上无限数量的请求(您的预算不会受到影响),我们现在有了一个解决方案，允许我们并行运行大量的测试。</p>

<p>然而，必须通过Lambda web控制台运行测试并不理想。如果我们可以用HTTP请求直接启动这些测试，那就方便多了，这是我们将在下一篇文章中实现的。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>