<html>
<head>
<title>End-to-end testing with Cypress - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Cypress - Octopus Deploy进行端到端测试</h1>
<blockquote>原文：<a href="https://octopus.com/blog/end-to-end-testing-with-cypress#2021-08-23">https://octopus.com/blog/end-to-end-testing-with-cypress#2021-08-23</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/blogimage-testing.png" class="zoom" data-title=""><img src="../Images/5e6d6175da069a8d7718363c2fc44e77.png" class="img-fluid center" alt="Professor Octopus testing" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/blogimage-testing.png"/>T2】</a></p>

<p>将测试代码作为开发过程的一部分的想法几乎已经被普遍接受。单元测试现在是大多数复杂代码库的共同特征。</p>

<p>然而，测试并没有随着单元测试而停止。描述应用程序生命周期中执行的测试模式的典型例子是测试金字塔(尽管有许多替代方案，如<a href="https://engineering.atspotify.com/2018/01/11/testing-of-microservices/" rel="nofollow">测试蜂巢</a>)，它描述了某些策略，如端到端测试，通常需要应用程序的实时运行实例来执行测试。</p>

<p>端到端测试的一个例子是通过像Cypress这样的工具，它与网页的交互方式与人类非常相似。这些测试必然要求web应用程序正在运行，这使得它们成为在测试环境中部署和运行web应用程序之后，在部署过程的最后阶段中包含的理想候选。</p>

<p>在这篇博客文章中，我们来看看在Octopus部署期间运行Cypress的一些实际问题。我还提出了一个解决方案，允许Cypress测试在最常见的场景中运行。</p>

<h2 id="including-cypress-in-your-deployment-process">在您的部署过程中包括Cypress</h2>

<p>要解决的第一个也是最紧迫的问题是让Cypress进入您的部署管道。</p>

<p>也许实现这一点最明显的方法是在虚拟机或物理机上安装Cypress和web浏览器。有许多像Ansible、Puppet和Chef这样的工具可以以可重复的方式自动化这个过程。</p>

<p>直接安装工具的缺点是，当您在托管的Octopus实例中使用动态工作器时，没有简单的方法做到这一点，并且在Kubernetes这样的平台中，没有VM的概念供您预先配置。</p>

<p>一个更通用的解决方案是<a href="https://github.com/cypress-io/cypress-docker-images" rel="nofollow">从Docker容器</a>运行Cypress。这很方便，因为Cypress团队已经完成了在其Docker映像中配置所有必需软件的艰苦工作。您还可以通过运行不同的Docker镜像版本，随心所欲地切换浏览器版本。</p>

<h2 id="referencing-cypress-tests">参考Cypress测试</h2>

<p>我们需要解决的下一个问题是如何在部署中包含单独的Cypress测试。</p>

<p>将测试放入定制的Docker映像中是可能的，如果您的测试没有太大的变化，这可能是一个非常合理的解决方案。</p>

<p>然而，我怀疑大多数投资于端到端测试的团队会希望继续快速更新他们的测试脚本，而没有将它们包含在新的Docker映像中的负担。拥有一个通用的Cypress Docker映像来执行随机的测试脚本不是很好吗？</p>

<p>直接运行Docker的时候，这个相对容易。您只需将包含您的测试脚本的本地目录挂载到通用的Cypress Docker映像中。Cypress <a href="https://github.com/cypress-io/cypress-docker-images/tree/master/included" rel="nofollow">文档</a>为此提供了一个例子，它将当前目录挂载为Docker容器中的<code>e2e</code>目录:</p>

<pre><code>docker run -it -v $PWD:/e2e -w /e2e cypress/included:6.4.0
</code></pre>

<p>不幸的是，Kubernetes不支持这种卷安装。<a href="https://stackoverflow.com/questions/33415913/whats-the-best-way-to-share-mount-one-file-into-a-pod" rel="nofollow">您可以将配置图的内容作为文件</a>挂载，但是该选项<a href="https://github.com/kubernetes/kubernetes/issues/62421" rel="nofollow">不支持目录结构</a>。当用Cypress进行测试时，这是一个明显的限制，因为<a href="https://docs.cypress.io/guides/core-concepts/writing-and-organizing-tests.html#Folder-Structure" rel="nofollow"> Cypress目录结构包括许多子目录</a>。</p>

<p>Octopus通过<a href="https://octopus.com/docs/projects/steps/execution-containers-for-workers"> worker containers </a>提供了一个解决方案，worker containers 在一个由适当配置的Docker映像生成的容器内执行一个部署步骤。Octopus步骤然后可以下载并解压缩一个包，并运行一个定制脚本。</p>

<p>在我们的例子中，我们将基于Cypress映像创建一个定制的(但仍然是通用的)Docker映像，Octopus可以在其中执行，以提取包含我们的测试脚本的包并执行Cypress。</p>

<p>我们的Docker形象由以下<code>Dockerfile</code>组成:</p>

<pre><code>FROM cypress/included:6.4.0
RUN apt-get update; apt-get install -y libicu-dev
RUN npm install -g inline-assets
ENTRYPOINT []
</code></pre>

<p>这个<code>Dockerfile</code>，是以柏树形象<code>cypress/included:6.4.0</code>为原型，安装<code>libicu-dev</code>(是需要的。NET Core applications)并安装<a href="https://www.npmjs.com/package/inline-assets" rel="nofollow"> inline-assets </a>工具来处理Cypress HTML报告(稍后将详细介绍)并清除<code>ENTRYPOINT</code>以便Octopus可以覆盖运行图像时使用的命令。</p>

<p>这个Docker映像可以用下面的命令构建和发布，用您自己的Docker Hub用户名替换<code>dockerhubusername</code>:</p>

<pre><code>docker build . -t dockerhubusername/workerimage
docker push dockerhubusername/workerimage
</code></pre>

<p>在我的例子中，我创建了一个名为<code>mcasperson/workerimage</code>的图像。我们现在可以使用这个图像来创建Octopus执行容器。</p>

<h2 id="creating-the-sample-cypress-test">创建样本Cypress测试</h2>

<p>对于这个例子，我们将创建一个简单的介绍性Cypress测试，它不执行实际的工作，但是允许我们模拟运行端到端测试的过程。这个样本测试的代码可以在<a href="https://github.com/OctopusSamples/simple-cypress-test" rel="nofollow"> GitHub </a>上找到。</p>

<p>我们从文件<code>package.json</code>开始，文件<a href="https://docs.cypress.io/guides/tooling/reporters.html#Examples" rel="nofollow">安装Mochawesome reporter </a>来生成HTML报告:</p>

<pre><code class="language-json">{
  "name": "cypress-test",
  "version": "0.0.1",
  "description": "A simple cypress test",
  "dependencies": {
    "mochawesome-merge": "^4.2.0",
    "mochawesome": "^6.2.1",
    "mocha": "^8.2.1"
  }
}
</code></pre>

<p>接下来我们有了<code>cypress.json</code>文件，它配置了我们测试的基本细节。请注意，我们已经启用了<code>&lt;!-- --&gt;</code> HTML报告:</p>

<pre><code class="language-json">{
  "baseUrl": "https://google.com",
  "reporter": "mochawesome",
  "reporterOptions": {
    "charts": true,
    "overwrite": false,
    "html": true,
    "json": false,
    "reportDir": "."
  }
}
</code></pre>

<p>最后，我们在<code>sample_spec.js</code>文件中有测试本身。这个测试总是通过，不与任何网页交互，但它证明了Cypress正在按预期运行:</p>

<pre><code class="language-javascript">describe('My First Test', () =&gt; {
  it('Does not do much!', () =&gt; {
    expect(true).to.equal(true)
  })
})
</code></pre>

<p>在运行<code>npm install</code>下载Mocha报告库之后，这些文件被打包成一个ZIP文件，我们可以将它上传到Octopus的内置提要中。为了方便起见，<a href="https://github.com/OctopusSamples/simple-cypress-test/releases" rel="nofollow"> GitHub发布页面</a>已经预先打包了ZIP文件，可以随时使用。</p>

<p>下面是上传到Octopus内置提要的Cypress测试:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/cypress-test-package.png" class="zoom" data-title=""><img src="../Images/4fb3ef1a4835135e3ff97b5a2435fb78.png" class="img-fluid center" alt="Cypress test package" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/cypress-test-package.png"/>T2】</a></p>

<h2 id="running-the-test">运行测试</h2>

<p>我们现在准备运行测试，作为我们部署的一部分。在<strong>运行脚本</strong>步骤中，我们将脚本配置为在<strong>容器映像</strong>部分下的worker映像中执行:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/worker-image.png" class="zoom" data-title=""><img src="../Images/9d787d96bc623a05f40d2a141626260f.png" class="img-fluid center" alt="Worker image" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/worker-image.png"/>T2】</a></p>

<p>接下来，我们运行以下Bash脚本:</p>

<pre><code class="language-bash">cd cypresstest
cypress run &gt; output.txt
RESULT=$?
inline-assets mochawesome.html selfcontained.html
new_octopusartifact "${PWD}/selfcontained.html" "selfcontained.html"
exit ${RESULT}
</code></pre>

<p>第一行输入我们的Cypress测试包将被提取并运行的目录<code>cypress</code>。输出被定向到一个名为<code>output.txt</code>的文件:</p>

<pre><code class="language-bash">cd cypresstest
cypress run &gt; output.txt
</code></pre>

<p>然后，我们捕获Cypress的退出代码，这将决定该步骤是成功还是失败:</p>

<pre><code class="language-bash">RESULT=$?
</code></pre>

<p>为了能够在Octopus中方便地查看测试结果，我们需要将构成HTML报告的所有单个文件(HTML、CSS和脚本文件)捆绑成一个单独的、自包含的HTML文件。这就是我们在工人映像中安装的<code>inline-assets</code>工具的用武之地。它将读取报告HTML文件，内联所有外部资源，并创建一个名为<code>selfcontained.html</code>的自包含HTML文件:</p>

<pre><code class="language-bash">inline-assets mochawesome.html selfcontained.html
</code></pre>

<p>我们将报告文件捕获为Octopus工件:</p>

<pre><code class="language-bash">new_octopusartifact "${PWD}/selfcontained.html" "selfcontained.html"
</code></pre>

<p>然后，我们脚本的退出代码被设置为Cypress的退出代码:</p>

<pre><code class="language-bash">exit ${RESULT}
</code></pre>

<p>最后，我们配置下载和提取包含Cypress脚本的包的步骤:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/script-package.png" class="zoom" data-title=""><img src="../Images/e549b624ba18f35f3ef1d5609fd55a3d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/script-package.png"/>T2】</a></p>

<p>当这个脚本运行时，我们自包含的HTML报告文件作为工件被捕获，并作为链接在<strong>任务摘要</strong>中公开:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/results.png" class="zoom" data-title=""><img src="../Images/d4c41a70ca8c2681d60fded93fd21313.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/results.png"/>T2】</a></p>

<p>我们可以直接在浏览器中打开此报告:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/report.png" class="zoom" data-title=""><img src="../Images/05175da274e89ea6e922868388027a14.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/report.png"/>T2】</a></p>

<p>这样，我们现在就有了一种方法，可以在由通用的共享Docker映像创建的容器中运行定制的Cypress测试。为了更新测试，我们只需上传一个新的包到Octopus，它们将包含在我们的下一个部署中。</p>

<h2 id="testing-in-kubernetes">在Kubernetes测试</h2>

<p>我们选择使用worker容器的原因之一是它允许我们在Kubernetes集群中运行相同的测试。为了验证这一点，我们需要在Kubernetes集群中运行一个Octopus worker。以下部署启动了Kubernetes集群中的一个触手:</p>

<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: octopus-worker
  labels:
    app: tentacle
spec:
  selector:
    matchLabels:
      octopusexport: OctopusExport
  revisionHistoryLimit: 1
  replicas: 1
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: tentacle
        octopusexport: OctopusExport
    spec:
      containers:
        - name: worker
          image: index.docker.io/octopusdeploy/tentacle
          env:
            - name: Space
              value: Test
            - name: ACCEPT_EULA
              value: 'Y'
            - name: TargetWorkerPool
              value: Testing
            - name: ServerUrl
              value: 'https://mattc.octopus.app'
            - name: ServerApiKey
              value: API-xxx
            - name: ServerPort
              value: '10943'
          securityContext:
            privileged: true
</code></pre>

<p>要在您自己的集群中运行这个worker，请确保更改<code>ServerUrl</code>、<code>ServerApiKey</code>、<code>TargetWorkerPool</code>和<code>Space</code>环境变量，以匹配您的服务器配置。</p>

<p>重要的是，这个部署创建的pod具有设置为<code>true</code>的<code>privileged</code>标志。这是支持Docker-in-Docker所必需的，它在Linux触手映像中启用。Docker-in-Docker允许我们的触手以与VM上的触手相同的方式执行工作容器。</p>

<p>当这个部署应用到集群时，您的Octopus实例将显示一个新的轮询工作器，如下所示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/worker.png" class="zoom" data-title=""><img src="../Images/ae75d3066b9cd37dbb02996089e8fc47.png" class="img-fluid center" alt="Polling worker" data-original-src="https://i.octopus.com/blog/2021-03/end-to-end-testing-with-cypress/worker.png"/></a>T2】</p>

<p>此时，我们可以对这个基于Kubernetes的worker运行相同的脚本步骤，就像我们对一个基于VM的worker运行测试一样。因为Octopus负责传输测试脚本，所以我们巧妙地避开了必须在pod中装载脚本的限制。</p>

<h2 id="conclusion">结论</h2>

<p>正如测试代码现在是常见的做法一样，通过端到端测试来验证部署越来越常见，以确保应用程序生命周期的这一阶段按预期工作。如今，我们被像Cypress这样的高质量测试平台宠坏了，通过使用定制的工人映像做一些基础工作，跨多个平台运行端到端测试变得很容易。</p>

<p>在这篇博文中，我们讨论了为什么worker容器对于运行测试如此有用，创建了一个定制的worker映像来执行我们的测试，查看了一个简单的Cypress测试脚本，并编写了一个简单的bash脚本来运行测试并收集结果。然后，我们看到了如何在Kubernetes集群中运行一个worker，该集群被配置为使用Docker-in-Docker运行相同的测试。</p>

<p>结果是一个可重用的测试过程，允许Cypress测试脚本跨多个平台快速开发、部署和执行。通过一些小的调整，可以用端到端测试来验证您的web应用程序部署，确保在应用程序到达最终用户之前，应用程序生命周期的每个阶段都经过测试和验证。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>