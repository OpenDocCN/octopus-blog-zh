<html>
<head>
<title>Selenium series: modifying HTTP requests - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:修改HTTP请求- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/14-modifying-http-requests/modifying-http-requests#2021-07-07">https://octopus.com/blog/selenium/14-modifying-http-requests/modifying-http-requests#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>除了捕获网络流量，BrowserMob还让我们能够修改浏览器发出的网络请求。在许多情况下，当运行测试时，修改请求可以证明是有用的，包括:</p>

<ul>
<li>模拟外部服务的失败。</li>
<li>防止像图像这样的资产被加载，这可以提高测试的性能。</li>
<li>测试期间阻止第三方服务，如社交媒体服务。</li>
</ul>

<p>通过代理的典型网络请求如下所示。代理位于浏览器和外部资源之间，来回传递请求。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image1.png" class="zoom" data-title=""><img src="../Images/1fad04d23709f0ee3f1f074befa1919f.png" class="img-fluid center" alt="C:\64a2439378bd827631823103f990261e" data-original-src="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image1.png"/>T2】</a></p>

<p>下图显示了我们试图实现的请求和响应。</p>

<ol>
<li>浏览器向类似PNG图像的资源的URL发出请求。</li>
<li>该请求被定向到代理。</li>
<li>代理使用请求过滤器来检查请求。</li>
<li>请求因空响应而短路。永远不会联系外部URL。</li>
<li>空响应被发送回浏览器。</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image2.png" class="zoom" data-title=""><img src="../Images/4c8fdd3c0559fa47ea38ab57d8e36bc0.png" class="img-fluid center" alt="C:\46f5ae53d5a2c2db101267136cb92e19" data-original-src="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image2.png"/>T2】</a></p>

<p>为了支持修改请求，我们向<code>AutomatedBrowser</code>接口添加了一个新方法:</p>

<pre><code class="language-java">void blockRequestTo(String url, int responseCode);
</code></pre>

<p>该方法接受要修改的请求的URL，以及请求该URL时应该返回的HTTP响应代码。</p>

<p>我们将默认方法添加到<code>AutomatedBrowserBase</code>类中:</p>

<pre><code class="language-java">@Override
public void blockRequestTo(final String url, final int responseCode) {
  if (getAutomatedBrowser() != null) {
    getAutomatedBrowser().blockRequestTo(url, responseCode);
  }
}
</code></pre>

<p>然后在<code>BrowserMobDecorator</code>类中实现该方法:</p>

<pre><code class="language-java">@Override
public void blockRequestTo(String url, int responseCode) {
  proxy.addRequestFilter((request, contents, messageInfo) -&gt; {
    if (Pattern.compile(url).matcher(messageInfo.getOriginalUrl()).matches()) {
      final HttpResponse response = new DefaultHttpResponse(
        request.getProtocolVersion(),
        HttpResponseStatus.valueOf(responseCode));

      response.headers().add(HttpHeaders.CONNECTION, "Close");

      return response;
    }

    return null;

  });

  getAutomatedBrowser().blockRequestTo(url, responseCode);
}
</code></pre>

<p>我们来分解一下这个方法。</p>

<p>我们首先向BrowserMob代理对象添加一个请求过滤器。请求过滤器作为一个lambda提供，它有三个参数:</p>

<ul>
<li><code>request</code>:包含HTTP请求的细节，比如URL、HTTP方法类型(GET、POST等)、头等等。</li>
<li><code>contents</code>:包含请求体。</li>
<li><code>messageInfo</code>:包含一些关于请求的附加信息，比如没有经过过滤器修改的原始请求细节。</li>
</ul>

<pre><code class="language-java">proxy.addRequestFilter((request, contents, messageInfo) -&gt; {
</code></pre>

<p>在lambda中，我们检查传递给<code>alterRequestTo()</code>方法的URL是否与请求的URL匹配。我们将URL视为正则表达式，以便在匹配URL时更加灵活:</p>

<pre><code class="language-java">if (Pattern.compile(url).matcher(messageInfo.getOriginalUrl()).matches()) {
</code></pre>

<p>如果URL匹配，我们返回一个代表HTTP响应的<code>DefaultHttpResponse</code>实例。这个响应有两个参数。</p>

<p>第一个是HTTP协议版本，我们将其设置为与请求相同的版本。</p>

<p>第二个是HTTP响应代码，我们将其设置为传递给<code>alterRequestTo()</code>方法的值:</p>

<pre><code class="language-java">final HttpResponse response = new DefaultHttpResponse(
  request.getProtocolVersion(),
  HttpResponseStatus.valueOf(responseCode));
</code></pre>

<p>然后我们需要指出这个请求不应该使用HTTP保持活动功能。这是通过将HTTP报头<code>Connection</code>设置为<code>Close</code>来实现的。</p>

<p>如果我们不设置这个头，浏览器将试图保持连接打开(或保持连接活动)，您会看到页面似乎加载了很长时间:</p>

<pre><code class="language-java">response.headers().add(HttpHeaders.CONNECTION, "Close");
</code></pre>

<p>返回这个对象意味着请求将被短路。请求不再传递给URL，而是由BrowserMob直接处理，在这种情况下，使用空响应和提供的HTTP响应代码:</p>

<pre><code class="language-java">return response;
</code></pre>

<p>如果URL与请求不匹配，我们返回<code>null</code>，这表示这个过滤器什么也不做，请求将像平常一样通过远程服务器:</p>

<pre><code class="language-java">return null;
</code></pre>

<p>最后一步是在测试中修改一些请求:</p>

<pre><code class="language-java">@Test
public void modifyRequests() {
  final AutomatedBrowser automatedBrowser =
  AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("Firefox");

  automatedBrowser.init();
  automatedBrowser.blockRequestTo(".*?\\.png", 201);
  automatedBrowser.blockRequestTo("https://.*?twitter\\.com/", 500);
  automatedBrowser.goTo("https://octopus.com/");
}
</code></pre>

<p>对<code>blockRequestTo()</code>的调用将为任何对PNG图像的请求返回一个空响应。我们使用HTTP返回代码<code>201</code>来表示响应成功但为空。这是我们通过阻止下载图像来加快测试速度的一个例子:</p>

<pre><code class="language-java">automatedBrowser.blockRequestTo(".*?\\.png", 201);
</code></pre>

<p>下一行代码块请求Twitter提供的服务。因为我们返回了一个HTTP响应代码<code>500</code>，它用于指示处理请求的服务器端错误，我们可以使用这些改变的请求作为模拟这些外部服务失败的一种方式。您可能还会发现，通过移除测试web应用程序不需要的更多网络流量，阻止这些可选服务可以加快测试速度:</p>

<pre><code class="language-java">automatedBrowser.blockRequestTo("https://.*?twitter\\.com/", 500);
</code></pre>

<p>你会注意到我们在这里没有调用<code>automatedBrowser.destory()</code>。这是为了让我们能够查看因网络请求被更改而产生的网页。如您所见，通常显示的图像现在不再显示，因为这些请求被拦截并作为空响应返回。</p>

<p>【T2 <img src="../Images/d3e7aa5ef8596473d232a67458dee4d8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image3.png"/></p>

<p>这里需要注意的一点是，一旦测试完成，就不可能再以任何有意义的方式与网页进行交互。这是因为BrowserMob已经关闭，这意味着配置浏览器的代理不再可用，因此所有未来的网络请求都将失败。</p>

<p>要与网页交互，您需要从浏览器设置中手动删除代理设置。下面的截图显示了我们在上一篇文章中看到的Firefox代理设置。选择<code>No proxy</code>选项将允许在浏览器关闭后使用浏览器。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image4.png" class="zoom" data-title=""><img src="../Images/d08081d7c1e890fe80741a1abb295b59.png" class="img-fluid center" alt="C:\8670254aa7b6874ef581d1f37eb34235" data-original-src="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image4.png"/>T2】</a></p>

<p>记住，由于没有调用<code>destory()</code>方法，我们现在负责手动关闭测试启动的驱动程序二进制文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image5.png" class="zoom" data-title=""><img src="../Images/fc751d24992b90343cc3f1a50f4bed88.png" class="img-fluid center" alt="C:\491bba4f05d276005b967a923068965a" data-original-src="https://i.octopus.com/blog/2018-10/selenium/14-modifying-http-requests/image5.png"/>T2】</a></p>

<p>阻止对图像之类的东西的网络请求可以加速WebDriver测试，这在针对无头浏览器运行测试时特别有用，因为没有人监视正在运行的测试，下载永远不会被看到的图像没有什么好处。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>