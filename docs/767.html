<html>
<head>
<title>Automated database deployment process: case study - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>自动化数据库部署流程:案例研究- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/use-case-for-designing-db-deployment-process#2021-08-12">https://octopus.com/blog/use-case-for-designing-db-deployment-process#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/use-case-for-designing-db-deployment-process/blogimage-databasedeploymentcasestudy.png" class="zoom" data-title=""><img src="../Images/913394eab7cf71be10eae2cedaa6d1b7.png" class="img-fluid center" alt="Octopus reading an automated database deployment process case study" data-original-src="https://i.octopus.com/blog/2019-11/use-case-for-designing-db-deployment-process/blogimage-databasedeploymentcasestudy.png"/>T2】</a></p>

<p>在加入Octopus Deploy之前，我是试点团队的首席开发人员，负责自动化数据库部署，将每次部署的时间从2到4小时缩短到10分钟。当我开始的时候，我认为我们应该自动化现有流程中的步骤，并且我开始实现工具来实现这一点。我一点也不知道，整个过程将会改变。</p>

<p>本文是上一篇文章的延续:<a href="/blog/designing-db-deployment-process">如何设计自动化的数据库部署过程</a>，如果您愿意，您可以跳到下一篇文章，在那里我为<a href="/blog/implementing-db-deployment-process">提供了使用Octopus Deploy </a>实现数据库部署过程的分步指南。</p>

<p>我们所有的数据库部署文章都可以在<a href="https://octopus.com/database-deployments">这里</a>找到。</p>

<h2 id="in-this-article">在这篇文章中</h2>



<h2 id="quick-overview-of-designing-a-database-deployment-process">设计数据库部署流程的快速概述</h2>

<p>如果你跳过了<a href="/blog/designing-db-deployment-process">上一篇文章</a>，这里有一篇TL；DR；</p>

<ul>
<li>创建一个小团队或工作组来定义流程。包括来自每个部署阶段的代表(开发人员、数据库管理员等。).工作组不应超过4至6人。</li>
<li>确定要包含在工作组中的试验团队或应用程序。</li>
<li>召开为期1至2天的会议，启动工作组。<ul>
<li>写下现有的流程，确定关键人员、难点和需要改变的内容。</li>
<li>起草理想的部署流程。</li>
<li>研究工具。</li>
<li>在启动结束时，试点团队应该知道需要实施什么以及使用什么工具。</li>
</ul>
</li>
<li>试点团队实施新流程。<ul>
<li>一直部署到生产。</li>
<li>迭代流程。</li>
<li>在这个过程成功一段时间后，看看是否有人愿意成为早期采用者。</li>
<li>与早期采用者团队一起迭代流程。</li>
</ul>
</li>
<li>普遍采用。<ul>
<li>专注于建立对流程的信任。</li>
<li>推广到多个团队。</li>
<li>找到痛点就迭代。</li>
</ul>
</li>
</ul>

<h2 id="forming-the-work-group">组建工作组</h2>

<p>该公司的一位DBA总结得很好，他们说:“我们的数据库部署过程是西部大开发。”我们每个月都有更多的开发人员加入公司，新的团队不断形成，每天都有更多的代码被部署，数据库部署的问题必须停止。</p>

<p>是时候成立一个工作组了。</p>

<p>DBA和数据库架构师都喜欢使用Redgate的工具，所以他们向Redgate寻求帮助。雷德盖特同意帮忙，以换取一个案例研究。他们会派两个人飞过来和我们的工作组会面几天。当我写这篇文章时，我99%确定他们不会一直这样做。我们本可以在正确的时间抓住他们。</p>

<p>数据库管理员确定了在工作组中代表他们的数据库管理员。最后决定的是试点团队。这是我参与的时候，因为我的团队被选为试点团队。</p>

<p>天真的我期望Redgate帮助我们在现有的流程中实现他们的工具，所以我开始着手做了。然而，工作组扔掉了我大约75%的工作。这没什么大不了的。这是一次很好的学习经历，因为它让我对数据库部署工具如何工作有了更好的基本理解，这有助于我为启动会议做出贡献。</p>

<h3 id="kick-off-meeting">启动会议</h3>

<p>我的团队中的数据库开发人员，一个DBA，一个数据库架构师，两个Redgaters，我见了两天。第一天的重点是设计我们的理想流程。最终目标是有一个流程部署到<code>development</code>、<code>test</code>、<code>staging</code>，并一直部署到<code>production</code>。</p>

<p>首先，我们浏览了现有的流程，如下所示:</p>

<ol>
<li>一个开发者在<code>test</code>做了一个改变。所有开发者在<code>test</code>都有sysadmin权限。他们应该在<code>development</code>中进行更改，但是<code>test</code>有所有的数据来验证他们的更改，所以这是他们的代码指向的服务器。</li>
<li>开发人员在SSMS更改连接，并对<code>development</code>进行更改。在<code>development</code>中所有开发者都有sysadmin权限。</li>
<li>数据库开发人员或首席开发人员运行<a href="https://www.red-gate.com/products/sql-development/sql-compare/" rel="nofollow"> Redgate SQL Compare </a>来生成<code>test</code>和<code>staging</code>之间的增量脚本。任何复杂的数据库更改(移动列、合并列等。)被删除并手动编写脚本。脚本保存在共享文件夹中。除了DBA之外的每个人都拥有对<code>staging</code>的只读权限。数据库管理员必须运行脚本。</li>
<li>通过电子邮件通知DBA运行<code>staging</code>上共享文件夹中的脚本。它们运行脚本并将输出发送给请求者。</li>
<li>在转到<code>production</code>之前，可以将多个变更推送到<code>staging</code>。因此，数据库开发人员或首席开发人员会在<code>staging</code>和<code>production</code>之间生成一个新的Redgate SQL比较增量脚本。就像以前一样，任何复杂的数据库更改(移动列、合并列等。)被删除并手动编写脚本。脚本保存在共享文件夹中。除了DBA之外，每个人都对<code>production</code>拥有只读权限。</li>
<li>DBA通过变更请求得到通知，在<code>production</code>中运行一组脚本。他们运行脚本，将结果保存到变更请求系统，该系统会向请求者发送电子邮件。</li>
</ol>

<p>我们接下来解决了这些问题:</p>

<ol>
<li>谁参与了这个过程？<strong>回答</strong>:开发人员、数据库开发人员、首席开发人员、DBA。</li>
<li>他们有什么权限？<strong>回答</strong>:开发人员、数据库开发人员、首席开发人员都有<code>development</code>和<code>test</code>的sysadmin权限。DBA拥有<code>development</code>、<code>test</code>、<code>staging</code>和<code>production</code>的系统管理员权限。</li>
<li>他们为什么会参与进来？<strong>回答</strong>:开发人员、首席开发人员和数据库开发人员对<code>development</code>和<code>test</code>进行修改。数据库开发人员和首席开发人员使用Redgate SQL Compare创建增量脚本。DBA将增量脚本部署到<code>staging</code>和<code>production</code>。</li>
<li>哪些环境有不同的流程？<strong>答</strong>:有三个流程，一个是部署到<code>development</code>和<code>test</code>的，而<code>staging</code>和<code>production</code>的流程相似但略有不同。<code>Production</code>涉及一个变更请求系统。</li>
<li>为什么会不一样？<strong>回答</strong>:权限和审核；<code>staging</code>从<code>production</code>定期刷新，用于暂存和最终验证，因此<code>staging</code>需要尽可能靠近<code>production</code>以帮助消除意外。对<code>production</code>的任何更改都需要一个更改请求，因为这是审计员检查的内容。</li>
<li>脚本运行失败会发生什么？<strong>回答</strong>:在<code>development</code>和<code>test</code>中，写剧本的人运行了剧本，他们做了必要的调整，重新运行。在<code>staging</code>和<code>production</code>中，DBA通知请求者失败。请求者调试脚本并进行必要的调整。然后，他们要求DBA再次运行该脚本。</li>
<li>为什么脚本通常会失败？<strong>回答</strong>:失败的发生是因为每个环境都有不同的delta脚本。缺少架构更改或迁移脚本。</li>
<li>谁审查脚本，何时审查？<strong>答</strong>:数据库开发人员或首席开发人员在进入<code>staging</code>之前审查变更。由于不同的delta脚本，DBA在去<code>staging</code>和<code>production</code>之前审查脚本。</li>
<li>谁需要参与每次部署？<strong>答</strong>:部署到<code>development</code>和<code>test</code>只涉及做出改变的人。到<code>staging</code>的部署涉及请求者、数据库开发人员或主要开发人员以及DBA。部署到<code>production</code>需要每个人，因为每个环境都有一个独特的增量脚本，任何问题都需要立即修复。</li>
<li>什么不起作用，什么需要改变？<strong>回答</strong>:见下文。</li>
</ol>

<h2 id="what-needed-to-change">需要改变什么</h2>

<p>敏锐的读者会注意到这些答案中反复出现的主题。</p>

<ul>
<li>三个不同的过程。</li>
<li>每个环境唯一的增量脚本。</li>
<li>独特的delta脚本意味着很难或者几乎不可能测试。</li>
<li>共享开发环境。</li>
<li>直到该去<code>staging</code>的时候，评论才出现。</li>
<li>在<code>production</code>部署期间“全体人员准备就绪”。</li>
<li>没有谁做了什么更改、何时做的或为什么做的历史记录。</li>
<li>通过文档手动跟踪更改。</li>
<li>在<code>development</code>、<code>test</code>或<code>staging</code>中没有审计。对<code>production</code>的一点点审核。</li>
</ul>

<p>我的团队负责的应用程序有700个表。所有数据库访问都是通过存储过程完成的，包括CRUD操作。数据库大约有5000个对象(表、存储过程、函数等)。).所有的开发都是在同一个数据库上完成的。当我们发布时，一些改变被推进，而另一些改变被排除。我们记录了要在一张纸上包含哪些更改。这不是20年前。这发生在2014年。</p>

<p>这些问题导致了2到4个小时的<code>production</code>部署，我们不信任这一过程，这导致了密集的验证过程。实际的部署可以在30分钟内完成，但是剩下的90分钟要花在验证部署上。这包括QA、业务所有者、业务分析师、开发人员、首席开发人员和运行各种场景的经理。即使付出了所有的努力，我们仍然错过了一些随机的事情，只有0.5%的用户遇到过。</p>

<blockquote class="blockquote">
<p>大约60%的情况下，由于错过了模式更改，我们不得不在第二天进行紧急修复。</p>
</blockquote>

<h2 id="draft-of-the-ideal-process">理想过程的草稿</h2>

<p>起草理想的流程花了相当多的时间。这是由于缺乏工具所能提供的知识造成的。当时，我们知道源代码控制、构建服务器和Redgate工具，但是我们都不熟悉部署工具能提供什么。谢天谢地，雷德盖特在那里帮助教育我们。</p>

<p>首先，我们列出了各种工具及其提供的功能:</p>

<ul>
<li>源代码控制          <ul>
<li>它存储所有的SQL脚本。</li>
<li>它是变化的真相中心。</li>
<li>包括为新特征创建分支的能力。</li>
<li>它提供了在合并之前检查变更的能力。</li>
</ul>
</li>
<li>数据库工具          <ul>
<li>它提供了一种在目标数据库上运行源代码管理中存储的脚本的方法。</li>
<li>包括某种<em>预览</em>功能，可以生成一个文件供人们在部署期间查看。该文件可以是实际的增量脚本，也可以是总结更改的HTML文件。</li>
</ul>
</li>
<li>构建服务器          <ul>
<li>从源代码管理中获取SQL脚本并将其打包。</li>
<li>它将包推送到部署服务器。</li>
<li>它可以监视多个分支，并为每个分支构建。</li>
</ul>
</li>
<li>部署工具          <ul>
<li>调用数据库工具来部署数据库更改。</li>
<li>使用数据库工具<em>预览</em>功能创建一个文件，以便在部署期间进行审查。</li>
<li>它提供审计和批准。</li>
<li>用于部署到所有环境。</li>
<li>具有允许各种场景的安全特性，例如只允许数据库管理员部署到<code>production</code>。</li>
</ul>
</li>
</ul>

<p>随着工具责任的排除，我们花了大量的时间讨论共享数据库模型和专用数据库模型。专用数据库模型意味着每个开发人员在他们自己的机器上运行数据库服务器。使用共享数据库模型，我们发现:</p>

<ul>
<li>进行了数据库更改，代码更改需要一个小时到几天才能使用新的数据库更改。有时会阻止其他开发人员和QA使用应用程序中的特定功能或区域。</li>
<li>有两个真实中心，源代码控制和共享数据库，所有的更改都在这里进行，然后保存到源代码控制。如果源代码管理和共享数据库之间有冲突，哪一方会赢？</li>
<li>我们无法有效利用分支机构。可以有1到N个分支，但只能有一个数据库。</li>
<li>在审查之前对中央数据库进行了更改，但是审查应该在什么时候进行？</li>
<li>每个人都使用相同的测试数据。一个人更改数据会影响团队中的多个人。</li>
</ul>

<p>我们决定改用专用数据库。对我们来说，这很有意义。我们知道工具是如何工作的，以及哪里会有变化。</p>

<p>是时候勾勒出理想的流程了:</p>

<ol>
<li>一名开发人员/数据库开发人员/首席开发人员创建了一个分支。</li>
<li>所有数据库更改和代码更改都在该分支上进行。</li>
<li>变更已完成并签入分支。</li>
<li>创建了一个合并请求，这启动了一个构建。构建验证更改是有效的SQL。</li>
<li>数据库开发人员或首席开发人员审查合并请求中的数据库更改，并提供修复反馈。</li>
<li>分支机构被批准并合并。</li>
<li>构建服务器启动一个构建，验证更改是否是有效的SQL，如果是，将它们打包并推送到部署服务器。构建服务器告诉部署服务器部署到<code>development</code>。</li>
<li>部署服务器部署到<code>development</code>。</li>
<li>开发人员/数据库开发人员/首席开发人员告诉部署服务器部署到<code>test</code>。</li>
<li>部署服务器部署到<code>test</code>。</li>
<li>变更在<code>test</code>进行验证。</li>
<li>一个开发人员/数据库开发人员/首席开发人员告诉部署服务器部署到<code>staging</code>。部署服务器使用数据库工具为DBA生成用于审批的审查文件。</li>
<li>部署服务器通知DBA对<code>staging</code>的部署请求。他们审查变更并提供修复反馈。</li>
<li>DBA批准对<code>staging</code>的更改。</li>
<li>部署服务器完成部署到<code>staging</code>。</li>
<li>开发人员/数据库开发人员/首席开发人员在<code>staging</code>中验证变更。</li>
<li>变更请求被提交给DBA，以将部署服务器中的特定包升级到<code>production</code>。</li>
<li>几个小时后，DBA告诉部署服务器部署到<code>production</code>。部署服务器使用数据库工具生成评审文件，供DBA评审。</li>
<li>DBA审查该文件作为最后的完整性检查。</li>
<li>部署服务器完成对<code>production</code>的部署。</li>
<li>负责应用程序的团队验证<code>production</code>中的变更。</li>
</ol>



<p>当提出这个过程时，我们有意避免使用工具。直到我们有了流程草案之后，才讨论工具。首先是已经在使用的工具:</p>

<ul>
<li>构建服务器:团队城市正在作为2012年TFS奥运会的替代项目进行试点。</li>
<li>源代码控制:团队城市的试点团队已经转移到Git。</li>
<li>数据库部署:Redgate的SQL变更自动化(当时是这么叫的)。</li>
<li>部署服务器:没有，虽然当时我认为构建服务器=部署服务器。</li>
</ul>

<p>TFS 2012就要过时了，所以继续使用它没有意义。我的团队是切换到Git和TeamCity的团队的一部分。</p>

<p>雷德盖特飞过来帮助我们。我们有一个使用他们工具的原型。我们讨论了SSDT和RoundhousE，但他们失败的原因大致相同。95%的人在SQL Server Management Studio中更改数据库，太多人忘记将这些更改迁移到SSDT或RoundhousE。我们的讨论以及我们设计的流程导致了对工具的以下关键要求:</p>

<ol>
<li>可以从SSMS保存数据库更改。</li>
<li>自动检测数据库变化。</li>
<li>由该工具处理的大多数更改(添加列、删除列、更改存储过程)能够手动编写和存储复杂的更改(将列移动到新表)。</li>
</ol>

<p>RoundhousE满足了3个中的1个(可以保存来自SSMS的数据库更改)，SSDT满足了3个中的1个(由该工具处理的大多数复杂更改)。对我们来说，继续在试点项目中使用Redgate是有意义的。</p>

<p>我们没有部署服务器，但是在Redgate的人解释了Octopus Deploy的好处和特性之后，我们使用TeamCity、Redgate和Octopus Deploy做了一个快速的概念验证。这个概念验证花了大约一个小时才完成，并且显示出了很大的潜力，所以我们决定使用Octopus Deploy进行试点。</p>

<h2 id="implementing-the-process">实施流程</h2>

<p>使用工具将商定的流程落实到位。让它在<code>development</code>和<code>staging</code>运行只需要很少的时间。我们确实遇到了一些在动员会上没有预料到的问题:</p>

<ul>
<li>权限:自动化流程能做什么，不能做什么。我们的目标是阻止流程创建新用户并将他们添加到角色中。这样，某人就不能在<code>production</code>中给自己db_owner权限。</li>
<li>解决所有环境之间的差异:在<code>production</code>中有模式变化，而在<code>development</code>中没有。我们第一次尝试在<code>production</code>中运行该流程时，我们几乎将它们消灭。我们很快将这一更改添加到源代码控制中，重新构建包，并通过环境将其推送到<code>production</code>。</li>
</ul>

<p>在解决了这些小问题之后，我们能够将流程部署到<code>staging</code>和<code>production</code>。</p>

<h2 id="speeding-up-deployments">加速部署</h2>

<p>很快，由于缺少模式更改而导致的紧急修复的数量下降到了零。仅此一项就是巨大的胜利。</p>

<p>因此，我们花在验证上的时间开始减少。</p>

<ol>
<li>30分钟部署，90分钟验证。</li>
<li>25分钟部署，80分钟验证。</li>
<li>20分钟部署，70分钟验证。</li>
<li>15分钟部署，60分钟验证。</li>
<li>10分钟部署，50分钟验证。</li>
<li>5-8分钟部署，40分钟验证。</li>
<li>5-8分钟部署，30分钟验证。</li>
</ol>

<p>这反过来又让我们想要更频繁地部署。频繁的部署意味着较小的变化。较小的变化意味着较少的验证。更少的验证意味着更快的部署。更快的部署意味着我们希望更频繁地部署。这个循环一直持续到验证也花了5到8分钟。</p>

<h2 id="early-adopters-and-iterations">早期采用者和迭代</h2>

<p>其他几个团队(剩下的9个团队中的)看到了我们正在做的事情，他们作为早期采用者加入进来。让三个团队使用该流程，找出棘手问题和需要改进的地方:</p>

<ul>
<li>没有部署已批准的项目。我没有正确使用Redgate工具。我使用了一个命令来生成预览以供审批。然后我忽略了那个预览，直接使用不同的命令来部署这个包。每30个部署中就有1个最终发生了意外变化。通过一点研究，找到并实现了正确的命令。</li>
<li><strong>将预览文件保存到文件共享。</strong>不知道章鱼还有把文件存为神器的能力。审批者可以从Octopus下载工件。这比在文件共享中找到正确的文件要好。对脚本的一个小调整解决了这个问题。</li>
<li><strong>数据库管理员成为瓶颈。</strong>三个团队部署到<code>staging</code>时，数据库管理员经常跟不上。他们也厌倦了在部署期间必须在线才能批准对<code>production</code>的部署。我们改变了流程，在部署到<code>staging</code>时生成两个文件，一个用于<code>staging</code>，一个用于<code>production</code>。部署将在<code>staging</code>进行，DBA在事后批准了一切。在<code>production</code>中，当部署失败时，我们添加了一个寻呼它们的步骤。</li>
<li><strong>开发人员没有使用他们的专用数据库。</strong>开发人员的数据库中没有测试数据，所以他们指向<code>test</code>来测试他们的更改。我们通过在每次部署后在<code>test</code>中创建数据库备份来解决这个问题。开发人员可以将该数据库恢复到他们的本地实例，并拥有他们需要的所有数据。</li>
</ul>

<p>没有一个过程从一开始就是100%完美的。预计迭代多次。</p>


<h2 id="general-adoption">普遍采用</h2>

<p>最终，普遍采用的时候到了。我对这种推后感到非常惊讶，特别是来自数据库开发人员的推后。他们花了太多的时间来生成部署脚本，他们相信这就是他们为团队带来价值的方式。人们担心这个过程会让他们失业。事实并非如此。该过程旨在消除所有浪费在生成和调整部署脚本上的时间，从而将他们解放出来，专注于重要的事情，如数据库结构、性能、审查更改以及处理复杂的更改。</p>

<p>事后看来，我应该:</p>

<ul>
<li>与数据库开发人员和团队中的首席开发人员安排一次会议，以完成整个过程。</li>
<li>为他们两人安排了另一次会面，以将应用程序的数据库纳入流程。</li>
<li>为他们安排了最后一次会议，教他们的团队如何使用该流程，我在后台回答问题。</li>
</ul>

<p>但我没有那么做。我把所有这些合并成一个大型会议。活到老学到老。</p>

<h2 id="conclusion">结论</h2>

<p>为了自动化数据库部署，我们不得不做一些改变。最终，这是值得的。部署到<code>production</code>变成了无事件。我在那家公司做的最后一次<code>production</code>部署涉及到我自己、企业所有者和我的经理。我们在线了30分钟。其中25分钟用来讲有趣的故事和糟糕的笑话。部署很顺利地完成了。</p>

<p>在本文中，我重点介绍了我们如何设计自动化数据库部署过程。我没有关注我们实际上做了什么，但是我将在下一篇文章中讨论这个问题。</p>

<p>下次再见，愉快的部署！</p>

<p>如果您喜欢这篇文章，好消息，我们有一个关于自动化数据库部署的完整系列。</p>

                    
                    
</body>
</html>