<html>
<head>
<title>Lessons learned implementing database deployments - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>实施数据库部署的经验教训- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/database-deployments-lessons-learned#2021-08-12">https://octopus.com/blog/database-deployments-lessons-learned#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-05/database-deployments-lessons-learned/database-deployments.png" class="zoom" data-title=""><img src="../Images/b1d6be0a69a2643587b977bc9872cab6.png" class="img-fluid center" alt="Lessons learned implementing database deployments" data-original-src="https://i.octopus.com/blog/2020-05/database-deployments-lessons-learned/database-deployments.png"/>T2】</a></p>

<p>在组织中实施数据库部署可能是一项艰巨的任务。在这篇文章中，我分享了我以前工作中的一些经验，以及在数据库部署中需要注意的一些事情。</p>

<h2 id="tightly-coupled-databases">紧密耦合的数据库</h2>

<p>这种情况时有发生，我们大多数人都见过，两个不同的系统访问彼此的数据库。他们需要从对方那里获得信息，而获得信息最快最简单的方法就是伸手进去拿走。它可能从单个表或视图开始，但是随着每个系统的增长，耦合变得越来越紧密，这带来了大量的问题。</p>

<h3 id="database-dependencies">数据库依赖性</h3>

<p>我记得在一个应用程序(我们称之为应用程序A)部署后召开了一次紧急会议，这次会议导致另一个应用程序(我们称之为应用程序B)开始出现故障。双方的脾气都很大，双方都坚定地指责对方。</p>

<p>作为配置经理，我负责部署，所以我在主持会议。最新的部署引入了对A的数据库模式的更改，这导致B失败。这种情况最麻烦的部分是，A不知道B在拉数据，所以自然地，A不明白为什么B这么激动。</p>

<h3 id="circular-dependencies">循环依赖</h3>

<p>还有一次，我在评估Microsoft SQL Server DACPAC作为自动化数据库部署方法时，遇到了循环依赖问题。我创建的Microsoft SQL Server数据库项目如果没有对它所联接的另一个数据库的DACPAC引用，将无法编译。当我试图为第二个数据库编译项目时，失败了，因为第二个项目依赖于第一个项目，并且不会编译它的DACPAC引用。</p>

<h2 id="redgate-sql-source-control-and-three-part-naming-convention">Redgate SQL源代码控制和三部分命名约定</h2>

<p>我工作的组织决定使用<a href="https://www.red-gate.com/products/sql-development/sql-source-control/" rel="nofollow"> Redgate SQL源代码控制</a>作为维护数据库模式的方法。当时的标准是总是使用由三部分组成的命名约定来编写连接，<code>database.schema.object</code>。对于Redgate SQL源代码控制，这导致了一个问题。当在对象引用中指定数据库时，它认为这是一个外部数据库调用，在确定对象的构建顺序时没有考虑它。这有时会导致在基础表存在之前就试图构建视图。</p>

<h2 id="constraints-without-names">没有名称的约束</h2>

<p>Microsoft SQL Server可能相当宽容，有时甚至是有害的。我们遇到的一个问题是没有给默认约束命名。以下是使用默认约束创建表的有效SQL语法:</p>

<pre><code>CREATE TABLE Persons
(
    P_Id int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255) DEFAULT 'Sandnes'
)
</code></pre>

<p>在这种情况下，微软SQL Server将<em>通过给约束一个生成的名称来帮助</em>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-05/database-deployments-lessons-learned/ssms-constraint-name.png" class="zoom" data-title=""><img src="../Images/3bf516fa57b5e7a5600fa331a6e8fd5b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-05/database-deployments-lessons-learned/ssms-constraint-name.png"/>T2】</a></p>

<p>基于状态(也称为基于模型)的部署从脚本文件夹创建一个<em>临时</em>数据库。当执行确保目标数据库处于所需状态的部署后检查时，部署会失败，因为约束没有相同的名称。</p>

<h2 id="mixing-deployment-technologies">混合部署技术</h2>

<p>我们使用Redgate SQL源代码控制进行模式更改，使用DbUp进行数据更改。大多数(如果不是全部的话)基于迁移的部署技术(<a href="https://dbup.readthedocs.io/en/latest/" rel="nofollow"> DBup </a>、<a href="https://flywaydb.org" rel="nofollow"> Flyway </a>和<a href="https://github.com/chucknorris/roundhouse" rel="nofollow"> RoundhousE </a>)在目标数据库中创建一个表，以跟踪哪些脚本已经被执行，这样它们就不会再次运行。基于状态的方法将删除状态中不存在的任何对象。我们没有考虑到这一点，Redgate SQL源代码控制一直删除DbUp创建的用于跟踪以前运行的脚本的<code>schemaversions</code>表。这导致原本要执行一次的脚本在每次部署时都要运行。</p>

<h2 id="bugs-in-the-software">软件中的错误</h2>

<p>基于状态的部署软件非常强大，同样复杂。我对该技术如何以正确的顺序生成脚本以将数据库转换到期望的状态印象深刻；然而，就像任何软件一样，总有不太正常的边缘情况。</p>

<p>这方面的一个例子是更改一个列，使它不是一个标识列。这通常没问题，但是这个表也被配置用于静态数据维护。Redgate SQL源代码控制成功地生成了修改表的正确脚本，但是由于静态数据维护，它在填充表时包含了<code>IDENTITY INSERT ON</code>。由于标识列已被删除，该语句失败。它已经被修复了，但是当我们试图发布时，这个错误引起了一些问题。</p>

<h2 id="conclusion">结论</h2>

<p>除了令人生畏之外，数据库部署问题调试起来也很麻烦。我希望这些提示能为您节省数小时甚至数天的调查和故障排除时间。</p>

                    
                    
</body>
</html>