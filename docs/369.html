<html>
<head>
<title>How to install a Jenkins instance with Helm - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何使用Helm - Octopus Deploy安装Jenkins实例</h1>
<blockquote>原文：<a href="https://octopus.com/blog/jenkins-helm-install-guide#2022-05-19">https://octopus.com/blog/jenkins-helm-install-guide#2022-05-19</a></blockquote>
                        <p>Kubernetes (K8s)已经成为托管Docker容器的最广泛使用的平台之一。Kubernetes提供高级编排功能、网络功能、集成安全性、用户管理、高可用性、卷管理、广泛的支持工具生态系统等等。</p>

<p>一个支持工具是<a href="https://helm.sh/" rel="nofollow"> Helm </a>，它为Kubernetes提供包管理功能。Helm部署的应用程序在图表中定义，Jenkins <a href="https://github.com/jenkinsci/helm-charts/blob/main/charts/jenkins/README.md" rel="nofollow">提供了一个Helm图表</a>来将Jenkins实例部署到Kubernetes。</p>

<p>在本文中，您将学习如何使用Helm和connect代理安装Jenkins实例来执行构建任务。</p>

<h2 id="prerequisites">先决条件</h2>

<p>要阅读这篇文章，您需要一个Kubernetes集群和Helm客户端。</p>

<p>所有主要的云提供商都提供托管的Kubernetes集群:</p>

<ul>
<li>AWS有<a href="https://aws.amazon.com/eks/" rel="nofollow"> EKS </a></li>
<li>Azure有<a href="https://azure.microsoft.com/en-au/services/kubernetes-service/" rel="nofollow">个AK</a></li>
<li>谷歌云有<a href="https://cloud.google.com/kubernetes-engine" rel="nofollow"> GKE </a></li>
</ul>

<p>如果您想在本地PC上运行一个开发Kubernetes集群，<a href="https://kind.sigs.k8s.io/docs/user/quick-start/" rel="nofollow"> kind </a>允许您创建和销毁用于测试的集群。帖子<a href="https://octopus.com/blog/testing-with-kind">用种类</a>创建测试Kubernetes集群提供了在本地运行Kubernetes的指导。</p>

<p>您还必须安装Helm客户端。<a href="https://helm.sh/docs/intro/install/" rel="nofollow">舵文档</a>提供安装说明。</p>

<h2 id="adding-the-jenkins-chart-repository">添加Jenkins图表存储库</h2>

<p>詹金斯掌舵图由<a href="https://charts.jenkins.io" rel="nofollow">https://charts . Jenkins . io</a>提供。要使此图表存储库可用，请运行以下命令:</p>

<pre><code class="language-bash">helm repo add jenkins https://charts.jenkins.io
helm repo update
</code></pre>

<h2 id="deploying-a-simple-jenkins-instance">部署简单的Jenkins实例</h2>

<p>要使用默认设置部署Jenkins实例，请运行命令:</p>

<pre><code class="language-bash">helm upgrade --install myjenkins jenkins/jenkins
</code></pre>

<p><code>helm upgrade</code>命令通常用于升级现有版本。然而,<code>--install</code>参数确保了如果发布不存在，它就会被创建。这意味着<code>helm upgrade --install</code>创建<em>和</em>更新一个版本，消除了根据该版本是否存在而修改安装和升级命令的需要。</p>

<p>发布的名称是<code>myjenkins</code>，最后一个参数<code>jenkins/jenkins</code>定义了要安装的图表。</p>

<p>输出如下所示:</p>

<pre><code class="language-bash">$ helm upgrade --install myjenkins jenkins/jenkins

Release "myjenkins" does not exist. Installing it now.
NAME: myjenkins
LAST DEPLOYED: Tue Oct 19 08:13:11 2021
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
1. Get your 'admin' user password by running:
  kubectl exec --namespace default -it svc/myjenkins -c jenkins -- /bin/cat /run/secrets/chart-admin-password &amp;&amp; echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  echo http://127.0.0.1:8080
  kubectl --namespace default port-forward svc/myjenkins 8080:8080

3. Login with the password from step 1 and the username: admin
4. Configure security realm and authorization strategy
5. Use Jenkins Configuration as Code by specifying configScripts in your values.yaml file, see documentation: http:///configuration-as-code and examples: https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos

For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine

For more information about Jenkins Configuration as Code, visit:
https://jenkins.io/projects/jcasc/


NOTE: Consider using a custom image with pre-installed plugins
</code></pre>

<p>注释中列出的第一个命令返回用户<code>admin</code>的密码:</p>

<pre><code class="language-bash">$ kubectl exec --namespace default -it svc/myjenkins -c jenkins -- /bin/cat /run/secrets/chart-admin-password &amp;&amp; echo
</code></pre>

<p>notes中列出的第二个命令建立了到Kubernetes集群中服务的隧道。</p>

<p>在Kubernetes中，服务是配置集群网络以公开一个或多个pod的资源。默认的服务类型是<code>ClusterIP</code>，它通过私有IP地址公开pod。我们就是通过这个私有IP地址来访问Jenkins web UI的。</p>

<p>Kubernetes pod是托管一个或多个容器的资源。这意味着Jenkins实例作为pod中的一个容器运行:</p>

<pre><code class="language-bash">$ kubectl --namespace default port-forward svc/myjenkins 8080:8080
Forwarding from 127.0.0.1:8080 -&gt; 8080
Forwarding from [::1]:8080 -&gt; 8080
</code></pre>

<p>建立隧道后，在本地PC上打开<a href="http://localhost:8080" rel="nofollow"> http://localhost:8080 </a>，您将被定向到Kubernetes集群中的Jenkins实例。使用用户名<code>admin</code>和第一个命令返回的密码登录。</p>

<p>现在，您已经有了一个运行在Kubernetes中的功能性的(如果是基本的)Jenkins实例。</p>

<h2 id="exposing-jenkins-through-a-public-ip-address">通过公共IP地址暴露詹金斯</h2>

<p>通过隧道访问Jenkins对于调试很有用，但对于生产服务器来说不是很好的体验。要通过公开可用的IP地址访问Jenkins，您必须覆盖图表中定义的默认配置。可以定义数百个值，通过运行以下命令可以获得完整的列表:</p>

<pre><code class="language-bash">helm show values jenkins/jenkins
</code></pre>

<p>配置将Jenkins pod公开为<code>LoadBalancer</code>的服务是公开访问Jenkins的最简单的方法。</p>

<p>类型为<code>LoadBalancer</code>的服务通过公共IP地址公开pod。如何创建公共IP地址的问题留给集群来解决。例如，EKS、AKS和GKE等托管的Kubernetes平台创建了一个网络负载平衡器，将流量导入K8s集群。</p>

<p>注意，<code>LoadBalancer</code>服务在使用本地测试Kubernetes集群时需要额外的配置，比如kind创建的集群。更多信息请参考<a href="https://kind.sigs.k8s.io/docs/user/loadbalancer/" rel="nofollow">种类文档</a>。</p>

<p>要将服务配置为<code>LoadBalancer</code>，您需要创建一个名为<code>values.yaml</code>的文件，其内容如下:</p>

<pre><code class="language-yaml">controller:
  serviceType: LoadBalancer
</code></pre>

<p>然后，使用命令<code>values.yaml</code>中定义的值升级Helm版本:</p>

<pre><code class="language-bash">helm upgrade --install -f values.yaml myjenkins jenkins/jenkins
</code></pre>

<p>通过添加新的指令来返回服务的公共IP，输出有了细微的变化:</p>

<pre><code class="language-bash">$ helm upgrade --install -f values.yaml myjenkins jenkins/jenkins
Release "myjenkins" has been upgraded. Happy Helming!
NAME: myjenkins
LAST DEPLOYED: Tue Oct 19 08:45:23 2021
NAMESPACE: default
STATUS: deployed
REVISION: 4
NOTES:
1. Get your 'admin' user password by running:
  kubectl exec --namespace default -it svc/myjenkins -c jenkins -- /bin/cat /run/secrets/chart-admin-password &amp;&amp; echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  NOTE: It may take a few minutes for the LoadBalancer IP to be available.
        You can watch the status of by running 'kubectl get svc --namespace default -w myjenkins'
  export SERVICE_IP=$(kubectl get svc --namespace default myjenkins --template "{{ range (index .status.loadBalancer.ingress 0) }}{{ . }}{{ end }}")
  echo http://$SERVICE_IP:8080/login

3. Login with the password from step 1 and the username: admin
4. Configure security realm and authorization strategy
5. Use Jenkins Configuration as Code by specifying configScripts in your values.yaml file, see documentation: http:///configuration-as-code and examples: https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos

For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine

For more information about Jenkins Configuration as Code, visit:
https://jenkins.io/projects/jcasc/


NOTE: Consider using a custom image with pre-installed plugins
</code></pre>

<p>使用步骤2中的新说明，运行以下命令获取服务的公共IP地址或主机名:</p>

<pre><code class="language-bash">kubectl get svc --namespace default myjenkins --template "{{ range (index .status.loadBalancer.ingress 0) }}{{ . }}{{ end }}"
</code></pre>

<p>我已将Jenkins部署到EKS集群，这是我的基础架构命令的结果:</p>

<pre><code class="language-bash">$ kubectl get svc --namespace default myjenkins --template "{{ range (index .status.loadBalancer.ingress 0) }}{{ . }}{{ end }}"
a84aa6226d6e5496882cfafdd6564a35-901117307.us-west-1.elb.amazonaws.com
</code></pre>

<p>要访问Jenkins，打开<a href="http://service_ip_or_hostname:8080" rel="nofollow">http://service _ IP _ or _ hostname:8080</a>。</p>

<p>您可能会注意到，当您通过Jenkins的公共IP地址访问它时，它会报告以下错误:</p>

<pre><code>It appears that your reverse proxy set up is broken.
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/jenkins-helm-install-guide/reverse-proxy-error.png" class="zoom" data-title=""><img src="../Images/99eb52b76d3a400a679512bdf469632f.png" class="img-fluid center" alt="Jenkins error message" data-original-src="https://i.octopus.com/blog/2022-01/jenkins-helm-install-guide/reverse-proxy-error.png"/>T2】</a></p>

<p>这可以通过在<code>controller.jenkinsUrl</code>属性中定义公共URL来解决，用Jenkins实例的IP地址或主机名替换<code>a84aa6226d6e5496882cfafdd6564a35-901117307.us-west-1.elb.amazonaws.com</code>:</p>

<pre><code class="language-yaml">controller:
  jenkinsUrl: http://a84aa6226d6e5496882cfafdd6564a35-901117307.us-west-1.elb.amazonaws.com:8080/
</code></pre>

<h2 id="installing-additional-plugins">安装附加插件</h2>

<p>列出要安装在<code>controller.additionalPlugins</code>阵列中的任何附加插件:</p>

<pre><code class="language-yaml">controller:
    additionalPlugins:
    - octopusdeploy:3.1.6
</code></pre>

<p>插件ID和版本可在<a href="https://plugins.jenkins.io/octopusdeploy/" rel="nofollow"> Jenkins插件网站</a>上找到:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/jenkins-helm-install-guide/jenkins-plugin.png" class="zoom" data-title=""><img src="../Images/8b74c63ec439ecc49ac0f7b25a5a82b9.png" class="img-fluid center" alt="Jenkins Plugin Website showing the ID and version number" data-original-src="https://i.octopus.com/blog/2022-01/jenkins-helm-install-guide/jenkins-plugin.png"/>T2】</a></p>

<p>这种方法很方便，但是缺点是Jenkins实例需要联系Jenkins更新站点来检索它们，作为第一次引导的一部分。</p>

<p>一种更健壮的方法是下载插件作为定制映像的一部分，这可以确保插件被嵌入到Docker映像中。它还允许在Jenkins控制器上安装额外的工具。<a href="https://octopus.com/blog/jenkins-docker-install-guide">上一篇文章</a>详细介绍了构建和发布自定义Docker图像。</p>

<p>请注意，除了任何自定义插件之外，自定义Docker映像还必须安装以下插件。这些插件是舵图正常工作所必需的:</p>

<ul>
<li>库伯内特斯</li>
<li>工作流聚合器</li>
<li>饭桶</li>
<li>代码配置</li>
</ul>

<p>下面是一个包含强制插件的示例<code>Dockerfile</code>:</p>

<pre><code class="language-dockerfile">FROM jenkins/jenkins:lts-jdk11
USER root
RUN apt update &amp;&amp; \
    apt install -y --no-install-recommends gnupg curl ca-certificates apt-transport-https &amp;&amp; \
    curl -sSfL https://apt.octopus.com/public.key | apt-key add - &amp;&amp; \
    sh -c "echo deb https://apt.octopus.com/ stable main &gt; /etc/apt/sources.list.d/octopus.com.list" &amp;&amp; \
    apt update &amp;&amp; apt install -y octopuscli
RUN jenkins-plugin-cli --plugins octopusdeploy:3.1.6 kubernetes:1.29.2 workflow-aggregator:2.6 git:4.7.1 configuration-as-code:1.52
USER jenkins
</code></pre>

<p>要使用自定义图像，您可以在<code>values.yml</code>中用以下属性定义它。此示例使用了推送到我的DockerHub帐户的自定义Jenkins图像<a href="https://hub.docker.com/r/mcasperson/myjenkins" rel="nofollow">:</a></p>

<pre><code class="language-yaml">controller:
  image: "docker.io/mcasperson/myjenkins"
  tag: "latest"
  installPlugins: false
</code></pre>

<p>你可以在<a href="https://github.com/OctopusSamples/jenkins-complete-image" rel="nofollow">Jenkins-complete-image repository</a>中找到一个为Java、DotNET Core、PHP、Python、Ruby安装工具的例子<code>Dockerfile</code>。</p>

<h2 id="jenkins-configuration-as-code">詹金斯配置代码</h2>

<p>Jenkins Configuration as Code(JC ASC)是一个<a href="https://plugins.jenkins.io/configuration-as-code/" rel="nofollow">插件</a>，它提供了一种通过YAML文件配置Jenkins的自以为是的方法。这为直接引用Jenkins API 编写<a href="https://www.jenkins.io/doc/book/managing/groovy-hook-scripts/" rel="nofollow"> Groovy脚本提供了一种替代方法，这种方法功能强大，但要求管理员能够熟练地编写代码。</a></p>

<p>JCasC是在<code>controller.JCasC.configScript</code>属性下定义的。<code>configScript</code>下的子键有您选择的由小写字母、数字和连字符组成的名称，并作为一种总结它们定义的文本块的方式。</p>

<p>分配给这些键的值是多行字符串，它们反过来定义了一个JCasC YAML文件。竖线(<code>|</code>)字符为定义多行字符串提供了一种方便的方法，但在其他方面并不重要。</p>

<p>最终结果给出了连续的YAML文档的外观。请记住，管道字符后面出现的内容只是一个多行文本值，碰巧也是YAML。</p>

<p>以下示例配置了Jenkins控制器可用的执行器数量，JCasC YAML定义在一个名为<code>this-is-where-i-configure-the-executors</code>的夸张键下，以强调这些键可以有任何名称:</p>

<pre><code class="language-yaml">controller:
  JCasC:
    configScripts:
      this-is-where-i-configure-the-executors: |
        jenkins:
          numExecutors: 5
</code></pre>

<p>作为比较，同样的配置也可以用下面的Groovy脚本来实现，该脚本在一个定制的Docker映像中保存为<code>/usr/share/jenkins/ref/init.groovy.d/executors.groovy</code>:</p>

<pre><code class="language-groovy">import jenkins.model.*
Jenkins.instance.setNumExecutors(5)
</code></pre>

<p>甚至这个简单的例子也强调了JCasC的好处:</p>

<ul>
<li>每个JCasC属性都记录在http://Jenkins host/configuration-as-code/reference中(用您自己的Jenkins实例的主机名替换<code>jenkinshost</code>，而编写Groovy脚本需要了解<a href="https://javadoc.jenkins-ci.org/jenkins/model/Jenkins.html" rel="nofollow"> Jenkins API </a>。</li>
<li>JCasC配置是普通的YAML，比用Groovy编写的脚本更容易理解。</li>
<li>JCasC坚持己见，为通用配置提供了一致的方法。Groovy脚本可以用多种方式解决同一个问题，这意味着包含多行代码的脚本需要软件工程师的专业知识才能理解。</li>
</ul>

<p>尽管有这么多好处，JCasC并不能完全替代设置系统属性或运行Groovy脚本。例如，<a href="https://github.com/jenkinsci/configuration-as-code-plugin/issues/1184" rel="nofollow"> JCasC将不支持禁用CSRF </a>的功能，这意味着该选项只能通过系统属性公开。</p>

<h2 id="backing-up-jenkins-volumes">备份Jenkins卷</h2>

<p>Kubernetes中的卷比常规Docker中的卷稍微复杂一些，因为K8s卷倾向于托管在运行pod的节点之外。这是因为pod可以在节点之间重新定位，因此需要从任何节点访问卷。</p>

<p>更复杂的是，与Docker卷不同，只有专门的Kubernetes卷可以在pod之间共享。这些共享卷被称为<code>ReadWriteMany</code>卷。不过，通常情况下，Kubernetes卷仅由单个pod使用，被称为<code>ReadWriteOnce</code>卷。</p>

<p>Jenkins Helm图表配置了一个<code>ReadWriteOnce</code>卷来托管Jenkins主目录。因为该卷只能由装入该卷的pod访问，所以所有备份操作都必须由该pod执行。</p>

<p>幸运的是，Helm chart提供了<a href="https://github.com/jenkinsci/helm-charts/blob/main/charts/jenkins/README.md#backup" rel="nofollow">全面的备份选项</a>，能够执行备份并将它们保存到云存储提供商。</p>

<p>但是，您可以使用两个命令来编排简单的、与云无关的备份。</p>

<p>第一个命令在pod内部执行<code>tar</code>，将<code>/var/jenkins_home</code>目录备份到<code>/tmp/backup.tar.gz</code>档案中。注意，吊舱名称<code>myjenkins-0</code>来源于舵释放名称<code>myjenkins</code>:</p>

<pre><code class="language-bash">kubectl exec -c jenkins myjenkins-0 -- tar czf /tmp/backup.tar.gz /var/jenkins_home
</code></pre>

<p>第二个命令将备份归档文件从pod复制到您的本地计算机:</p>

<pre><code class="language-bash">kubectl cp -c jenkins myjenkins-0:/tmp/backup.tar.gz ./backup.tar.gz
</code></pre>

<p>此时<code>backup.tar.gz</code>可以被复制到一个更永久的位置。</p>

<h2 id="adding-jenkins-agents">添加Jenkins代理</h2>

<p>除了在Kubernetes集群上安装Jenkins之外，还可以在集群中动态创建Jenkins代理。这些代理是在Jenkins中安排新任务时创建的，并在任务完成后自动清理。</p>

<p>代理的默认设置在<code>values.yaml</code>文件中的<code>agent</code>属性下定义。以下示例定义了一个带有Jenkins标签<code>default</code>的代理，该代理是在以名称<code>default</code>为前缀的pod中创建的，并且具有CPU和内存限制:</p>

<pre><code class="language-yaml">agent:
  podName: default
  customJenkinsLabels: default
  resources:
    limits:
      cpu: "1"
      memory: "2048Mi"
</code></pre>

<p>在<code>additionalAgents</code>属性下定义了更多的专业代理。这些pod模板继承了在<code>agent</code>属性中定义的值。</p>

<p>以下示例定义了第二个pod模板，将pod名称和Jenkins标签更改为<code>maven</code>，并指定新的Docker图像<code>jenkins/jnlp-agent-maven:latest</code>:</p>

<pre><code class="language-yaml">agent:
  podName: default
  customJenkinsLabels: default
  resources:
    limits:
      cpu: "1"
      memory: "2048Mi"
additionalAgents:
  maven:
    podName: maven
    customJenkinsLabels: maven
    image: jenkins/jnlp-agent-maven
    tag: latest
</code></pre>

<p>要找到代理定义，导航到<strong>管理Jenkins </strong>，然后<strong>管理节点和云</strong>，最后<strong>配置云</strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-01/jenkins-helm-install-guide/k8s-cloud.png" class="zoom" data-title=""><img src="../Images/5f1090148f418b7c9103306cb4d80e27.png" class="img-fluid center" alt="Jenkins K8s Cloud, Configure Clouds screen" data-original-src="https://i.octopus.com/blog/2022-01/jenkins-helm-install-guide/k8s-cloud.png"/>T2】</a></p>

<p>要使用代理来执行管道，请如下定义<code>agent</code>块:</p>

<pre><code class="language-groovy">pipeline {
  agent {
      kubernetes {
          inheritFrom 'maven'
      }
  }
  // ...
}
</code></pre>

<p>例如，Java应用程序的管道使用<code>maven</code>代理模板:</p>

<pre><code class="language-groovy">pipeline {
  // This pipeline requires the following plugins:
  // * Pipeline Utility Steps Plugin: https://wiki.jenkins.io/display/JENKINS/Pipeline+Utility+Steps+Plugin
  // * Git: https://plugins.jenkins.io/git/
  // * Workflow Aggregator: https://plugins.jenkins.io/workflow-aggregator/
  // * Octopus Deploy: https://plugins.jenkins.io/octopusdeploy/
  // * JUnit: https://plugins.jenkins.io/junit/
  // * Maven Integration: https://plugins.jenkins.io/maven-plugin/
  parameters {
    string(defaultValue: 'Spaces-1', description: '', name: 'SpaceId', trim: true)
    string(defaultValue: 'SampleMavenProject-SpringBoot', description: '', name: 'ProjectName', trim: true)
    string(defaultValue: 'Dev', description: '', name: 'EnvironmentName', trim: true)
    string(defaultValue: 'Octopus', description: '', name: 'ServerId', trim: true)
  }
  tools {
    jdk 'Java'
  }
  agent {
      kubernetes {
          inheritFrom 'maven'
      }
  }
  stages {
    stage('Environment') {
      steps {
          echo "PATH = ${PATH}"
      }
    }
    stage('Checkout') {
      steps {
        // If this pipeline is saved as a Jenkinsfile in a git repo, the checkout stage can be deleted as
        // Jenkins will check out the code for you.
        script {
            /*
              This is from the Jenkins "Global Variable Reference" documentation:
              SCM-specific variables such as GIT_COMMIT are not automatically defined as environment variables; rather you can use the return value of the checkout step.
            */
            def checkoutVars = checkout([$class: 'GitSCM', branches: [[name: '*/master']], userRemoteConfigs: [[url: 'https://github.com/mcasperson/SampleMavenProject-SpringBoot.git']]])
            env.GIT_URL = checkoutVars.GIT_URL
            env.GIT_COMMIT = checkoutVars.GIT_COMMIT
            env.GIT_BRANCH = checkoutVars.GIT_BRANCH
        }
      }
    }
    stage('Dependencies') {
      steps {
        // Download the dependencies and plugins before we attempt to do any further actions
        sh(script: './mvnw --batch-mode dependency:resolve-plugins dependency:go-offline')
        // Save the dependencies that went into this build into an artifact. This allows you to review any builds for vulnerabilities later on.
        sh(script: './mvnw --batch-mode dependency:tree &gt; dependencies.txt')
        archiveArtifacts(artifacts: 'dependencies.txt', fingerprint: true)
        // List any dependency updates.
        sh(script: './mvnw --batch-mode versions:display-dependency-updates &gt; dependencieupdates.txt')
        archiveArtifacts(artifacts: 'dependencieupdates.txt', fingerprint: true)
      }
    }
    stage('Build') {
      steps {
        // Set the build number on the generated artifact.
        sh '''
          ./mvnw --batch-mode build-helper:parse-version versions:set \
          -DnewVersion=\\${parsedVersion.majorVersion}.\\${parsedVersion.minorVersion}.\\${parsedVersion.incrementalVersion}.${BUILD_NUMBER}
        '''
        sh(script: './mvnw --batch-mode clean compile', returnStdout: true)
        script {
            env.VERSION_SEMVER = sh (script: './mvnw -q -Dexec.executable=echo -Dexec.args=\'${project.version}\' --non-recursive exec:exec', returnStdout: true)
            env.VERSION_SEMVER = env.VERSION_SEMVER.trim()
        }
      }
    }
    stage('Test') {
      steps {
        sh(script: './mvnw --batch-mode -Dmaven.test.failure.ignore=true test')
        junit(testResults: 'target/surefire-reports/*.xml', allowEmptyResults : true)
      }
    }
    stage('Package') {
      steps {
        sh(script: './mvnw --batch-mode package -DskipTests')
      }
    }
    stage('Repackage') {
      steps {
        // This scans through the build tool output directory and find the largest file, which we assume is the artifact that was intended to be deployed.
        // The path to this file is saved in and environment variable called JAVA_ARTIFACT, which can be consumed by subsequent custom deployment steps.
        script {
            // Find the matching artifacts
            def extensions = ['jar', 'war']
            def files = []
            for(extension in extensions){
                findFiles(glob: 'target/**.' + extension).each{files &lt;&lt; it}
            }
            echo 'Found ' + files.size() + ' potential artifacts'
            // Assume the largest file is the artifact we intend to deploy
            def largestFile = null
            for (i = 0; i &lt; files.size(); ++i) {
                if (largestFile == null || files[i].length &gt; largestFile.length) { 
                    largestFile = files[i]
                }
            }
            if (largestFile != null) {
                env.ORIGINAL_ARTIFACT = largestFile.path
                // Create a filename based on the repository name, the new version, and the original file extension. 
                env.ARTIFACTS = "SampleMavenProject-SpringBoot." + env.VERSION_SEMVER + largestFile.path.substring(largestFile.path.lastIndexOf("."), largestFile.path.length())
                echo 'Found artifact at ' + largestFile.path
                echo 'This path is available from the ARTIFACTS environment variable.'
            }
        }
        // Octopus requires files to have a specific naming format. So copy the original artifact into a file with the correct name.
        sh(script: 'cp ${ORIGINAL_ARTIFACT} ${ARTIFACTS}')
      }
    }
    stage('Deployment') {
      steps {
        octopusPushPackage(additionalArgs: '', packagePaths: env.ARTIFACTS.split(":").join("\n"), overwriteMode: 'OverwriteExisting', serverId: params.ServerId, spaceId: params.SpaceId, toolId: 'Default')
        octopusPushBuildInformation(additionalArgs: '', commentParser: 'GitHub', overwriteMode: 'OverwriteExisting', packageId: env.ARTIFACTS.split(":")[0].substring(env.ARTIFACTS.split(":")[0].lastIndexOf("/") + 1, env.ARTIFACTS.split(":")[0].length()).replace("." + env.VERSION_SEMVER + ".zip", ""), packageVersion: env.VERSION_SEMVER, serverId: params.ServerId, spaceId: params.SpaceId, toolId: 'Default', verboseLogging: false, gitUrl: env.GIT_URL, gitCommit: env.GIT_COMMIT, gitBranch: env.GIT_BRANCH)
        octopusCreateRelease(additionalArgs: '', cancelOnTimeout: false, channel: '', defaultPackageVersion: '', deployThisRelease: false, deploymentTimeout: '', environment: params.EnvironmentName, jenkinsUrlLinkback: false, project: params.ProjectName, releaseNotes: false, releaseNotesFile: '', releaseVersion: env.VERSION_SEMVER, serverId: params.ServerId, spaceId: params.SpaceId, tenant: '', tenantTag: '', toolId: 'Default', verboseLogging: false, waitForDeployment: false)
        octopusDeployRelease(cancelOnTimeout: false, deploymentTimeout: '', environment: params.EnvironmentName, project: params.ProjectName, releaseVersion: env.VERSION_SEMVER, serverId: params.ServerId, spaceId: params.SpaceId, tenant: '', tenantTag: '', toolId: 'Default', variables: '', verboseLogging: false, waitForDeployment: true)
      }
    }
  }
}
</code></pre>

<p>通过运行以下命令，您可以确认在任务执行期间在集群中创建了代理:</p>

<pre><code class="language-bash">kubectl get pods
</code></pre>

<p>在下面的示例中，pod <code>java-9-k0hmj-vcvdz-wknh4</code>正在被创建以执行上面的示例管道:</p>

<pre><code class="language-bash">$ kubectl get pods
NAME                                     READY   STATUS              RESTARTS   AGE
java-9-k0hmj-vcvdz-wknh4                 0/1     ContainerCreating   0          1s
myjenkins-0                              2/2     Running             0          49m
</code></pre>

<h2 id="conclusion">结论</h2>

<p>在Kubernetes集群中托管Jenkins及其代理允许您创建一个可伸缩且响应迅速的构建平台，动态地创建和销毁代理以处理弹性工作负载。多亏了Jenkins Helm图表，安装Jenkins和配置节点只需要几行YAML。</p>

<p>在这篇文章中，你学会了如何:</p>

<ul>
<li>将詹金斯部署到库伯内特斯</li>
<li>将詹金斯暴露在公共IP地址上</li>
<li>在安装过程中安装附加插件</li>
<li>通过JCasC配置Jenkins</li>
<li>备份Jenkins主目录</li>
<li>创建Kubernetes代理，根据需要创建和销毁这些代理</li>
</ul>

<p>查看我们关于安装Jenkins的其他帖子:</p>



<p><a href="https://oc.to/JenkinsPipelineGenerator" rel="nofollow">试试我们免费的Jenkins管道生成器工具</a>，用Groovy语法创建一个管道文件。这是您启动管道项目所需的一切。</p>

<h2 id="watch-our-jenkins-pipeline-webinar">观看我们的詹金斯管道网络研讨会</h2>

<iframe src="https://www.youtube.com/embed/D_7AHTML_xw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">VIDEO</iframe>

<p>我们定期举办网络研讨会。请参见<a href="https://octopus.com/events">网络研讨会页面</a>，了解关于即将举办的活动和实时流录制的详细信息。</p>

<p>阅读我们的<a href="https://octopus.com/blog/tag/CI%20Series">持续集成系列</a>的其余部分。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>