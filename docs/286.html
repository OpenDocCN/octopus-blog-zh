<html>
<head>
<title>Publishing a package to a local Octopus instance with GitHub Actions - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用GitHub Actions - Octopus Deploy将包发布到本地Octopus实例</h1>
<blockquote>原文：<a href="https://octopus.com/blog/github-actions-local-runner#2022-04-11">https://octopus.com/blog/github-actions-local-runner#2022-04-11</a></blockquote>
                        <p>今年早些时候，我的同事Ryan Rousseau写了一篇关于使用GitHub Actions 向Octopus Deploy发布一个包的博文。在这篇文章中，我将更进一步，发布一个包到一个用自托管GitHub Actions Runner部署的本地Octopus实例。</p>

<h2 id="github-actions">GitHub操作</h2>

<p>GitHub Actions是GitHub版本的构建服务器。像许多其他构建工具一样，如BitBucket PipeLines和Azure DevOps，GitHub Actions使用另一种标记语言(YAML)来定义构建过程，称为<strong>工作流</strong>。下面是一个GitHub Actions工作流YAML文件的例子。</p>

<p>该示例构建了<a href="https://github.com/OctopusSamples/OctoPetShop" rel="nofollow"> OctoPetShop示例</a>。NET核心应用程序，然后将包推送到我们的<a href="https://samples.octopus.app/" rel="nofollow"> Octopus Deploy Samples </a>实例:</p>

<pre><code>name: .NET Core 

on:
  push:
    branches: [ master ] 
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest 

    steps:
    - uses: actions/checkout@v2
    - name: Set Version
      run: echo "::set-env name=PACKAGE_VERSION::$(date +'%Y.%m.%d').$GITHUB_RUN_NUMBER"
    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 2.2.207
    - name: Install dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --configuration Release --no-restore
    - name: Test
      run: dotnet test --no-restore --verbosity normal
    - name: Create artifacts folder
      run: |
        mkdir "$GITHUB_WORKSPACE/artifacts"
        mkdir "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.Database"
        mkdir "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.Web"
        mkdir "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.ProductService"
        mkdir "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.ShoppingCartService"
    - name: Publish OctoPetShopDatabase
      run: dotnet publish OctopusSamples.OctoPetShop.Database/OctopusSamples.OctoPetShop.Database.csproj --configuration Release --no-restore --output "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.Database"
    - name: Publish OctoPetShopWeb
      run: dotnet publish OctopusSamples.OctoPetShop.Web/OctopusSamples.OctoPetShop.Web.csproj --configuration Release --no-restore --output "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.Web"
    - name: Publish OctoPetShopProductService
      run: dotnet publish OctopusSamples.OctoPetShop.ProductService/OctopusSamples.OctoPetShop.ProductService.csproj --configuration Release --no-restore --output "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.ProductService"
    - name: Publish OctoPetShopShoppingCartService
      run: dotnet publish OctopusSamples.OctoPetShop.ShoppingCartService/OctopusSamples.OctoPetShop.ShoppingCartService.csproj --configuration Release --no-restore --output "$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetshop.ShoppingCartService"
    - name: Install Octopus CLI
      uses: OctopusDeploy/install-octocli@v1
      with:
        version: 7.4.2
    - name: Package OctoPetShopDatabase
      run: |
        octo pack --id="OctoPetShop.Database" --format="Zip" --version="$PACKAGE_VERSION" --basePath="$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.Database" --outFolder="$GITHUB_WORKSPACE/artifacts"
    - name: Package OctoPetShopWeb
      run: |
        octo pack --id="OctoPetShop.Web" --format="Zip" --version="$PACKAGE_VERSION" --basePath="$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.Web" --outFolder="$GITHUB_WORKSPACE/artifacts"
    - name: Package OctoPetShopProductService
      run: |
        octo pack --id="OctoPetShop.ProductService" --format="Zip" --version="$PACKAGE_VERSION" --basePath="$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetShop.ProductService" --outFolder="$GITHUB_WORKSPACE/artifacts"
    - name: Package OctoPetShopShoppingCartService
      run: |
        octo pack --id="OctoPetShop.ShoppingCartService" --format="Zip" --version="$PACKAGE_VERSION" --basePath="$GITHUB_WORKSPACE/artifacts/OctopusSamples.OctoPetshop.ShoppingCartService" --outFolder="$GITHUB_WORKSPACE/artifacts"
    - name: Push OctoPetShop Database
      run: |
        octo push --package="$GITHUB_WORKSPACE/artifacts/OctoPetShop.Database.$PACKAGE_VERSION.zip" --server="${{ secrets.OCTOPUSSERVERURL }}" --apiKey="${{ secrets.OCTOPUSSERVERAPIKEY }}" --space="${{ secrets.OCTOPUSSERVERSPACE_HYBRID }}"
    - name: Push OctoPetShop Web
      run: |
        octo push --package="$GITHUB_WORKSPACE/artifacts/OctoPetShop.Web.$PACKAGE_VERSION.zip" --server="${{ secrets.OCTOPUSSERVERURL }}" --apiKey="${{ secrets.OCTOPUSSERVERAPIKEY }}" --space="${{ secrets.OCTOPUSSERVERSPACE_HYBRID }}"
    - name: Push OctoPetShop ProductService
      run: |
        octo push --package="$GITHUB_WORKSPACE/artifacts/OctoPetShop.ProductService.$PACKAGE_VERSION.zip" --server="${{ secrets.OCTOPUSSERVERURL }}" --apiKey="${{ secrets.OCTOPUSSERVERAPIKEY }}" --space="${{ secrets.OCTOPUSSERVERSPACE_HYBRID }}"
    - name: Push OctoPetShop ShoppingCartService
      run: |
        octo push --package="$GITHUB_WORKSPACE/artifacts/OctoPetShop.ShoppingCartService.$PACKAGE_VERSION.zip" --server="${{ secrets.OCTOPUSSERVERURL }}" --apiKey="${{ secrets.OCTOPUSSERVERAPIKEY }}" --space="${{ secrets.OCTOPUSSERVERSPACE_HYBRID }}"
</code></pre>

<p>随着GitHub托管的runners推送到Octopus Cloud，这个解决方案工作得非常好。然而，如果不穿透防火墙，GitHub托管的runners就无法将包推送到您的自托管Octopus Deploy服务器。</p>

<h3 id="local-build-runners">本地生成运行程序</h3>

<p>GitHub托管的runner预打包了许多功能，但有时您有特定的软件需求，需要能够控制您正在使用的版本，或者需要runner能够访问内部资源，如Octopus Deploy。为了解决这个问题，GitHub的人开发了本地托管跑步者的功能。本地运行器的工作方式类似于Octopus轮询触角，它们伸出GitHub动作，而不是GitHub动作伸入。</p>

<h4 id="set-up-the-runner">设置跑步者</h4>

<p>设置本地跑步者非常简单。感谢GitHub让它变得如此简单。创建工作流YAML文件后，在GitHub repo中进行<strong>设置</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-settings.png" class="zoom" data-title=""><img src="../Images/ae1bc8be11490e23260b7230e11a496e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-settings.png"/>T2】</a></p>

<p>在那里，单击操作:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-settings-actions.png" class="zoom" data-title=""><img src="../Images/380c7aed50fc1bf9e48cd6fec11f70ff.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-settings-actions.png"/>T2】</a></p>

<p>稍微向下滚动以看到<strong>添加流道</strong>按钮并点击它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-add-runner.png" class="zoom" data-title=""><img src="../Images/15e9f13e8015e2874544e9698ca4fc92.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-add-runner.png"/>T2】</a></p>

<p>下一个屏幕为您提供了选择本地runner架构的选项，然后提供了下载和配置它所必需的命令:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-runner-choices.png" class="zoom" data-title=""><img src="../Images/efd2c8ad35b14c0fe4e14883fea7826d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-runner-choices.png"/>T2】</a></p>

<p>当运行配置命令时，您将被询问一些基本的问题，比如runner名称、标签和工作文件夹位置。在这些提示下按Enter键接受默认值。</p>

<p>当你完成后，你将有一个本地的跑步者监听工作:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-local-runner.png" class="zoom" data-title=""><img src="../Images/453aceeeb4013a19138fb3f5d2cc1ba6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-local-runner.png"/>T2】</a></p>

<h4 id="configure-the-workflow-to-use-a-local-runner">将工作流配置为使用本地流道</h4>

<p>在YAML中，将工作流配置为使用本地运行器只需一行代码。以上面的YAML为例，我们将行<code>runs-on</code>改为本地实例的标签。<code>runs-on</code>的当前值使用单个标签<code>ubuntu-latest</code>。然而，当你需要多个标签时，你必须把它们放在一个数组中，这个数组是用方括号指定的。对于我们的新跑步者，我们希望它使用标签<code>self-hosted</code>和<code>linux</code>。为此，我们将改变:</p>

<pre><code class="language-yaml">runs-on: ubuntu-latest 
</code></pre>

<p>收件人:</p>

<pre><code class="language-yaml">runs-on: [self-hosted, linux]
</code></pre>

<p>将我们的工作流配置为使用本地运行器后，我们现在可以将包推送到Octopus Deploy的本地实例。通过对YAML文件进行更改，它启动了一个构建，我可以看到我的本地运行人员通过点击<code>Actions</code>已经获得了它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-build.png" class="zoom" data-title=""><img src="../Images/7765473a18b8ad013d6cec7124f6f66b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-build.png"/>T2】</a></p>

<p>在我的虚拟机上，我看到正在运行作业的消息:</p>

<pre><code>
√ Connected to GitHub

2020-06-09 23:47:30Z: Listening for Jobs
2020-06-10 00:27:20Z: Running job: build
</code></pre>

<p>检查日志输出，我们可以看到构建的版本号是2020.06.10.6:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-build-log.png" class="zoom" data-title=""><img src="../Images/e9dc0713f669e6f3bd7cf0fb00a6f39c.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/github-actions-build-log.png"/></a>T2】</p>

<p>在我的本地Octopus部署实例上，我发现这已经被推了:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-06/github-actions-local-runner/octopus-library-packages.png" class="zoom" data-title=""><img src="../Images/c6d846b9b8e803dfedd59166620075fd.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-06/github-actions-local-runner/octopus-library-packages.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>这篇文章演示了一种使用云构建服务器通过使用本地构建运行器或代理将包推送到自托管Octopus Deploy实例的方法。虽然这里关注的是GitHub动作，但同样的想法也可以扩展到TeamCity、Jenkins或Azure DevOps。</p>

                    
                    
</body>
</html>