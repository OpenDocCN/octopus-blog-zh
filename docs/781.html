<html>
<head>
<title>Using template files in Kubernetes - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Kubernetes - Octopus Deploy中使用模板文件</h1>
<blockquote>原文：<a href="https://octopus.com/blog/using-template-files-in-kubernetes#2021-08-12">https://octopus.com/blog/using-template-files-in-kubernetes#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/kubernetes-template-files.png" class="zoom" data-title=""><img src="../Images/67f6f25c611c514f591652c6f6f8bce1.png" class="img-fluid center" alt="Using template files in Kubernetes" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/kubernetes-template-files.png"/>T2】</a></p>

<p>如果您以前在Octopus中部署过应用程序，那么您可能已经在文件中使用了变量替换，作为一种在部署期间获取通用应用程序包并注入特定于环境的配置的方式。这个过程很方便，因为您可以生成单个应用程序工件，然后每个环境负责对其进行定制，以匹配本地基础设施。</p>

<p>替换应用程序包(如ZIPs或NUPKGs)中的文件是非常简单的，因为这些文件是标准的归档文件，在从工件存储库下载之后、部署到最终目标之前可以很容易地修改。</p>

<p>Docker图像文件不太容易处理。首先，在构建层的方式上有一些魔法，以确保新的和删除的文件都受到尊重，这意味着解包Docker图像文件不像解包各个层那么简单。第二，Kubernetes希望直接从存储库中下载图像，这样就可以将Octopus从分发定制工件的管道中移除。</p>

<p>好消息是，我们可以利用社区创建的一些开源工具来下载和解包Docker图像，然后使用Kubernetes中的本机功能将单个文件挂载到Pods中，以实现与部署修改后的包几乎相同的最终结果。</p>

<h2 id="the-sample-application">示例应用程序</h2>

<p>为了演示模板文件处理，我们有一个非常简单的基于HTTPD的Docker图像，它将显示一个带有当前环境名称的HTML页面。这张图片的代码可以在<a href="https://github.com/OctopusDeploy/DockerFileReplacementDemo" rel="nofollow"> GitHub </a>上找到，并已作为图片<a href="https://hub.docker.com/r/mcasperson/dockerfilereplacement" rel="nofollow">mcasperson/docker file replacement</a>发布。</p>

<p>Docker应用程序显示的HTML文件如下所示。一旦使用Octopus完成部署，字符串<code>#{Octopus.Environment.Name}</code>将被替换为环境的名称:</p>

<pre><code class="language-html">&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;#{Octopus.Environment.Name}&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>为了查看这个Docker映像的运行情况，我们将使用以下Docker run命令在本地运行Docker映像:</p>

<pre><code>docker run -p 8888:80 mcasperson/dockerfilereplacement:0.0.1
</code></pre>

<p>如您所料，在本地运行这个Docker映像会以未处理的形式显示web页面。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/local-docker.png" class="zoom" data-title=""><img src="../Images/6398f62867dc392017f2364d421aff26.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/local-docker.png"/>T2】</a></p>

<p><em>当由Docker直接运行时，web服务器暴露原始模板文件。</em></p>

<h2 id="working-with-docker-images-without-using-docker">处理Docker图像，不使用Docker</h2>

<p>当我们将部署转移到Octopus时，第一步是下载并解压缩Docker映像。通常，与Docker映像和存储库的交互是通过<code>docker</code> CLI工具完成的。尽管总是运行Docker守护进程并不十分有效，但是已经开发了额外的第三方工具来处理Docker守护进程之外的Docker映像。</p>

<p>第一个工具叫做<a href="https://github.com/containers/skopeo" rel="nofollow"> skopeo </a>。我们将使用<code>skopeo</code>下载一个Docker映像，并将其作为一个独立的文件保存在本地磁盘上。</p>

<p>第二个工具叫做<a href="https://umo.ci/" rel="nofollow"> umoci </a>。我们将使用<code>umoci</code>来解包<code>skopeo</code>下载的文件，允许我们访问由Docker映像中所有单独层创建的最终目录结构。</p>

<p>虽然这两个工具都是开源的，但是获得二进制版本可能是一个挑战。在这个练习中，我使用SUSE Linux VM(即SUSE Linux Enterprise Server)作为一个<a href="https://octopus.com/docs/infrastructure/workers"> Octopus worker </a>。SUSE创建了<code>umoci</code>，并从GitHub发布页面提供<a href="https://github.com/openSUSE/umoci/releases" rel="nofollow">二进制下载，而标准的SUSE包存储库包含一个<code>skopeo</code>版本，这意味着我们不必经历尝试自己构建这些工具的痛苦。</a></p>

<h2 id="downloading-and-extracting-the-docker-image">下载并提取Docker图像</h2>

<p>让我们看看由Octopus <code>Run a script</code>步骤运行的bash脚本，它将从Docker映像下载、提取和保存文件内容:</p>

<pre><code class="language-bash">read_file () {
  CONTENTS=""
  while read -r line || [ -n "$line" ]; do
    CONTENTS="${CONTENTS}${line}";
  done &lt; ${1}
  printf -v "${2}" '%s' "${CONTENTS}"
}

skopeo copy docker://mcasperson/dockerfilereplacement:0.0.1 oci:image:latest
umoci unpack --image image --rootless bundle

cd bundle/rootfs/usr/local/apache2/htdocs
read_file template.html TemplateHtml
echo -e $TemplateHtml

set_octopusvariable "TemplateHtml" ${TemplateHtml}
</code></pre>

<p>我们从一个bash函数开始，它逐行读取文件的内容，作为第一个参数提供。然后将结果字符串保存回一个全局变量中，该变量的名称作为第二个参数传入(因为bash函数只能返回整数退出代码)，使用<code>printf</code>:</p>

<pre><code class="language-bash">read_file () {
  CONTENTS=""
  while read -r line || [ -n "$line" ]; do
    CONTENTS="${CONTENTS}${line}";
  done &lt; ${1}
  printf -v "${2}" '%s' "${CONTENTS}"
}
</code></pre>

<p>Docker映像由<code>skopeo</code>下载，并保存在名为<code>image</code>的开放容器倡议(OCI)包中:</p>

<pre><code class="language-bash">skopeo copy docker://mcasperson/dockerfilereplacement:0.0.1 oci:image:latest
</code></pre>

<p>然后用<code>umoci</code>解压这个文件:</p>

<pre><code class="language-bash">umoci unpack --image image --rootless bundle
</code></pre>

<p>此时，我们已经在本地提取了构成Docker映像的文件。我们感兴趣的模板文件是<code>/usr/local/apache/htdocs/template.html</code>。使用我们之前创建的bash函数，这个文件的内容被读入一个名为<code>TemplateHtml</code>的变量。我们还使用<code>echo</code>将该变量的内容转储到屏幕上，以确认我们得到了预期的内容:</p>

<pre><code class="language-bash">cd bundle/rootfs/usr/local/apache2/htdocs
read_file template.html TemplateHtml
echo -e $TemplateHtml
</code></pre>

<p>一旦我们有了文件的内容，我们将它保存为一个<a href="https://octopus.com/docs/deployment-process/variables/output-variables">输出变量</a>:</p>

<pre><code class="language-bash">set_octopusvariable "TemplateHtml" ${TemplateHtml}
</code></pre>

<h2 id="creating-the-kubernetes-configmap">创建Kubernetes配置图</h2>

<p>将文件内容保存为Octopus变量后，下一步是创建一个Kubernetes ConfigMap来保存处理后的值。我们将通过Octopus中的<code>Deploy raw Kubernetes YAML</code>步骤来实现这一点。</p>

<p>以下是该步骤将部署以创建配置图的Kubernetes YAML:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: templateconfigmap
data:
  template.html: "#{Octopus.Action[Extract File].Output.TemplateHtml}"
</code></pre>

<p><code>template.html</code>字段是这个配置图的重要部分。这个键定义了我们要替换的文件名，而<code>"#{Octopus.Action[Extract File].Output.TemplateHtml}"</code>的值将导致我们在上一步中提取的文件内容被处理，然后分配给这个键。重要的是，这意味着变量<code>Octopus.Action[Extract File].Output.TemplateHtml</code>中的任何嵌套变量引用都将被替换。</p>

<p>最终结果是一个ConfigMap，它保存了<code>template.html</code>文件的原始内容，但是执行了任何变量替换。</p>

<h2 id="mounting-the-kubernetes-configmap">安装Kubernetes配置图</h2>

<p>最后一步是从Kubernetes ConfigMap获取值，并将其装载回Kubernetes Pod，从而替换原始的、未处理的文件。我们将通过Octopus中的<code>Deploy Kubernetes containers</code>步骤来实现这一点。</p>

<p>这是通过定义一个引用上一步中创建的配置图的卷来实现的。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/volumes.png" class="zoom" data-title=""><img src="../Images/726351895a126d525ffd8030226300b8.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/volumes.png"/>T2】</a></p>

<p><em>库本内特斯卷的概要。</em></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/volume.png" class="zoom" data-title=""><img src="../Images/08c6a66a43174901a473f9d498cd2a0b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/volume.png"/>T2】</a></p>

<p><em>库伯内特卷的细节。</em></p>

<p>然后将配置图安装到Pod中。这里的技巧是将<code>Mount path</code>设置为要被替换的单个文件的完整路径，并将<code>Sub path</code>设置为ConfigMap中包含该文件内容的条目。</p>

<p>使用此配置，我们将在Pod中装入一个包含配置图中的值的文件，替换原始的通用文件。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/volume-mount.png" class="zoom" data-title=""><img src="../Images/4bf5236938ce065c6a8699a5162ae488.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/volume-mount.png"/>T2】</a></p>

<p><em>一个Kubernetes卷挂载，向Kubernetes容器添加一个文件。</em></p>

<p>为了完整起见，这是来自<code>Deploy Kubernetes containers</code>步骤的容器部分。您可以看到，我们正在部署映像<code>mcasperson/dockerfilereplacement</code>，公开端口80，并将配置图挂载为一个卷。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/k8s-container.png" class="zoom" data-title=""><img src="../Images/14d3ad44e2033f674ff4ce091ef20eb3.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/k8s-container.png"/>T2】</a></p>

<p><em>Kubernetes容器配置概要。</em></p>

<p>为了方便起见，这个Pod将由负载平衡器服务直接公开。这为我们提供了一个公共IP地址，我们可以使用它与Pod进行交互。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/service.png" class="zoom" data-title=""><img src="../Images/dd4d7c8ea79c5d45f1ff27830d072424.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/service.png"/>T2】</a></p>

<p><em>Pod由负载平衡器服务公开。</em></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/service-ports.png" class="zoom" data-title=""><img src="../Images/e23a017adccb49403eb9ace94ed3d1e1.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/service-ports.png"/>T2】</a></p>

<p><em>该服务从Pod公开端口80。</em></p>

<h2 id="the-processed-result">处理结果</h2>

<p>一旦部署完成，我们将拥有一个公共IP，可以用来访问web服务器。现在，当我们打开<code>template.html</code>页面时，我们得到的是替换了变量的HTML模板文件。这意味着我们现在可以在网页正文中看到环境的名称。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/k8s-pod.png" class="zoom" data-title=""><img src="../Images/77dea58f3dc3440605482866d39136df.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/k8s-pod.png"/>T2】</a></p>

<p>在开发环境中，HTTPD展示了经过处理的template.html文件。</p>

<p>如果我们将这个部署推进到下一个环境，我们可以看到新创建的负载平衡器公开了一个将环境名<code>Test</code>放入<code>template.html</code>的Pod。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/k8s-test-pod.png" class="zoom" data-title=""><img src="../Images/be2f130a03ca103d4e623f634d3ffe40.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-11/using-template-files-in-kubernetes/k8s-test-pod.png"/>T2】</a></p>

<p><em>相同的template.html文件在部署后被推送到测试环境中。</em></p>

<h2 id="conclusion">结论</h2>

<p>文件变量替换是创建可部署到任何环境的通用包的一种便捷方式。尽管还需要一些额外的步骤，但是同样的工作流也可以应用到Kubernetes部署中。</p>

<p>通过利用<code>skopeo</code>和<code>umoci</code>下载和提取Docker映像，然后在Kubernetes中使用ConfigMaps作为卷挂载，我们可以实现在部署期间替换模板化文件的效果，而不必发布特定于环境的Docker映像。</p>

                    
                    
</body>
</html>