<html>
<head>
<title>Creating multi-environment Kubernetes deployments - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建多环境Kubernetes部署- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/multi-environment-k8s-deployments#2021-08-12">https://octopus.com/blog/multi-environment-k8s-deployments#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/blogimage-creating-multi-environment-kubernetes-deployments-2020.png" class="zoom" data-title=""><img src="../Images/48818fe1e8acca4d631f464782bf3101.png" class="img-fluid center" alt="Creating multi-environment Kubernetes deployments" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/blogimage-creating-multi-environment-kubernetes-deployments-2020.png"/>T2】</a></p>

<p>Kubernetes资源的声明性质提供了一种方便的方式来描述集群的期望状态。然而，Kubernetes没有本土的环境概念。虽然名称空间提供了一种对集群进行分区的自然机制，但是仅仅通过运行<code>kubectl</code>或查看传统的Kubernetes仪表板，很难了解部署了什么。</p>

<p>通过Octopus管理Kubernetes部署，应用程序可以在不同的环境(由名称空间和名称空间受限的服务帐户表示)中运行，当前的环境状态由Octopus仪表板汇总。</p>

<p>在这篇博文和截屏中，我们来看看Kubernetes部署如何在多种环境中进行。我们还将创建一些操作手册来管理和检查集群，为将来负责支持部署和集群的任何人提供一组基本的自动化工具。</p>

<h2 id="screencast">截屏</h2>

<p>下面的视频演示了将web应用程序部署到Kubernetes集群中的多个环境的过程。博文的其余部分提供了其他资源的链接和本演示中使用的脚本副本:</p>

<iframe src="https://www.youtube.com/embed/WexwK4ro9Bs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">VIDEO</iframe>

<h2 id="the-feeds">饲料</h2>

<p>我们的部署需要指向Docker Hub的Docker feed和Helm feed:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/feeds.png" class="zoom" data-title=""><img src="../Images/522f551a9e0d3073ca57ecfbb2cde530.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/feeds.png"/>T2】</a></p>

<h2 id="the-environments">环境</h2>

<p>我们有三个环境来代表我们部署的应用程序的进展:<strong>开发</strong>、<strong>测试</strong>和<strong>生产</strong>。然后我们有一个名为<strong> Admin </strong>的环境，用于管理集群范围内的资源:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/environments.png" class="zoom" data-title=""><img src="../Images/61a892b308356af4ac2277b827ec4b03.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/environments.png"/></a>T2】</p>

<p><strong>开发</strong>、<strong>测试</strong>和<strong>生产</strong>环境都启用了<strong>动态基础设施</strong>选项:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/dynamic-infrastructure.png" class="zoom" data-title=""><img src="../Images/22aa9d83531253c48ff15eedafa488fc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/dynamic-infrastructure.png"/>T2】</a></p>

<h2 id="the-certificates">证书</h2>

<p>由Let's Encrypt生成的通配符证书已上载到证书库。这将由入口资源稍后使用:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/certificate.png" class="zoom" data-title=""><img src="../Images/0cedb634a0a1f2fd95bc49fc649e5db7.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/certificate.png"/>T2】</a></p>

<h2 id="the-admin-target">管理目标</h2>

<p>我们需要一个具有管理特权的Kubernetes目标作为起点。该目标将用于安装和检查集群范围的工具，如入口控制器，以及创建特定于环境的目标。该目标具有<strong>管理角色</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/admin-target.png" class="zoom" data-title=""><img src="../Images/dc6092ff21b66efae75daa1f99f68ce2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/admin-target.png"/>T2】</a></p>

<h2 id="the-deployment-targets">部署目标</h2>

<p>从概念上讲，Octopus中的Kubernetes目标是一个安全边界，将部署限制在特定的环境中。在本例中，我们在一个集群中创建多个环境，安全边界由一个名称空间和一个只能访问该名称空间的服务帐户定义。然后，名称空间表示环境，服务帐户的有限范围防止对该名称空间/环境的部署修改任何其他名称空间/环境。</p>

<p>要创建仅限于特定名称空间的服务帐户，必须创建三个Kubernetes资源:</p>

<ul>
<li>服务账户</li>
<li>一个角色</li>
<li>角色绑定</li>
</ul>

<p>然后，服务帐户创建一个包含用于身份验证的生成令牌的密码。</p>

<p>幸运的是，一个名为<strong>Kubernetes-Create Service Account and Target</strong>的社区步骤模板为您完成了创建这些Kubernetes资源以及创建Octopus token帐户和Kubernetes目标本身的艰巨工作。在这里，我们将此步骤配置为运行手册的一部分，以创建角色<strong> k8s </strong>链接到环境的小写名称的目标:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/create-targets.png" class="zoom" data-title=""><img src="../Images/6823971f5222c10658766ac4800fc62a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/create-targets.png"/>T2】</a></p>

<p>在<strong>开发</strong>、<strong>测试</strong>和<strong>生产</strong>环境中运行runbook会导致创建三个新的Kubernetes目标。以下是生产部署目标:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/production-target.png" class="zoom" data-title=""><img src="../Images/b72e74c7e0e2cb44d8675f392f8423dd.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/production-target.png"/>T2】</a></p>

<h2 id="the-deployment-process">部署流程</h2>

<p>我们将随机报价示例应用程序部署到集群中。这个Spring Boot应用程序的源代码可以在<a href="https://github.com/OctopusSamples/RandomQuotes-Java" rel="nofollow"> GitHub </a>上找到，Docker图片可以在<a href="https://hub.docker.com/r/octopusdeploy/randomquotesjava" rel="nofollow"> DockerHub </a>上找到。</p>

<p>为了演示传递到每个部署的环境特定变量，我们将创建一个名为<strong>环境</strong>的变量，它有三个值，分别作用于<strong>开发</strong>、<strong>测试</strong>和<strong>生产</strong>环境:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/variables.png" class="zoom" data-title=""><img src="../Images/81afe18cc56c3b7118368344df144c53.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/variables.png"/>T2】</a></p>

<p>然后我们使用<strong>部署Kubernetes容器</strong>步骤部署这个映像。这一步为创建Kubernetes资源提供了一个自以为是的UI驱动的界面，在本例中，我们将创建一个部署、服务和入口资源。</p>

<p>部署资源创建一个带有容器的pod，该容器公开端口80并将<strong>环境</strong>变量映射到名为<strong> SPRING_PROFILES_ACTIVE </strong>的环境变量。这将设置Spring活动概要文件的名称，它将显示在屏幕上，允许我们验证是否为每个环境应用了正确的Octopus变量:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/deployment.png" class="zoom" data-title=""><img src="../Images/c40969ba90d4a6e050bc2ae6aad4101d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/deployment.png"/>T2】</a></p>

<p>然后，群集IP服务在群集内部公开端口80:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/service.png" class="zoom" data-title=""><img src="../Images/07e1fb2c54330475732cf0a57cca5b45.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/service.png"/>T2】</a></p>

<p>入口将服务暴露给主机<strong> #{Octopus上的任何请求。Environment.Name | ToLower} .章鱼. tech </strong>。它还会为该主机名分配一个HTTPS证书:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/ingress.png" class="zoom" data-title=""><img src="../Images/53eb92ef54e96f981870fa1fdf22a126.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/ingress.png"/>T2】</a></p>

<h2 id="the-ingress-controllers">入口控制器</h2>

<p>我们的Kubernetes集群需要一个入口控制器来检查入口资源，并创建适当的网络规则来公开我们的web应用程序。有许多<a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" rel="nofollow">第三方入口控制器可用</a>，对于这个例子，我们将安装NGINX入口控制器。</p>

<p>安装NGINX入口控制器最简单的方法是使用<code>nginx-ingress</code>舵图。我们将通过<strong>升级舵图</strong>步骤来安装这个舵图，作为操作手册的一部分。该步骤将在<strong> admink8s </strong>目标上运行，因为入口控制器是一个集群范围的服务:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/nginx-ingress.png" class="zoom" data-title=""><img src="../Images/46da3b4d31be0546063cff57d173febc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/nginx-ingress.png"/>T2】</a></p>

<p>为了确保运行helm部署的工作人员能够访问helm v3可执行文件，来自<a href="https://github.com/helm/helm/releases" rel="nofollow"> helm releases页面</a>的档案被上传到内置提要，并在该步骤的<strong> Connection </strong>部分被引用。对于Windows workers来说，<code>helm.exe</code>文件的路径是<code>windows-amd64\helm.exe</code>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/helm-windows.png" class="zoom" data-title=""><img src="../Images/0ab48d4ab4c222b48892ec7fbbf82344.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/helm-windows.png"/>T2】</a></p>

<p>对于Linux工作者，路径是<code>linux-amd64/helm</code>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/helm-linux.png" class="zoom" data-title=""><img src="../Images/774b57f2da06db7510a5bf191e53dded.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/helm-linux.png"/>T2】</a></p>

<h2 id="inspecting-the-ingress-controller-load-balancer-public-ip">检查入口控制器负载平衡器公共IP</h2>

<p>NGINX入口控制器的安装创建了一个带有公共IP的负载平衡器。我们需要知道这个公共IP，以便将其映射到DNS主机名。</p>

<p>为了检查Kubernetes资源，我们使用一个名为<strong>Kubernetes-Inspect Resources</strong>的社区步骤模板。这一步是对<code>kubectl</code>的方便包装，我们将使用它来检查NGINX创建的服务的细节:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/inspect-service.png" class="zoom" data-title=""><img src="../Images/b35130c3ba869975d1460ed90392b083.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-12/multi-environment-k8s-deployments/inspect-service.png"/>T2】</a></p>

<h2 id="update-the-dns-records">更新DNS记录</h2>

<p>octopus.tech域由SimpleDNS托管，它提供了一个API来更新DNS记录。更新现有的DNS记录是通过HTTP补丁操作来执行的，我们已经使用<code>curl</code>完成了这个操作。<strong> IP地址</strong>变量的值是在运行runbook之前通过提示符提供的，并且<strong> SimpleDNS令牌</strong>变量是一个秘密:</p>



<pre><code class="language-powershell">Set-Content -Path data.json -Value '{"content":"#{IP Address}"}'

.\curl\curl-7.72.0-win64-mingw\bin\curl.exe  `
  --silent `
  -H "Authorization: Bearer #{SimpleDNS Token}" `
  -H "Accept: application/json" `
  -H "Content-Type: application/json" `
  -X "PATCH" `
  --data-binary '@data.json' `
  "https://api.dnsimple.com/v2/36730/zones/octopus.tech/records/20067854"
</code></pre>

<p>大多数Linux发行版都会安装curl，或者通过包含的包管理器获得，所以bash中的这个脚本是:</p>

<pre><code class="language-bash">echo "#{IP Address}" &gt; data.json

curl \
  --silent \
  -H "Authorization: Bearer #{SimpleDNS Token}" \
  -H "Accept: application/json" \
  -H "Content-Type: application/json" \
  -X "PATCH" \
  --data-binary '@data.json' \
  "https://api.dnsimple.com/v2/36730/zones/octopus.tech/records/20067854"
</code></pre>

<h2 id="conclusion">结论</h2>

<p>多环境是一种常见的部署模式，Octopus为在多环境中进行Kubernetes部署提供了一流的支持。通过为每个环境创建Kubernetes目标，并使用仅有权访问单个名称空间的服务帐户对这些目标进行身份验证，Octopus确保了部署是在正确的名称空间中创建的，并且不会影响它们不应该访问的资源。</p>

<p>在这篇博文和截屏中，我们了解了如何创建多环境Kubernetes部署流程，使用社区步骤模板创建特定于环境的目标，并创建大量操作手册来配置和管理Kubernetes集群以及DNS提供商等相关基础设施。最终结果是一个web应用程序部署到了<strong>开发</strong>、<em>、<strong>、</strong>、<em>、<strong>生产</strong>、</em>环境中，安全地暴露在HTTPS和一套操作手册中，以帮助任何人在未来支持集群。</em></p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>