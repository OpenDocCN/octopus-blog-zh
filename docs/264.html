<html>
<head>
<title>Faster deployments with the Executions API - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过执行API - Octopus Deploy加快部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/faster-deployments-with-the-executions-api#2022-10-04">https://octopus.com/blog/faster-deployments-with-the-executions-api#2022-10-04</a></blockquote>
                        <p>Executions API是一组新的端点，可以显著提高部署、版本创建和runbook执行等操作的性能。在对这些操作进行审查后，我们设计并添加了这些端点，作为<a href="https://octopus.com/blog/octopus-release-2022-q3"> Octopus 2022 Q3版本</a>的一部分。结果是这些操作的性能显著提高，部署时的可伸缩性更好。</p>

<p>在这篇文章中，我将深入探讨我们为什么创建Executions API，以及它如何增强性能和开发人员体验。</p>

<h2 id="measuring-network-performance-with-the-octopus-cli">使用Octopus CLI测量网络性能</h2>

<p>今年早些时候，少数客户让我们知道了一个可以通过他们的部署来改善的问题。他们注意到构建环境和Octopus REST API之间有大量的网络流量。我们希望通过准确了解正在发生的事情来提高性能。</p>

<p>我们的调查从测量Octopus CLI生成的网络流量开始，以建立基线。Octopus CLI广泛用于自动化场景，包括Azure Pipelines、Buildkite、GitHub Actions、Jenkins和TeamCity。Octopus CLI被用来创建和部署发行版，推送构建信息和软件包，以及运行操作手册。这些操作以Octopus REST API为目标来执行工作。</p>

<p>我们运行了一系列测试，涉及3个Octopus CLI操作:</p>

<ul>
<li><code>create-release</code></li>
<li><code>deploy-release</code></li>
<li><code>run-runbook</code></li>
</ul>

<p>我们跟踪了Octopus CLI和Octopus REST API之间发送的网络流量，并获得了它们的网络配置文件摘要:</p>

<table class="table">
<thead>
<tr>
<th>操作</th>
<th>申请数量</th>
<th>持续时间</th>
<th>请求(正文)</th>
<th>回应(正文)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create-release</code></td>
<td>17</td>
<td>1060毫秒</td>
<td>8.1 kB</td>
<td>96.4 kB</td>
</tr>
<tr>
<td><code>deploy-release</code></td>
<td>18</td>
<td>1275毫秒</td>
<td>8.7 kB</td>
<td>105.6 kB</td>
</tr>
<tr>
<td><code>run-runbook</code></td>
<td>14</td>
<td>1452毫秒</td>
<td>6.9 kB</td>
<td>90 kB</td>
</tr>
</tbody>
</table>

<p>17 HTTP请求支持像<code>create-release</code>这样的命令确实是一个非常闲聊的话题！对Octopus CLI中的<code>create-release</code>命令的检查显示，针对Octopus REST API发出了以下HTTP请求:</p>

<pre><code class="language-yaml"> 1  200  CONNECT  /   
 2  200  GET      /api
 3  200  GET      /api
 4  200  GET      /api
 5  200  GET      /api/spaces
 6  200  GET      /api
 7  200  GET      /api/users/me
 8  200  GET      /api/users/{id}/spaces
 9  200  GET      /api/{id}
10  200  GET      /api/users/me
11  200  GET      /api/{id}/projects/projects?name={name}
12  200  GET      /api/{id}/projects/projects/{id}/channels
13  200  GET      /api/{id}/deploymentprocesses/{id}
14  200  GET      /api/{id}/projects/{id}/deploymentprocesses/template?channel={id}
15  200  GET      /api/{id}/projects/{id}/deploymentsettings
16  201  POST     /api/{id}/releases?{ignore-channel-rules}
17  200  GET      /api/{id}/releases/{id}
</code></pre>

<p>第16行的HTTP POST是负责创建发布的HTTP请求。之前的大多数HTTP请求都内置在Octopus CLI中，以限定资源标识符(例如，项目的ID是什么，“octopes”？).这也代表了一条快乐的道路；如果遇到异常和/或错误并需要解决，则可能涉及更多网络流量。更糟糕的是，这些HTTP请求是按顺序发出的:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-10/faster-deployments-with-the-executions-api/executions-api-requests.png" class="zoom" data-title=""><img src="../Images/13de29831038bc2210cb35b936c900a0.png" class="img-fluid center" alt="Screenshot of executions API http requests" data-original-src="https://i.octopus.com/blog/2022-10/faster-deployments-with-the-executions-api/executions-api-requests.png"/>T2】</a></p>

<p>这些操作在Octopus REST API中强制执行数据检查和决策树。如果一个发布涉及不同的包版本，这种情况会变得更糟，因为这可能会执行额外的服务操作。所有这些网络流量导致了更多的负载，损害了我们的可伸缩性。</p>

<p>我们需要一个更好的解决方案。我们在2022年第二季度开始工作，建立一组新的服务端点，统称为执行API。这些API极大地减少了Octopus REST API和诸如Octopus CLI之类的API客户端之间发送的网络流量。</p>

<h2 id="introducing-the-executions-api">执行API简介</h2>

<p>执行API由以下操作和路线组成:</p>

<table class="table">
<thead>
<tr>
<th>操作</th>
<th>途径</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create-release</code></td>
<td><code>/api/{space-id}/releases/create/v1</code></td>
</tr>
<tr>
<td><code>run-runbook</code></td>
<td><code>/api/{space-id}/runbook-runs/create/v1</code></td>
</tr>
<tr>
<td><code>tenanted-deployment</code></td>
<td><code>/api/{space-id}/deployments/create/tenanted/v1</code></td>
</tr>
<tr>
<td><code>untenanted-deployment</code></td>
<td><code>/api/{space-id}/deployments/create/untenanted/v1</code></td>
</tr>
</tbody>
</table>

<p>这些API包含了Octopus CLI执行的所有“繁重”工作。这不仅减少了网络流量，还使这项工作更接近数据。结果是执行API比通过Octopus REST API表示的集合调用快3倍:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-10/faster-deployments-with-the-executions-api/executions-api-performance-graph.png" class="zoom" data-title=""><img src="../Images/b4e95e842ab256a13f39a46eb6eb4376.png" class="img-fluid center" alt="Graph comparing the Executions API and Octopus Rest API" data-original-src="https://i.octopus.com/blog/2022-10/faster-deployments-with-the-executions-api/executions-api-performance-graph.png"/>T2】</a></p>

<h2 id="a-better-developer-experience-with-the-executions-api">更好的开发人员执行API体验</h2>

<p>除了解决性能问题之外，我们还希望Executions API能够提供出色的开发人员体验。我们通过以下方式实现了这一目标:</p>

<ol>
<li>将版本控制合并到所有路线中</li>
<li>将版本控制合并到所有消息中</li>
<li>将camel case应用于消息模式</li>
<li>将资源名称(尽可能地)应用于消息模式</li>
</ol>

<p>将版本化策略合并到执行API中具有重要的战略意义。我们知道API可以存在很长时间，需要进化。将版本应用于路由和消息为我们提供了一条途径，将更改合并到我们的API客户端库和现有集成中。</p>

<p>消息模式中键的骆驼大小写提供了更好的开发人员体验，因为它符合客户的期望:</p>

<pre><code class="language-YAML">{
  "channelName": "Default",
  "gitRef": "refs/heads/main",
  "projectName": "OctoPetShop",
  "releaseVersion": "1.2.3",
  "spaceId": "Spaces-2006",
  "spaceIdOrName": "Pattern - Tenants"
}
</code></pre>

<p>使用Executions API，您可以在消息有效负载中为资源指定名称而不是id(只要有可能)。这可以节省您执行查找的时间，从而获得更好的整体开发体验。</p>

<h2 id="whats-next">下一步是什么？</h2>

<p>Executions API极大地提高了部署、版本创建和runbook执行等操作的性能，并且可供运行<a href="https://octopus.com/downloads/"> Octopus Deploy 2022.3 </a>的客户使用。</p>

<p>我们的下一步是将它们整合到我们现有的集成和工具中。已经开始将执行API与新的Octopus CLI结合起来。将新的Octopus CLI与Executions API结合使用时，您应该会注意到部署时间显著缩短。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>