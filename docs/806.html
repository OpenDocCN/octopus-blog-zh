<html>
<head>
<title>What is GitOps? - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>什么是GitOps？-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/what-is-gitops#2022-12-20">https://octopus.com/blog/what-is-gitops#2022-12-20</a></blockquote>
                        <p>GitOps是我们行业中不断增长的“Ops”范例列表中的一个相对较新的成员。这一切都是从DevOps开始的，虽然DevOps这个术语已经存在了很多年，但似乎我们仍然无法就它是一个过程、思维模式、职位名称、一套工具还是它们的组合达成一致。在我们的<a href="https://octopus.com/blog/introduction-to-devops">DevOps简介</a>帖子中，我们捕捉到了关于devo PS的想法，在我们的<a href="https://octopus.com/devops/"> DevOps工程师手册</a>中，我们更深入地探讨了这些想法。</p>

<p>术语GitOps也有同样的歧义，所以在本帖中，我们来看看:</p>

<ul>
<li>吉托普的历史</li>
<li>GitOps目标和理想</li>
<li>GitOps的局限性</li>
<li>支持GitOps的工具</li>
<li>在您自己的组织中采用GitOps的实际意义</li>
</ul>

<h2 id="the-origins-of-gitops">GitOps的起源</h2>

<p>GitOps这个术语最初是由WeaveWorks在一篇名为<a href="https://www.weave.works/blog/gitops-operations-by-pull-request" rel="nofollow">GitOps-Pull Request</a>的博客文章中提出的。这篇文章描述了WeaveWorks如何使用git作为真理的来源，带来了以下好处:</p>

<blockquote class="blockquote">
<p>我们的AWS资源供应和k8s部署是声明性的</p>
<p>我们的整个系统状态都在版本控制之下，并在单个Git存储库中描述</p>
<p>运营变更由拉式请求(加上构建和发布管道)做出</p>
<p>Diff工具检测任何差异，并通过松弛警报通知我们；同步工具支持融合</p>
<p>回滚和审计日志也通过Git提供”</p>
</blockquote>

<p>自从那篇博文发表以来，像<a href="https://github.com/cncf/tag-app-delivery/tree/main/gitops-wg" rel="nofollow"> GitOps工作组</a>这样的计划已经被组织起来:</p>

<blockquote class="blockquote">
<p>清楚地定义GitOps的供应商中立的、原则主导的含义，这将为工具、一致性和认证之间的互操作性建立基础。"</p>
</blockquote>

<p>该工作组最近发布了其<a href="https://github.com/open-gitops/documents/blob/main/PRINCIPLES.md" rel="nofollow">原则</a>的第一个版本，其中指出:</p>

<blockquote class="blockquote">
<p>GitOps受管系统的理想状态必须是:</p>
<p>声明性——由GitOps管理的系统必须声明性地表达其期望的状态。</p>
<p>版本化和不可变——期望的状态以一种强制不变性、版本化和保留完整版本历史的方式存储。</p>
<p>自动提取-软件代理自动从源代码中提取所需的状态声明。</p>
<p>持续协调-软件代理持续观察实际的系统状态，并尝试应用期望的状态。"</p>
</blockquote>

<p>在大多数博客文章中发现的GitOps的低级实现和工作组描述的GitOps系统的高级理想之间的对比值得讨论，因为它们之间的差异是许多混乱的来源。</p>

<h2 id="gitops-doesnt-imply-the-use-of-git">GitOps并不意味着使用Git</h2>

<p>围绕GitOps的大多数讨论都集中在如何在Git上构建过程，从而产生许多归于GitOps范例的好处。Git自然地提供了一个(几乎)不可变的变更历史，通过pull请求对变更进行了注释和批准，其中Git存储库的当前状态自然地代表了系统的期望状态，因此充当了事实的来源。Git和GitOps之间的重叠是不可否认的。</p>

<p>但是，您可能已经注意到，工作组从未将Git作为GitOps的一个需求。因此，虽然Git是GitOps解决方案的一个方便的组件，但GitOps本身关注的是系统的功能需求，而不是将声明性模板签入Git。</p>

<p>这种区别很重要，因为许多团队专注于GitOps的“Git”部分。GitOps这个术语对于它试图表达的概念来说是一个不合适的名字，这导致许多人认为Git是GitOps的核心方面。但GitOps赢得了营销战，并在IT部门获得了思想份额。虽然它可能是一个限制性术语，用来描述与Git无关的功能需求，但是GitOps现在是描述实现一组高级关注点的过程的简写。</p>

<h2 id="gitops-doesnt-imply-the-use-of-kubernetes">GitOps并不意味着使用Kubernetes</h2>

<p>Kubernetes是第一个广泛使用的平台，它将声明性状态和持续协调的思想与执行环境相结合，以实现协调并托管运行的应用程序。看着Kubernetes集群重新配置自己以匹配应用于系统的最新模板真是太神奇了。所以毫不奇怪，Kubernetes是Flux和Argo CD等GitOps工具的基础，而像<a href="https://dzone.com/articles/30-tools-list-for-gitops" rel="nofollow">30+GitOps工具列表</a>这样的帖子提到Kubernetes 20次。</p>

<p>虽然持续的和解令人印象深刻，但这并不是真正的魔术。在幕后，Kubernetes运行许多<a href="https://octopus.com/blog/operators-with-kotlin">操作符</a>，这些操作符会收到配置更改的通知，并执行定制逻辑以将集群恢复到期望的状态。</p>

<p>持续对账的主要要求是:</p>

<ul>
<li>对以声明方式表达所需状态的配置或模板的访问</li>
<li>当配置改变时，执行能够协调系统的过程的能力</li>
<li>流程可以运行的环境</li>
</ul>

<p>Kubernetes将这些需求烘焙到平台中，很容易实现持续的调和。但这些要求也可以通过一些简单的编排、基础设施即代码(IaC)工具来满足，如Terraform、Ansible、Puppet、Chef、CloudFormation、Arm模板以及CI server或Octopus等执行环境:</p>

<ul>
<li>IaC模板可以存储在Git中，Git是像S3或Azure Blob存储这样的文件托管平台，具有不可变的审计历史。</li>
<li>CI/CD系统可以轮询存储，通过webhooks获得更改通知，或者通过GitHub Actions等平台触发构建或部署。</li>
<li>然后执行IaC工具，使系统符合期望的状态。</li>
</ul>

<p>事实上，真实世界中的端到端GitOps系统不可避免地会包含Kubernetes之外的编排。例如，Kubernetes不太可能管理您的DNS记录、集中式认证平台或Slack之类的消息系统。您可能还会发现，至少有一种托管服务比试图在Kubernetes集群中复制它们更有吸引力，比如数据库、消息队列、调度和报告。此外，任何已建立的IT部门都保证拥有非Kubernetes系统，这些系统将受益于GitOps。</p>

<p>因此，虽然最初选择的专用GitOps工具倾向于紧密集成到Kubernetes中，但要在已建立的基础设施上实现GitOps的功能需求，将不可避免地需要编排一个或多个IaC工具。</p>

<h2 id="continuous-reconciliation-is-half-the-battle">持续的和解是成功的一半</h2>

<p>如工作组所述，持续协调描述了对两种系统变化的反应。</p>

<p>第一个是您所期望的，对Git或其他版本化存储中的配置的故意更改被检测到并应用到系统。这是配置更改的逻辑流程，代表正确配置的GitOps工作流的正常操作。</p>

<p>第二种情况是代理检测到源配置中未描述的不良系统更改。在这种情况下，您的系统不再反映期望的状态，代理需要将系统恢复到Git中维护的配置。</p>

<p>这种解决第二种情况的能力是一种很好的技术能力，但是代表了一个不完整的业务流程。</p>

<p>想象一下，前台的保安报告说他们驱逐了一名入侵者。作为一次性事件，该报告可能会引起轻微的关注，但是安全团队完成了他们的工作并解决了问题。但是现在想象一下你每周都收到这些报告。显然，有一个更重要的问题迫使安全团队对每周的入侵做出响应。</p>

<p>同样，一个不断移除不良系统状态的系统对于一个更根本的问题来说是一个不完整的解决方案。真正的问题是谁在做出这些改变，为什么要做出改变，为什么不通过正确的过程做出改变？</p>

<p>您的系统<em>能够</em>对不良状态做出响应的事实证明了一个健壮的过程能够适应不可预测的事件，这种能力不应该被低估。团队应该执行他们的恢复过程，这是一个由来已久的最佳实践，因此在发生灾难时，团队能够运行一个排练良好的恢复过程。连续协调可以被视为一种自动恢复过程，允许该过程被轻松地测试和验证。</p>

<p>但是，如果你的系统<em>必须</em>对不良状态做出反应，这就是一个有缺陷的过程的证据，在这个过程中，人们可以访问他们不应该或者没有遵循既定的过程。过度依赖一个可以在不良改变发生后将其撤销的系统，可能会掩盖一个更重要的潜在问题。</p>

<h2 id="gitops-is-not-a-complete-solution">GitOps不是一个完整的解决方案</h2>

<p>虽然GitOps描述了管理良好的基础设施和部署流程的许多可取特征，但它并不是一个完整的解决方案。除了GitOps描述的4项功能要求之外，健壮的系统还必须:</p>

<ul>
<li>可验证——基础设施和应用程序一旦部署，就必须是可测试的。</li>
<li>可恢复——团队必须能够从不良状态中恢复过来。</li>
<li>可见——基础设施和部署到基础设施上的应用程序的状态必须呈现在一个易于使用的摘要中。</li>
<li>安全——必须存在关于谁可以对哪些系统进行什么更改的规则。</li>
<li>可测量的——必须收集有意义的指标，并以易于使用的格式公开。</li>
<li>标准化——必须以一致的方式描述应用程序和基础设施。</li>
<li>可维护性——支持团队必须能够查询系统并与之交互，通常是以非声明的方式。</li>
<li>协调——应用程序和基础设施的变更必须在团队之间进行协调。</li>
</ul>

<p>对于在配置提交给Git repo或其他版本化且不可变的存储之前会发生什么，GitOps几乎没有提供任何建议或见解，但它是“repo的左边”,您的大部分工程流程将在这里定义。</p>

<p>如果您的Git repo是您系统的权威表示，那么任何可以编辑repo的人本质上都拥有管理权限。然而，Git回购并没有为您在已建立的基础设施中发现的那种细微的责任分离提供天然的安全边界。这意味着您最终会为每个应用程序、每个环境、每个角色创建一个repo。获得这些回购的可见性并确保它们拥有正确的权限并非易事。</p>

<p>您还会很快发现，仅仅因为您可以在Git中保存任何内容，并不意味着您应该这样做。不难想象这样一条规则:开发团队必须创建Kubernetes部署资源，而不是单独的pods，使用响应非常具体的主机名的入口规则，并始终包括一个标准的安全策略。这种标准化很难通过拉请求来实现，所以一个更好的解决方案是给团队标准的资源模板，他们用自己特定的配置来填充这些模板。但这不是Git或GitOps固有的特性。</p>

<p>然后，我们有那些“集群的权利”的过程，其中定义了管理和支持任务。</p>

<p>报告Git提交的意图几乎是不可能的。如果您查看两次提交之间的差异，发现增加了一个部署映像标记，添加了新的秘密值，删除了一个配置映射，您将如何描述这一变化的意图？简单的答案是读取提交消息，但这对于报告工具来说不是一个可行的选择，这些工具必须将高级事件(如“部署了新的应用程序版本”或“bug修复发布”)映射到两次提交之间的差异，如果你想根据标准指标(如<a href="https://www.devops-research.com/research.html" rel="nofollow"> DORA报告</a>中提供的指标)来衡量自己，这是至关重要的。即使你能推测出一种理解Git提交意图的算法，Git repo也绝不应该被用作时序数据库。</p>

<p>GitOps也没有提供在系统处于理想状态后如何执行支持任务的指导。您会对Git repo承诺什么来删除行为不当的pod，以便它们可以被其父部署重新创建？也许一个工作可以做到这一点，但你必须小心，Kubernetes不会试图申请该工作资源两次。但是，您会向repo承诺什么来查看服务的pod日志，比如预装在您的集群上的入口控制器？一想到在GitOps模型中重建<code>kubectl logs mypod</code>需要实现的所有异步消息处理，我就感到困惑。</p>

<p>像这样的即席报告和管理任务在GitOps模型中没有自然的解决方案。</p>

<p>这并不是说GitOps有缺陷或不完整，而是说它解决了特定的问题，并且必须用其他流程和工具来补充，以满足基本的操作需求。</p>

<h2 id="git-is-the-least-interesting-part-of-gitops">Git是GitOps中最没意思的部分</h2>

<p>我想向你们展示一个理论和一个思维实验，并将其应用于:</p>

<p><strong>在任何足够复杂的GitOps流程中，您的Git repo只是另一个结构化数据库。</strong></p>

<p>您使用Git和Kubernetes的常见组合开始您的GitOps之旅。所有更改都由pull request审查，提交到Git repo，由Argo CD或Flux等工具使用，并部署到您的集群。您已经满足了GitOps的所有功能需求，并享受到了单一事实来源、不可变的变更历史和持续协调的好处。</p>

<p>但是，每次发布新的图像时，让一个人打开一个pull请求来碰撞部署资源中的图像属性会变得很乏味。因此，您指示您的构建服务器获取Git repo，编辑部署资源YAML文件，并提交更改。您现在拥有GitOps和CI/CD。</p>

<p>您现在需要衡量您的工程团队的表现。新版本部署到生产环境的频率如何？您很快意识到从Git提交中提取这些信息效率很低，而且Kubernetes API不是为频繁和复杂的查询设计的，所以您选择用部署事件填充一个更合适的数据库。</p>

<p>随着集群复杂性的增加，您发现需要实现关于可以部署哪种资源的标准。工程团队只能创建部署、机密和配置映射。部署资源必须包括资源限制、一组标准标签，并且不能授予pod特权。事实上，在构成部署到集群的资源的数百条YAML线路中，只有大约10条应该被定制。正如您对image标记更新所做的那样，您将资源的编辑从手动Git提交提升到了一个自动化的过程，在这个过程中，模板拥有一个严格控制的属性子集，这些属性随着每次部署而更新。</p>

<p>现在，您的CI/CD正在执行Git的大部分提交，您意识到您不再需要使用Git repos作为实施安全规则的手段。您将为代表单个应用程序和环境而创建的几十个回购整合到一个只有CI/CD系统每天与之交互的回购中。</p>

<p>您发现自己不得不回滚失败的部署，却发现恢复Git提交的概念过于简单。对您想要恢复的一个应用程序的更改已经与十几个其他部署混合在一起。这并不是说任何人都应该直接接触Git回购，因为合并冲突可能会带来灾难性的后果。但是您可以使用CI/CD服务器来重新部署旧版本的应用程序，因为CI/CD服务器具有组成单个应用程序的上下文，所以重新部署只更改与该应用程序相关的文件。</p>

<p>在这一点上，你承认你的Git repo是另一个结构化的数据库，反映了“真理之源”的子集:</p>

<ul>
<li>人类不能碰它。</li>
<li>所有的改变都是由自动化工具完成的。</li>
<li>自动化工具需要特定位置的特定格式的已知文件。</li>
<li>Git历史显示了由机器人而不是人所做的更改列表。</li>
<li>Git历史现在显示为“Deployment #X.Y.Z”，其他提交信息只在自动化工具的上下文中有意义。</li>
<li>不再使用拉请求。</li>
<li>“事实的来源”现在可以在Git repo(显示文件的变更)、CI/CD平台的历史(显示发起变更的人，以及做出变更的脚本)和度量数据库中找到。</li>
<li>您整合了您的Git repos，这意味着即使您想隔离对人类的访问，您的能力也是有限的。</li>
</ul>

<p>您还意识到，您的GitOps流程中增加独特业务价值的部分是“回购的遗留部分”,包括度量收集、标准化模板、发布编排、回滚和部署自动化；以及带有报告、控制面板和支持脚本的“集群右侧”。Git repo和集群之间的过程现在是如此自动化和可靠，以至于您不需要考虑它。</p>

<h2 id="conclusion">结论</h2>

<p>GitOps已经封装了一个理想功能需求的子集，这些需求可能会为实现这些需求的任何团队提供大量的好处。虽然Git和Kubernetes都不是满足GitOps所必需的，但它们是开始GitOps之旅的逻辑平台，因为它们得到了当今更成熟的GitOps工具的良好支持。</p>

<p>但是GitOps工具倾向于重点关注Git repo的提交和Kubernetes集群之间发生的事情。尽管这无疑是任何部署渠道的一个关键组成部分，但要实施强大的CI/CD渠道和DevOps工作流，在“repo的左边”和“集群的右边”还有许多工作要做。</p>

<p>GitOps工具还倾向于假设，因为所有东西都在Git中，所以每个更改的意图都用提交消息进行了注释，与作者相关联，经过了审查过程，并且可供将来检查。然而，这过于简单了，因为任何足够先进的团队考虑实现GitOps都会通过自动化手动接触点立即开始迭代过程，通常是关于如何将配置添加到Git repo中。</p>

<p>当您规划GitOps工作流的自然发展时，您可能会得出这样的结论:如此多的自动化流程依赖于特定位置和格式的声明性配置，Git提交必须以与数据库迁移非常相似的方式来处理。必须管理和协调GitOps流程的输入，并且必须测试、测量和维护输出。与此同时，Git repo和集群之间的处理应该是自动化的，使我们今天谈论的许多GitOps只是专门的CI/CD管道或DevOps工作流中的一个中间步骤。</p>

<p>围绕GitOps的最大困惑可能是误解了它代表了一个端到端的解决方案，并且您实现了GitOps和以GitOps为中心的工具，而排除了替代流程和平台。</p>

<p>实际上，GitOps封装了基础设施和部署管道中的一个步骤，必须用其他流程和平台来补充，以满足常见的业务需求。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>