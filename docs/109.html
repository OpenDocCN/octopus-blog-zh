<html>
<head>
<title>Change a runbook process to use execution containers - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>更改runbook流程以使用执行容器- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/changing-a-runbook-to-use-exec-containers#2022-07-07">https://octopus.com/blog/changing-a-runbook-to-use-exec-containers#2022-07-07</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/execution-workers.png" class="zoom" data-title=""><img src="../Images/f91df9a90e427079bc3ed89f0327273a.png" class="img-fluid center" alt="Changing a runbook process to use execution containers" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/execution-workers.png"/>T2】</a></p>

<p>继我的上一篇文章<a href="https://octopus.com/blog/extending-octopus-execution-container">workers</a>的执行容器之后，我想将一本操作手册从直接在worker上运行步骤改为使用<a href="https://g.octopushq.com/ExecutionContainersForWorkers" rel="nofollow">执行容器</a>。这样做意味着我可以在我的工作机器上安装最少的软件，而不是在我用作执行容器的Docker映像中维护软件版本。</p>

<p>我正在使用项目<a href="https://g.octopushq.com/PatternRollingSamplePetClinicIacRunbooks" rel="nofollow"> PetClinic Infrastructure </a>，它加速了Google Cloud (GCP)基础设施，以便其他项目部署到我们的示例实例上的<strong>模式滚动</strong>空间中。</p>



<h2 id="set-up-the-worker-machine">设置工作机</h2>

<p>该项目已经使用了它启动的特定工作机，我将使用创建工作机的<a href="https://samples.octopus.app/app#/Spaces-45/projects/petclinic-infrastructure/operations/runbooks/Runbooks-445/process/RunbookProcess-Runbooks-445" rel="nofollow"> runbook </a>并确保它安装了Docker。为此，我需要更新在新创建的GCP虚拟机上用作启动脚本的引导脚本。我采用了一个在新机器上安装所需软件的现有脚本，并添加了以下内容来安装Docker:</p>

<pre><code class="language-bash"># Install Docker
apt-get update
apt-get -y install apt-transport-https ca-certificates curl software-properties-common
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
apt-get update
apt-get -y install docker-ce docker-ce-cli containerd.io

</code></pre>

<p>完整的脚本可以在GitHub上找到。</p>

<p>然后，为了让runbook使用新脚本，我更新了<code>Project.GCP.Targets.StartupScriptUrl</code>项目变量以指向原始版本:<a href="https://raw.githubusercontent.com/OctopusSamples/IaC/master/gcp/bootstrap/gcp-linux-listening-tentacle-wildfly.sh" rel="nofollow">https://raw . githubusercontent . com/OctopusSamples/IaC/master/GCP/bootstrap/GCP-Linux-listening-tentacle-wildly . sh</a>。该变量由<code>Create Compute Engine Instance Worker</code>步骤使用。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/create-worker-step.png" class="zoom" data-title=""><img src="../Images/d458bcf54df6e0895b4e06c99edafa7c.png" class="img-fluid center" alt="Create worker" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/create-worker-step.png"/>T2】</a></p>

<h2 id="create-the-docker-image">创建Docker图像</h2>

<p>我正在做的项目中的大部分工作都使用了<a href="https://cloud.google.com/" rel="nofollow">谷歌云(GCP) </a>。这个项目中的所有脚本都在PowerShell中，对于第一次更新，我将坚持使用它。这意味着我需要一个带有<a href="https://cloud.google.com/sdk/install" rel="nofollow"> Google SDK </a>和<a href="https://github.com/powershell/powershell" rel="nofollow"> PowerShell </a>的图片。这是我的文档:</p>

<pre><code class="language-dockerfile">FROM ubuntu:18.04

ARG DEBIAN_FRONTEND=noninteractive
ARG Azure_Cli_Version=2.9.0\*
ARG Powershell_Version=7.0.0\*

# get `wget` &amp; utils &amp; software-properties-common
# https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7#ubuntu-1804
RUN apt-get update &amp;&amp; \ 
    apt-get install -y wget apt-utils curl &amp;&amp; \
    apt-get install -y software-properties-common 

# get powershell for 18.04
RUN wget -q https://packages.microsoft.com/config/ubuntu/18.04/packages-microsoft-prod.deb &amp;&amp; \
    dpkg -i packages-microsoft-prod.deb &amp;&amp; \
    apt-get update &amp;&amp; \
    add-apt-repository universe &amp;&amp; \
    apt-get install -y powershell=${Powershell_Version}

# Install Google SDK
RUN echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | tee -a /etc/apt/sources.list.d/google-cloud-sdk.list &amp;&amp; \
  apt-get -y install apt-transport-https ca-certificates gnupg &amp;&amp; \
  curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key --keyring /usr/share/keyrings/cloud.google.gpg add - &amp;&amp; \
  apt-get update &amp;&amp; apt-get -y install google-cloud-sdk

RUN apt-get clean

</code></pre>

<p>我已经构建了它，并将其发布到Docker hub上的Docker存储库中:<code>octocrock/gcp-tools</code>。</p>

<h2 id="update-the-runbook-to-use-execution-containers">更新runbook以使用执行容器</h2>

<p>我要转换成使用执行容器的操作手册是<strong>摧毁GCP北海巨妖</strong>。该操作手册删除了所有部署目标基础设施。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/initial-runbook-state.png" class="zoom" data-title=""><img src="../Images/a06a849147cc5d35c23288cafc4bb5be.png" class="img-fluid center" alt="Initial runbook state" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/initial-runbook-state.png"/>T2】</a></p>

<p>该runbook还会注销并删除工作机。重构的一部分是将这些步骤提取到一个单独的操作手册中。我已经创建了一个新的runbook，<strong> Destroy Ubuntu worker </strong>来做这个，我可以复制任何有用的步骤。</p>

<h3 id="the-google-cloud-sdk">谷歌云软件开发套件</h3>

<p>在上面的Dockerfile文件中，我安装了<code>google-cloud-sdk</code>。在runbook中，有一个在工作机器上安装SDK的步骤。因为我将使用Docker映像作为执行容器，所以不再需要安装SDK。在我将这个步骤复制到我的<strong>销毁Ubuntu worker </strong> runbook之后，我将删除<strong>安装GCloud SDK </strong>步骤。</p>

<h3 id="authentication">证明</h3>

<p>runbook有一个设置认证范围的步骤。这需要改变，因为我们需要在每个步骤上设置身份验证范围。我们可以将其重构为一个可重用的脚本模块。</p>

<p>我将前往<strong> <span class="path">库➜脚本模块➜添加脚本模块</span> </strong>，并添加以下我从<strong>激活GCloud服务帐户</strong>步骤中复制的PowerShell代码:</p>

<pre><code class="language-Powershell">function Set-GCPAuth() {
  $JsonKey = $OctopusParameters["GCP.ServiceAccount.Key"]
  $JsonFile = [System.IO.Path]::GetTempFileName()

  if (Test-Path $JsonFile)
  {
      Remove-Item $JsonFile -Force
  }

  New-Item $JsonFile -Type "File" -Force

  $JsonKey | Set-Content $JsonFile
  $gcpServiceAccountEmail = $OctopusParameters["GCP.ServiceAccount.Email"]
  $gcpProjectName = $OctopusParameters["Project.GCP.ProjectName"]
  Write-Host "Activating service account $gcpServiceAccountEmail"

  Write-Host "##octopus[stderr-progress]"
  gcloud auth activate-service-account $gcpServiceAccountEmail --key-file=$JsonFile --project=$gcpProjectName --quiet
  Test-LastExit "gcloud auth activate-service-account"

  if (Test-Path $JsonFile)
  {
      Write-Host "Clearing up temp auth file"
      Remove-Item $JsonFile -Force
  }
}
</code></pre>

<p>然后我只需要进入我的操作手册，通过点击<code>Change</code>并选择<strong> GCP认证</strong>来包含新创建的脚本模块:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/include-script-module.png" class="zoom" data-title=""><img src="../Images/04784be25cccf6a444f247145c278e1d.png" class="img-fluid center" alt="Include script module" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/include-script-module.png"/>T2】</a></p>

<p>现在，在我将步骤复制到我的<strong>销毁Ubuntu worker </strong> runbook之后，我可以删除步骤<strong>激活GCloud服务帐户</strong>。</p>

<h3 id="specify-the-execution-container">指定执行容器</h3>

<p>我要使用执行容器的第一步是<strong>获取GCP·NLB的IP </strong>。在使用容器之前，我必须为<a href="https://hub.docker.com/" rel="nofollow"> DockerHub </a>设置一个<a href="https://g.octopushq.com/DockerRegistries" rel="nofollow">外部进料</a>。为此，导航至<strong> <span class="path">库➜外部进给➜添加进给</span> </strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/docker-feed.png" class="zoom" data-title=""><img src="../Images/9a2da7c8e4e39012427252f5153a46d7.png" class="img-fluid center" alt="docker feed" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/docker-feed.png"/>T2】</a></p>

<p>在runbook中，大多数步骤都在运行GCP脚本，但有一个步骤使用Azure CLI来管理DNS。我将设置两个变量来指定Docker图像。</p>

<ul>
<li><code>Project.Default.Worker.DockerImage</code>:该值为<code>octopusdeploy/worker-tools:1.0-ubuntu.18.04</code>。我将使用的默认图像是Octopus <a href="https://hub.docker.com/r/octopusdeploy/worker-tools/" rel="nofollow"> worker-tools </a>图像。这将运行Azure CLI步骤。不过，该映像没有安装GCP命令行界面。</li>
<li><code>Project.GCP.Worker.DockerImage</code>:它的值为<code>octocrock/gcp-tools:1.0.0</code>，指向从上面创建的Dockerfile创建的图像。</li>
</ul>

<p><strong>获取GCP·NLB IP</strong>run book步骤运行一个使用GCloud的脚本。我可以设置步骤来使用Worker池，该池包含我配置的安装了Docker的机器。我选择<strong> Linux工人池</strong>。我还通过指定<code>Project.GCP.Worker.DockerImage</code>变量来设置要使用的容器图像。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/set-exec-container.png" class="zoom" data-title=""> T32 </a></p>

<p>正如我上面提到的，每个步骤都需要通过GCP认证，所以现在我们需要在脚本中设置它。该步骤的当前脚本代码是:</p>

<pre><code class="language-powershell">CheckForGCPSDK

$projectName = $OctopusParameters["Project.GCP.ProjectName"]
$loadbalancerIPName = $OctopusParameters["Project.GCP.LoadBalancer.ExternalIP.Name"]

Write-Host "Getting compute address matching name: $loadbalancerIPName"
Write-Host "##octopus[stderr-progress]"
$ipAddress=(&amp; $GCloudExecutable compute addresses list --project=$projectName --filter="name=($loadbalancerIPName)" --format="get(address)" --quiet)
Test-LastExit "gcloud compute addresses list"

if( -not ([string]::IsNullOrEmpty($ipAddress))) 
{
    Write-Highlight "Found $loadbalancerIPName of: $ipAddress"
    Set-OctopusVariable -name "IPAddress" -value $ipAddress
}
else {
    Set-OctopusVariable -name "IPAddress" -value ""
</code></pre>

<p>这里的第一个命令现在已经过时，正在安装GCP检查，因为我们知道它包含在我们正在使用的Docker映像中。我将用一个对为GCP认证创建的函数<code>Set-GCPAuth</code>的调用来替换它。</p>

<p>接下来，因为我们直接在容器中使用GCP CLI，我可以将引用<code>$GCloudExecutable</code>改为<code>gcloud</code>。</p>

<p>更新后的脚本如下所示:</p>

<pre><code class="language-powershell">Set-GCPAuth

$projectName = $OctopusParameters["Project.GCP.ProjectName"]
$loadbalancerIPName = $OctopusParameters["Project.GCP.LoadBalancer.ExternalIP.Name"]

Write-Host "Getting compute address matching name: $loadbalancerIPName"
Write-Host "##octopus[stderr-progress]"
$ipAddress=(&amp; gcloud compute addresses list --project=$projectName --filter="name=($loadbalancerIPName)" --format="get(address)" --quiet)
Test-LastExit "gcloud compute addresses list"

if( -not ([string]::IsNullOrEmpty($ipAddress))) 
{
    Write-Highlight "Found $loadbalancerIPName of: $ipAddress"
    Set-OctopusVariable -name "IPAddress" -value $ipAddress
}
else {
    Set-OctopusVariable -name "IPAddress" -value ""
}
</code></pre>

<p>这就是我们在容器中运行这个步骤所需要的全部内容。使用GCP脚本的所有其他步骤都需要进行相同的更改。</p>

<h3 id="azure-cli-step">Azure CLI步骤</h3>

<p>此runbook引用的DNS记录在Microsoft Azure中管理。删除DNS记录的步骤需要安装了Azure CLI的不同Docker映像。</p>

<p>我将设置<strong>删除所有负载平衡器DNS记录</strong>步骤，以使用我在上面设置的<code>Project.Default.Worker.DockerImage</code>变量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/set-exec-container-default.png" class="zoom" data-title=""><img src="../Images/7357ac30e9107300d789234b8effdc66.png" class="img-fluid center" alt="set exec container default" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/set-exec-container-default.png"/>T2】</a></p>

<p>这个Docker图像也可以用于松弛消息步骤。</p>



<p>正如我上面提到的，有一个新的run book<strong>Destroy Ubuntu worker</strong>，它会拆掉worker机器。除了前面的步骤之外，我还复制了通知步骤，并将<strong>从工人池中注销工人</strong>步骤从<strong>销毁北海巨妖</strong>操作手册中移走。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/destroy-worker.png" class="zoom" data-title=""><img src="../Images/aac996b8c51c33bbbf148516884e77ea.png" class="img-fluid center" alt="worker runbook" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/destroy-worker.png"/>T2】</a></p>

<p>最后，我们需要确保在<strong>销毁GCP北海巨妖</strong>运行手册中删除计算引擎实例时，不会从GCP中删除该工人。这包括更改选择计算资源的行以忽略工作机:</p>

<pre><code class="language-powershell">
$instanceList=(&amp; gcloud compute instances list --project=$gcpProjectName --filter="tags.items=$machineTag AND -tags.items=$workerTag" --format="get(name)" --quiet)

</code></pre>

<p>通过添加<code>AND -tags.items=$workerTag</code>子句，查询发生了变化，带有我们的worker machine标签的项目将不会被选择。</p>

<p>相反，在<strong>销毁Ubuntu worker </strong> runbook中，删除worker compute实例的步骤中的行只选择那些带有<code>$workerTag</code>的资源:</p>

<pre><code class="language-powershell">
$instanceList=(&amp; $GCloudExecutable compute instances list --project=$gcpProjectName --filter="tags.items=$workerTag" --format="get(name)" --quiet)

</code></pre>

<h4 id="finishing-up">收尾工作</h4>

<p>这是完成的<strong>摧毁北海巨妖</strong>的操作手册:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/finished-runbook.png" class="zoom" data-title=""><img src="../Images/7e446758af6a3e7f8ff8581c8be1dae2.png" class="img-fluid center" alt="finished runbook" data-original-src="https://i.octopus.com/blog/2020-08/changing-a-runbook-to-use-exec-containers/finished-runbook.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>将这个runbook转换成使用执行容器是非常直接的。我们现在可以在其他地方使用GCP Docker映像，相信通过更新映像的版本以在变量中选择，工具版本的更新将在所有项目中获得。为了进一步减少步骤，我们可以设置一个库变量集并全局设置值。我们甚至可以将版本设置为<code>latest</code>，尽管不建议这样做，因为对于何时吸收对图像所做的更改控制较少。</p>

                    
                    
</body>
</html>