<html>
<head>
<title>Using ad-hoc scripts in your database deployment automation pipeline - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在数据库部署自动化管道中使用专用脚本——Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/automated-database-deployments-adhoc-scripts#2020-04-09">https://octopus.com/blog/automated-database-deployments-adhoc-scripts#2020-04-09</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/blogimage-sqlscript.png" class="zoom" data-title=""><img src="../Images/6d4da028279be7dabd60bf23daf92204.png" class="img-fluid center" alt="Octopus worker deploying an ad-hoc SQL script illustration" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/blogimage-sqlscript.png"/>T2】</a></p>

<p>自动化数据库部署在连续交付方面实现了巨大飞跃。我无法相信自动化数据库部署解决了这么多问题。无论是添加新表、修改存储过程还是创建索引。不管是什么，我不再需要确定环境之间的差异。</p>

<p>尽管有这些优势，一个常见的场景不断出现；在数据库服务器上运行即席查询。我见过的最常见的用例是修复数据。通常，当用户做了意想不到的事情时，数据会处于一种奇怪的状态。在某些情况下，根本问题不会被修复(这种情况发生得不够频繁)，或者问题在一周左右的时间内不会被修复，但是数据需要立即修复。</p>

<p>当我过去遇到这种情况时，过程是:</p>

<ol>
<li>开发人员创建脚本来修复数据。</li>
<li>他们将脚本发送给DBA或拥有更改数据所需权限的人。</li>
<li>有权运行脚本的人。</li>
<li>通知开发人员脚本已经运行。</li>
</ol>

<p>这个过程有很多缺陷。在我职业生涯的某个阶段，我要么是开发人员，要么是运行脚本的人，这不是一个愉快的过程:</p>

<ol>
<li>运行脚本的人不是系统专家。大多数情况下，在运行脚本之前，只是粗略地浏览一下。</li>
<li>拥有必要权限的人可能已经回家了，出去吃午饭了，或者正在开会。该脚本可能几个小时都不会运行。在某些情况下，必须立即修复数据。</li>
<li>通知开发人员是一个手动过程，这意味着脚本可能已经运行，但通知尚未发送。</li>
<li>大多数公司不给初级开发人员修改产品的权利。坦率地说，运行脚本的人还有其他更重要的职责。他们可能真的专注于某件事，被打断会打断他们的思路。</li>
<li>如果请求是通过电子邮件或slack完成的，就不会进行审计，电子邮件是文档死亡的地方。</li>
</ol>

<p>Octopus Deploy不仅仅可以部署软件。增加了许多新功能，使Octopus部署了一个更完整的DevOps工具。在这篇文章中，我将带您完成一个自动运行即席查询的过程。</p>

<p>我使用Octopus Deploy的原因(除了我在这里工作的事实之外)是因为它可以为这个过程提供以下内容:</p>

<ul>
<li>审计:Octopus Deploy可以告诉您谁提出了请求，谁批准了请求，以及这一切是何时发生的。</li>
<li>工件:使用Octopus Deploy内置的工件功能，可以存储和捕获运行的确切脚本，但是，如果有人在文件共享之后更改了脚本，就无从得知了。</li>
<li>认可:在某些情况下，让另一双眼睛看剧本是很重要的。Octopus Deploy可以设置为基于一组标准有条件地批准脚本。</li>
<li>自动化:不再需要手动发送电子邮件。不再需要手动发送确认。不再打开SSMS和运行脚本。</li>
<li>可重复:将在所有环境中使用相同的过程来运行脚本。</li>
</ul>

<h2 id="use-cases">用例</h2>

<p>为了这篇博文的目的。以下是使用案例:</p>

<ul>
<li>作为一名开发人员，我需要运行一个特别的查询来添加一个索引，看看这是否能解决一个性能问题。如果是，那么将该索引添加到数据库定义中，并将其推送到所有环境中。</li>
<li>作为一名DBA，我需要运行一个特殊查询来创建一个SQL登录。</li>
<li>作为一名支持工程师，我需要运行一个特别的查询来授予开发人员选择权限。</li>
<li>作为一名业务分析师，我需要为用户解决一个数据问题。</li>
</ul>

<h2 id="requirements">要求</h2>

<p>考虑到用例，以下是流程的要求:</p>

<ul>
<li>章鱼展开。</li>
<li>没有源代码管理。许多DBA、支持工程师和业务分析师不熟悉源代码控制工具。</li>
<li>自动化。当脚本准备好时，它们应该在五分钟内运行，而不必填写表格或通知任何人。</li>
<li>对脚本的分析，如果脚本包含某些关键字，那么人应该在运行它之前检查脚本。</li>
<li>在任何环境下工作。我们希望鼓励人们在任何环境下运行这个。甚至是戴夫。</li>
</ul>

<h2 id="setup">设置</h2>

<h3 id="tentacles">触须</h3>

<p>我们的<a href="https://octopus.com/docs/deployment-examples/sql-server-databases">数据库部署文档</a>建议您在Octopus Deploy和数据库服务器之间的<strong>跳转框</strong>上安装触角。当使用集成安全性时，这些触角在有权处理部署的服务帐户下运行。这些触角将处理正常部署。</p>

<p>您有几个选项来设置临时流程和权限:</p>

<ol>
<li>继续使用部署触角，但赋予他们执行额外任务的提升权限。</li>
<li>创建一组具有提升权限的新服务帐户，并为这些新服务帐户创建新的触角。</li>
<li>选项1和选项2的组合。创建两条管道。一个用于数据修复，另一个用于其他更改。数据修复通过常规部署目标运行，但是其他更改通过一组新的部署目标运行，这些目标具有新的服务帐户。</li>
</ol>

<h3 id="lifecycle">生命周期</h3>

<p>这个过程允许人们在生产中直接运行脚本。使用默认的开发生命周期来测试预生产到生产没有太大意义。创建新的生命周期，允许部署到任何环境。我称我的脚本生命周期为:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-lifecycle.png" class="zoom" data-title=""><img src="../Images/16c694bfc458cf54241a6784a7c80ba5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-lifecycle.png"/></a>T2】</p>

<p>您可以通过创建一个阶段并将所有环境添加到该阶段来实现这一点:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-scriptlifecycle-details.png" class="zoom" data-title=""><img src="../Images/e0cba84b1486a2f64861d099031f4200.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-scriptlifecycle-details.png"/>T2】</a></p>

<h2 id="projects-and-process">项目和流程</h2>

<p>对于这个过程，我创建了许多步骤模板。我不想把它们提交给社区图书馆，因为它们不够通用，但是你可以在我们的<a href="https://github.com/OctopusSamples/AdHoc-SQLQueries" rel="nofollow"> GitHub示例库</a>中找到它们。</p>

<h3 id="ingesting-scripts">摄取脚本</h3>

<p>我将为这个用例编写一个数据库脚本:</p>

<p><em>作为一名业务分析师，我需要为一名用户解决一个数据问题。</em></p>

<p>我想到了几个问题:</p>

<ol>
<li>问:什么环境？答:生产。</li>
<li>问:什么SQL服务器？答:127.0.0.1。</li>
<li>问:SQL Server上的什么数据库？答:RandomQuotes_Dev。</li>
<li>问:谁在提交剧本？鲍勃·沃克。</li>
</ol>

<p>好了，我们知道了答案，我们如何把这些从我们的大脑中释放到章鱼的大脑中呢？为此，我将使用一个名为元数据的YAML文件，其中包含所有这些信息:</p>

<pre><code>---
DatabaseName: RandomQuotes_Dev
Server: 127.0.0.1
Environment: Dev
SubmittedBy: Bob.Walker@octopus.com
...
</code></pre>

<p>下一个问题是如何将YAML文件和SQL脚本发送到Octopus Deploy来运行？为了使提交脚本的人尽可能容易，我将使用一个热文件夹。我编写了一个PowerShell脚本，它将:</p>

<ol>
<li>在常用文件夹中查找任何新目录。</li>
<li>使用Octo.exe打包文件夹。</li>
<li>将包推至Octopus Deploy。</li>
<li>创建新版本。</li>
<li>使用MetaData.yaml文件确定要部署到哪个环境。</li>
<li>将文件夹移动到已处理的位置，以便脚本不会再次运行。</li>
</ol>

<p>我可以设置一个在服务器上运行的计划任务。但是这个任务没有真正的可视性。如果它开始失败，我不会知道它失败了，直到我RDP到服务器上。</p>

<p>我没有经历那个噩梦，而是在Octopus Deploy中建立了一个新项目，名为“即席查询构建数据库包”该过程只有一个步骤，即运行PowerShell脚本来构建数据库包。记下生命周期，它只运行在一个虚拟环境中，我称之为<code>SpinUp</code>:</p>

<p>【T2 <img src="../Images/de730dce10e10d16b6bf0274a36d972e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-build-database-package-process.png"/></p>

<p>它有一个触发器，每五分钟创建一个新版本，并运行以下流程:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-build-database-package-triggers.png" class="zoom" data-title=""><img src="../Images/1bb3444ec21a9ab26925a3f0f0929380.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-build-database-package-triggers.png"/>T2】</a></p>

<p>在事件中，我想扩展这个过程以支持其他类型的脚本，我将它作为一个步骤模板:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-build-database-package-script-files.png" class="zoom" data-title=""><img src="../Images/b44feee099de33ed01dc6c475b429ac3.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-build-database-package-script-files.png"/>T2】</a></p>

<p>眼尖的读者会看到参数<code>Octopus</code>项目。这是运行脚本的项目。</p>

<h3 id="running-the-scripts">运行脚本</h3>

<p>为了满足上述要求，我希望该流程执行以下操作:</p>

<ol>
<li>将软件包下载到跳转框中。</li>
<li>获取包中的所有文件，并将它们作为工件添加(如果需要审查的话)。</li>
<li>对脚本执行一些基本的分析。如果任何脚本没有使用事务，或者使用关键字<em> Drop </em>或<em> Delete </em>，那么我想触发一个手动干预。</li>
<li>需要手动干预时发出通知。我喜欢的工具是slack。</li>
<li>运行脚本。</li>
<li>如果脚本失败，发送失败通知。</li>
<li>如果脚本成功，发送成功通知。</li>
</ol>

<p>【T2 <img src="../Images/21af082d38f3903a2218a0d7de1d6bdb.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-process.png"/></p>

<p>下载软件包的步骤非常简单。将软件包下载到服务器。不要运行任何配置转换。不要替换任何变量。只需部署软件包:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-download-package.png" class="zoom" data-title=""><img src="../Images/b9adc6c19620feb5ec0b1a5a6ef36c3e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-download-package.png"/>T2】</a></p>

<p>“从要检查的包中获取脚本”是一个步骤模板，它执行以下操作:</p>

<ol>
<li>读取YAML文件并设置输出参数。</li>
<li>将包中的所有文件作为工件添加。</li>
<li>对SQL文件执行一些基本的分析。</li>
<li>如果分析失败，设置一个输出变量<code>ManualInterventionRequired</code>。</li>
</ol>

<p>这都是在一个步骤模板中完成的。唯一需要的参数是下载包的步骤:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-get-script-files.png" class="zoom" data-title=""><img src="../Images/9770ce48d6bd7a5e802430fce9310efa.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-get-script-files.png"/>T2】</a></p>

<p>Octopus Deploy输出参数的格式可能很难记住。我知道我会输错一些东西，所以与其这样做，我使用变量。这样，如果我真的要改变什么，我只需要改变一个地方:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-variables.png" class="zoom" data-title=""><img src="../Images/9fb92c67dc0a86fe8c5ff50ca0ad3abf.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-variables.png"/>T2】</a></p>

<p>当我通知某人时，我可以很容易地包含这些信息。另外，请注意，该步骤将基于<code>ManualInterventionRequired</code>输出变量运行:</p>

<p>【T2 <img src="../Images/735ca8858b0c3ee4f56b8f6414a1444d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-notifications.png"/></p>

<p>人工干预也是如此。运行条件基于<code>ManualInterventionRequired</code>输出变量:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-manual-intervention.png" class="zoom" data-title=""><img src="../Images/151557971658668d5d256ba1d66c7308.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-manual-intervention.png"/>T2】</a></p>

<p>运行SQL脚本步骤将遍历所有SQL文件并运行它们。同样，为了使它更容易，我使用了一个步骤模板。该流程使用了<code>invoke-sqlcmd</code>，它将捕获输出并添加任务历史:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-run-scripts.png" class="zoom" data-title=""><img src="../Images/fdec0c46ae13e7db55df2c1416cc9cb6.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-run-scripts.png"/>T2】</a></p>

<p>假设一切顺利，成功通知可以发出:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-success-notification.png" class="zoom" data-title=""><img src="../Images/9fdef7fd5f81602aba64341ce37988e9.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-success-notification.png"/>T2】</a></p>

<p>否则，失败通知可能会发出:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-failure-notification.png" class="zoom" data-title=""><img src="../Images/cc3ee502dc606f6f3838a8ad46626612.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-octopus-run-database-package-failure-notification.png"/>T2】</a></p>

<h2 id="process-demo">流程演示</h2>

<p>我准备了一个可以运行脚本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-folder.png" class="zoom" data-title=""><img src="../Images/bc8cbade70174f9f0d8fd047a346ba1a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-folder.png"/></a>T2】</p>

<p>MetaData.yaml文件将脚本设置为在Dev:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-metadata.png" class="zoom" data-title=""><img src="../Images/0be2fb2935f693b9d8cb727a4572ee00.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-metadata.png"/>T2】</a></p>

<p>剧本本身没什么特别的。我不打算用一个事务来表明流程会选择它并强制进行手动干预:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-script.png" class="zoom" data-title=""><img src="../Images/8e76e6ebb3278d7dab49b5d883ecdc07.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-script.png"/>T2】</a></p>

<p>我已将该文件夹复制到常用文件夹中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-hot-folder.png" class="zoom" data-title=""><img src="../Images/546d708342a89a6ecae2f2fa0a6c466b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-hot-folder.png"/>T2】</a></p>

<p>章鱼拿起那个文件夹:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-build-package.png" class="zoom" data-title=""><img src="../Images/f2d334fcfbb11956de64f43b9feca648.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-build-package.png"/>T2】</a></p>

<p>我现在看到demo文件夹已经移动到processed文件夹中。我在上面贴了一个时间戳，这样我就能确切地知道那个文件夹是什么时候被处理的:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-processed.png" class="zoom" data-title=""><img src="../Images/4d1b82704b14051e7b7f52978f21d257.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-processed.png"/>T2】</a></p>

<p>查看运行脚本的项目，我可以看到已经创建了一个新的版本，并且有一个手动干预正在等待我:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-new-deployment.png" class="zoom" data-title=""><img src="../Images/750d937dae10d6ecb08fbf8fd6b4da2b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-new-deployment.png"/></a>T2】</p>

<p>我可以检查松弛通道，并看到批准消息已发送:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-slack-manual-approval.png" class="zoom" data-title=""><img src="../Images/beb183209bf3845783b22753a9ce9c48.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-slack-manual-approval.png"/>T2】</a></p>

<p>进入发布，我可以看到工件已经生成。如果我愿意，我可以下载它们并查看将要运行的确切脚本。当我查看审批详细信息时，我可以看到该消息与时差通知相同:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-artifacts.png" class="zoom" data-title=""><img src="../Images/a586ae33f0dd78e8ef84c21c398cbc5d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-artifacts.png"/>T2】</a></p>

<p>批准部署后，将运行脚本并捕获输出:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-run-script-task.png" class="zoom" data-title=""><img src="../Images/888bc94b591274114632c57d238731dc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-run-script-task.png"/>T2】</a></p>

<p>由于脚本成功运行，成功通知被发送到slack:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-slack-success.png" class="zoom" data-title=""><img src="../Images/f19d84bcce15b5cf3e5f2fc7eb8e8ec2.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-03/database-deployment-automation-adhoc-scripts/adhoc-demo-slack-success.png"/>T2】</a></p>

<h2 id="faq">常见问题解答</h2>

<h3 id="how-can-i-prevent-someone-from-submitting-a-script-to-the-dev-environment-but-allow-it-for-a-production-sql-server">我如何阻止某人向开发环境提交脚本，但允许它用于生产SQL Server？</h3>

<p>使用集成安全性时，每个环境都要有一个触手。该触手只能访问其环境中的SQL服务器。使用SQL身份验证时，每个环境有单独的用户和密码。无论哪种情况，脚本都将失败，因为用来登录SQL Server的用户将无法登录。</p>

<h3 id="what-if-i-want-to-have-every-script-reviewed-when-they-are-sent-to-pre-production-and-production">如果我想让每个剧本在进入前期制作和制作阶段时都接受审查，该怎么办？</h3>

<p>将手动干预步骤更改为始终运行。此外，将环境更改为生产前和生产环境。有条件批准是为了仅在满足某些条件时才要求批准。事实上，从一开始，我建议所有发送到前期制作和生产的脚本都要经过人工批准。当在流程中建立了信任后，就应该引入有条件的批准了。</p>

<h3 id="this-seems-like-overkill.couldnt-you-use-prompted-variables-in-octopus-deploy">这看起来有点过了。你不能在Octopus Deploy中使用提示变量吗？</h3>

<p>绝对的！我有另一个项目来做这个。问题是，谁来提交这些脚本？他们应该有权利创建一个版本并投入生产吗？每个人都可以使用Octopus Deploy吗？对于我的用例，我的答案是否定的。我在这个过程中的主要目标是消除尽可能多的手动步骤。使用提示变量手动创建版本增加了太多的手动步骤。</p>

<h2 id="conclusion">结论</h2>

<p>我第一个承认这个过程远非完美。这并不适用于每家公司。这篇文章的目的是提供一个流程的例子，你可以修改这个流程以用于你的公司。</p>

<p>下次再见，愉快的部署！</p>

<hr/>

<p>数据库部署自动化系列文章:</p>



                    
                    
</body>
</html>