<html>
<head>
<title>Selenium series: Asynchronous Lambdas - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:异步Lambdas - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/33-asynchronous-lambdas/asynchronous-lambdas#2021-07-07">https://octopus.com/blog/selenium/33-asynchronous-lambdas/asynchronous-lambdas#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>我们现在有能力用AWS Lambda函数运行Gherkin特性。但到目前为止，我们不得不从AWS控制台触发测试。当我们测试Lambda工作时，这是好的，但是这不是一个非常方便的运行测试的方法。</p>

<p>为了允许在不使用AWS Lambda控制台的情况下执行测试，我们将在无服务器配置文件中配置一个HTTP事件。这个事件允许我们从HTTP POST请求中执行Lambda函数，这又允许我们使用任何标准的HTTP工具或库来触发测试。</p>

<p>为了配置HTTP事件，我们更新了<code>serverless.yml</code>文件:</p>

<pre><code class="language-yaml">service:
  name: cucumber-chrome-aws

provider:
  name: aws
  runtime: java8
  region: us-east-1

package:
  artifact: target/webdrivertraining-1.0-SNAPSHOT.jar

functions:
  runCucumber:
    handler: com.octopus.LambdaEntry::runCucumber
    timeout: 300
    memorySize: 512
    events:
      - http:
          method: post
          path: runCucumber
          integration: lambda
          request:
            parameters:
              headers:
                'X-Amz-Invocation-Type': true
            template:
              text/plain: "\"$util.escapeJavaScript($input.body).replaceAll(\"\\'\",\"'\")\""
          response:
            headers:
              Content-Type: "'application/json'"
            template: $util.parseJson($input.body)
</code></pre>

<p>新的<code>events</code>部分添加了一个<code>http</code>事件。HTTP <code>method</code>是<code>post</code>，我们可以访问的<code>path</code>被称为<code>runCucumber</code>，因为这个事件触发了一个Lambda函数，所以<code>integration</code>被设置为<code>lambda</code>:</p>

<pre><code class="language-yaml">events:
  - http:
      method: post
      path: runCucumber
      integration: lambda
</code></pre>

<p>当我们执行HTTP POST时，我们在请求体中传递将要运行的Gherkin特性文件。但是正如我们之前看到的，Lambda函数期望所有输入都是JSON数据。在从控制台测试Lambda时，我们通过使用一个简单的web页面将纯文本转换为JSON字符串来解决这个需求。我们可以使用请求模板实现同样的转换。</p>

<p>这里我们已经配置了一个请求模板，当发出一个包含<code>text/plain</code>内容的请求时会用到这个模板。关键字<code>text/plain</code>是多用途互联网邮件扩展(MIME)类型，这是一种表示文档性质和格式的标准化方法:</p>

<pre><code class="language-yaml">request:
  template:
    text/plain: "\"$util.escapeJavaScript($input.body).replaceAll(\"\\'\",\"'\")\""
</code></pre>

<p>处理纯文本请求的模板，没有最外面的引号和里面的转义引号，是这样的:</p>

<pre><code>"$util.escapeJavaScript($input.body).replaceAll("\'","'")"
</code></pre>

<p>这个模板的目的与我们编写的将纯文本转换成JSON字符串的web页面相同。但是，这个模板是使用Velocity模板语言编写的，这是AWS使用的模板库。该模板的逻辑如下:</p>

<table class="table">
<thead>
<tr>
<th>模式</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>"</code></td>
<td>打印一个字面双引号</td>
</tr>
<tr>
<td><code>$util.escapeJavaScript($input.body)</code></td>
<td>从保存在<code>$input.body</code>中的请求中获取原始文本(即作为HTTP POST主体发送的文本)，并传递给<code>$util.escapeJavaScript()</code>函数。</td>
</tr>
<tr>
<td><code>.replaceAll("\'","'")</code></td>
<td><code>escapeJavaScript()</code>函数将转义单引号，这不是有效的JSON。所以用单引号替换所有转义的引号。</td>
</tr>
<tr>
<td><code>"</code></td>
<td>打印一个字面双引号</td>
</tr>
</tbody>
</table>

<p>作为响应，我们希望传回Lambda函数返回的JSON。我们通过将<code>Content-Type</code>头设置为MIME类型<code>application/json</code>来确定响应返回JSON。</p>

<p>我们再次使用模板来转换响应。该模板获取Lambda函数返回的JSON字符串，该字符串被公开为<code>$input.body</code>，并将其传递给<code>$util.parseJson()</code>函数，该函数将JSON解析为一个对象以返回给发送方:</p>

<pre><code class="language-yaml">response:
  headers:
    Content-Type: "'application/json'"
  template: $util.parseJson($input.body)
</code></pre>

<p>通过对<code>serverless.yml</code>文件的这些更改，我们可以再次用无服务器部署命令重新发布Lambda函数。该命令的输出如下所示:</p>

<pre><code>Serverless: Packaging service...
Serverless: WARNING: Function runCucumber has timeout of 300 seconds, however, it's attached to API Gateway so it's automatically limited to 30 seconds.
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (22.67 MB)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
........................
Serverless: Stack update finished...
Service Information
service: cucumber-chrome-aws
stage: dev
region: us-east-1
stack: cucumber-chrome-aws-dev
api keys:
None
endpoints:
POST - https://hkm5i7fmlc.execute-api.us-east-1.amazonaws.com/dev/runCucumber
functions:
runCucumber: cucumber-chrome-aws-dev-runCucumber
</code></pre>

<p>注意，日志文件显示了我们可以用来触发HTTP事件的端点的URL。在上面的例子中，URL<a href="https://hkm5i7fmlc.execute-api.us-east-1.amazonaws.com/dev/runCucumber" rel="nofollow">https://hkm 5i 7 fmlc . execute-API . us-east-1 . amazonaws . com/dev/run cumber</a>是我们将通过HTTP POST请求调用的，以执行一个小黄瓜特性。</p>

<p>要发出HTTP请求，我们将使用一个名为Postman的工具，你可以从https://www.getpostman.com/下载。Postman提供了一个简单的接口，我们可以用它来创建定制的HTTP请求，在这种情况下，我们将向上面找到的URL发出POST请求。</p>

<p>下面的屏幕截图显示了需要填写的重要字段，以便提出发布请求。</p>

<ul>
<li>从选项卡顶部的下拉列表中选择<code>POST</code>。</li>
<li>在选项卡顶部的文本框中输入URL。</li>
<li>选择<code>Body</code>选项卡。</li>
<li>选择<code>raw</code>选项。</li>
<li>从内容类型下拉列表中选择<code>Text</code>。</li>
<li>将小黄瓜特性粘贴到标签底部的文本区域。</li>
<li>点击<code>Send</code>按钮。</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image1.png" class="zoom" data-title=""><img src="../Images/116fef8f07726fe1c1659208d86a9ec8.png" class="img-fluid center" alt="/C:/941191ba7e622160892a5123816cf59a" data-original-src="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image1.png"/>T2】</a></p>

<p>如果你幸运的话，你可能会看到这个回复。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image2.png" class="zoom" data-title=""><img src="../Images/c002c408408cb65c4bb74b8a6ceb1151.png" class="img-fluid center" alt="/C:/643a4cd7e0389640c129bc0a2485278f" data-original-src="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image2.png"/>T2】</a></p>

<p>我说幸运，因为您可能已经看到了<code>Endpoint request timed out</code>错误消息。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image3.png" class="zoom" data-title=""><img src="../Images/8e9118761f6ec353c098ec5f5984c9aa.png" class="img-fluid center" alt="/C:/6258b00237e59450e4167ba1a9104d2c" data-original-src="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image3.png"/>T2】</a></p>

<p>那么<code>Endpoint request timed out</code>错误信息是什么意思呢？</p>

<p>这个错误是由于在Lambda函数前面提供HTTP端点所实现的服务的不同限制造成的。</p>

<p>如果您打开Lambda控制台并查看该函数，您可以看到一个名为API Gateway的服务位于Lambda函数的前面。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image4.png" class="zoom" data-title=""><img src="../Images/20d95c00a01611140f6795ada6b96b74.png" class="img-fluid center" alt="/C:/edb84ea8b782041656cd633e9368260c" data-original-src="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image4.png"/>T2】</a></p>

<p>API Gateway是另一个用于构建HTTP APIs的AWS服务，它是无服务器应用程序在我们添加HTTP事件时构建的服务。API Gateway接收我们的HTTP请求，用我们定义的模板转换它们，将它们传递给Lambda函数，转换Lambda函数的响应，并将结果传递回调用者。</p>

<p>然而，虽然Lambda函数可以运行5分钟，但是通过API网关发出的请求只能保持打开29秒。这些是AWS对这些服务施加的限制，我们没有扩展它们的选项。</p>

<p>当API网关调用的Lambda函数花费了超过29秒的时间来完成时，就会生成<code>Endpoint request timed out</code>错误消息。</p>

<p>这对我们来说是个问题，因为我们不太可能写出能在29秒内可靠完成的WebDriver测试。通常我们编写测试来完成web应用程序的整个旅程，这可能需要几分钟。那么如何才能克服API Gateway强加的29秒时间限制呢？</p>

<p>解决方案是异步运行我们的Lambda。这意味着API Gateway启动Lambda，但不等待返回值，而是直接向调用者返回一个空结果。这意味着我们不再受Lambda运行时间的限制，因为它是在后台运行的。</p>

<p>为了指示API Gateway异步调用Lambda，我们需要传递值为<code>Event</code>的<code>X-Amz-Invocation-Type</code>头。</p>

<p>这里是新的<code>serverless.yml</code>文件:</p>

<pre><code class="language-yaml">service:
  name: cucumber-chrome-aws

provider:
  name: aws
  runtime: java8
  region: us-east-1

package:
  artifact: target/webdrivertraining-1.0-SNAPSHOT.jar

functions:
  runCucumber:
    handler: com.octopus.LambdaEntry::runCucumber
    timeout: 300
    memorySize: 512
    events:
      - http:
          method: post
          path: runCucumber
          integration: lambda
          request:
            parameters:
              headers:
                'X-Amz-Invocation-Type': true
              template:
                text/plain: "\"$util.escapeJavaScript($input.body).replaceAll(\"\\'\",\"'\")\""
          response:
            headers:
              Content-Type: "'application/json'"
            template: $util.parseJson($input.body)
</code></pre>

<p>在以下配置中，我们定义了需要<code>X-Amz-Invocation-Type</code>标题(将该值设置为<code>true</code>意味着它是必需的):</p>

<pre><code class="language-yaml">request:
  parameters:
    headers:
      'X-Amz-Invocation-Type': true
</code></pre>

<p>使用无服务器重新部署功能。更新后，通过点击<code>Headers</code>选项卡并添加一个带有关键字<code>X-Amz-Invocation-Type</code>和值<code>Event</code>的头，将<code>X-Amz-Invocation-Type</code>头添加到Postman中的HTTP请求。这个头和值对就是我们如何指示API Gateway以异步方式执行相关的Lambda函数。</p>

<p>将<code>X-Amz-Invocation-Type</code>头值设置为<code>RequestResponse</code>会恢复之前的默认同步行为，如果您确定您的测试将在29秒内完成，这可能会很有用。</p>


<p>在<a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/integrating-api-with-aws-services-lambda.html" rel="nofollow">https://docs . AWS . Amazon . com/API gateway/latest/developer guide/integrating-API-with-AWS-services-lambda . html中更详细地记录了<code>X-Amz-Invocation-Type</code>头。</a></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image5.png" class="zoom" data-title=""><img src="../Images/4bd2f662a22217b58bfdfb224ac32516.png" class="img-fluid center" alt="/C:/c702d2a86f09873ae9edd675c653e749" data-original-src="https://i.octopus.com/blog/2018-10/selenium/33-asynchronous-lambdas/image5.png"/>T2】</a></p>

<p>这个请求几乎会立即返回，并以一个空对象作为响应。</p>

<p>太好了，我们现在可以通过HTTP调用来运行Gherkin脚本，而不需要担心通过API网关发出的请求的时间限制。但是现在我们无法知道测试是通过了还是失败了。异步运行Lambda意味着我们得到一个空响应。由于来自<code>runCucumber</code>函数的响应从未被捕获，我们不再知道结果是什么。</p>

<p>这个难题的最后一部分是为<code>runCumumber</code>函数提供一种返回测试结果的方法，因为它是以异步方式调用的。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>