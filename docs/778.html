<html>
<head>
<title>Using the NGINX Docker image - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用NGINX Docker映像- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/using-nginx-docker-image#2022-09-12">https://octopus.com/blog/using-nginx-docker-image#2022-09-12</a></blockquote>
                        <p>Docker是一个打包和运行web应用程序的引人注目的平台，尤其是当它与云平台提供的众多平台即服务(PaaS)产品之一结合使用时。NGINX长期以来为DevOps团队提供了在Linux上托管web应用程序的能力，并且还提供了一个官方的Docker映像作为定制web应用程序的基础。</p>

<p>在这篇文章中，我解释了DevOps团队如何使用<a href="https://hub.docker.com/_/nginx" rel="nofollow"> NGINX Docker映像</a>在Docker上构建和运行web应用程序。</p>

<h2 id="getting-started-with-the-base-image">基础映像入门</h2>

<p>NGINX是一个多用途的工具，包括负载平衡器、反向代理和网络缓存。然而，当在Docker容器中运行NGINX时，这些高级功能中的大部分被委托给其他专门的平台或NGINX的其他实例。通常，当运行在Docker容器中时，NGINX实现了web服务器的功能。</p>

<p>要使用默认网站创建NGINX容器，请运行以下命令:</p>

<pre><code class="language-bash">docker run -p 8080:80 nginx
</code></pre>

<p>该命令将下载<code>nginx</code>映像(如果尚未下载)并创建一个容器，将容器中的端口80暴露给主机上的端口8080。然后可以打开<code>http://localhost:8080/index.html</code>查看默认的“欢迎使用nginx！”网站。</p>

<p>为了允许NGINX容器公开定制的web资产，可以在Docker容器中挂载一个本地目录。</p>

<p>将以下HTML代码保存到名为<code>index.html</code>的文件中:</p>

<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
        Hello from Octopus!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>接下来，运行下面的命令，在NGINX容器中的<code>/usr/share/nginx/html</code>下挂载当前目录，并进行只读访问:</p>

<pre><code class="language-bash">docker run -v $(pwd):/usr/share/nginx/html:ro -p 8080:80 nginx
</code></pre>

<p>再次打开<code>http://localhost:8080/index.html</code>,您会看到显示的自定义HTML页面。</p>

<p>Docker映像的一个好处是能够将所有相关文件捆绑到一个可分发的工件中。要实现这一优势，您必须基于NGINX映像创建一个新的Docker映像。</p>

<h2 id="creating-custom-images-based-on-nginx">基于NGINX创建自定义图像</h2>

<p>要创建自己的Docker图像，请将以下文本保存到名为<code>Dockerfile</code>的文件中:</p>

<pre><code class="language-dockerfile">FROM nginx
COPY index.html /usr/share/nginx/html/index.html
</code></pre>

<p><code>Dockerfile</code>包含构建自定义Docker映像的说明。在这里，您使用<code>FROM</code>命令将您的映像基于NGINX one，然后使用<code>COPY</code>命令将您的<code>index.html</code>文件复制到<code>/usr/share/nginx/html</code>目录下的新映像中。</p>

<p>使用以下命令构建新映像:</p>

<pre><code class="language-bash">docker build . -t mynginx
</code></pre>

<p>这构建了一个名为<code>mynginx</code>的新图像。使用以下命令运行新映像:</p>

<pre><code class="language-bash">docker run -p 8080:80 mynginx
</code></pre>

<p>注意，这次您没有挂载任何目录。然而，当你打开<code>http://localhost:8080/index.html</code>时，你的定制HTML页面会显示出来，因为它嵌入在你的定制图像中。</p>

<p>NGINX不仅仅能够托管静态文件。要解锁此功能，您必须使用自定义NGINX配置文件。</p>

<h2 id="advanced-nginx-configuration">高级NGINX配置</h2>

<p>NGINX通过配置文件公开其功能。默认的NGINX映像附带了一个简单的默认配置文件，用于托管静态web内容。该文件位于默认图像中的<code>/etc/nginx/nginx.conf</code>处，其内容如下:</p>

<pre><code>user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</code></pre>

<p>不需要详细理解这个配置文件，但是有一行有趣的内容指示NGINX从<code>/etc/nginx/conf.d</code>目录加载额外的配置文件:</p>

<pre><code>include /etc/nginx/conf.d/*.conf;
</code></pre>

<p>默认的<code>/etc/nginx/conf.d</code>文件将NGINX配置为web服务器。具体来说，<code>location /</code>阻止从<code>/usr/share/nginx/html</code>加载文件是你之前将HTML文件挂载到那个目录的原因:</p>

<pre><code>server {
    listen       80;
    server_name  localhost;

    #access_log  /var/log/nginx/host.access.log  main;

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    # proxy the PHP scripts to Apache listening on 127.0.0.1:80
    #
    #location ~ \.php$ {
    #    proxy_pass   http://127.0.0.1;
    #}

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
    #
    #location ~ \.php$ {
    #    root           html;
    #    fastcgi_pass   127.0.0.1:9000;
    #    fastcgi_index  index.php;
    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
    #    include        fastcgi_params;
    #}

    # deny access to .htaccess files, if Apache's document root
    # concurs with nginx's one
    #
    #location ~ /\.ht {
    #    deny  all;
    #}
}

</code></pre>

<p>您可以利用该指令来加载<code>/etc/nginx</code>中的任何<code>*.conf</code>配置文件，以定制NGINX。在本例中，您添加了一个健康检查，它通过一个自定义位置监听端口90，用HTTP 200 OK响应对<code>/nginx-health</code>路径的请求。</p>

<p>将以下文本保存到名为<code>health-check.conf</code>的文件中:</p>

<pre><code>server {
    listen       90;
    server_name  localhost;

    location /nginx-health {
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
</code></pre>

<p>修改<code>Dockerfile</code>将配置文件复制到<code>/etc/nginx/conf.d</code>:</p>

<pre><code class="language-Dockerfile">FROM nginx
COPY index.html /usr/share/nginx/html/index.html
COPY health-check.conf /etc/nginx/conf.d/health-check.conf
</code></pre>

<p>使用以下命令构建映像:</p>

<pre><code class="language-bash">docker build . -t mynginx
</code></pre>

<p>使用命令运行新映像。请注意9090上显示的新端口:</p>

<pre><code class="language-bash">docker run -p 8080:80 -p 9090:90 mynginx
</code></pre>

<p>现在打开<code>http://localhost:9090/nginx-health</code>。返回运行状况检查响应，表明web服务器已启动并正在运行。</p>

<p>以上示例基于默认的<code>nginx</code>图像定制您的图像。但是也有其他的变体，在不牺牲任何功能的情况下提供更小的图像尺寸。</p>

<h2 id="choosing-nginx-variants">选择NGINX变体</h2>

<p>默认的<code>nginx</code>图像基于<a href="https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-debian.template" rel="nofollow"> Debian </a>。不过NGINX也提供基于<a href="https://github.com/nginxinc/docker-nginx/blob/master/Dockerfile-alpine.template" rel="nofollow">阿尔卑斯</a>的图片。</p>

<p>Alpine经常被用作Docker图像的轻量级基础。要查看Docker图像的大小，必须首先将它们下载到您的本地工作站:</p>

<pre><code class="language-bash">docker pull nginx
docker pull nginx:stable-alpine
</code></pre>

<p>然后，您可以使用以下命令查找图像大小:</p>

<pre><code class="language-bash">docker image ls
</code></pre>

<p>从这里你可以看到Debian图像重约140 MB，而Alpine图像重约24 MB。这大大节省了图像尺寸。</p>

<p>为了让您的图像基于Alpine变体，您需要更新<code>Dockerfile</code>:</p>

<pre><code class="language-Dockerfile">FROM nginx:stable-alpine
COPY index.html /usr/share/nginx/html/index.html
COPY health-check.conf /etc/nginx/conf.d/health-check.conf
</code></pre>

<p>使用以下命令构建并运行映像:</p>

<pre><code class="language-bash">docker build . -t mynginx
docker run -p 8080:80 -p 9090:90 mynginx
</code></pre>

<p>再次打开<code>http://localhost:9090/nginx-health</code>或<code>http://localhost:8080/index.html</code>查看网页。一切都像以前一样继续工作，但是您的自定义映像现在要小得多。</p>

<h2 id="conclusion">结论</h2>

<p>NGINX是一个强大的web服务器，官方的NGINX Docker映像允许DevOps团队在Docker中托管定制的web应用程序。NGINX还支持高级场景，因为它能够读取复制到自定义Docker映像中的配置文件。</p>

<p>在本文中，您了解了如何创建托管静态web应用程序的自定义Docker映像，添加了高级NGINX配置文件来提供健康检查端点，并比较了Debian和Alpine NGINX映像的大小。</p>

<p>了解如何使用其他流行的容器图像:</p>



<h2 id="resources">资源</h2>



<h2 id="learn-more">了解更多信息</h2>

<p>如果您想在AWS平台(如EKS和ECS)上构建和部署容器化的应用程序，请尝试使用<a href="https://octopusworkflowbuilder.octopus.com/#/" rel="nofollow"> Octopus Workflow Builder </a>。构建器使用GitHub Actions工作流构建的示例应用程序填充GitHub存储库，并使用示例部署项目配置托管的Octopus实例，这些项目展示了最佳实践，如漏洞扫描和基础架构代码(IaC)。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>