<html>
<head>
<title>Running unit tests in GitHub Actions - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在GitHub Actions - Octopus Deploy中运行单元测试</h1>
<blockquote>原文：<a href="https://octopus.com/blog/githubactions-running-unit-tests#2023-02-23">https://octopus.com/blog/githubactions-running-unit-tests#2023-02-23</a></blockquote>
                        <p>在典型的开发工作流中，用单元测试验证代码变更是一个关键的过程。GitHub Actions提供了许多自定义操作来收集和处理测试结果，允许开发人员浏览结果、调试失败的测试并生成报告。</p>

<p>在这篇文章中，我将向您展示如何将单元测试添加到GitHub Actions工作流中，并配置自定义操作来处理结果。</p>

<h2 id="getting-started">入门指南</h2>

<p>GitHub Actions是一个托管服务，所以你需要的只是一个GitHub帐户。所有其他依赖项，如软件开发工具包(SDK)，都是在GitHub Actions工作流执行期间安装的。</p>

<h2 id="selecting-an-action">选择操作</h2>

<p>GitHub Actions非常依赖社区贡献的第三方行动。快速的Google搜索显示了至少六个处理单元测试结果的操作，包括:</p>



<p>要缩小选择范围，您需要考虑以下功能:</p>

<ul>
<li>行动支持你的测试框架吗？例如，有些动作只处理JUnit测试结果，而其他动作则包括其他格式，如TRX。</li>
<li>该操作是否允许您基于失败测试的存在使工作流失败？</li>
<li>该操作是否用测试结果的细节注释了源代码？</li>
<li>该行动是否会生成有用的报告？</li>
<li>项目有几个明星？</li>
</ul>

<p>经过一些反复试验，我决定采用<a href="https://github.com/marketplace/actions/test-reporter" rel="nofollow">测试报告者</a>动作，这将在本文中演示。</p>

<h2 id="unit-testing-in-java">Java中的单元测试</h2>

<p>下面显示的工作流文件使用Maven运行测试，并使用test-reporter操作处理结果:</p>

<pre><code class="language-yaml">name: Java

on:
  push:
  workflow_dispatch:

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v1

      - name: Set up JDK 1.11
        uses: actions/setup-java@v2
        with:
          java-version: '11'
          distribution: 'adopt'

      - name: Build
        run: mvn --batch-mode -DskipTests package

      - name: Test
        run: mvn --batch-mode -Dmaven.test.failure.ignore=true test

      - name: Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Maven Tests
          path: target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: true
</code></pre>

<p><code>Build</code>、<code>Test</code>和<code>Report</code>步骤对测试过程很重要。</p>

<p>您从构建应用程序开始，但是跳过测试:</p>

<pre><code class="language-yaml">      - name: Build
        run: mvn --batch-mode -DskipTests package
</code></pre>

<p>接下来，您运行测试，即使有失败的测试，也允许命令通过。这允许您将对失败测试的响应推迟到测试处理操作:</p>

<pre><code class="language-yaml">      - name: Test
        run: mvn --batch-mode -Dmaven.test.failure.ignore=true test
</code></pre>

<p>在最后一步中，您将从JUnit XML文件生成一个报告。</p>

<p><code>if</code>属性被设置为总是运行这个步骤，即使上面的<code>Test</code>步骤被设置为在测试失败的情况下失败，也允许您生成报告。</p>

<p>如果存在失败的测试，则将<code>fail-on-error</code>属性设置为<code>true</code>以使该工作流失败。这是一个将对失败测试的响应推迟到测试处理操作的示例:</p>

<pre><code class="language-yaml">      - name: Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Maven Tests
          path: target/surefire-reports/*.xml
          reporter: java-junit
          fail-on-error: true
</code></pre>

<p>测试结果显示为原始工作流结果下的链接:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-unit-tests/java-test-results.png" class="zoom" data-title=""><img src="../Images/c4a820eb271156bc80686ff7c8bda8a4.png" class="img-fluid center" alt="Java Tests Results" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-unit-tests/java-test-results.png"/>T2】</a></p>

<p>失败的测试显示其他详细信息，如测试名称、测试结果和原始测试输出:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-unit-tests/failing-test.png" class="zoom" data-title=""><img src="../Images/32fa951915e91f44d2ae94b15e0c19bd.png" class="img-fluid center" alt="Failed test" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-unit-tests/failing-test.png"/>T2】</a></p>

<h2 id="unit-testing-in-dotnet">DotNET中的单元测试</h2>

<p>下面显示的工作流文件使用DotNET Core CLI运行测试，并使用test-reporter操作处理结果:</p>

<pre><code class="language-yaml">name: .NET Core

on:
  push:
  workflow_dispatch:

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - name: Checkout  
      uses: actions/checkout@v1

    - name: Setup .NET Core
      uses: actions/setup-dotnet@v1
      with:
        dotnet-version: 3.1.402

    - name: Build
      run: dotnet build --configuration Release

    - name: Test
      run: dotnet test --logger "trx;LogFileName=test-results.trx" || true

    - name: Test Report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: DotNET Tests
        path: "**/test-results.trx"                            
        reporter: dotnet-trx
        fail-on-error: true
</code></pre>

<p>测试由DotNET核心CLI执行，并将结果保存为Visual Studio测试结果(TRX)报告文件。</p>

<p>如果任何测试失败,<code>test</code>命令会返回一个非零的退出代码，但是您将响应失败测试的责任委托给了测试处理器。通过将<code>|| true</code>链接到命令，您可以确保该步骤总是通过:</p>

<pre><code class="language-yaml">    - name: Test
      run: dotnet test --logger "trx;LogFileName=test-results.trx" || true
</code></pre>

<p>然后，测试报告器动作处理报告文件，如果有任何失败的测试，将<code>fail-on-error</code>设置为<code>true</code>以使构建失败:</p>

<pre><code class="language-yaml">    - name: Test Report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: DotNET Tests
        path: "**/test-results.trx"                            
        reporter: dotnet-trx
        fail-on-error: true
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-unit-tests/dotnet-test-results.png" class="zoom" data-title=""><img src="../Images/88412c1963f2ebc235199c18b34c0b8e.png" class="img-fluid center" alt="DotNET Core Test Results" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-unit-tests/dotnet-test-results.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>GitHub Actions主要是一个任务执行环境，旨在验证和构建代码，并发布结果工件。有许多第三方动作可以让你生成测试报告并对失败的测试做出响应，但是GitHub动作在跟踪测试结果方面有一些不足。尽管如此，今天可用的报告功能是有用的，而且只会改进。</p>

<p>在这篇文章中，你学到了:</p>

<ul>
<li>评估第三方处理测试结果的行动时要问的一些问题</li>
<li>如何编写测试Java和DotNET核心应用程序的基本工作流</li>
<li>如何处理测试结果并显示生成的报告</li>
</ul>

<p>查看我们下一篇关于在GitHub Actions中测试的文章:</p>



<p>还可以了解一下为什么<a href="https://octopus.com/github"> GitHub和Octopus在一起更好</a>。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>