<html>
<head>
<title>Octopus Workers - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>八达通工人-八达通部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octopus-workers#2021-08-12">https://octopus.com/blog/octopus-workers#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/blogimage-workers2.png" class="zoom" data-title=""><img src="../Images/843cd478482bf923af1a127dc678889e.png" class="img-fluid center" alt="Octopus Workers illustration" data-original-src="https://i.octopus.com/blog/2018-07/blogimage-workers2.png"/>T2】</a></p>

<p>我们即将发布一个伟大的新功能，给你各种新的力量来建立你的八达通基础设施。在2018.7.0中，我们将引入工人。</p>

<p>在这篇文章中，我会给你一个预发布的预览，告诉你Workers是什么和为什么，并向你展示如何使用Workers将步骤从Octopus服务器上移走。</p>

<p>未来的帖子将给出更多的示例，通过Workers和使用Workers进行云部署来扩展您的Octopus基础设施。</p>

<p>Workers为您提供了一些很好的方法来设置您的部署并将工作从您的Octopus服务器上移走，因此它非常值得仔细阅读，但我们也设计了它<a href="#what-wait-no.i-dont-need-workers-change-it-back">,因此如果您不想使用它，您甚至不需要知道它在那里</a>。</p>

<h2 id="what-are-these-workers-anyway">这些工人到底是什么？</h2>

<p>从3.0版本开始，Octopus就有了一个工人。我们一开始并没有把它叫做工人，你可能甚至不知道它的存在就用上了。它被称为内置工人，它与章鱼服务器捆绑在一起。</p>

<p>Azure、AWS和Terraform步骤都需要在某个地方运行，因此，开箱即用就是Octopus服务器上的内置工作器。Octopus中的步骤由我们的开源、基于约定的部署可执行文件<a href="https://github.com/OctopusDeploy/Calamari" rel="nofollow"> Calamari </a>执行。通常，Calamari运行在部署目标上，但是在Azure、AWS和Terraform步骤中，Octopus服务器使用内置的Worker在本地调用Calamari。</p>

<p>脚本步骤透露了Octopus可以在本地调用Calamari。在图中的脚本步骤中，你可以看到在Octopus服务器上运行的选项；是内在的工人使这成为可能。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-run-on-server.png" class="zoom" data-title=""><img src="../Images/1507b003991889402a6398d8e4c8150d.png" class="img-fluid center" alt="Script Step run-on-server" data-original-src="https://i.octopus.com/blog/2018-07/workers-run-on-server.png"/>T2】</a></p>

<p>Worker所做的就是利用内置的Worker，在服务器可以本地执行Calamari的地方获取这些点，并让您选择在其他地方的Worker上执行它们。</p>

<h3 id="what-a-worker-is-and-isnt">什么是工人，什么不是</h3>

<p>工作人员不会取代Octopus服务器来协调部署；它只是执行服务器指示的步骤。脚本、Azure、AWS或Terraform步骤的执行方式没有任何变化；工人只是提供一个关于在哪里执行这些步骤的选项。</p>

<p>Octopus服务器协调整个部署过程。部署目标是部署的目的地，工作人员是可以为服务器执行某些步骤的机器，但不是部署的目标。</p>

<p>所以，worker只是可以运行script、Azure、AWS、Terraform步骤的机器，可以是监听触角、轮询触角，也可以是SSH机器(SSH Workers只能运行bash脚本)。</p>

<h2 id="when-might-you-want-to-use-a-worker">什么时候你可能需要一个工人</h2>

<p>在接下来的几篇文章中，我将充实工人派上用场(或必不可少)的三个案例的细节。</p>

<ol>
<li><a href="#Stopping-steps-running-on-the-Octopus-Server">移动八爪鱼服务器的步骤——安全</a></li>
<li><a href="https://octopus.com/blog/octopus-workers">扩大规模的工人-绩效</a></li>
<li>设置云工人-云(在下面的帖子中)</li>
</ol>

<p>当然，也有其他使用工人的方法。</p>

<p>但是，在我们进入示例之前，让我们看看整个Workers设置是如何工作的。</p>

<h2 id="how-workers-works">工人<em>如何工作</em></h2>

<h3 id="workers">工人</h3>

<p>工人是监听触角，轮询触角或者SSH机器。设置与触手或SSH部署目标相同。工人甚至使用相同的触手和卡拉马里二进制文件作为部署目标。</p>

<p>例如，这里我使用触手管理器来<a href="https://octopus.com/docs/infrastructure/windows-targets">设置触手</a>，但是您也可以<a href="https://octopus.com/docs/infrastructure/windows-targets/automating-tentacle-installation">编写设置</a>的脚本，甚至从命令行执行完整的<a href="https://octopus.com/docs/octopus-rest-api/tentacle.exe-command-line/register-with">工作注册</a>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-tentacle-setup.png" class="zoom" data-title=""><img src="../Images/2dd29d510aab0913581cffe5e744b473.png" class="img-fluid center" alt="Tentacle Manager" data-original-src="https://i.octopus.com/blog/2018-07/workers-tentacle-setup.png"/>T2】</a></p>

<p>一旦我设置了触手，我就导航到<em>基础设施</em>中的新<em>工人</em>选项卡，并选择“添加工人”。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-infrastructure.png" class="zoom" data-title=""><img src="../Images/c734f84b1918ade1b9294f06edd1866b.png" class="img-fluid center" alt="Workers Infrastructure Page" data-original-src="https://i.octopus.com/blog/2018-07/workers-infrastructure.png"/>T2】</a></p>

<p>在输入我配置的触手的主机和端口之后，我给这个工作者一个名字，选择一个机器策略，并把这个工作者放在一个工作者池中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-set-worker-pool.png" class="zoom" data-title=""><img src="../Images/c0ddfa7e1a6faab4fe1e55d43244cbca.png" class="img-fluid center" alt="Worker Details" data-original-src="https://i.octopus.com/blog/2018-07/workers-set-worker-pool.png"/></a>T2】</p>

<h3 id="worker-pools">工人池</h3>

<p>工人被分组到工人池中。从Octopus服务器的角度来看，一个池中的所有工作人员都是等效的。池可能代表机器设置，以帮助特定类型的部署，或者安装特定的工具集，或者您可能会为您正在进行的特定团队或项目分配池(当我们的空间特性出现时，这将很快工作)。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-pools.png" class="zoom" data-title=""><img src="../Images/64ecb24aa6e838f34dc900c84d18265a.png" class="img-fluid center" alt="Worker Pools" data-original-src="https://i.octopus.com/blog/2018-07/workers-pools.png"/>T2】</a></p>

<h3 id="running-steps-on-workers">工人的跑步步骤</h3>

<p>步骤——well、script、Azure、AWS或Terraform步骤——现在可以针对一个工人池，并将在该池中的工人上执行。如果没有指定任何其他内容，那么总是有一个默认池被假定为步骤的目标。您可以自由更改哪个池是默认池。不出所料，最初它是作为一个名为“默认工人池”的池开始的。</p>

<p>Octopus只有两种选择来选择一个工人来执行一个步骤。</p>

<ol>
<li>如果步骤解析到默认池，并且默认池中没有工作线程，Octopus将选择内置工作线程。</li>
<li>在所有其他情况下，Octopus从给定的池中挑选任何健康的工人。</li>
</ol>

<p>差不多就是这样。您设置工作人员(就像设置部署目标一样简单)，将工作人员分组到池中(就像将部署目标放入环境中一样简单)，然后您将一个步骤指向一个池，Octopus就会分发您的部署流程的工作。</p>

<h2 id="what-wait-no.i-dont-need-workers-change-it-back">什么，等等，不。我不需要工人，把它改回来...</h2>

<p>我们仔细研究了使用工人的<em>而不是</em>的用例以及过渡到工人的用例。我们认为这两个问题都得到了圆满的答案。</p>

<p><strong>如果你不想用工人，那么真的很简单——忽略它</strong>就好。如果您是现有的Octopus用户，您的步骤不会改变，您的任何部署流程都不会改变，您的Octopus体验不会改变，甚至您的部署日志也不会改变。</p>

<p>以上第(1)点说明了一切。任何需要Worker的步骤都将解析(因为您的步骤不会有任何不同)到默认的Worker池，并且最终会在内置的Worker中结束，这与Octopus用户从3.0版本开始的体验相同。</p>

<h2 id="stopping-steps-running-on-the-octopus-server">停止在Octopus服务器上运行的步骤</h2>

<p>我们也有一个很好的故事，从章鱼服务器上运行步骤的过渡。没有需要更新的部署流程。只需一点点设置，Octopus就会将步骤从服务器转移到工人身上。</p>

<p>我们都喜欢我们的开发团队(至少像我这样的开发人员希望你喜欢)，但是如果他们不能在你的Octopus服务器上执行代码，也许你会更喜欢这样。</p>

<p>好吧，你现有的所有Azure、AWS和Terraform步骤(以及任何针对服务器的脚本步骤)都不会提到Worker池，所以最终使用默认池，它是空的，因此这些步骤运行在内置的Worker上。但是，如果您在默认池中删除了一个Worker，那么规则(2)适用，并且该步骤在该Worker上运行，而不是在内置Worker上运行。</p>

<p>让我们来看看实际情况。我从一个没有工作线程(当然，除了内置工作线程)和工作线程池(除了默认池)的Octopus服务器设置开始。我用一个针对服务器的脚本创建了一个简单的项目。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-script-step.png" class="zoom" data-title=""><img src="../Images/e5e3c31d1e4f8606a6367b6c305e7ba2.png" class="img-fluid center" alt="Script Step" data-original-src="https://i.octopus.com/blog/2018-07/workers-script-step.png"/>T2】</a></p>

<p>部署项目后，日志清楚地指出脚本运行在Octopus服务器上。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-ran-on-server.png" class="zoom" data-title=""><img src="../Images/741bf001856a4df549defdf810752d42.png" class="img-fluid center" alt="Script ran on Octopus Server" data-original-src="https://i.octopus.com/blog/2018-07/workers-ran-on-server.png"/>T2】</a></p>

<p>然后，正如上面所描述的<a href="#workers">，我提供了一个触手，并将其注册为默认工作池中的一个工作线程。</a></p>

<p>在部署同一个项目的0.0.2版本(未更改)时，日志让我知道它现在运行在Worker上，而不是服务器上。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-07/workers-ran-on-worker.png" class="zoom" data-title=""><img src="../Images/a03b39c1e3e0ad0d1e1edbc2835e0179.png" class="img-fluid center" alt="Script ran on a Worker" data-original-src="https://i.octopus.com/blog/2018-07/workers-ran-on-worker.png"/>T2】</a></p>

<p>这就够了。仅仅一根触手就足以阻止用户代码在Octopus服务器上执行。</p>

<p>当然，也可以提供多个工作人员来分担服务器分配的工作。我将在下一篇文章中谈到这一点。</p>

<p>也可以关闭内置的Worker，这意味着它永远不会被调用，即使默认池碰巧是空的。选中{配置-&gt;功能}中的选项。</p>

<p>相同的并发规则一如既往地适用。服务器仍然尊重您的并行步骤和<code>Octopus.Action.MaxParallelism</code>，因此多个并发步骤可以在Worker上运行，甚至可以在同一个Worker上运行，就像内置Worker并发运行许多步骤一样。</p>

<h2 id="coming-soon">即将推出</h2>

<p>工人即将在Octopus 2018.7.0中发布，所以请关注我们的发布。</p>

<p>在博客上，我会发布更多关于工人的文章。接下来，我将考虑使用Workers来减少Octopus服务器上的负载。在那之后，我将看一看我们如何使用Workers来为云部署提供一些好的模式。</p>

                    
                    
</body>
</html>