<html>
<head>
<title>Creating a custom Docker registry - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建自定义Docker注册表- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/custom-docker-registry#2021-07-26">https://octopus.com/blog/custom-docker-registry#2021-07-26</a></blockquote>
                        <p>你想知道当你做<code>docker push</code>或<code>docker pull</code>时会发生什么吗？在幕后，像Docker Hub这样的存储库实现了<a href="https://docs.docker.com/registry/spec/api/" rel="nofollow"> Docker V2 HTTP API </a>规范，响应这些请求来接收或交付Docker映像。不过，这个规范对任何人都是开放的，您可以从一个最小的docker注册实现中了解更多关于Docker的知识。</p>

<p>在这篇文章中，我们创建了一个成功响应<code>docker push</code>或<code>docker pull</code>命令的C#服务器。在这个过程中，您可以看到组成Docker图像的各个组件。</p>

<h2 id="docker-api-for-pushing-and-pulling-images">用于推和拉图像的Docker API</h2>

<p>这些是我们的应用程序必须实现以支持推和拉图像的路径:</p>

<ul>
<li>GET <code>/v2</code> : Docker访问这个路径来验证服务器是否支持Docker HTTP API的版本2。</li>
<li>HEAD <code>{name}/blobs/{digest}</code>:该路径用于判断服务器上是否存在该图层。</li>
<li>GET <code>{name}/blobs/{digest}</code>:一旦客户端确定该层存在于服务器上，该路径返回该层。</li>
<li>POST <code>{name}/blobs/uploads</code>:这个路径被调用来启动层上传。</li>
<li>PATCH <code>{name}/blobs/uploads/{uuid}</code>:该路径接收分块层上传。</li>
<li>PUT <code>{name}/blobs/uploads/{uuid}</code>:一旦分块层上传完成，就调用这个路径。</li>
<li>HEAD <code>{name}/manifests/{reference}</code>:调用这个路径来确定服务器上是否存在清单。</li>
<li>GET <code>{name}/manifests/{reference}</code>:这个路径返回一个层，一旦客户端确定它存在于服务器上。</li>
<li>PUT <code>{name}/manifests/{reference}</code>:这个路径在服务器上创建一个清单。</li>
</ul>

<h2 id="pushing-an-image">推送图像</h2>

<p>推送Docker图像的流程是:</p>

<ol>
<li>联系<code>/v2</code>以确认服务器支持正确的API。</li>
<li>对<code>{name}/blobs/{digest}</code>进行头部查询，其中<code>name</code>是类似<code>alpine</code>的图像名称，<code>digest</code>是图层的哈希。</li>
<li>如果该层不存在，执行提交到<code>{name}/blobs/uploads</code>。来自该路径的响应包括格式为<code>{name}/blobs/uploads/{uuid}</code>的<code>Location</code>报头，在此执行层上传。</li>
<li>然后上传该层，可能会上传与对<code>{name}/blobs/uploads/{uuid}</code>的补丁请求一样多的小块。被发送的数据在<code>Range</code>头中被捕获，服务器被期望用每个传入的块增量地填充层文件。</li>
<li>当上传一个层时，对<code>{name}/blobs/uploads/{uuid}</code>进行一个PUT调用。这个请求包括一个名为<code>digest</code>的查询参数，它的值是已经完成的层的散列。</li>
<li>一旦层被上传，在<code>{name}/manifests/{reference}</code>上的头部查询确定清单是否已经存在于服务器上。</li>
<li>如果清单不存在，那么对<code>{name}/manifests/{reference}</code>的PUT请求会创建它。</li>
</ol>

<h2 id="pulling-an-image">提取图像</h2>

<p>拉图像比推图像容易:</p>

<ol>
<li>联系<code>/v2</code>确认服务器支持正确的API。</li>
<li>在<code>{name}/manifests/{reference}</code>上执行头部查询，以确定清单是否存在。</li>
<li>如果清单存在，用对<code>{name}/manifests/{reference}</code>的GET请求检索它。</li>
<li>对于清单中列出的每个映像，在<code>{name}/blobs/{digest}</code>上执行头部查询以验证它是否存在。</li>
<li>然后通过对<code>{name}/blobs/{digest}</code>的GET请求下载图像。</li>
</ol>

<h2 id="the-sample-application">示例应用程序</h2>

<p>我们的示例应用程序并不漂亮，您不能用它来承载生产工作负载。但它的功能足以允许推拉图像。这为深入了解Docker图像的幕后情况提供了一个很好的视角。</p>

<p>这里描述的源代码可以从<a href="https://github.com/OctopusSamples/DotNetCoreDockerRegistry" rel="nofollow"> GitHub </a>获得。</p>

<p>从一个将其所有方法都放在<code>v2</code>根路径下的控制器开始。这个根路径是Docker规范中的一个硬性要求。一些混合工件存储库在其自己的端口上公开一个Docker注册表，以确保这个根路径不会与其他API冲突:</p>

<pre><code class="language-csharp">namespace Controllers
{
    [Route("v2/")]
    public class DockerRegistry : ControllerBase
    {
</code></pre>

<p>每次启动应用程序时，创建一个新的临时目录来保存Docker图像和层。这对于测试来说非常好，因为你可以重启应用程序并拥有一个空的注册表:</p>

<pre><code class="language-csharp">        private static readonly string LayerPath;

        static DockerRegistry()
        {
            LayerPath = GetTemporaryDirectory();
            Console.Out.WriteLine($"Saving artifacts to {LayerPath}");
        }

        static string GetTemporaryDirectory()
        {
            var tempFolder = Path.GetTempFileName();
            System.IO.File.Delete(tempFolder);
            Directory.CreateDirectory(tempFolder);

            return tempFolder;
        }
</code></pre>

<p>这个处理程序响应<code>/v2</code>根路径上的GET请求。您返回一个HTTP 200 OK响应，让客户端知道您支持V2 API:</p>

<pre><code class="language-csharp">        [HttpGet]
        public IActionResult Root(string path)
        {
            return Ok();
        }
</code></pre>

<p>接下来，构建处理程序以允许图像被推送到服务器。您需要响应HEAD请求，检查服务器上是否已经存在图像。<code>name</code>参数是图像名称(如<code>alpine</code>),而<code>digest</code>参数是标识层的散列，如<code>sha256:11ad9c3e3069bdb53ff873af66070ca6c4309e85581cf3befe05459f889fd729</code>。</p>

<p>在这里采取一个小捷径，将图层保存为SHA哈希，减去<code>sha256:</code>前缀。如果文件存在，返回200 OK，用<code>content-length</code>头表示图像的大小。如果图层不存在，返回404未找到:</p>

<pre><code class="language-csharp">        [HttpHead("{name}/blobs/{digest}")]
        public IActionResult Exists(string name, string digest)
        {
            var hash = digest.Split(":").Last();

            if (System.IO.File.Exists(LayerPath + "/" + hash))
            {
                Response.Headers.Add("content-length", new FileInfo(LayerPath + "/" + hash).Length.ToString());
                Response.Headers.Add("docker-content-digest", digest);
                return Ok();
            }

            return NotFound();
        }
</code></pre>

<p>如果该层不存在，客户端将使用这个POST请求启动上传。响应包括一个带有唯一URL的<code>location</code>头，实际图层数据将发送到该头:</p>

<pre><code class="language-csharp">        [HttpPost("{name}/blobs/uploads")]
        public IActionResult StartUpload(string name)
        {
            var guid = Guid.NewGuid().ToString();
            Response.Headers.Add("location", "/v2/" + name + "/blobs/uploads/" + guid);
            Response.Headers.Add("range", "0-0");
            Response.Headers.Add("content-length", "0");
            Response.Headers.Add("docker-upload-uuid", guid);
            return Accepted();
        }
</code></pre>

<p>Docker支持<a href="https://docs.docker.com/registry/spec/api/#monolithic-upload" rel="nofollow">整体</a>和<a href="https://docs.docker.com/registry/spec/api/#chunked-upload" rel="nofollow">分块</a>上传。该处理程序支持分块上传方法(示例应用程序不支持整体上传)。</p>

<p>客户端可能会也可能不会提供一个指示正在上传的块的<code>content-range</code>头。通常整个层作为单个块上传，并且不提供<code>content-range</code>头。</p>

<p>在这个方法中，您将请求的主体保存到一个文件中，该文件带有在<code>StartUpload</code>方法中生成的随机GUID:</p>

<pre><code class="language-csharp">        [DisableRequestSizeLimit] 
        [HttpPatch("{name}/blobs/uploads/{uuid}")]
        public async Task&lt;IActionResult&gt; Upload(string name, string uuid)
        {
            var start = Request.Headers["content-range"].FirstOrDefault()?.Split("-")[0] ?? "0";
            await using (var fs = System.IO.File.OpenWrite(LayerPath + "/" + uuid))
            {
                fs.Seek(long.Parse(start), SeekOrigin.Begin);
                await Request.Body.CopyToAsync(fs);

                Response.Headers["range"] = "0-" + (fs.Position - 1);
            }

            Response.Headers["docker-upload-uuid"] = uuid;
            Response.Headers["location"] = $"/v2/{name}/blobs/uploads/{uuid}";
            Response.Headers["content-length"] = "0";
            Response.Headers["docker-distribution-api-version"] = "registry/2.0";
            return Accepted();
        }
</code></pre>

<p>上传图层后，将调用此方法来表示上传完成。<a href="https://docs.docker.com/registry/spec/api/#completed-upload" rel="nofollow">规范提到，这个方法可能会被调用，最终的内容块将被保存到层</a>，因此您需要将PUT主体中的任何内容追加到层文件中。</p>

<p>现在使用来自<code>digest</code>查询参数的散列将文件从临时GUID重命名为散列:</p>

<pre><code class="language-csharp">        [HttpPut("{name}/blobs/uploads/{uuid}")]
        public async Task&lt;IActionResult&gt; FinishUpload(string name, string uuid)
        {
            if (Request.Headers["content-length"].First() != "0")
            {
                var ranges = Request.Headers["content-range"].First().Split("-");
                await using var fs = System.IO.File.OpenWrite(LayerPath + "/" + uuid);
                fs.Seek(long.Parse(ranges[0]), SeekOrigin.Begin);
                await Request.Body.CopyToAsync(fs);
            }

            var rawDigest = Request.Query["digest"];
            var digest = Request.Query["digest"].First().Split(":").Last();
            System.IO.File.Move(LayerPath + "/" + uuid, LayerPath + "/" + digest);
            Response.Headers.Add("content-length", "0");
            Response.Headers.Add("docker-content-digest", rawDigest);

            return Created("/v2/" + name + "/blobs/" + digest, "");
        }
</code></pre>

<p>在层被上传之后，清单(你可以认为是Docker图像)被创建。首先，客户端发出HEAD请求，查看清单是否存在。</p>

<p>奇怪的是，<code>reference</code>可能是一个标签名，比如<code>latest</code>，也可能是一个散列。为方便起见，将清单保存在两个位置:</p>

<ul>
<li>一个基于标签名</li>
<li>一个基于散列</li>
</ul>

<p>这效率不高，但对于您的示例应用程序来说，这是一个简单的解决方案:</p>

<pre><code class="language-csharp">        [HttpHead("{name}/manifests/{reference}")]
        public IActionResult ManifestExists(string name, string reference)
        {
            var hash = reference.Split(":").Last();
            var path = LayerPath + "/" + name + "." + reference + ".json";
            var hashPath = LayerPath + "/" + hash + ".json";
            var testedPath = System.IO.File.Exists(path) ? path :
                System.IO.File.Exists(hashPath) ? hashPath :
                null;

            if (testedPath != null)
            {
                Response.Headers.Add("docker-content-digest", "sha256:" + Sha256Hash(path));
                Response.Headers.Add("content-length", new FileInfo(path).Length.ToString());

                var content = System.IO.File.ReadAllText(path);
                var mediaType = JObject.Parse(content)["mediaType"].ToString();

                Response.Headers.Add("content-type", mediaType);

                return Ok();
            }

            return NotFound();
        }
</code></pre>

<p>如果清单不存在，用对该方法的PUT请求保存它。再次注意，您必须将清单保存在两个地方:</p>

<ul>
<li>一个文件名中带有标签</li>
<li>另一个在文件名中包含哈希:</li>
</ul>

<pre><code class="language-csharp">        [HttpPut("{name}/manifests/{reference}")]
        public async Task&lt;IActionResult&gt; SaveManifest(string name, string reference)
        {
            var path = LayerPath + "/" + name + "." + reference + ".json";

            await using (var fs = System.IO.File.OpenWrite(path))
            {
                await Request.Body.CopyToAsync(fs);
            }

            var hash = Sha256Hash(path);
            Response.Headers.Add("docker-content-digest", "sha256:" + hash);

            System.IO.File.Copy(path, LayerPath + "/" + hash + ".json", true);

            return Created($"/v2/{name}/manifests/{reference}", null);
        }
</code></pre>

<p>这些端点允许你完成一个<code>docker push</code>命令。</p>

<p>提取图像需要另外两种方法。</p>

<p>第一个使用GET请求将图层数据返回给以下方法:</p>

<pre><code class="language-csharp">        [HttpGet("{name}/blobs/{digest}")]
        public async Task&lt;IActionResult&gt; GetLayer(string name, string digest)
        {
            var hash = digest.Split(":").Last();
            var path = LayerPath + "/" + hash;

            if (System.IO.File.Exists(LayerPath + "/" + hash))
            {
                Response.Headers.Add("content-length", new FileInfo(path).Length.ToString());
                await using (var fs = new FileStream(path, FileMode.Open))
                {
                    await fs.CopyToAsync(Response.Body);
                    return Ok();
                }
            }

            return NotFound();
        }
</code></pre>

<p>清单数据随对以下方法的GET请求一起返回。就像HEAD请求一样，您需要基于标记名或散列码搜索清单文件，因为<code>reference</code>可能是这两个值中的任何一个。</p>

<p>注意，这里您加载了清单文件，将其解析为JSON，并提取了<code>mediaType</code>属性。这作为<code>content-type</code>头发送回客户端:</p>

<pre><code class="language-csharp">        [HttpGet("{name}/manifests/{reference}")]
        public async Task&lt;IActionResult&gt; GetManifest(string name, string reference)
        {
            var hash = reference.Split(":").Last();
            var path = LayerPath + "/" + name + "." + reference + ".json";
            var hashPath = LayerPath + "/" + hash + ".json";
            var testedPath = System.IO.File.Exists(path) ? path :
                System.IO.File.Exists(hashPath) ? hashPath :
                null;

            if (testedPath != null)
            {
                Response.Headers.Add("docker-content-digest", "sha256:" + Sha256Hash(testedPath));

                var content = System.IO.File.ReadAllText(testedPath);
                var mediaType = JObject.Parse(content)["mediaType"].ToString();

                Response.Headers.Add("content-type", mediaType);
                Response.Headers.Add("content-length", new FileInfo(testedPath).Length.ToString());

                await using (var fs = new FileStream(testedPath, FileMode.Open))
                {
                    await fs.CopyToAsync(Response.Body);
                }

                return Ok();
            }

            return NotFound();
        }
</code></pre>

<p>这样，您就拥有了支持拉取图像所需的所有端点。</p>

<h2 id="testing-the-server">测试服务器</h2>

<p>web应用程序已通过<code>launchSettings.json</code>文件配置为监听所有IP地址。下面是显示<code>applicationUrl</code>设置的精简文件，它被配置为监听<code>0.0.0.0</code>，这意味着应用程序响应所有IP地址上的请求。</p>

<p>我在测试中发现这是必要的，因为推送至<code>localhost</code>在基于Windows的机器上不起作用，所以我不得不推送至机器的本地IP地址:</p>

<pre><code>{
...

  "profiles": {

    ...

    "dockerregistry": {
      "applicationUrl": "https://0.0.0.0:5002;http://0.0.0.0:5001",
    }
  }
}
</code></pre>

<p>默认情况下，Docker试图通过HTTPS联系所有外部存储库。web应用程序有一个自签名证书，所以为了测试，您希望Docker使用HTTP。</p>

<p>我的笔记本电脑的IP地址是10.1.1.37。要指示Docker通过您的IP访问注册表，您需要编辑Docker配置文件中的<code>insecure-registries</code>数组:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-07/custom-docker-registry/docker-config.png" class="zoom" data-title=""><img src="../Images/9034cf0d73a8ea8d36755dbb53ff04ca.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-07/custom-docker-registry/docker-config.png"/>T2】</a></p>

<p>使用以下内容运行应用程序:</p>

<pre><code class="language-powershell">dotnet run
</code></pre>

<p>存放工件的临时目录显示在控制台中:</p>

<pre><code class="language-powershell">$ dotnet run
Building...
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: https://0.0.0.0:5002
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: http://0.0.0.0:5001
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Development
info: Microsoft.Hosting.Lifetime[0]
      Content root path: C:\Users\Matthew\Octopus\dockerregistry
Saving artifacts to C:\Users\Matthew\AppData\Local\Temp\tmp5E8E.tmp
</code></pre>

<p>下载Docker映像并根据本地存储库重新标记它:</p>

<pre><code class="language-powershell">$ docker pull alpine
$ docker tag alpine 10.1.1.37:5001/alpine
</code></pre>

<p>然后将映像推送到本地服务器:</p>

<pre><code class="language-powershell">$ docker push 10.1.1.37:5001/alpine
</code></pre>

<p>在临时目录中创建了四个文件:两个图像层，以及与标签和散列一起保存的清单:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-07/custom-docker-registry/files.png" class="zoom" data-title=""><img src="../Images/3f3583a25a74e17716d24598337e5f1b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-07/custom-docker-registry/files.png"/>T2】</a></p>

<p>现在从你的本地电脑上删除图像。这可以确保此图像的任何下载都不能重复使用您以前缓存的图像:</p>

<pre><code>$ docker image rm 10.1.1.37:5001/alpine
$ docker image rm alpine
</code></pre>

<p>使用以下命令从您的服务器下载映像:</p>

<pre><code>$ docker pull 10.1.1.37:5001/alpine
</code></pre>

<p>现在，您已经从最小Docker存储库中推送和提取了图像。仍然缺少一些功能，比如删除图像和搜索，但是我们将把实现留在这里。</p>

<h2 id="conclusion">结论</h2>

<p>Docker是许多开发工作流的核心，但有趣的是，关于如何实现Docker API的信息并不多。<a href="https://docs.docker.com/registry/spec/api/#monolithic-upload" rel="nofollow">官方文档</a>有点密集(正如规范通常的那样)，所以在这篇文章中，我们看了一个非常简单的实现，它允许使用常规的Docker客户端来推和拉Docker图像。</p>

<p>希望这能揭开围绕Docker图像传输的一些过程，如果您希望将自己的应用程序与Docker客户机集成，这是一个有用的起点。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>