<html>
<head>
<title>Octopus Deploy 3.2 - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>八达通部署3.2 -八达通部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octopus-deploy-3.2#2015-11-05">https://octopus.com/blog/octopus-deploy-3.2#2015-11-05</a></blockquote>
                        <p><em> <strong> Octopus Deploy 3.2于2015年11月3日发布，在<a href="/downloads">此处</a>可用。</strong> </em></p>



<h1>特征</h1>

<p>Octopus Deploy 3.2完全是关于<a href="#channels">通道</a>的，这是我们给最初在我们的<a href="/blog/rfc-branching"> RFC分支</a>中讨论的特性起的名字。</p>

<blockquote>
  <p>构建服务器构建。章鱼展开。</p>
</blockquote>

<p>我们认为区分源代码分支、<a href="/why">哪些构建服务器关心</a>和部署是很重要的，部署是渠道的来源。</p>

<h2>频道<a name="channels"/></h2>

<p>在一个软件项目中，您可能希望对某些版本进行不同的处理，Octopus Deploy中的通道使这一点易于管理。每个渠道都有不同的生命周期、不同的变量和不同的部署流程。我们设计了一些渠道，使实施、管理和发展更复杂的部署场景变得更加容易。</p>

<p><img src="../Images/89919bcdfa6401da1025870b45e252c4.png" alt="Sample process" data-original-src="https://i.octopus.com/blog/201510-2015-10-2613_07_38-sampleprocess-ZZMG.png"/></p>

<p>虽然在Octopus Deploy中可以在没有通道的情况下模拟复杂的部署场景，但它通常涉及克隆项目，这会带来一系列复杂的问题。</p>

<p>我们认为开始使用Octopus Deploy中的通道的最佳方式是探索我们遇到的一些部署场景，以及通道如何在每个场景中提供帮助:</p>



<h3>场景1:更安全的标准发布推广<a name="safer-standard-release-promotion"/></h3>

<blockquote>
  <p>Matthew正在改进和修复他公司最新发布的旗舰产品的缺陷。他希望推动他的代码更改，并让它们自动部署到一个<strong>开发</strong>环境中，然后让他的测试团队通过一个<strong>测试</strong>环境来促进发布，最后在准备就绪时将发布部署到<strong>生产</strong>。他还想构建预发布包，但想防止这些包被意外部署到<strong>生产</strong>。</p>
</blockquote>

<p>这是一个非常典型的场景，Octopus Deploy已经支持这个场景，不需要通道，除了通过添加一个简单的版本规则，您可以防止预发布意外地部署到生产中。</p>

<p><strong>注意:</strong>版本规则将在您遵循<strong> <a href="http://semver.org">语义版本化(SemVer) </a> </strong>的版本化策略时发挥最佳作用。</p>

<p><img src="../Images/907eb418f9476d6603a40cb2eb819bea.png" alt="Prevent pre-release from being deployed to Production" data-original-src="https://i.octopus.com/blog/201510-2015-10-1914_28_22-editchannelscenario1-Z6H2.png"/></p>

<p><img src="../Images/515db2134daa98b6d42fccb55de56964.png" alt="Design Version Rule" data-original-src="https://i.octopus.com/blog/201510-non-pre-releasechannelrules-T59L.gif"/></p>

<h3>场景2:支持多个版本(不断发展的部署设计)<a name="supporting-multiple-versions"/></h3>

<blockquote>
  <p>版本1.x刚刚发布，Andrew正在着手2.x的工作。作为2.x的一部分，Andrew需要引入一个新的服务，该服务需要一些新的步骤和一些新的变量。他希望尽快开始发布预发布版本。与此同时，Stephanie正在增强和修复1.x版本的错误，并希望1.x的部署能够像以前一样正常工作。</p>
</blockquote>

<p>在这种情况下，Andrew可以创建一个名为<code>2.x Unstable</code>的新通道，并将新步骤和变量限定在该通道的范围内，以便它们只包含在2.x的部署中。他还可以配置版本规则，以便更容易、更安全地创建1.x或2.x版本，确保使用正确的包和部署步骤。</p>

<p><img src="../Images/3bbb9724d9a5f20e9b335f5820ee1e38.png" alt="Evolving Deployment Design" data-original-src="https://i.octopus.com/blog/201510-2015-10-2613_49_48-evolvingdeploymentdesign-4J86.png"/></p>

<p>由于Andrew花时间创建了<code>2.x Unstable</code>通道，Stephanie可以继续部署1.x版本，确信部署过程仍将工作，不会意外地错误包含任何2.x包。</p>

<h3>场景3:热修复部署<a name="hotfix-deployments"/></h3>

<blockquote>
  <p>Stephanie刚刚收到一个警告，由于与第三方集成的问题，1.x版本中的检验流程在<strong>生产</strong>中失败。补救措施是对<strong>订单处理器</strong>服务进行简单的代码更改，她希望毫不延迟地为<strong>生产</strong>部署紧急修补程序版本。</p>
</blockquote>

<p>谢天谢地，在这种情况下，斯蒂芬妮已经提前计划，并创建了一个使用<code>Hotfix</code>生命周期的<code>1.x Hotfix</code>频道。现在，她可以在<code>Hotfix</code>渠道创建修补程序版本，并将其直接部署到<strong>生产</strong>中，然后将该版本回填到<strong>开发</strong>和<strong>测试</strong>中。</p>

<p><img src="../Images/cf58ce647e5c8ba414507a4490b83a3d.png" alt="Hotfix Channel" data-original-src="https://i.octopus.com/blog/201510-2015-10-2613_52_34-hotfixchannel-66X6.png"/></p>

<h3>场景4:早期访问计划<a name="early-access-programs"/></h3>

<blockquote>
  <p>Andrew已经准备好开始与特定的可信测试客户群共享2.x的早期构建。他希望将特定的预发布版本部署到测试环境中，并将新的预发布版本通知给这些客户。</p>
</blockquote>

<p>在这种情况下，Andrew可以配置一个新的<code>Beta</code>环境、<code>Beta</code>生命周期和<code>2.x Beta</code>通道。现在，他可以将发布直接部署到新的<code>Beta</code>环境中，并防止它们被提升到其他环境中。他还可以配置一个新的步骤，作用于<code>Beta</code>通道，向所有早期访问的客户发送一封电子邮件，其中包含新测试版的URL。</p>

<p><img src="../Images/6a1c82a9463773cf7458bd91bfb535c9.png" alt="Beta Channel" data-original-src="https://i.octopus.com/blog/201510-2015-10-2613_54_19-betachannel-WTNH.png"/></p>

<h3>场景5:特性分支部署<a name="feature-branch-deployments"/></h3>

<blockquote>
  <p>Sarah正在为2.x版本开发一个名为多租户的新功能，她希望确保人们可以尽快测试她的工作，而不会中断1.x和2.x版本中正在进行的其他工作。</p>
</blockquote>

<p>在这种情况下，莎拉可以创建一个名为<code>2.x Feature Branch</code>的通道，该通道范围内的一些步骤将自动在公共云中提供一个环境，该环境由基于发布版本的<strong>标签</strong>部分的约定命名。她甚至可以使用脚本模板将新特性分支部署的细节发布到他们的团队聊天中。</p>

<p><img src="../Images/5f79c500d1e86089482f97e747be682c.png" alt="Feature Branch Process" data-original-src="https://i.octopus.com/blog/201510-2015-10-2613_57_09-featurebranchprocess-GPQQ.png"/></p>

<p>既然Sarah花时间创建了<code>2.x Feature Branch</code>频道:</p>

<ul>
<li>当她团队中的任何人推出一个新的特性分支时，他们会在几分钟后收到一个通知，其中包含他们刚刚配置和部署的特性的测试环境的URL</li>
<li>当任何人向现有的特性分支推送新代码时，新代码将被部署到他们特定特性的现有测试环境中</li>
<li>他们可以随时删除托管环境，并通过部署一个版本来重新配置它</li>
</ul>

<h3>演练<a name="walkthrough"/></h3>

<p>我们已经创建了实现这些场景的演练。你可以看视频或者<a href="/blog/channels-walkthrough">自己做演练</a>。</p>

<p/>

<h2>向后兼容性</h2>

<p>我们将这一特性设计成不引人注目且向后兼容的。如果这些场景都不适合您，或者您已经有了自己的管理方法，您可以假装通道不存在，并像以前一样使用Octopus Deploy。</p>

<h2>概括起来</h2>

<p>既然渠道已经完成，看看我们的<a href="/roadmap">路线图</a>看看接下来会发生什么！不要忘了看看我们关于<a href="/blog/rcf-octopus-reactions-integration-toolkit">Octopus Reactions-Integration Toolkit</a>的RFC，并参与设计Octopus Deploy的未来。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>