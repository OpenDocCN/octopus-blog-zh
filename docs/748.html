<html>
<head>
<title>Tips for building custom execution containers - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>构建定制执行容器的技巧——Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/tips-building-custom-execution-containers#2021-08-12">https://octopus.com/blog/tips-building-custom-execution-containers#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/execution-workers.png" class="zoom" data-title=""><img src="../Images/8869fbe972cf9d2e1ee0465ac91258ba.png" class="img-fluid center" alt="White octopus inside a blue cube-shaped container" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/execution-workers.png"/>T2】</a></p>

<p>执行容器是Octopus Deploy中隐藏的瑰宝。我最近完成了对它们的深入研究，以帮助一位客户。这包括创建一个定制的Docker映像，用于执行容器特性。我学到了一些提示和技巧，我想分享给你，帮助你写你的自定义图片。</p>

<h2 id="execution-container-benefits">执行容器的优势</h2>

<p>当2018年<a href="https://octopus.com/docs/infrastructure/workers"> workers </a>发布时，我对从Octopus服务器卸载部署任务的能力感到兴奋。我开始创建工人池。我在配置工作人员时遇到的一个问题是需要预安装软件。在某些情况下，某些软件(如Terraform)版本之间不兼容。并排运行在技术上是可能的，但它可能会导致问题，而且我无法在不修复一堆部署的情况下升级到最新版本。</p>

<p>我最终得到了这样的工人池:</p>

<ul>
<li>Terraform 11工人池</li>
<li>Terraform 12工人池</li>
<li>等等。</li>
</ul>

<p>执行容器解决了这个问题。我可以用我需要预装的软件创建Docker映像。现在，在我的部署过程中，我指定下载并运行一个Docker映像。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/specify-custom-execution-container-version.png" class="zoom" data-title=""><img src="../Images/9204cdd45051b18d95cfd7e4e96b1cd9.png" class="img-fluid center" alt="specify custom Docker image in deployment process" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/specify-custom-execution-container-version.png"/>T2】</a></p>

<p>版本是部署过程的一部分。将我的部署过程升级到最新的工具需要更改分配给Docker映像的版本号和运行该过程的任何步骤。这并不奇怪，因为所需工具的版本是部署过程的一部分。</p>

<h2 id="tip-1-referencing-packages-with-execution-containers">技巧1:用执行容器引用包</h2>

<p>数据库部署是工作人员的常见用例。数据库部署至少涉及一个包含所需状态或迁移脚本的包，但是包引用如何与执行容器一起工作呢？</p>

<p>首先，在执行容器上运行的步骤通常来自于<strong>运行脚本步骤</strong>。<strong>运行脚本步骤</strong>提供了<a href="https://octopus.com/docs/deployments/custom-scripts/run-a-script-step#referencing-packages">引用包</a>的能力。这将把必要的目录作为卷安装到Docker容器上。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/reference-packages.png" class="zoom" data-title=""><img src="../Images/413a3716c080a3e7150dfa7b67754e49.png" class="img-fluid center" alt="referencing packages with execution containers" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/reference-packages.png"/>T2】</a></p>

<p>您可以轻松地将包的内容传递给执行容器，这应该会使它从直接在服务器上运行无缝地过渡到执行容器。这适用于<a href="https://hub.docker.com/r/octopusdeploy/worker-tools" rel="nofollow"> Octopus Deploy提供的图像</a>或您的自定义图像。</p>

<h2 id="tip-2-image-requirements">技巧2:映像需求</h2>

<p>创建自定义执行容器映像时，有一些要求:</p>

<ol>
<li>Linux镜像应该是基于Ubuntu的，并且安装了<code>wget unzip apt-utils curl software-properties-common</code>。这是Calamari正确运行所需的软件。</li>
<li>Dockerfile文件中不能定义入口点。Octopus拥有容器的生命周期；入口点可能会过早结束容器。</li>
<li>Linux容器运行在Linux主机上，Windows容器运行在Windows主机上。Windows主机上没有Linux容器。</li>
<li>假设您使用多种体系结构标记映像(下面将详细介绍)，工作池可以由Windows主机或Linux主机组成。</li>
</ol>

<h2 id="tip-3-understanding-the-working-directory-and-configuring-executable-paths">技巧3:了解工作目录并配置可执行路径</h2>

<p><code>docker run</code>命令还利用workdir或<code>-w</code>参数<a href="https://docs.docker.com/engine/reference/run/#workdir" rel="nofollow">来设置容器中的工作目录，以匹配主机中的工作目录。</a></p>

<p>通常，容器中的工作目录并不重要。如果脚本运行成功，它是从根目录还是从随机文件夹运行都没关系，除非您需要在Docker映像上安装定制软件。它不使用包管理器，如Windows的Chocolatey，Linux发行版的APT或YUM。</p>

<p>我最近在为Flyway构建执行容器时遇到了这个问题。包管理器非常有用，因为它为环境变量添加了必要的路径。我可以使用<code>flyway info</code>而不是<code>C:\Flyway\flyway.exe info</code>来运行info命令。在撰写本文时，只有一个Maven repo，您可以使用它下载一个. tar或。zip文件。</p>

<p>对于基于Linux的发行版，命令如下:</p>

<pre><code class="language-Dockerfile">ARG FLYWAY_VERSION=7.7.1

# Change the workdir to Flyway to install flyway binaries
WORKDIR /flyway

# Install flyway
RUN curl -L https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/${FLYWAY_VERSION}/flyway-commandline-${FLYWAY_VERSION}.tar.gz -o flyway-commandline-${FLYWAY_VERSION}.tar.gz \
  &amp;&amp; tar -xzf flyway-commandline-${FLYWAY_VERSION}.tar.gz --strip-components=1 \
  &amp;&amp; rm flyway-commandline-${FLYWAY_VERSION}.tar.gz \
  # Make the /flyway/flyway command an executable
  &amp;&amp; chmod +x /flyway/flyway \
  # Make it so any user can call /flyway/flyway 
  &amp;&amp; ln -s /flyway/flyway /usr/local/bin/flyway

# Octopus expects to start in the default directory
WORKDIR /
</code></pre>

<p>这会将Flyway包的内容提取到<code>/flyway</code>目录，使<code>/flyway/flyway</code>成为可执行文件，然后将其添加到适当的路径。我在脚本中需要做的就是调用<code>/flyway/flyway info</code>来运行<a href="https://flywaydb.org/documentation/command/info" rel="nofollow">飞行路线信息命令</a>。</p>

<p>对于Windows容器，这方面的命令是:</p>

<pre><code class="language-Dockerfile">SHELL ["powershell", "-Command"]

ARG FLYWAY_VERSION=7.7.1

# # Install Flyway
RUN Invoke-WebRequest "https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/${env:FLYWAY_VERSION}/flyway-commandline-${env:FLYWAY_VERSION}-windows-x64.zip" -OutFile flyway-cli.zip; `
    &amp; '.\Program Files\7-Zip\7z.exe' x .\flyway-cli.zip; `
    rm .\flyway-cli.zip;

RUN $old = (Get-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name path).path; `
    Write-Host $old; `
    $flywayPath = ';C:\flyway-' + ${env:FLYWAY_VERSION}; `    
    $new = $old + $flywayPath; `
    Write-Host $new; `
    Set-ItemProperty -Path 'Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment' -Name path -Value $new; `
    refreshenv
</code></pre>

<p>该脚本将Flyway可执行文件下载并提取到<code>C:\flyway-[version number]</code>，然后将该目录添加到环境路径中。我在脚本中需要做的就是调用<code>flyway info</code>来运行<a href="https://flywaydb.org/documentation/command/info" rel="nofollow">飞行路线信息命令</a>。</p>

<h2 id="tip-4-creating-base-images">技巧4:创建基本图像</h2>

<p>我建议创建包含任何子映像都可以利用的基础映像。我为Flyway执行容器映像创建了<a href="https://github.com/OctopusDeployLabs/workertools" rel="nofollow">基础映像</a>:</p>

<ul>
<li>Windows 2019映像          <ul>
<li>PowerShell核心</li>
<li>巧克力</li>
<li>计算机编程语言</li>
<li>7Zip</li>
</ul>
</li>
<li>Ubuntu图像          <ul>
<li>。NET核心必备软件(Calamari是一个自带的。网芯app)</li>
<li>卷曲</li>
<li>拉开…的拉链</li>
<li>PowerShell核心</li>
<li>Python3</li>
</ul>
</li>
</ul>

<p>这样，子映像只需提取基础映像并安装必要的软件。基本映像可以减少子映像的构建时间，因为核心映像很少改变。</p>

<p>在转移到基本映像之前，我的Linux和Windows版本大约需要13分钟。移动到基本图像减少到5分钟。</p>

<h2 id="tip-5-using-docker-manifest-for-cross-platform-images">技巧5:对跨平台图像使用Docker清单</h2>

<p>要求一个人选择Windows或Linux映像是一个额外的认知负荷，特别是如果工具是跨平台的。它迫使用户思考容器将在哪里运行。</p>

<p>而不是这个:<a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/incorrect-versioning.png" class="zoom" data-title=""> <img src="../Images/f587e555697346fc68e39adcca93874d.png" class="img-fluid center" alt="incorrect picking of version" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/incorrect-versioning.png"/> </a></p>

<p>使之成为可能:<a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/correct-versioning.png" class="zoom" data-title=""> <img src="../Images/e8fe7f6d9fa7a8b1698fb009411cc41e.png" class="img-fluid center" alt="correct picking of version" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/correct-versioning.png"/> </a></p>

<p>这可以通过使用<a href="https://docs.docker.com/engine/reference/commandline/manifest/" rel="nofollow">码头货单</a>来完成。</p>

<p>Docker提供了<a href="https://docs.docker.com/buildx/working-with-buildx/" class="alert-link" rel="nofollow"> buildx </a>作为manifest命令的替代。在撰写本文时，buildx不容易支持Windows容器和Linux容器。</p>


<p>为了利用<code>docker manifest</code>，你必须打开Docker中的实验特性。有很多例子说明如何为Linux做这件事。如果您使用的是Docker Desktop for Windows，请以管理员身份运行此PowerShell命令，然后重新启动Docker引擎:</p>

<pre><code>[Environment]::SetEnvironmentVariable("DOCKER_CLI_EXPERIMENTAL", "enabled")
</code></pre>

<p>清单的工作原理:</p>

<ol>
<li>为Windows构建映像:<code>docker build ./windows-2019 --tag octopuslabs/flyway-workertools:$FLYWAY_VERSION_TO_BUILD-windows.2019 --tag octopuslabs/flyway-workertools:latest-windows.2019</code>。</li>
<li>为Windows: <code>docker push octopuslabs/flyway-workertools:$FLYWAY_VERSION_TO_BUILD-windows.2019</code>的每个标签推送图片。</li>
<li>转到Linux容器。</li>
<li>为Linux构建映像:<code>docker build ./ubuntu-1804 --tag octopuslabs/flyway-workertools:$FLYWAY_VERSION_TO_BUILD-ubuntu.1804 --tag octopuslabs/flyway-workertools:latest-ubuntu.1804</code>。</li>
<li>为Linux的每个标签推送图片:<code>docker push octopuslabs/flyway-workertools:$FLYWAY_VERSION_TO_BUILD-ubuntu.1804</code>。</li>
<li>构建清单:<code>docker manifest create octopuslabs/flyway-workertools:latest octopuslabs/flyway-workertools:latest-windows.2019 octopuslabs/flyway-workertools:latest-ubuntu.1804</code>。</li>
<li>推送清单:<code>docker manifest push octopuslabs/flyway-workertools:latest</code>。</li>
</ol>

<p>您将为每个架构(Windows和Linux)构建并标记一个映像。这些标签对于该架构是唯一的。当您为<code>latest</code>标签构建清单时，您可以“将最新的windows.2019和最新的ubuntu.1804合并到一个标签中”。完成后，您的标签将在Docker Hub上显示如下。</p>

<p>必须在构建清单之前推送图像。否则，您会收到一个关于找不到图像的错误，因为清单没有查看本地计算机。</p>


<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/docker-tags-docker-hub.png" class="zoom" data-title=""><img src="../Images/a4f5c85917675050be530329206969e7.png" class="img-fluid center" alt="multiple architecture tags" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/docker-tags-docker-hub.png"/>T2】</a></p>

<p>我已经让GitHub动作来<a href="https://github.com/OctopusDeployLabs/flyway-workertools/blob/main/.github/workflows/docker-build-push.yml" rel="nofollow">构建公共的Flyway执行容器</a>，所以你可以看到它的运行。</p>

<h2 id="tip-6-leveraging-docker-build-arguments">技巧6:利用Docker构建参数</h2>

<p>您会注意到，在我的Dockerfile文件示例中，我使用了<code>ARG</code>命令:</p>

<pre><code class="language-dockerfile">ARG FLYWAY_VERSION=7.7.1
</code></pre>

<p>当一个新版本的Flyway准备好安装时，假设其他一切都是一致的，我只需在我的<code>docker build</code>命令中传递一个<code>--build-arg</code>开关。</p>

<pre><code>docker build ./ubuntu-1804 --tag octopuslabs/flyway-workertools:$FLYWAY_VERSION_TO_BUILD-ubuntu.1804 --tag octopuslabs/flyway-workertools:latest-ubuntu.1804 --build-arg FLYWAY_VERSION=$FLYWAY_VERSION_TO_BUILD
</code></pre>

<p>为了创建Docker映像的新版本，我只更改了管道中的一个点，而不是多个地方。</p>

<h2 id="tip-7-name-and-version-the-docker-image-based-on-the-key-software">技巧7:根据关键软件对Docker镜像进行命名和版本化</h2>

<p>我一直使用Flyway作为我的示例容器。这是容器的关键软件。其他软件，如Java Runtime Environment (JRE ),需要它才能正常工作。图像的名称为<code>flyway-workertools</code>，版本基于Flyway版本。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/flyway-workertools-versioning.png" class="zoom" data-title=""><img src="../Images/f6c45bf4ab9e464c43e07dfe42d18fe8.png" class="img-fluid center" alt="flyway versioning for the worker tools image" data-original-src="https://i.octopus.com/blog/2021-04/tips-building-custom-execution-containers/flyway-workertools-versioning.png"/>T2】</a></p>

<p>目标是减少图像消费者的模糊性。任何运行<code>flyway-workertools</code>图像的<code>7.7.2</code>的人都知道他们将得到Flyway的<code>7.7.2</code>。</p>

<h2 id="tip-8-scheduling-builds-to-check-for-new-versions">技巧8:安排构建来检查新版本</h2>

<p>最后一个技巧与日常维护有关。执行容器很棒，但是保持所有工具的最新版本是非常耗时的。Flyway发布了一个清单文件，我可以让我构建检查。我的脚本将:</p>

<ol>
<li>检查Flyway清单文件中的最新版本。</li>
<li>从Docker Hub中调出所有标签，搜索最新版本。</li>
<li>如果发现最新版本是一个标签，那么停止构建。</li>
<li>如果发现最新版本是<em>而不是</em>作为标签，那么构建一个新版本。</li>
</ol>

<p>下面的脚本来自用于构建Flyway worker工具映像的<a href="https://github.com/OctopusDeployLabs/flyway-workertools/blob/main/.github/workflows/docker-build-push.yml" rel="nofollow"> GitHub动作。因为这是一个GitHub动作，所以它设置输出变量，供后面的动作和步骤使用。</a></p>

<pre><code class="language-PowerShell">$manifestDataRaw = Invoke-WebRequest "https://repo1.maven.org/maven2/org/flywaydb/flyway-commandline/maven-metadata.xml"
$manifestData = [Xml]$manifestDataRaw
$latestFlywayVersion = $manifestData.metadata.versioning.latest
$workerToolsTags = Invoke-RestMethod "https://registry.hub.docker.com/v1/repositories/octopuslabs/flyway-workertools/tags"
$matchingTag = $workerToolsTags | Where-Object { $_.name -eq $latestFlywayVersion }
echo "::set-output name=CURRENT_FLYWAY_VERSION::$latestFlywayVersion"
if ($null -ne $matchingTag)
{
    Write-Host "Docker container already has latest version of flyway"
    echo "::set-output name=Continue::No"
}
else
{
    Write-Host "We need to upgrade the flyway container to $latestFlywayVersion"            
    echo "::set-output name=Continue::Yes"
}     
</code></pre>

<p>有了这个脚本，我可以安排一个每日构建来检查新版本，并在发现新版本时构建一个新容器。只要消费者引用一个特定的版本号(例如，<code>7.7.2</code>，他们就不会注意到新的图像。</p>

<p>包管理器的逻辑是不同的，并且<a href="https://stackoverflow.com/questions/18885820/how-to-check-the-version-before-installing-a-package-using-apt-get" rel="nofollow">依赖于包管理器本身</a>。</p>

<h2 id="conclusion">结论</h2>

<p>Octopus Deploy中的执行容器使得管理依赖关系更加容易。Octopus提供图像来帮助尽可能多的人开始使用执行容器。它们应该适用于大多数情况，但是图像可能包含您不需要的额外软件，导致膨胀和更长的下载时间。</p>

<p>我希望所提供的技巧能帮助你制作出符合你特定需求的图片。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>