<html>
<head>
<title>Integrating docker-compose steps with Octopus Deploy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>集成docker-compose步骤和Octopus Deploy - Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/docker-compose#2021-08-12">https://octopus.com/blog/docker-compose#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/blogimage-docker-compose.png" class="zoom" data-title=""><img src="../Images/118c67c519cb501b0a2cf25f02b0b189.png" class="img-fluid center" alt="Octopus working with Docker Compose illustration" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/blogimage-docker-compose.png"/>T2】</a></p>

<p>从版本3.5.0开始，Octopus就支持简单的Docker步骤，从那时起，容器的前景发生了巨大的变化。越来越多的持续部署管道使用容器，无论是标准化构建环境、测试还是运行时。尽管我们最近将注意力集中在改进我们的Kubernetes支持上，但是对于某些需求，一个简单的docker-compose文件就足够了。你只需要一把锤子，为什么还要用射钉枪呢？</p>

<p>随着最近在<code>2018.8.0</code>版本中对<code>Run a Script</code>部署步骤的升级，执行<code>docker-compose</code>任务现在可以更好地集成到您的Octopus部署项目中。在本帖中，我们将看看如何通过利用一些伟大的新脚本特性来轻松提供环境变量以及将图像版本绑定到Octopus版本。本例中的所有图片和脚本都可以在GitHub或DockerHub上找到。</p>

<h2 id="starting-with-a-simple-compose">从简单的作曲开始</h2>

<p>我们想建立一个简单的网站，有一个访问者计数器(你好，1990年的)和一个简单的消息。为此，我们将运行一个小型python网站，将访问者状态存储在redis数据存储中。将网站包装到一个容器中，并通过docker-compose运行它们，这意味着我们可以确保执行环境总是符合我们的期望。我不会深入讨论编写python脚本或为该网站构建docker映像的细节，但可以随意查看托管这些项目文件的<a href="https://github.com/OctopusSamples/Docker-Compose" rel="nofollow"> GitHub repo </a>上的<a href="https://github.com/OctopusSamples/Docker-Compose/blob/master/WebAppAndRedis/app/app.py" rel="nofollow"> web应用</a>和<a href="https://github.com/OctopusSamples/Docker-Compose/blob/master/WebAppAndRedis/app/Dockerfile" rel="nofollow"> Dockerfile </a>的源代码。</p>

<p>在构建我们的web应用程序映像之后，我们可以创建一个类似于</p>

<pre><code class="language-yaml">version: '2'
services:
  web:
    image: sample-python-webapp:latest
    ports:
     - "5000:5000"
    environment:
      - text="Hello World"
  redis:
    image: redis:latest
</code></pre>

<p>然后只需要运行<code>docker-compose up</code>就可以了，我们得到了一个很棒的网站</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/localhost.png" class="zoom" data-title=""><img src="../Images/deeba480332f3d5cdb9fa570289ab3fb.png" class="img-fluid center" alt="localhost" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/localhost.png"/>T2】</a></p>

<h2 id="deploying-through-octopus">通过Octopus部署</h2>

<p>现在我们知道我们的网站工作，我们想通过Octopus Deploy部署它，这样我们就可以充分利用环境进展，控制图像版本和变量注入。</p>

<h3 id="custom-values-during-docker-compose">docker编写期间的自定义值</h3>

<p>我们希望能够通过标准的docker变量动态传递细节，而不是将图像细节硬编码到<code>docker-compose.yml</code>文件中。</p>

<p>然后，<code>docker-compose.yml</code>文件看起来像这样</p>

<pre><code class="language-yaml">version: '2'
services:
  web:
    image: ${WEB_IMAGE}:${WEB_TAG}
    ports:
     - "${WEB_PORT}:5000"
    environment:
      - text=${TEXT_MESSAGE}
  redis:
    image: ${DB_IMAGE}:${DB_TAG}
</code></pre>

<p>但是，如果我尝试在本地运行这个，我会得到一堆错误，因为docker不知道这些变量应该有什么值。我们可以通过提供一个<a href="https://docs.docker.com/compose/env-file/" rel="nofollow">T2文件</a>来解决这个问题。</p>

<pre><code>WEB_IMAGE=mywebapp
WEB_TAG=1.0.0
DB_IMAGE=redis
DB_TAG=latest
TEXT_MESSAGE=I Am A Local Message
WEB_PORT=5889
</code></pre>

<p>现在当我运行<code>docker-compose up</code>时，docker将使用这个文件中的值。</p>

<h3 id="the-octopus-project">章鱼项目</h3>

<p>虽然没有docker-compose的具体步骤，但是我们可以使用最新版本的脚本步骤中提供的多包功能来提供关于我们想要用于<code>.env</code>文件的具体图像的信息。我们将自己调用<code>docker-compose</code>，所以我们将从<code>run a script</code>步骤开始。</p>

<p>由于我们想要对所有的脚本和<code>docker-compose.yml</code>文件进行版本化，我们将通过<a href="https://octopus.com/docs/packaging-applications/package-repositories/github-feeds"> GitHub feed </a>获取它们。我们实际上没有任何构建这些脚本所需的过程(忽略我们通过单独的过程构建的web应用程序映像本身)，所以使用GitHub feed允许Octopus直接从源代码控制中获得我们的脚本代码。在我们的例子中，我们将使用前面提到的公共GitHub库，并将脚本文件设置为<code>WebAppAndRedis/octopus_startup.sh</code>，并传递几个参数<code>-n "#{ProjectName}" -o</code>。这个脚本将包含我们希望Octopus在部署期间运行的代码，我们将很快检查它的内容和那些参数。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/script_selection.png" class="zoom" data-title=""><img src="../Images/e08213afbe602d622276155f49d80b2c.png" class="img-fluid center" alt="script selection" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/script_selection.png"/>T2】</a></p>

<p>这些字段下是新特性<code>Additional Packages</code>。让我们添加对用于这个项目的两个docker图像的引用。在这种情况下，我们将利用<a href="https://octopus.com/docs/packaging-applications/package-repositories/registries/docker-hub"> DockerHub feed </a>并选择官方<code>redis</code>图像</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/redis_image.png" class="zoom" data-title=""><img src="../Images/a461aff215777f32e06c15c8bc5b6f3f.png" class="img-fluid center" alt="redis image" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/redis_image.png"/>T2】</a></p>

<p>我们之前使用的<code>sample-python-webapp</code>图像已经被推送到<a href="https://hub.docker.com/u/octopusdeploy" rel="nofollow"> OctopusDeploy DockerHub </a>注册表中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/sample_python_webapp_image.png" class="zoom" data-title=""><img src="../Images/18acdcb96bb885cb52fd98abc74659a9.png" class="img-fluid center" alt="redis image" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/sample_python_webapp_image.png"/>T2】</a></p>

<p>在这两种情况下，我们都选择了<em>而不是</em>在服务器上获得它们。这意味着包的细节将作为变量提供给脚本，但是采集不会被执行。在我们的<code>docker-compose</code>步骤中，如果有必要的话，docker会自动将它们拉下来，但是在某些情况下，您可能希望包文件可用，例如，您希望使用我们在第一步中选择的主包中不包含的附加脚本或工具。注意我们给这两个额外的包引用的名字(<code>DBImage</code>和<code>WebImage</code>)，这将被用来作为变量引用不同的包细节。</p>

<h3 id="getting-octopus-variables-into-docker-compose">让Octopus变量进入docker-compose</h3>

<p>我们想要做的是通过<code>.env</code>文件向<code>docker-compose.yml</code>文件提供选定的图像细节。我们可以用一堆Octopus变量替换现有的<code>.env</code>文件，以便在部署时<a href="https://octopus.com/docs/deployment-process/configuration-features/substitute-variables-in-files">替换</a>，但是这样我们就不能在开发期间本地运行它。相反，让我们创建一个单独的文件<code>octopus.env</code></p>

<pre><code class="language-yaml">WEB_TAG=#{Octopus.Action.Package[WebImage].PackageVersion}
WEB_IMAGE=#{Octopus.Action.Package[WebImage].PackageId}
DB_TAG=#{Octopus.Action.Package[DBImage].PackageVersion}
DB_IMAGE=#{Octopus.Action.Package[DBImage].PackageId}
TEXT_MESSAGE=#{WebMessage}
WEB_PORT=#{WebPort}
</code></pre>

<p>脚本步骤的另一个很棒的新特性是执行变量替换或配置转换的能力。让我们启用这个特性，并确保这个新文件<code>octopus.env</code>替换了变量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/variable_replacement.png" class="zoom" data-title=""><img src="../Images/aa16970b34c5d7fb7bd46b76168e439d.png" class="img-fluid center" alt="variable replacement" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/variable_replacement.png"/>T2】</a></p>

<p>这里是用于这个项目的其他变量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/project_variables.png" class="zoom" data-title=""><img src="../Images/6b292d8bc76df272b8fcb736a7ad2e56.png" class="img-fluid center" alt="Project variables" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/project_variables.png"/>T2】</a></p>

<h3 id="the-execution-script">执行脚本</h3>

<p>我们之前跳过了实际的脚本执行，所以现在我们知道我们将有一个Octopus提供的<code>.env</code>文件，让我们看看这个脚本实际上做了什么。</p>

<p>在撰写本文时，<code>docker-compose</code>还没有提供一个简单的方法来传递一个定制的<code>.env</code>文件，尽管有一个活动的<a href="https://github.com/docker/compose/issues/4841" rel="nofollow"> GitHub问题</a>，所以下面的步骤将来可能会变得简化。为了避开这个限制，我们将在部署时把<code>octopus.env</code>文件重命名为<code>.env</code>。这发生在变量替换之后，因此当我们运行<code>docker-compose</code>时，它将利用<em>这些</em>变量，而不是我们在开发时包含的默认变量。</p>

<p>因为我们也希望能够在本地运行和测试这个脚本，所以我们将确保<code>.env</code>文件更改可以配置为<em>而不是</em>发生，因为我们只在Octopus部署期间传递了<code>-o</code>参数。</p>

<pre><code class="language-bash">#!/bin/bash 

 cmd="up"
 octopus=0
 project_name="MyApp"
 while getopts ":n:c:o" opt; do
  case $opt in
    o) octopus=1
    ;;
    n) project_name="$OPTARG"
    ;;
    c) cmd="$OPTARG"
    ;;
    \?) echo "Invalid option -$OPTARG" &gt;&amp;2
    ;;
  esac
done

if [[ $cmd = "up" ]]; then
    if [[ octopus -eq 1 ]]; then
        echo "Replacing '.env' file with '.octopus.env'"
        mv ./.env ./.env.old
        mv ./octopus.env ./.env
    fi
    #docker-compose pushes non errors onto stderr. Redirect to stdout
    docker-compose --project-name $project_name  up -d  2&gt;&amp;1
else
    docker-compose --project-name $project_name  $cmd  2&gt;&amp;1
fi
</code></pre>

<p>我们现在可以用<code>.octopus_startup.sh up</code>或<code>.octopus_startup.sh down</code>在本地运行这个脚本。使用<code>-n</code>参数传递项目名称可以设置docker放在容器上的名称，并允许我们在同一个服务器上运行多个实例。因为在本例中我们将在同一台机器上运行两个Octopus环境，所以compose项目名称将包含Octopus环境名称作为项目变量<code>MyApp-#{Octopus.Environment.Name}</code>。</p>

<p>根据您的部署的简单或复杂程度，您的执行脚本可能需要与这个脚本有很大的不同，因此将它作为说明预期行为的指南。核心目标是替换<code>.env</code>文件并调用<code>docker-compose up</code>命令。例如，您可能希望增加特定容器的实例数量，或者执行额外的配置，如设置卷装载等。</p>

<p>我们在SSH目标上运行这个脚本，所以我使用了bash脚本，但是在GitHub repo中也有类似的PowerShell脚本。</p>

<h3 id="create-release-and-deploy">创建发布并部署</h3>

<p>现在一切就绪，我们可以部署我们的项目了！当我们创建一个版本时，我们可以看到我们能够选择3个不同的包，尽管我们只有一个步骤！</p>

<p>【T2 <img src="../Images/e3d342667bed61e1cb7b3b1950bb1875.png" class="img-fluid center" alt="Create Release" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/create_release.png"/></p>

<p>如你所见，我们可以选择包含GitHub中所有脚本文件的包的版本，以及DockerHub中包含的两个图像的版本。</p>

<p>然后，我们可以将我们的发布部署到开发中</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/dev.png" class="zoom" data-title=""><img src="../Images/f386127faa4aa58f505a4574ce2cab23.png" class="img-fluid center" alt="dev" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/dev.png"/>T2】</a></p>

<p>和分级</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-09/docker-compose/staging.png" class="zoom" data-title=""><img src="../Images/df58721548e5c35fa3cbece7d2b77a04.png" class="img-fluid center" alt="staging" data-original-src="https://i.octopus.com/blog/2018-09/docker-compose/staging.png"/>T2】</a></p>

<p>如果我们想更新传递到容器中的问候文本，我们只需更新项目变量并再次部署即可！如果我们推出新版本的web应用程序，我们只需创建一个新版本，指定该映像的最新版本并进行部署！</p>

<h2 id="docker-compose-and-octopus">Docker-Compose和章鱼</h2>

<p>如上所示，使用脚本步骤中可用的新的多包选择为部署自动化提供了全新的可能性，包括更容易的docker-compose部署。要将docker-compose集成到Octopus流程中，请选择每个图像作为附加的脚本步骤包，并使用<code>.env</code>文件来提供需要更改的值。</p>

<p>希望这篇文章能给你一些关于从哪里开始docker-compose部署的想法。我们将继续向Octopus Deploy添加额外的功能，以使部署容器变得尽可能简单，这样您就可以回到实际编写代码的工作中来了！看看我们的<a href="/blog/octopus-release-2018.8"> Kubernetes支持</a>在最新的大版本<code>2018.8.0</code>中作为alpha版本提供！</p>

                    
                    
</body>
</html>