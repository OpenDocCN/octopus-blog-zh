<html>
<head>
<title>Using Cake build scripts for your .NET Core web apps - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用蛋糕构建脚本为您的。NET核心web应用程序- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/cake-build-scripts#2022-08-09">https://octopus.com/blog/cake-build-scripts#2022-08-09</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/cake-build-scripts/blogimage-cakebuild.png" class="zoom" data-title=""><img src="../Images/a6d60f3777dbb33bff5826cf589f51fc.png" class="img-fluid center" alt="Illustration showing building a cake w/ code, markdown and images in a mixing bowl" data-original-src="https://i.octopus.com/blog/2019-10/cake-build-scripts/blogimage-cakebuild.png"/>T2】</a></p>

<p>Cake是一个为。NET开发人员使用C#领域特定语言(DSL)编写构建过程的脚本。在本文中，我们将通过一个具体的工作示例来探索Cake的好处及其主要特性，以实现灵活、可维护、自动化的构建过程。</p>

<p>您可能在过去听说过Make和makefiles，但是如果您没有听说过也不用担心，因为您就要知道了。Make是一个构建自动化工具，而makefile是一个包含Make构建应用程序所需的指令的文件。它还可以用来运行相关的任务，比如清理构建目录。</p>

<p>随着开发人员希望使用他们喜欢的语言来定义他们的构建过程，这些年来出现了许多Make的变体。Rake (Ruby Make)和Ruby on Rails一起变得非常流行。</p>

<p>在。NET世界中，根据您选择的语言，您有几个选项。有<a href="https://github.com/psake/psake" rel="nofollow">PSake</a>(PowerShell)<a href="https://fake.build/" rel="nofollow">山寨</a> (F#)，还有<a href="https://cakebuild.net/" rel="nofollow">蛋糕</a> (C#)。我们今天主要讨论蛋糕，但是如果你想用PowerShell或者F#编写脚本，可以看看其他的。</p>

<h2 id="benefits-of-cake">蛋糕的好处</h2>

<p>使用Cake的主要好处之一是您的构建脚本将使用C# DSL编写。您的团队可以使用他们最熟悉的语言来自动化他们的构建，而不是使用XML、JSON或YAML。</p>

<p>另一个不容忽视的好处是能够在本地和CI服务器上执行Cake脚本。想一想。除非您的构建代理存在任何环境问题，否则相同的Cake脚本将在您的机器、团队成员的机器和CI服务器上运行。您的CI项目配置可以简化为:</p>

<ol>
<li>从源代码管理中签出。</li>
<li>运行这个蛋糕脚本。</li>
</ol>

<p>说到源代码控制，您的Cake脚本位于您的项目存储库中。您的构建过程是版本化的，并且可以使用与您的应用程序代码相同的代码评审过程进行更改和评审。提交您的脚本还将您的应用程序代码与构建过程结合起来，因此您不必在CI服务器中单独更改构建步骤。应用程序和构建脚本的这种链接是YAML成为构建管道建模的流行选择的原因之一。Cake还有一个额外的好处，就是可以在您的机器上运行这些构建步骤。</p>

<p>Cake通过<a href="https://cakebuild.net/extensions/" rel="nofollow">社区贡献的插件</a>内置了对许多工具(包括Octopus Deploy)和许多其他工具的支持。您用于构建的工具很有可能是受支持的，如果不支持，您可以创建一个外接程序在脚本中使用。</p>

<h2 id="example-cake-script">蛋糕脚本示例</h2>

<p>我们的示例项目OctoPetShop有一个<a href="https://github.com/OctopusSamples/OctoPetShop/blob/a9254521a67db6364ff4ac888fa56873ae07f7c8/build.cake" rel="nofollow">完整的蛋糕脚本示例</a>,我们将在本文中探讨。该链接指向撰写本文时使用的版本。如果您想查看最新版本，您可以查看<a href="https://github.com/OctopusSamples/OctoPetShop/blob/master/build.cake" rel="nofollow">此链接</a>。</p>



<p>Cake脚本的第一部分导入您在构建过程中使用的任何外部工具、插件或模块。在我们的例子中，我们添加了一个#tool指令，并指定我们需要NuGet的OctopusTools版本6.13.1。然后我们为<code>Cake.Common.Tools.OctopusDeploy</code>名称空间添加了一个<code>using</code>语句:</p>

<pre><code class="language-cs">#tool "nuget:?package=OctopusTools&amp;version=6.13.1"

using Cake.Common.Tools.OctopusDeploy;
</code></pre>

<p>到目前为止，我们在这个脚本中只使用了Octopus Deploy工具，但是Cake内置了对许多工具的支持，包括NuGet、测试框架等等。</p>

<h3 id="arguments-and-global-variables">参数和全局变量</h3>

<p>在下一节中，我们将设置一些在脚本执行期间使用的参数和变量。</p>

<p>有了<code>Argument</code>别名，Cake会给你一个从命令行提供的参数值或者你指定的默认值。我们有要运行的目标任务的参数、要使用的构建配置、用于版本控制的版本和预发布标签，以及与Octopus服务器集成的信息。</p>

<p>之后，我们有一个简单的类来收集关于我们项目的信息和一些变量，我们将在<code>Setup</code>中填充它们:</p>

<pre><code class="language-cs">var target = Argument("target", "Default");
var configuration = Argument("configuration", "Release");
var version = Argument("packageVersion", "0.0.1");
var prerelease = Argument("prerelease", "");
var databaseRuntime = Argument("databaseRuntime", "win-x64");
var octopusServer = Argument("octopusServer", "https://your.octopus.server");
var octopusApiKey = Argument("octopusApiKey", "hey, don't commit your API key");

class ProjectInformation
{
    public string Name { get; set; }
    public string FullPath { get; set; }
    public string Runtime { get; set; }
    public bool IsTestProject { get; set; }
}

string packageVersion;
List&lt;ProjectInformation&gt; projects;
</code></pre>

<h3 id="setup">设置</h3>

<p>让我们来看看那个<code>Setup</code>方法。</p>

<p>我们检查是否在本地运行构建，如果是，并且没有提供预发布标签，我们将预发布标签设置为"-local。"</p>

<p>然后我们设置我们的全局变量<code>packageVersion</code>和<code>projects</code>:</p>

<pre><code class="language-cs">Setup(context =&gt;
{
    if (BuildSystem.IsLocalBuild &amp;&amp; string.IsNullOrEmpty(prerelease))
    {
        prerelease = "-local";
    }

    packageVersion = $"{version}{prerelease}";

    projects = GetFiles("./**/*.csproj").Select(p =&gt; new ProjectInformation
    {
        Name = p.GetFilenameWithoutExtension().ToString(),
        FullPath = p.GetDirectory().FullPath,
        Runtime = p.GetFilenameWithoutExtension().ToString() == "OctopusSamples.OctoPetShop.Database" ? databaseRuntime : null,
        IsTestProject = p.GetFilenameWithoutExtension().ToString().EndsWith(".Tests")
    }).ToList();

    Information("Building OctoPetShop v{0}", packageVersion);
});
</code></pre>

<h3 id="tasks">任务</h3>

<p>任务定义您的构建过程。它们类似于传统持续集成(CI)项目或管道中的构建步骤。</p>

<p>让我们来看看我们的第一个任务，<code>Clean</code>。我们用<code>Task</code>方法定义它，并提供一个名称。然后我们使用<code>Does</code>方法来定义这个任务做什么。在这种情况下，我们清理我们的发布和打包目录，然后为我们的项目调用<code>DotNetCoreClean</code>:</p>

<pre><code class="language-cs">Task("Clean")
    .Does(() =&gt;
        {
            CleanDirectory("publish");
            CleanDirectory("package");

            var cleanSettings = new DotNetCoreCleanSettings { Configuration = configuration };

            foreach(var project in projects)
            {
                DotNetCoreClean(project.FullPath, cleanSettings);
            }
        });
</code></pre>

<h3 id="dependencies">属国</h3>

<p>让我们直接跳到<code>Build</code>任务。看起来和<code>Clean</code>差不多，但是多了一个新棋子:<code>IsDependentOn</code>。这个方法让我们在任务之间创建一个依赖链。当我们调用<code>Build</code>任务时，Cake将确保<code>Clean</code>和<code>Restore</code>都被首先调用:</p>

<pre><code class="language-cs">Task("Build")
    .IsDependentOn("Clean")
    .IsDependentOn("Restore")
    .Does(() =&gt;
    {
        foreach(var project in projects)
        {
            var buildSettings = new DotNetCoreBuildSettings()
                {
                    Configuration = configuration,
                    NoRestore = true
                };

            if (!string.IsNullOrEmpty(project.Runtime))
            {
                buildSettings.Runtime = project.Runtime;
            }

            DotNetCoreBuild(project.FullPath, buildSettings);
        }
    });
</code></pre>

<p>我们还有另一个名为<code>RunUnitTests</code>的任务，它依赖于<code>Build</code>。运行<code>RunUnitTests</code>任务将触发<code>Clean</code>、<code>Restore</code>和<code>Build</code>:</p>

<pre><code class="language-CSU’s">Task("RunUnitTests")
    .IsDependentOn("Build")
    .Does(() =&gt;
    {
        foreach(var project in projects.Where(p =&gt; p.IsTestProject))
        {
            DotNetCoreTest(project.FullPath, new DotNetCoreTestSettings { Configuration = configuration });
        }
    });
</code></pre>

<p>如果您继续通读脚本，您将看到发布应用程序、使用Octopus工具打包应用程序、将包推送到Octopus以及使用Octopus创建和部署发行版的任务。</p>

<p>最后，我们在剧本的结尾有这些台词。这创建了一个<code>Default</code>任务，它将运行<code>RunUnitTests</code>任务及其依赖项。</p>

<p>调用<code>RunTarget</code>方法的最后一行代码启动了构建过程。这里我们传入由用户、CI服务器提供的全局变量<code>target</code>，或者默认为名为<code>Default</code>的任务:</p>

<pre><code class="language-cs">Task("Default")
    .IsDependentOn("RunUnitTests");

RunTarget(target);
</code></pre>

<h2 id="executing-cake-locally">在本地执行蛋糕</h2>

<p>Cake提供了一个<a href="https://cakebuild.net/docs/tutorials/setting-up-a-new-project" rel="nofollow"> PowerShell或Shell引导脚本</a>，您可以使用它来执行您的Cake脚本:</p>

<pre><code class="language-ps">.\build.ps1 -Target Pack -ScriptArgs '--packageVersion=1.2.3 --prerelease=-dev'
</code></pre>

<p>就是这样！脚本启动了，在短暂的等待之后，我们在本地构建了NuGet包，并得到了这个方便的报告:</p>

<pre><code>Task                          Duration
--------------------------------------------------
Setup                         00:00:00.1432566
Clean                         00:00:05.4768163
Restore                       00:00:06.1162465
Build                         00:00:09.6114684
RunUnitTests                  00:00:04.3110846
Publish                       00:00:06.9924016
Pack                          00:00:12.7274733
--------------------------------------------------
Total:                        00:00:45.3787473
</code></pre>

<p>我们可以将这些包直接上传到我们的Octopus服务器，或者提交我们的更改，因为我们知道我们的构建是有效的。</p>

<p>还有针对Visual Studio和Visual Studio代码的扩展，这些扩展提供了智能感知、语法突出显示以及从ide运行脚本的能力。</p>

<h2 id="executing-cake-from-a-ci-server">从CI服务器执行Cake</h2>

<p>现在我们有了本地运行的Cake脚本，我们可以把它带到CI服务器上。在这个例子中，我们使用Azure DevOps，它有一个运行Cake脚本的扩展。</p>

<p>下面是创建新的ASP.NET核心构建管道时生成的步骤片段。这与我们在蛋糕脚本中创建的步骤非常相似。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/cake-build-scripts/azure-devops-no-cake.png" class="zoom" data-title=""><img src="../Images/1a3f690b9a7446e980cdcefe873ca67d.png" class="img-fluid center" alt="Screenshot showing an Azure DevOps Build Pipeline with standard steps configured" data-original-src="https://i.octopus.com/blog/2019-10/cake-build-scripts/azure-devops-no-cake.png"/>T2】</a></p>

<p>在安装了蛋糕扩展后，我们可以在构建中添加蛋糕步骤，在这种情况下，这是我们需要的唯一步骤。我们提供了蛋糕脚本的路径，我们想要运行的目标，以及一些版本号和章鱼服务器信息的附加参数。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/cake-build-scripts/azure-devops-cake.png" class="zoom" data-title=""><img src="../Images/00ab1bf5f61451287431c3cfbe7f0529.png" class="img-fluid center" alt="Screenshot showing an Azure DevOps Build Pipeline with a Cake step configured" data-original-src="https://i.octopus.com/blog/2019-10/cake-build-scripts/azure-devops-cake.png"/>T2】</a></p>

<p>运行构建后，我们不仅可以在日志中获得蛋糕脚本的完整输出，还可以像在本地运行时一样获得任务摘要:</p>

<pre><code>Task                          Duration
--------------------------------------------------
Setup                         00:00:00.0434025
Clean                         00:00:18.1795863
Restore                       00:01:07.9769173
Build                         00:00:36.6475174
RunUnitTests                  00:00:21.3958462
Publish                       00:00:06.2555954
Pack                          00:00:12.0804766
PushPackages                  00:00:16.0161892
CreateRelease                 00:00:05.4893287
DeployRelease                 00:02:09.6799635
--------------------------------------------------
Total:                        00:05:13.7648231
</code></pre>

<h2 id="conclusion">结论</h2>

<p>像蛋糕这样的构建自动化框架给你和你的团队带来了很多好处。有了Cake，您可以使用熟悉的C# DSL编写构建脚本。它使您能够将开发过程应用到您的构建中。您可以在本地和配置项服务器上运行相同的步骤。而且，Cake广泛的内置工具支持和社区插件应该能够满足大部分(如果不是全部)脚本需求。</p>

                    
                    
</body>
</html>