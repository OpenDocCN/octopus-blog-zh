<html>
<head>
<title>Migrating 426 Nancy API endpoints to ASP.NET Core controllers - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将426个Nancy API端点迁移到ASP.NET核心控制器- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/migrating-nancy-api-endpoints-to-asp-net#2021-08-31">https://octopus.com/blog/migrating-nancy-api-endpoints-to-asp-net#2021-08-31</a></blockquote>
                        <p>当Octopus Deploy在2011年宣布时，<a href="https://github.com/NancyFx/Nancy" rel="nofollow"> NancyFx </a>的低调方法使其成为我们API层的理想框架。在Nancy之上，我们添加了一个定制层，以便于添加符合我们惯例的新路线。</p>

<p>但随着我们的成长，这种定制层成了新手的困惑之源。我们周围的世界也发生了变化，到2020年，南希不再被抚养。</p>

<p>因此，我们将Octopus Deploy迁移到一种新的、更标准化的API编写方式。它利用了加入公司的开发人员的现有知识。我们选择了ASP.NET控制器。</p>

<p>Octopus Deploy API包含426个不同的端点，分布在73个Nancy模块中(这些端点集合成一个类)。每个模块都定义了与特定资源类型相关的端点。</p>

<p>对我们来说，这显然是一项意义重大的任务。所以我们采用了一个<a href="https://lethain.com/migrations/" rel="nofollow">策略</a>:去风险，使能，完成。</p>

<h2 id="derisk">德列兹</h2>

<p>我们想出了一个办法，让ASP.NET和南希共处:</p>

<ul>
<li>传入的请求被传递到ASP.NET中间件。</li>
<li>如果请求匹配ASP.NET路由，则调用相关的控制器。</li>
<li>如果没有找到匹配，那么请求被传递给Nancy。</li>
</ul>

<p>接下来，我们从单个Nancy模块开始，一个接一个地迁移端点。每个端点分三步完成:</p>

<ol>
<li>分析和测试</li>
<li>移动</li>
<li>核实</li>
</ol>

<h3 id="analyse-test">分析和测试</h3>

<p>我们使用了<a href="https://github.com/droyad/Assent" rel="nofollow"> Assent </a>测试来捕捉来自一个端点的整个HTTP响应，包括快乐路径和任何边缘情况。这些测试还测量了端点的响应时间，因此我们可以检查任何性能退化。</p>

<h3 id="migrate">移动</h3>

<p>对于一个简单的GET端点，迁移可能很简单。对于改变状态的端点，事情可能会更耗时。诸如验证之类的规则被考虑、理解并移植到ASP.NET控制器模式中。</p>

<h3 id="verify">核实</h3>

<p>之前添加的测试在CI中重新运行，提醒我们任何性能退化、功能变化或响应内容的变更。然后对变更以及变更是否可接受做出客观的决定。</p>

<h2 id="enable">使能够</h2>

<p>这种方法是成功的，证明了迁移整个Octopus Deploy API是可能的。</p>

<p>这也向我们展示了:</p>

<ul>
<li>Nancy端点通常需要大约100毫秒来返回响应。</li>
<li>对ASP.NET端点的第一次调用将在大约200毫秒内返回，但后续调用仅用了30-40毫秒。</li>
</ul>

<p>一个由4名工程师组成的团队花了6个月的时间专注于迁移。</p>

<p>为了优化迁移，我们瞄准了相似且不太复杂的端点。为了找出哪些端点符合这些标准，我们编写了一个C#脚本，在LINQPad中执行，它反映了Octopus Deploy代码库，并按公共代码和基类对端点进行了分组。</p>

<p>为了获得相对复杂性的度量，我们根据基于代码行数和圈复杂度的度量进行了排序。这种分组和排序允许我们关注迁移的机制，同时避免过多的领域复杂性。</p>

<p>我们学到了一些东西:</p>

<ul>
<li>由于ASP.NET的性能改进，没有必要继续测试性能退化。</li>
<li>基于快照的测试很难编写，因为您必须考虑和“清理”端点调用之间发生变化的数据，例如时间戳或id。</li>
<li>对于检查边缘情况的测试，断言您真正关心的响应部分更简单，比如响应代码和错误文本。</li>
<li>测试需要数据，而数据的创建并不容易，因此将这一点从测试的细节中分离出来非常重要。</li>
<li>为您如何迁移建立和记录可重复的模式是至关重要的，这样工程团队中的其他人也可以进行迁移。</li>
<li>理解特定于端点的域可能是迁移中最困难的部分。</li>
</ul>

<p>我们还发现这种类型的工作可能是重复的，有降低开发人员积极性的风险。为了解决这个问题，我们庆祝了一路上的里程碑。这些包括迁移的端点百分比，以及特定分组或类型的所有端点的迁移。</p>

<p>我们还用经典燃尽图的变化来跟踪我们的进展。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-08/migrating-nancy-api-endpoints-to-asp-net/nancyendpointsburndown-2021-07-26.png" class="zoom" data-title=""><img src="../Images/7efd67979cbea544c5db6f51104ee9ab.png" class="img-fluid center" alt="NancyEndpoints burndown chart" data-original-src="https://i.octopus.com/blog/2021-08/migrating-nancy-api-endpoints-to-asp-net/nancyendpointsburndown-2021-07-26.png"/></a>T2】</p>

<h2 id="finish">结束</h2>

<p>从一开始，我们就同意，当API 100%迁移到ASP.NET时，将会看到最大的庆祝和好处。</p>

<p>六个月后，我们已经迁移了40%的API端点，因此我们已经进入了迁移的新阶段，整个工程团队<em>都同意，如果您正在更改一个区域，请用测试覆盖它，并在您处于该区域时迁移该区域中剩余的Nancy端点。</em></p>

<p>这种方法利用了开发人员的领域知识，并将迁移工作分散到整个工程团队中。</p>

<h2 id="conclusion">结论</h2>

<ul>
<li>像这样的迁移是可以完成的，但这需要大量的时间投入。</li>
<li>重要的是量化工作，并找到最有效的方法来组织工作。</li>
<li>这是非常并行的工作。</li>
<li>建立和记录模式允许组织中的任何开发人员提供帮助。</li>
<li>你必须接受一定程度的风险。</li>
<li>衡量进展可以让你庆祝过程中的关键里程碑。</li>
</ul>

<p>愉快的部署！</p>

                    
                    
</body>
</html>