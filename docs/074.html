<html>
<head>
<title>Deploying Azure Functions with Octopus Deploy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Octopus Deploy部署Azure函数</h1>
<blockquote>原文：<a href="https://octopus.com/blog/azure-functions#2022-07-20">https://octopus.com/blog/azure-functions#2022-07-20</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/blogimage-azurefunctions.png" class="zoom" data-title=""><img src="../Images/bf4a1bee00b97cca8a5e4d01798c1fc3.png" class="img-fluid center" alt="Azure Functions in the Cloud" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/blogimage-azurefunctions.png"/>T2】</a></p>

<p>根据许多云提供商的说法，<strong>无服务器计算</strong>应用模型是未来的发展方向(需要引用)。AWS Lambdas和Azure函数都允许你编写代码，根据它们的实际使用情况付费。虽然这意味着您现在将被迫为编写松散的代码付出代价，但它也允许您编写和交付松散耦合的服务，这些服务只在代码执行时增加您的账单，而在代码空闲时没有任何成本。</p>

<p>在Octopus Deploy，我们希望在未来几个月为AWS Lambdas提供一流的支持，所以请继续关注他们的到来。事实证明，Azure功能基本上只是在引擎盖下的Azure Web应用程序，上面有一些额外的处理程序，所以我们现有的<strong>部署Azure Web应用程序的步骤仍然符合要求。</strong></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/web_app_step.png" class="zoom" data-title=""><img src="../Images/9b7d4d925ef61054612526cb170f9635.png" class="img-fluid center" alt="WebAppStep" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/web_app_step.png"/>T2】</a></p>

<p>为了证明这一点，并表明我并没有试图避免添加新的Azure函数步骤，让我们来看看如何通过Octopus Deploy构建和部署一个基本的Azure函数。</p>

<h2 id="create-and-package-a-simple-azure-function-project">创建并打包一个简单的Azure函数项目</h2>

<p>对于我们简单的Azure函数，我们将创建一个HTTP触发的端点，它返回一个JSON有效负载，其中包含一些我们希望Octopus在部署期间提供的值。</p>

<h3 id="visual-studio-project">Visual Studio项目</h3>

<p>如果您通过Visual Studio创建函数，请确保您拥有<a href="https://www.visualstudio.com/vs/" rel="nofollow"> Visual Studio 2017 v15.4 </a>或更高版本，其中包括Azure SDKs。</p>

<p>创建一个新项目并选择<code>Azure Functions</code>项目类型。右击项目，<strong>添加新项目</strong>，添加一个<strong> Azure函数</strong>。</p>

<p>用以下内容替换生成的类:</p>

<pre><code class="language-C#">    public static class ReticulateSplines
    {
        [FunctionName("ReticulateSplines")]
        public static async Task&lt;HttpResponseMessage&gt; Run([HttpTrigger(AuthorizationLevel.Function, "get", Route = null)]
            HttpRequestMessage req, TraceWriter log)
        {
            log.Info("Incoming Request request.");
            var myName = Environment.GetEnvironmentVariable("MyName", EnvironmentVariableTarget.Process);
            var release = Environment.GetEnvironmentVariable("Release", EnvironmentVariableTarget.Process);
            var reponse = new {Message = $"Hello {myName}", Release = release};
            return req.CreateResponse(HttpStatusCode.OK, reponse);
        }
    }
</code></pre>

<p>当被调用时，这个函数将提取名为<code>MyName</code>和<code>Release</code>的变量，并在JSON响应中将它们返回给用户。</p>

<p>在解决方案资源管理器中打开<code>local.settings.json</code>文件，并添加以下属性:</p>

<pre><code class="language-json">{
  "IsEncrypted": false,
  "Values": {
    "MyName": "Steve",
    "Release":  "0.0.0"
  }
}
</code></pre>

<p>这些值在本地开发过程中使用。如果您从Visual Studio运行该解决方案，Azure Functions开发环境应该会启动并提供一个本地端点，您可以用它来测试您的代码。</p>

<p>【T2 <img src="../Images/860d2aa8b24d8c93af8e9b816bd34267.png" class="img-fluid center" alt="Running Azure Developer SDK" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/console.png"/></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/localhost_browser.png" class="zoom" data-title=""><img src="../Images/5e13502e776587b5426b2e9a5e115110.png" class="img-fluid center" alt="running localhost" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/localhost_browser.png"/>T2】</a></p>

<h3 id="package-for-octopus">章鱼包装</h3>

<p>遗憾的是，由于Azure函数项目的输出，标准的<a href="https://octopus.com/docs/packaging-applications/create-packages/octopack"> <code>OctoPack</code> </a>生成的NuGet包将无法工作。这些函数的配置文件是在构建阶段之后生成的<em>，也就是Octopack被配置为生效的时候。我们建议使用<code>dotnet publish</code>将项目发布到一个目录，然后打包生成的文件:</em></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/folder.png" class="zoom" data-title=""><img src="../Images/97daa7768bda68cd198c977b49c7ba84.png" class="img-fluid center" alt="folder" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/folder.png"/>T2】</a></p>

<p>幸运的是，由于Octopus会很乐意部署任何打包到zip中的东西，我们可以利用另一个名为<a href="https://octopus.com/docs/packaging-applications/create-packages/octopus-cli"> Octopus CLI </a>的Octopus命令行工具。使用您的标准构建工具(或者甚至在本地进行测试)，确保当前工作目录集是项目目录的，并调用:</p>

<pre><code class="language-shell">dotnet publish --output bin\Release\PublishOutput --configuration Release
cd bin\Release\PublishOutput
octo pack --id=AcmeFunctions --format=zip --outFolder=./dist --version=9.14.159-pi
octo push --server=http://myoctopusserver.acme.com --apiKey=API-ABC123IS4XQUUOG9TWDXXX --package=dist/AcmeFunctions.9.14.159-pi.zip
</code></pre>

<p>替换Octopus服务器、API密钥和版本信息的相关值。或者，你可以使用我们为<a href="https://octopus.com/docs/packaging-applications/build-servers/teamcity"> TeamCity </a>、<a href="https://octopus.com/docs/packaging-applications/package-repositories/guides/nuget-repositories/tfs-azure-devops"> VSTS </a>、<a href="https://octopus.com/docs/packaging-applications/build-servers/bamboo"> Bamboo </a>或即将推出的<a href="https://www.appveyor.com" rel="nofollow"> AppVeyor </a>开发的插件，将项目的内容打包成zip文件。</p>

<h2 id="create-the-azure-function">创建Azure函数</h2>

<p>虽然我可以在一个单独的部署项目中使用<strong>部署Azure资源组</strong>步骤来构建Azure功能，但为了保持演示的简单，我将直接通过Azure门户创建该功能。</p>

<p>在门户中点击<strong>创建资源</strong>按钮，搜索<strong>功能App </strong>。填写细节并记下<code>App name</code>和<code>Resource Group</code>值，因为我们需要很快将它们添加到我们的Octopus项目中。创建功能应用程序后，将其打开，进入<strong>功能应用程序设置</strong>页面并启用插槽。这个特性目前被标记为<em>预览</em>，虽然不是必需的，但它将允许我们创建一个蓝色\绿色部署模式。采用这种策略，我们首先部署到一个插槽，并确认其配置和运行正确，然后将其与<em>生产</em>插槽交换。在这种情况下，术语<em>生产</em>不同于<em>生产环境</em>和Octopus <em>生产</em>环境。它只是指Azure功能有多个可以独立配置的端点。启用该功能后，创建一个名为<em>蓝色</em>的新插槽:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/create_function.png" class="zoom" data-title=""><img src="../Images/f5345c37a4d912b7cca18e7f8dfabc10.png" class="img-fluid center" alt="CreateFunction" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/create_function.png"/>T2】</a></p>

<h2 id="create-an-octopus-project">创建一个章鱼项目</h2>

<p>我们现在将在Octopus deploy中创建项目，该项目将使用蓝色\绿色部署策略将我们的包推送到Azure，并提供在我们的函数中使用的适当范围的变量。</p>

<blockquote class="blockquote">
<p><strong>注意:</strong>在Octopus Deploy中跨多个环境部署Azure功能的合适模型是为每个环境提供一个<strong>单独的Azure功能</strong>。这使我们能够在每个阶段安全地配置功能，而不会在环境中泄漏潜在的更改。我们建议您不要试图在一个函数上使用多个插槽来模拟环境。Azure的功能很便宜，除了在使用的时候，你不需要花费任何东西，所以没有理由像其他云资源一样，把它们“挤”在一起。</p>
</blockquote>

<h3 id="add-variables">添加变量</h3>

<p>由于我们将需要编写几个部署后步骤来处理插槽交换，因此将所有配置放入项目的变量部分允许我们将它们整合到一个地方，并在不同的环境中对它们进行调整。在标准部署生命周期的情况下，我们通常会在不同的Octopus环境中使用不同的Azure资源组和/或Azure功能应用。</p>

<p>对于我们简单的单一环境场景，这些值是:</p>

<pre><code>- AzureFunctionName = "OctoAcmeFunction"
- AzureResourceGroupName = "OctoAcmeRG"
- AzureStagingSlotName = "Blue"
- MyName = "Max Powers"
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/variables.png" class="zoom" data-title=""> T32 </a></p>

<h3 id="step-1-deploy-function">步骤1:部署功能</h3>

<p>如上所述，Azure功能有效地使用了与标准Azure Web应用相同的架构，因此我们可以在Octopus中创建一个项目，该项目使用<strong>部署Azure Web应用</strong>步骤来推送包。</p>

<p>使用上面定义的项目变量，设置资源名称和Web app。因为我们计划首先部署到暂存槽，所以这一步的Web应用程序名称采用了<code>&lt;WebAppName&gt;(&lt;SlotName&gt;)</code>的格式:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/step1_deploy.png" class="zoom" data-title=""><img src="../Images/0b91f01eef0284bddd93f23602136664.png" class="img-fluid center" alt="Step 1: Deploy Function" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/step1_deploy.png"/>T2】</a></p>

<h3 id="step-2-update-appsettings">步骤2:更新AppSettings</h3>

<p>虽然我们可以在包上传过程中对配置文件执行变量替换，但推荐的处理Azure函数配置值的方式是通过AppSettings。这些将自己作为环境变量暴露给正在运行的函数进程。</p>

<p>AppSettings还包含Azure Functions本身使用的其他环境变量，因此我们不能删除其中包含的任何值。最安全的方法是首先加载现有变量，更新我们想要更改的几个关键属性，然后更新整个集合(Azure PowerShell cmdlets不提供修改单个值的粒度方法)。</p>

<p>创建一个<strong>运行一个Azure PowerShell脚本</strong>步骤，并提供以下脚本:</p>

<pre><code class="language-powershell">function UpdateAppSettings {
 param( [string]$ResourceGroup, [string]$FunctionAppName, [string]$Slot, [hashtable]$AppSettings )

    Write-Host "Loading Existing AppSettings"
    $webApp = Get-AzureRmWebAppSlot -ResourceGroupName  $ResourceGroup -Name $FunctionAppName -Slot $Slot

    Write-Host "Applying New AppSettings"
    $hash = @{}
    ForEach ($kvp in $webApp.SiteConfig.AppSettings) {
        $hash[$kvp.Name] = $kvp.Value
    }

    ForEach ($key in $AppSettings.Keys) {
        $hash[$key] = $AppSettings[$key]
    }

    Write-Host "Saving AppSettings"
    Set-AzureRMWebAppSlot -ResourceGroupName $ResourceGroup -Name $FunctionAppName -AppSettings $hash -Slot $Slot | Out-Null
    Write-Host "AppSettings Updated"
}

UpdateAppSettings -AppSettings @{"MyName" = $OctopusParameters["MyName"]; Release = $OctopusParameters["Octopus.Release.Number"]} `
    -ResourceGroup $OctopusParameters["AzureResourceGroupName"] `
    -FunctionAppName $OctopusParameters["AzureFunctionName"] `
    -Slot $OctopusParameters["AzureStagingSlotName"]
</code></pre>

<p>请注意我们是如何提供要应用于AppSettings的Octopus变量的。这允许我们精确地知道我们的函数需要什么，而不是盲目地遍历所有的章鱼变量，并假设可能需要某些东西。</p>

<p>一旦在部署过程中运行了这个步骤和前面的步骤，蓝色的<em>插槽就会用最新的包及其变量进行更新。该功能先前部署的版本(假设这不是流程第一次运行)仍可从<em>生产</em>插槽中获得。去往<code>https://octoacmefunction.azurewebsites.net/api/ReticulateSplines</code>的所有流量仍将去往之前的版本，但是<code>https://octoacmefunction-blue.azurewebsites.net/api/ReticulateSplines</code>的端点现在将使用新的部署，我们可以对其进行测试并确保其按预期工作。下一步将交换这些插槽，这样没有插槽名称的请求就可以转到我们当前部署在<em>蓝色</em>插槽中的插槽:</em></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/live_browser.png" class="zoom" data-title=""><img src="../Images/bc3bbae52483bee05ea68ea4bf03f085.png" class="img-fluid center" alt="Live Browser" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/live_browser.png"/>T2】</a></p>

<h3 id="step-3-swapslot">第三步:互换位置</h3>

<p>还有一个为Azure Web应用程序构建的现有步骤，我们也可以很好地利用Azure函数。添加一个新步骤，并在步骤库中搜索<strong>Switch Azure Staging Deployment Slot</strong>步骤。为上述第一步中提供的<code>ResourceGroupName</code>、<code>AppName</code>和<code>SlotName</code>提供变量。对于<code>AzureAccount</code>字段，您目前需要获得您在Octopus中配置的Azure帐户的帐户ID。当你通过八达通门户网站查看帐户时，可以在URL中看到这一点。在接下来的几周内，我们预计这一需求将会消失，因为我们将为<a href="https://octopus.com/docs/projects/variables/azure-account-variables"> Azure账户</a>提供一个类型化变量，就像我们为<a href="https://octopus.com/docs/projects/variables/aws-account-variables"> AWS账户</a>所做的一样。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/step2_slot_swap.png" class="zoom" data-title=""><img src="../Images/c20147e9f3a531d66d6322fb55ef6b37.png" class="img-fluid center" alt="Step 2: Slot Swap" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/step2_slot_swap.png"/>T2】</a></p>

<p><code>SmokeTest</code>配置将命中该函数的主机地址，尽管它更适合预热Web应用程序，但确保该函数已成功部署也无妨。</p>

<h2 id="deploy">部署</h2>

<p>对于每个部署，<em>蓝色的</em>槽将作为更新目标，然后指向两个不同槽的外部指针将被交换(记住这实际上是一个<em>名称</em>交换，内容本身不会移动)。如果新的部署开始遇到问题，可以选择将插槽<em>交换回</em>，以便流量再次被传送到以前的版本(尽管我们总是鼓励尽可能使用前滚方法):</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-03/azure-functions/slot_swap.png" class="zoom" data-title=""><img src="../Images/6f238d592987b8b5bbd0dfc258395d07.png" class="img-fluid center" alt="Slot Swap" data-original-src="https://i.octopus.com/blog/2018-03/azure-functions/slot_swap.png"/>T2】</a></p>

<h2 id="azure-functions-in-octopus">Octopus中的Azure函数</h2>

<p>正如我们所见，虽然Azure函数提供了一种开发和托管代码的新机制，但底层基础设施主要是建立在Azure网站产品的基础上，因此它已经在Octopus Deploy开箱即用中工作。通过Octopus管理这些部署提供了一个简单易懂的流程，允许任何人利用这种新的<em>无服务器</em>计算方法的能力。随着我们未来计划很快为AWS Lambdas提供一流的支持，没有理由不尝试这些新产品。</p>

                    
                    
</body>
</html>