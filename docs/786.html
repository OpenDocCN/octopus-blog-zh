<html>
<head>
<title>Creating dynamic run conditions with new Octostache filters - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用新的Octostache过滤器创建动态运行条件- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/variable-run-conditions-with-octostache#2021-11-10">https://octopus.com/blog/variable-run-conditions-with-octostache#2021-11-10</a></blockquote>
                        <p>我喜欢使用的Octopus Deploy的一个特性是<a href="https://octopus.com/docs/projects/steps/conditions#variable-expressions">可变运行条件</a>。可变运行条件允许您根据业务逻辑跳过步骤。当与<a href="https://octopus.com/docs/projects/variables/output-variables">输出变量</a>结合时，它们是一个强大的工具。</p>

<p>在我们的2021.2版本中，过滤器<code>Match</code>和<code>Contains</code> <a href="https://octopus.com/docs/projects/variables/variable-filters#VariableSubstitutionSyntax-ComparisonFilters">被添加到Octostache </a>中。</p>

<p>在我们的<a href="https://octopus.com/blog/octopus-release-2021-q3">发布公告</a>中了解更多关于Octopus 2021.2 (Q3)发布的信息。</p>

<p>在这篇文章中，我将带您了解如何将可变运行条件与输出变量和新的<code>Contains</code>过滤器结合起来。</p>

<h2 id="the-scenario">场景</h2>

<p>我一直在帮助一个客户使用Octopus部署了<a href="https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/overview" rel="nofollow"> Azure虚拟机规模集</a>。可以按计划或根据指标添加或删除虚拟机。基于指标的规则的一个示例是，如果10分钟内CPU使用率为60%，则添加更多虚拟机。</p>

<p>对于我们客户的场景，需要注意的事项有:</p>

<ul>
<li>晚上，他们会缩减规模集中的虚拟机数量</li>
<li>早上，他们向规模集添加了10多台虚拟机</li>
<li>它们使用标准映像，但每个应用程序都要安装和配置额外的后端软件(IIS、MSMQ、。网等。)</li>
</ul>

<p>客户使用<a href="https://octopus.com/docs/projects/project-triggers/deployment-target-triggers">部署目标触发器</a>，在添加新的部署目标时触发部署。</p>

<h2 id="the-problem-to-solve">要解决的问题</h2>

<p>从远处看，一切看起来都很棒，并且正常工作，但是放大看，就有一个时间问题:</p>

<ul>
<li>虚拟机规模集无法同时完成所有虚拟机的设置。</li>
<li>Octopus Deploy不知道虚拟机规模集；它获取一批新的部署目标并进行部署。</li>
<li>每个应用程序需要30多分钟来完成后端软件的安装和配置。</li>
<li>默认情况下，Azure虚拟机规模集启用了过度配置。要求增加10台虚拟机，最初创建了14台。10台虚拟机成功运行后，另外4台将被删除。但是这4个用Octopus Deploy注册了自己。</li>
</ul>

<p>每天早上，扩展虚拟机数量都要花费两倍或三倍的时间。例如，如果他们将虚拟机数量从5台增加到25台，就会出现这种情况:</p>

<ol>
<li>Azure创建了27个新的虚拟机(而不是20个),并开始供应过程。</li>
<li>虚拟机上线并以分散的方式向Octopus Deploy注册。</li>
<li>Octopus Deploy中的部署目标触发器选择5到8台虚拟机并开始部署。</li>
<li>部署开始安装附加软件。</li>
<li>90–180秒后，剩余的虚拟机完成资源调配。</li>
<li>Azure移除了额外的7个虚拟机。</li>
<li>第一次部署变慢是因为这7个虚拟机中有一个在第一批中。Octopus正在等待超时发生。</li>
<li>第一次部署在30分钟后完成。</li>
<li>部署目标触发器选择剩余的机器。</li>
<li>第二次部署在虚拟机添加到虚拟机规模集后一个多小时完成。</li>
</ol>

<p>因此，客户在早上很早就开始横向扩展。他们需要确保在工作日开始时有足够的虚拟机。</p>

<h2 id="solution-requirements">解决方案要求</h2>

<p>等待一个多小时是不可接受的。虽然可以调整时间表，但由于意外负载，仍然存在伸缩问题。这时，客户问:</p>

<blockquote class="blockquote">
<p>在虚拟机规模集完成所有新虚拟机的配置时，配置Octopus以暂停部署有多难？</p>
</blockquote>

<p>经过讨论，我们确定了这些要求:</p>

<ul>
<li>Octopus应该暂停并等待虚拟机规模集完成配置。</li>
<li>应该同时配置和部署所有新的虚拟机。</li>
<li>应该跳过所有现有的虚拟机。</li>
<li>单个部署流程应该处理手动部署和由部署目标触发器创建的部署。</li>
</ul>

<h2 id="the-solution">解决方案</h2>

<p>我知道解决这个问题将使用新的<a href="https://library.octopus.com/step-templates/e04c5cd8-0982-44b8-9cae-0a4b43676adc/actiontemplate-check-vmss-provision-status-(deployment-targets)" rel="nofollow">检查VMSS供应状态</a>步骤模板(我编写该模板是为了帮助解决这个客户的问题)、<a href="https://octopus.com/docs/projects/built-in-step-templates/health-check">健康检查步骤</a>和<a href="https://octopus.com/docs/projects/steps/conditions#variable-expressions">可变运行条件</a>。</p>

<p>简化的部署流程是:</p>

<ol>
<li><strong>检查VMSS供应状态</strong>:仅在部署目标导致部署时运行</li>
<li><strong>健康检查步骤</strong>:仅在部署目标导致部署时运行</li>
<li><strong>配置网络服务器</strong></li>
<li>部署应用程序</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/high-level-deployment-process.png" class="zoom" data-title=""><img src="../Images/c0be091dc80d39edf5ad13a734c56d74.png" class="img-fluid center" alt="High-Level View of Deployment Process" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/high-level-deployment-process.png"/>T2】</a></p>

<p>此部署流程中的所有步骤都使用可变的运行条件。只有当部署目标触发器导致部署时，才需要运行步骤1和2。我将在下一节介绍第3步和第4步。</p>

<pre><code>#{unless Octopus.Deployment.Error}#{if Octopus.Deployment.Trigger.Name}True#{/if}#{/unless}
</code></pre>

<h3 id="check-vmss-provision-status">检查VMSS设置状态</h3>

<p><strong>检查VMSS供应状态</strong>是一个新的步骤模板，具有以下功能:</p>

<ul>
<li>它会一直等待，直到VMSS完成对规模集中所有虚拟机的资源调配。</li>
<li>VMSS完成资源调配后，它会使用Octopus Deploy来协调规模集中的虚拟机列表。任何其他部署目标注册都将被删除。</li>
<li>设置包含计算机名、计算机id和一个布尔值的输出变量，该值指示是否添加了新的部署目标。</li>
</ul>

<p>将该步骤添加到部署流程的顶部。</p>

<p>不要忘记将运行条件设置为之前的值。</p>

<p>【T2 <img src="../Images/8edb744056f354853efe21e98a0b6cc9.png" class="img-fluid center" alt="Check VMSS Provision Status" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/check-vmss-provision-status-step.png"/></p>

<h3 id="health-check-step">健康检查步骤</h3>

<p><strong>健康检查步骤</strong>将所有新虚拟机添加到部署中。<strong>运行状况检查步骤</strong>是我们如何将添加到规模集的所有新虚拟机部署到<em>，而不仅仅是那些导致部署目标触发器触发的虚拟机。</em></p>

<p>设置以下选项:</p>

<ul>
<li><strong>关于角色</strong>中的目标:与部署目标相同的角色。</li>
<li><strong>运行状况检查类型</strong>:执行仅连接测试(由机器策略执行的初始运行状况检查已经完成了完整的运行状况检查，因此无需再次执行)。</li>
<li><strong>健康检查错误</strong>:跳过不可用的部署目标。</li>
<li><strong>新部署目标</strong>:在部署中包含新的部署目标。</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/health-check-step.png" class="zoom" data-title=""><img src="../Images/844186c2e9349ddf1f8e952fdc408196.png" class="img-fluid center" alt="Health Check Step" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/health-check-step.png"/>T2】</a></p>

<h2 id="skipping-existing-virtual-machines">跳过现有虚拟机</h2>

<p><strong>运行状况检查步骤</strong>会将<em>规模集中的所有</em>虚拟机添加到部署中。这是一个问题，因为一个要求是在部署过程中应该跳过所有现有的虚拟机。简而言之，这种情况会发生:</p>

<ol>
<li>虚拟机规模集中的虚拟机数量从5个增加到25个。</li>
<li>部署目标触发器将看到7个新的部署目标并开始部署。</li>
<li>“检查VMSS预配状态”步骤将一直等到添加了剩余的13个部署目标。</li>
<li>运行状况检查步骤将添加新的15个部署目标和先前存在的5个部署目标。</li>
</ol>

<p><strong>健康检查步骤</strong>将触发器的部署目标数量从7个增加到25个，而不是20个(新虚拟机的数量)。我需要跳过其中的5个部署目标。</p>

<p>关于可变运行条件的一个鲜为人知的事实是，当一个步骤被配置为在一个角色上执行时，它们为每个部署目标运行。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/execution-location-is-deployment-target.png" class="zoom" data-title=""><img src="../Images/f2f1c4628c643d36f7da12831270cc91.png" class="img-fluid center" alt="step configured to execute on a role" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/execution-location-is-deployment-target.png"/>T2】</a></p>

<p>这意味着当我有25个部署目标时，它运行变量run条件25次。每当变量run condition返回<code>False,</code>时，它就会跳过那个部署目标。</p>

<p>父/子步骤或滚动部署也是如此。为了简单起见，滚动部署不在本文讨论范围之内。</p>


<p>获取部署目标ID很简单；使用<code>#{Octopus.Machine.Id}</code>。我需要一份<em>新</em>虚拟机的列表，以便与该ID进行比较。</p>

<p>这就是<a href="https://library.octopus.com/step-templates/e04c5cd8-0982-44b8-9cae-0a4b43676adc/actiontemplate-check-vmss-provision-status-(deployment-targets)" rel="nofollow">检查VMSS供应状态</a>步骤模板的用武之地。如上所述，它创建了一个输出变量，其中包含添加到虚拟机规模集的所有部署目标id的列表。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/exclude-pre-existing-servers.png" class="zoom" data-title=""><img src="../Images/207e32e6b2c53e2829dc328899b50f35.png" class="img-fluid center" alt="parameter excluding pre-existing machines" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/exclude-pre-existing-servers.png"/>T2】</a></p>

<p>在这个运行示例中，虚拟机<code>vmss-ti000020</code>已经存在，它从输出变量中排除了它。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/output-variables-pre-existing-missing.png" class="zoom" data-title=""><img src="../Images/456ee54c421eca602e3ddbfa8b353b27.png" class="img-fluid center" alt="virtual machine excluded because it is pre-existing" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/output-variables-pre-existing-missing.png"/>T2】</a></p>

<p>现在，我有了一个新创建的部署目标列表和要部署到的特定部署目标。最后一块拼图是可变运行条件。这就是新的<code>Contains</code> <a href="https://octopus.com/docs/projects/variables/variable-filters#VariableSubstitutionSyntax-ComparisonFilters">可变滤波器</a>的用武之地。</p>

<p><code>Contains</code>过滤器检查一个字符串是否包含另一个字符串。<code>Match</code>以同样的方式工作，但是它使用正则表达式。对于我的用例，正则表达式是多余的。</p>

<p>以下是完整的运行条件:</p>

<pre><code>#{unless Octopus.Deployment.Error}
    #{if Octopus.Deployment.Trigger.Name}
        #{Octopus.Action[Check VMSS Provision Status].Output.VMSSDeploymentTargetIds | Contains #{Octopus.Machine.Id} }
     #{else}
        True
     #{/if}
#{/unless}
</code></pre>

<p>运行条件是:</p>

<ol>
<li>如果有错误，那么不要运行这一步。</li>
<li>进行手动部署时，然后部署到所有部署目标。</li>
<li>当触发器导致部署时，检查当前部署目标是否在步骤模板的输出变量中。如果不是，则跳过该部署目标。</li>
</ol>

<p>继续看前面的截图，我们可以看到<code>vmss-ti000020</code>被跳过了。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/variable-run-condition-skipping-targets.png" class="zoom" data-title=""><img src="../Images/b24844c6ac2dd27d21d1ea7337b89044.png" class="img-fluid center" alt="skipped deployment target because of variable run condition" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/variable-run-condition-skipping-targets.png"/>T2】</a></p>

<p>手动部署将跳过步骤1和2，并在所有部署目标上运行步骤3和4。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/manual-deployment.png" class="zoom" data-title=""><img src="../Images/7a1daf2a488b74248a1eb97d260a5d8c.png" class="img-fluid center" alt="manual deployment" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/manual-deployment.png"/>T2】</a></p>

<h2 id="one-final-gotcha">最后一个问题</h2>

<p>在我的一些实践部署中，部署目标触发器会在完成第一次部署后的一分钟内运行第二次部署。尽管之前的部署已经部署到所有机器上，但还是发生了这种情况。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/duplicate-run-happening.png" class="zoom" data-title=""><img src="../Images/45b9f8c9a48e4a72ae9d5ab1194d30ef.png" class="img-fluid center" alt="Example of a duplicate run" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/duplicate-run-happening.png"/>T2】</a></p>

<p>那是有问题的；您不想重新部署并导致停机。谢天谢地<a href="https://library.octopus.com/step-templates/e04c5cd8-0982-44b8-9cae-0a4b43676adc/actiontemplate-check-vmss-provision-status-(deployment-targets)" rel="nofollow">检查VMSS供应状态</a>处理。它通过计算当前部署的队列时间减去前一个部署的完成时间的差值来检测重复运行。如果差值小于3分钟，则重复运行。您可以配置步骤模板来取消当前部署或让其继续进行。</p>

<p>但是这不是必需的。我们在前面配置了该步骤来删除预先存在的机器。预先存在的部署目标是在触发器触发前3分钟就存在的目标。除非您的部署花费的时间少于3分钟，否则将排除第一次运行中的所有现有部署目标。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/duplicate-run-all-machines-skipped.png" class="zoom" data-title=""><img src="../Images/64fe9fdd8d5579deeb36fe50bab0e209.png" class="img-fluid center" alt="Duplicate run skipping pre-existing machines" data-original-src="https://i.octopus.com/blog/2021-09/variable-run-conditions-with-octostache/duplicate-run-all-machines-skipped.png"/>T2】</a></p>

<p>我们预先存在的新变量过滤器与输出变量和运行条件的组合无需额外配置即可处理这种情况。对你来说，这可能是一个有争议的问题。当我在测试中向一个虚拟机规模集添加超过10个虚拟机时，往往会发生这种情况。</p>

<h2 id="conclusion">结论</h2>

<p>当您将八进制、输出变量和运行条件结合起来时，您会得到一个健壮的部署过程。Octostache中添加了<code>Contains</code>和<code>Match</code>滤镜，使得这一组合更加强大。您可以使用更容易维护的<code>Contains</code>比较，而不是索引匹配或循环。</p>

<p>如果您对如何在您的部署流程中组合八进制、输出变量和运行条件有任何疑问，请联系位于<a href="mailto:customersuccess@octopus.com" rel="nofollow">customersuccess@octopus.com</a>的客户成功团队。我们很乐意帮忙。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>