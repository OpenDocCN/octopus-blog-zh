<html>
<head>
<title>Docker on Windows and Octopus Deploy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Docker on Windows和Octopus Deploy - Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/docker-windows-octopus#2016-10-23">https://octopus.com/blog/docker-windows-octopus#2016-10-23</a></blockquote>
                        <p><strong>更新2016-08:自从本文撰写以来，Docker与Windows的集成已经取得了进展。查看我们的<a href="https://octopus.com/blog/rfc-docker-integration"> RFC帖子</a>,了解关于我们在Octopus Deploy中发展这一特性的令人兴奋的更新！</strong></p>

<p>今天，Gu宣布<a href="http://weblogs.asp.net/scottgu/docker-and-microsoft-integrating-docker-with-windows-server-and-microsoft-azure?__r=8d1b6a232c813b9">微软与Docker合作，将Docker引入Windows </a>。</p>

<blockquote>
  <p>微软和Docker正在将开源的Docker引擎与下一个版本的Windows Server集成在一起。此版本的Windows Server将包括新的容器隔离技术，并支持同时运行这两种技术。NET和这些容器中的其他应用程序类型(Node.js、Java、C++等)。开发人员和组织将能够使用Docker为Windows Server创建分布式的、基于容器的应用程序，这些应用程序利用了Docker的用户、应用程序和工具生态系统。</p>
</blockquote>

<p>多刺激啊！在过去的几个小时里，我一直在钻研Docker，以及这一声明对的未来可能意味着什么。NET应用程序部署。以下是我目前为止的想法。</p>

<h2>容器与虚拟机</h2>

<p>除了Scott的帖子，我找不到太多关于Windows Server中容器支持的信息，所以我先声明这只是推测，纯粹是假设它们的工作方式类似于Linux容器。</p>

<p>曾几何时，你只有一台物理服务器，运行着包含上百个网站的IIS。现在，随着虚拟化和云计算的兴起，我们倾向于拥有一台物理服务器，运行几十个虚拟机，每个虚拟机运行一个应用程序。</p>

<p>我们为什么要这么做？这真的是关于孤立。每个应用程序可以在不同的操作系统上运行，具有不同的系统库、不同的修补程序、不同的Windows功能(例如，安装了IIS)、不同版本的。NET运行时，等等。更重要的是，如果一个应用程序出现严重故障，导致操作系统崩溃，或者操作系统需要重启进行更新，其他应用程序不会受到影响。</p>

<p>过去，我们开始在一个版本的。NET framework(比如说3.5)，却被告知没有人会把3.5放在生产服务器上，因为在那个服务器上有49个使用3.0的应用程序可能会崩溃，并且要花很长时间来测试它们。虚拟化让我们摆脱了这些限制。</p>

<p>从部署自动化的角度来看，构建服务器编译代码，并生成准备部署的包。Octopus Deploy服务器将包推送到远程代理(即触手)进行部署。</p>

<p><img src="../Images/bbaaa65c190ac1351de8f93184d80173.png" alt="Deployment today with Octopus on virtual machines" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-10-16_at_2_32_54_am_qhfc2k.png"/></p>

<p>所以，隔离很好。但是主要的缺点是我们实际上只有一台物理服务器，每台服务器都运行相同操作系统内核的多个副本。这是一个真正的遗憾，因为这个操作系统是为多任务设计的服务器级操作系统。事实上，假设您在每个虚拟机上运行一个主应用程序，那么您的物理机器实际上运行的操作系统比运行的主应用程序还要多！</p>

<p>容器是相似的，但是不同的:只有一个内核，但是每个容器保持相对独立。有很多关于安全容器与虚拟机相比如何的争论，所以对于共享相同硬件的完全不同的客户来说，VM可能总是更受欢迎。然而，假设存在基本的信任，容器是一个很好的中间地带。</p>

<p>什么是Docker 页面很好地概述了为什么容器不同于虚拟机。我还没有看到Windows Server中的容器是如何工作的，但是在这篇文章中，我假设它们是非常相似的。</p>

<h2>Docker适合哪里</h2>

<p>Docker在这些容器之上提供了一个层，使得构建在容器中运行的图像以及共享这些图像变得更加容易。使用基于文本的<a href="https://docs.docker.com/reference/builder/">Docker文件</a>定义docker图像，该文件指定:</p>

<ul>
<li>从基础操作系统映像开始</li>
<li>准备/构建映像的命令</li>
<li>图像“运行”时要调用的命令</li>
</ul>

<p>对于一个Windows Dockerfile文件，我想它看起来会像这样:</p>

<ul>
<li>从Windows Server 2014 SP1基础映像开始</li>
<li>安装。NET 4.5.1</li>
<li>安装IIS并启用ASP.NET</li>
<li>复制动态链接库，CSS，JS等。ASP.NET web应用程序的文件</li>
<li>配置IIS应用程序池等。并启动网站</li>
</ul>

<p>因为它只是一个小的文本文件，所以您的Dockerfile可以提交给源代码控制。然后从命令行构建一个“映像”(即执行Dockerfile)，它将下载所有的二进制文件并创建一个磁盘映像供以后执行。然后，您可以在不同的机器上运行该映像的实例，或者通过Docker的Hub与其他人共享它。</p>

<p>Docker和使用这样的容器的巨大优势不仅仅在于节省内存/CPU，还在于使您在测试环境中测试的应用程序更有可能在生产环境中实际工作，因为它将以完全相同的方式配置——它是完全相同的映像。这是一件非常好的事情，将<a href="http://octopusdeploy.com/blog/build-your-binaries-once">构建二进制文件一次</a>发挥到了极致。</p>

<h2>这对章鱼意味着什么</h2>

<p>首先，记住Octopus是一个部署自动化工具，我们特别适合那些不断构建同一应用程序新版本的团队。例如，一个团队在两周的冲刺中构建一个内部web应用程序，每两周部署一个新的应用程序版本。</p>

<p>考虑到这一点，Docker和containers可能以几种不同的方式与Octopus一起使用。</p>

<h3>方法1: Docker是一个基础设施问题</h3>

<p>这可能是最基本的方法。基础架构团队将维护docker文件，并根据这些文件构建映像，然后在配置新服务器时部署它们。这将保证无论他们使用哪个托管提供商，服务器都有一个共同的基线——相同的系统库、服务包、启用的操作系统特性，等等。</p>

<p>该图像将简单地包含我们的触手服务，而不是将应用程序作为图像的一部分。结果看起来类似于Octopus现在的工作方式，事实上不需要对Octopus做任何修改。</p>

<p><img src="../Images/4c68b7fead45c24e569c7e91ae09b2ab.png" alt="Octopus/Tentacle in a world of Docker" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-10-16_at_2_33_10_am_fukefd.png"/></p>

<p>这有利于加快应用程序部署——我们只是推动应用程序二进制文件，而不是整个映像。这仍然意味着应用程序相互隔离，几乎就像在虚拟机中一样，没有开销。然而，它确实允许cruft随着时间的推移在图像中累积，所以它可能不是Docker的一个非常“纯粹”的用法。</p>

<h3>方法2:为每个部署构建一个新的映像</h3>

<p>这种方法非常不同。我们只需要在物理服务器上有一个，而不是有很多触手的副本。在部署时，我们会创建新的映像并在Docker中运行它们。</p>

<p><img src="../Images/331f3caf91de97095bee4f719cd114d2.png" alt="" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-10-16_at_2_33_16_am_iefu8y.png"/></p>

<ol>
<li>构建服务器构建代码，运行单元测试，等等。并创建一个NuGet包</li>
<li>包中包含一个Dockerfile文件，其中包含构建映像的指令</li>
<li>在部署期间，Octopus将NuGet包推送到远程机器</li>
<li>触手运行<code>docker build</code>来创建图像</li>
<li>如果实例正在运行，Tentacle会停止它，然后使用新的映像启动新的实例</li>
</ol>

<p>这样做的缺点是，由于我们每次都构建不同的图像，我们失去了Docker的一致性；每个web服务器的配置可能会稍有不同，这取决于当时各种库的最新版本。</p>

<p>从好的方面来看，我们确实获得了一些灵活性。每个应用程序可能有不同的<code>web.config</code>设置等。，Octopus可以在文件放入映像之前更改这些值。</p>

<h3>方法3:每次发布映像</h3>

<p>更好的方法可能是在过程的早期构建Docker映像，比如在构建结束时，或者在Octopus中第一次创建发布时。</p>

<p><img src="../Images/658d6a0aceaebdf03b831e60ababb7da.png" alt="Docker images in Octopus" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-10-16_at_2_33_02_am_rtueia.png"/></p>

<ol>
<li>构建服务器构建代码，运行单元测试，等等。</li>
<li>构建服务器(或者可能是Octopus)运行<code>docker build</code>并创建一个映像</li>
<li>图像被推送到Octopus或Docker Hub</li>
<li>Octopus将该图像部署到远程机器上</li>
<li>如果实例正在运行，Tentacle会停止它，然后使用新的映像启动新的实例</li>
</ol>

<p>这种方法似乎最适合Docker，并在环境之间提供了更多的一致性-生产将与UAT相同，因为它在生产中运行的映像与在UAT运行的映像完全相同。</p>

<p>有一个问题:我们将如何处理配置变更？例如，在UAT和生产环境中，我们将如何处理不同的连接字符串或API键？请记住，这些值的变化速率往往不同于应用程序二进制文件或其他将在映像中拍摄快照的文件。</p>

<p>在Docker世界中，这些设置似乎是通过在启动映像实例时将环境变量传递给<code>docker run</code>来处理的。虽然节点或Java开发人员可能习惯于使用环境变量。NET开发人员很少使用它们进行配置——我们期望从<code>web.config</code>或<code>app.config</code>获得设置。</p>

<p>还有一些其他的复杂性；目前，在部署web应用程序时，Octopus会将新版本与旧版本并行部署，对其进行配置，然后切换IIS绑定，从而减少机器的整体停机时间。使用Docker，我们需要停止旧的实例，启动新的实例，然后配置它。除非我们每次都用不同的配置构建一个新的映像(方法2)，否则停机时间将很难管理。</p>

<h2>八达通还会增值吗？</h2>

<p>是的，当然！:-)</p>

<p>Docker使得打包应用程序和运行它所需的所有依赖项变得非常容易，而且操作系统提供的容器有助于实现高度隔离。Octopus不是关于单个应用程序/机器部署的机制(触手在这方面有所帮助，但这不是Octopus的核心)。章鱼是关于整个配器的。</p>

<p>Octopus提供价值的地方是涉及多台机器或多种应用程序的部署。例如，在将新的web应用程序映像部署到Docker之前，您可能需要备份数据库。然后只将它部署到一台机器上，暂停一下进行手动验证，然后转移到其余的web服务器上。最后，为不同的应用程序部署另一个Docker映像。这些步骤的顺序很重要，有些是并行的，有些是阻塞的。Octopus将提供这些高级编排能力，无论您是部署NuGet包、Azure云包还是Docker映像。</p>

<h2>Azure云服务项目的未来？</h2>

<p>说到Azure云包，它们还会有意义吗？</p>

<p>这里有一些相似之处。有了Azure，就有了网站(只需推送一些文件，它就会在现有的虚拟机上为您托管)，或者您可以供应整个虚拟机并自己管理它们。中间是云服务，即web和工作者角色，它涉及到在每次部署时配置一个新的虚拟机，并依赖于打包在一起的应用程序和操作系统设置。老实说，在Windows Docker的世界里，很难看到这类包有任何用处。</p>

<h2>结论</h2>

<p>对于Windows来说，这是一个非常令人兴奋的变化，这意味着我们在Windows中看到的一些其他变化开始融合在一起。Docker在很大程度上依赖于Linux生态系统中的其他工具，比如包管理器，来配置实际的映像。在Windows世界中，直到最近的OneGet才出现这种情况。PowerShell DSC也很重要，尽管我确实觉得sytax对它来说还是太复杂了，无法真正被采用。</p>

<p>Octopus将如何适应Docker？时间会证明一切，但是正如你所看到的，我们有几种不同的方法可以采用，其中#3是最有可能的(已经支持#1)。随着下一款搭载Docker的Windows服务器即将上市，我们将密切关注它。</p>

                    
                    
</body>
</html>