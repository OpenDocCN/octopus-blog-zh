<html>
<head>
<title>Learn how to call the Jenkins REST API from PowerShell - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解如何从PowerShell - Octopus Deploy调用Jenkins REST API</h1>
<blockquote>原文：<a href="https://octopus.com/blog/jenkins-rest-api#2021-07-07">https://octopus.com/blog/jenkins-rest-api#2021-07-07</a></blockquote>
                        <p>虽然典型的部署工作流会看到像Jenkins这样的CI系统在Octopus中触发部署，但有时让Octopus trigger在Jenkins中构建是有用的。在这篇博文中，我们将看看如何使用REST API和PowerShell来触发Jenkins部署。</p>

<h2 id="jenkins-csrf-security">詹金斯·CSRF保安公司</h2>

<p>詹金斯有一个安全功能，防止<a href="https://support.cloudbees.com/hc/en-us/articles/219257077-CSRF-Protection-Explained" rel="nofollow">跨站点请求伪造</a>攻击，这是在<span class="path">詹金斯➜管理詹金斯➜配置全球安全➜防止跨站点请求伪造利用</span>下发现的。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-02/jenkins-rest-api/csrf.png" class="zoom" data-title=""><img src="../Images/a3d12640856c528d1955373e53184306.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-02/jenkins-rest-api/csrf.png"/>T2】</a></p>

<p>实际上，这意味着对Jenkins API的每个请求都需要在头中定义一个称为crumb的东西。要生成这个面包屑，我们需要向http://Jenkins server/Jenkins/crumbIssuer/API/JSON发出请求。</p>

<p>下面的PowerShell向您展示了如何生成面包屑:</p>

<pre><code>$user = 'user'
$pass = 'password'

# The header is the username and password concatenated together
$pair = "$($user):$($pass)"
# The combined credentials are converted to Base 64
$encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair))
# The base 64 credentials are then prefixed with "Basic"
$basicAuthValue = "Basic $encodedCreds"
# This is passed in the "Authorization" header
$Headers = @{
    Authorization = $basicAuthValue
}
# Make a request to get a crumb. This will be returned as JSON
$json = Invoke-WebRequest -Uri 'http://jenkinsserver/jenkins/crumbIssuer/api/json' -Headers $Headers
# Parse the JSON so we can get the value we need
$parsedJson = $json | ConvertFrom-Json
# See the value of the crumb
Write-Host "The Jenkins crumb is $($parsedJson.crumb)"
</code></pre>

<h2 id="rest-api-links">REST API链接</h2>

<p>现在我们有了一个crumb，我们可以用它来调用Jenkins REST API。您可以通过每个屏幕右下角的<code>REST API</code>链接找到与Jenkins系统交互的URL:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-02/jenkins-rest-api/restapi.png" class="zoom" data-title=""><img src="../Images/a709484e9ca64cba54b2556c85f584af.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-02/jenkins-rest-api/restapi.png"/>T2】</a></p>

<p>在这个例子中，我们想要触发一个Jenkins项目的构建，所以我们打开这个项目，发现<code>REST API</code>链接指向一个URL，比如http://Jenkins server/Jenkins/job/Run % 20a % 20 script/API/。如果我们打开此链接，我们会看到描述可用的常见操作的文档页面。我们特别感兴趣的是嵌入在句子<code>to programmatically schedule a new build, post to this URL.</code>中的链接，该链接将我们带到一个URL，如http://Jenkins server/Jenkins/job/Run % 20a % 20 script/build。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-02/jenkins-rest-api/restapidocs.png" class="zoom" data-title=""><img src="../Images/8e4602763849234ed36d2dd057ca2d71.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-02/jenkins-rest-api/restapidocs.png"/>T2】</a></p>

<h2 id="triggering-the-build">触发构建</h2>

<p>我们现在有了触发构建所需的链接和Jenkins在每个API请求中需要的信息。让我们完成PowerShell脚本，该脚本发出在Jenkins中开始构建的最后一个请求:</p>

<pre><code>$user = 'user'
$pass = 'password'

# The header is the username and password concatenated together
$pair = "$($user):$($pass)"
# The combined credentials are converted to Base 64
$encodedCreds = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes($pair))
# The base 64 credentials are then prefixed with "Basic"
$basicAuthValue = "Basic $encodedCreds"
# This is passed in the "Authorization" header
$Headers = @{
    Authorization = $basicAuthValue
}
# Make a request to get a crumb. This will be returned as JSON
$json = Invoke-WebRequest -Uri 'http://jenkinsserver/jenkins/crumbIssuer/api/json' -Headers $Headers
# Parse the JSON so we can get the value we need
$parsedJson = $json | ConvertFrom-Json
# See the value of the crumb
Write-Host "The Jenkins crumb is $($parsedJson.crumb)"
# Extract the crumb filed from the returned json, and assign it to the "Jenkins-Crumb" header
$BuildHeaders = @{
    "Jenkins-Crumb" = $parsedJson.crumb
    Authorization = $basicAuthValue
}
Invoke-WebRequest -Uri "http://jenkinsserver/jenkins/job/Run%20a%20script/build" -Headers $BuildHeaders -Method Post
</code></pre>

<p>运行该脚本将显示crumb值，以及启动作业的API调用的结果。注意，结果是一个HTTP 201代码。此代码表示在Jenkins服务器上创建了一个作业:</p>

<pre><code>PS C:\Users\Matthew\Desktop&gt; .\jenkins.ps1
The Jenkins crumb is 574608b1e95315787b2fa0b74fce2441


StatusCode        : 201
StatusDescription : Created
Content           : {}
RawContent        : HTTP/1.1 201 Created
                    Date: Tue, 19 Feb 2019 04:46:46 GMT
                    Server: Apache
                    X-Frame-Options: SAMEORIGIN
                    X-Content-Type-Options: nosniff
                    Location: http://jenkinsserver/jenkins/queue/item/11/
                    Content-L...
Headers           : {[Date, System.String[]], [Server, System.String[]], [X-Frame-Options, System.String[]], [X-Content-Type-Options, System.String[]]...}
RawContentLength  : 0
RelationLink      : {}
</code></pre>

                    
                    
</body>
</html>