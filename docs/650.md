# 安全模式更新——接近零停机时间的数据库部署——Octopus 部署

> 原文：<https://octopus.com/blog/safe-schema-updates-7-near-zero-downtime-deployments>

这篇博文是我的安全模式更新系列的第 7 部分。本系列其他文章的链接如下:

**批评现有系统:**

**想象更好的系统:**

**构建更好的系统:**

小的、频繁的和简单的改变更安全。大的、不频繁的和复杂的变化更危险。如果你不同意，从头重新阅读这个系列，从我的关于数据库交付地狱的[帖子](https://octopus.com/blog/safe-schema-updates-1-delivery-hell)开始。

数据库很少孤立存在。在修改数据库模式时，我们通常需要考虑依赖关系。数据库通常服务于前端应用程序/服务，这意味着模式更改通常需要与其他系统的更改相协调。

可能需要停机一段时间，因为我们不能冒险提供不匹配的版本:

1.  系统离线
2.  所有的变更都是一次/按顺序部署的
3.  系统恢复在线

在整个过程中，我们的用户被锁定。

有一百种方式会导致糟糕的结局。凤凰计划就是这样一场灾难。数据库更新花费的时间比预期的长，关键系统无法按时恢复。

尽管有风险，但是如果我们有数据库模式，避免对模式进行更改是不明智的。随着时间的推移，这种僵化的策略会导致糟糕的体系结构，不能反映不断发展的业务需求。

我们的目标是使模式能够安全地发展。因此，我们需要确保小规模且经常地执行此类部署。

不幸的是，每次部署所需的停机时间越长，我们就越不可能做到这一点。如果每次部署都需要一个小时的停机时间，我们永远不会一天部署 10 次。

更有可能的是，工程师将需要提前做好计划，并玩弄政治来协商一些停机时间。可能是一夜之间。(疲惫的员工并不以他们的可靠性、对细节的关注或解决问题的能力而闻名。)

由于这些机会不会经常出现，所以变化会分批出现。尽可能多的更改将被塞进尽可能短的窗口中。

这…太愚蠢了。(见开篇段落。)

不可避免的结论是:我们必须在尽可能短的停机时间内执行模式更改。只有通过最小化停机时间，我们才能增加部署频率，降低部署规模/复杂性，并交付更安全的模式更新。

根据我的经验，对于所有关于源代码控制和部署自动化的讨论，最小化停机时间的必要性并没有被那些拥有数据库模式并希望保护它们安全的人所理解。

这篇文章不是关于模式更新的自动化或执行的——还有许多关于这个的文章。这篇文章是关于最小化停机时间的模式。

## 重载术语:部署和发布

许多人交替使用“发布”和“部署”这两个词，没有考虑它们之间的区别。

如果您使用 Octopus Deploy(或类似的产品),那么您对“发布”的理解可能是工具中常见命名约定的结果。在大多数部署自动化工具中,“发布”是您的源代码的一个特定版本，一组配置变量，以及一组需要运行来执行“部署”的步骤。您可能会认为“发布”是被“部署”的东西。首先发布，然后部署。这对你来说很自然。

你是少数。

对大多数人来说，特别是对任何营销人员来说，“发布”是不同的。“发布”你的软件的一个新版本，或者最新的 iPhone，或者新的 Adele 专辑，就是要让它可用，并告诉人们。这个东西是预先创建的，后来才发布。最新的詹姆斯·邦德电影制作于 2020 年，但上映时间推迟到 2021 年。

当谈到零停机部署时，我们倾向于以第二种方式使用“发布”。部署是关于做出改变，但是发布是关于向我们的用户揭示那些改变。当我在这篇文章中使用“发布”时，我不是指部署的准备，我是指让用户看到更新。

区分部署变更和向用户发布/展示这些变更是至关重要的。这两件事不需要同时发生。事实上，正是分离这些事件的能力实现了零停机发布，以及其他各种令人兴奋的实践，如生产中的测试和一些快速回滚模式。

## 应用零停机模式

这篇文章是关于数据库部署的，但是数据库并不是孤立存在的。我们需要从一些背景开始。

支持零停机时间(更准确地说，接近零停机时间)的应用程序部署模式通常分为两类:

*   基于基础设施
*   基于应用的

### 基于基础设施的部署模式

**基于基础设施的**技术包括[蓝/绿](https://martinfowler.com/bliki/BlueGreenDeployment.html)部署、[金丝雀释放](https://martinfowler.com/bliki/CanaryRelease.html)，以及集群免疫系统。它们通常基于巧妙的负载平衡技巧。新代码被部署在新的基础设施上，经过测试，并被添加到轮换中。

通过更改我们的负载平衡器中的设置，我们可以将流量发送到新的或旧的基础架构。这潜在地允许我们逐渐“发布”新版本。首先是 1%的生产流量，然后是 5%，10%，随着我们观察遥测数据、我们的社交媒体渠道和/或我们的支持票来检查一切是否顺利运行，逐渐节流。

如果一切顺利，该版本将逐步在全球推广。如果没有，我们可以通过撤销负载平衡器上的设置来立即恢复到旧版本。我们避免了任何就地升级，因此旧服务器仍在运行，并准备好在需要时接收全部负载。

### 基于应用程序的部署模式

**基于应用的**方法倾向于基于[特征切换/标记](https://martinfowler.com/articles/feature-toggles.html)。旧版本和新版本将被并排部署，但是哪个版本被执行可以通过代码和一些外部数据库来管理。

例如，也许我们已经有一个*特性切换*数据库在生产中运行。部署我们的新代码后，每次调用应用程序中的方法时，它都会查询 *featuretoggle* 数据库，以确定是否启用了某些功能。根据响应，它可以运行一个代码块或另一个代码块。也许 *featuretoggle* 数据库可以通过指示应用程序在 x%的时间内使用新代码来抑制首次展示。

这允许通过更改外部数据库中的设置来发布或回滚新功能。不需要额外的部署。

我们可以更进一步。也许，如果我们有一个新特性，但我们关心性能，我们可以运行两个代码块，但只在 UI 中显示旧的功能。这被称为黑暗启动，它允许工程师用现场生产工作负载测试他们的代码的性能，用一种简单的方法来调节或关闭新代码。

你可以在 [Deploy！=释放](https://blog.turbinelabs.io/deploy-not-equal-release-part-one-4724bc1e726b)。这也在[devo PS 手册](https://octopus.com/blog/devops-reading-list#handbook)中有更详细的介绍。

基于基础设施的模式和基于应用程序的模式的共同点是，首先部署代码，然后以受控和可测试的方式发布，允许快速、几乎即时的回滚。

这对数据库意味着什么？**向前向后兼容至关重要。**

## 扩展/收缩，向前和向后兼容

如果我们希望在数据库中进行会影响我们的相关服务的模式更改，并且如果我们希望避免计划内停机，我们可能会遵循上面讨论的基于应用程序或基础设施的模式之一。无论哪种情况，我们都需要通过三个阶段来发展数据库。

1.  **扩展:**对数据库的附加更改，以支持相关应用程序的新旧版本。
2.  **部署:**部署、测试和发布新版本的应用程序。理想情况下是这个顺序。
3.  契约:在首次展示之后，我们可以安全地删除旧的模式对象。

这个单一的大的重构需要多个小的模式变化。为了避免计划停机，每个变更必须具有以下属性:

*   可以独立于其他步骤或任何其他依赖项来执行
*   产生最小的风险
*   具有快速回滚选项(这可以避免数据丢失或重要和必要的数据处理，这可能会导致各种问题)

用一个例子来解释最简单:考虑将一个 *fullName* 列拆分成单独的 *firstName* 和 *lastName* 列。我们可以在没有任何危险的停机窗口或可怕的模式更新的情况下实现这一点，如下所示:

**展开:**

1.  新列被添加到数据库中。(这没什么风险。)
2.  如果使用存储过程来添加/更新/删除数据，则可以更新这些存储过程，以便添加/更新/删除旧列和新列。
3.  现有数据在后台逐渐迁移。(这可以是无明显性能影响的滴加，如果有任何问题，可以暂停或停止该过程。)

现在数据库支持这两个版本。

**卷展栏:**

1.  当旧列和新列中的数据可靠地同步时，任何读取的存储过程都可以指向新列。
2.  如果应用程序直接引用列，而不是通过存储过程，那么使用上述的一种基础设施或基于应用程序的模式来部署新的应用程序版本。

现在新的东西在全球发行。

**合同:**

1.  理论上，我们可以删除旧列。然而，在有许多缺乏文档记录的依赖项的系统中，我们总是有可能遗漏一些东西。最好先重命名旧列。(并更新任何更新了旧列的存储过程。)如果有人抱怨，我们可以通过恢复任何存储过程的旧版本，立即用另一个重命名来修复它。
2.  在这两种情况下，经过一段时间后，我们应该安排删除旧列。没有人需要看到数百个附加了`_toDelete`的对象。(提示:试试`_ToDeleteOn2021-12-01`吧。它在一定程度上集中了人们的思想，我们甚至可以包装一些自动化的过程来备份和挑选旧的对象。)

重构完成。只要按照这个顺序执行这些步骤，每个步骤都可以单独执行。这些步骤都没有产生巨大的风险。如果有任何错误，每一步都可以很容易地恢复。

## 摘要

这是更新模式的一种更安全的方式。至关重要的是，由于它不需要任何停机时间，这些变更不需要批量发布。

可能会有一些读到这里的人认为这需要更长的时间。恐怕这些人仍然在考虑小的改变需要很长的准备时间。也许他们正在考虑变更审批委员会，或者他们正在为每一步设想单独的 JIRA 入场券。也许他们正在考虑对每一步进行单独的为期一周的测试。

忘掉这一切。

如果这个重构需要批准，它应该作为一个整体来审查，即使它是分步执行的。并且大多数测试和部署管道应该是自动化的。

是的:这个更难。没人说这会很容易。我们正在优化安全性，这需要严谨和努力。

当然，依赖关系越多，这就越难。有些人可能认为这不可行。当然，这个过程需要在任何依赖系统中进行一定程度的防御性编程和测试/遥测。

在理想的世界中，我们将与松散耦合的系统一起工作(参见我的系列文章的第 4 部分和第 5 部分的[和](https://octopus.com/blog/safe-schema-updates-4-loose-coupling-mitigates-tech-problems)[)。默认情况下，这些代码是防御性的，对数据库的依赖性大大降低。使这一切变得容易得多的属性。](https://octopus.com/blog/safe-schema-updates-5-loose-coupling-mitigates-human-problems)

如果您的系统是紧耦合的，也许现在您已经看到了松耦合的巨大好处。也许你也被眼前挑战的艰巨性吓到了:将你错综复杂的依赖关系网进化成更安全的东西。

## 下次

下一次，我们通过探索扼杀者模式来结束这个系列。一种安全重构复杂、紧密耦合系统的方法。

本系列其他文章的链接如下:

**批判现有系统:**

**想象更好的系统:**

**构建更好的系统:**

## 观看网络研讨会

我们的第一次网络研讨会讨论了松耦合架构如何带来可维护性、创新性和安全性。第二部分讨论了如何将一个成熟的系统从一种架构转换到另一种架构。

### 数据库开发:想象更好的系统

[https://www.youtube.com/embed/oJAbUMZ6bQY](https://www.youtube.com/embed/oJAbUMZ6bQY)

VIDEO

### 数据库开发:构建更好的系统

[https://www.youtube.com/embed/joogIAcqMYo](https://www.youtube.com/embed/joogIAcqMYo)

VIDEO

愉快的部署！