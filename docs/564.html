<html>
<head>
<title>Creating a Kubernetes Operator with Kotlin - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Kotlin - Octopus Deploy创建Kubernetes操作员</h1>
<blockquote>原文：<a href="https://octopus.com/blog/operators-with-kotlin#2021-08-12">https://octopus.com/blog/operators-with-kotlin#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-02/operators-with-kotlin/java-octopus.png" class="zoom" data-title=""><img src="../Images/6784f28ce8a15a8220da17a417cdd782.png" class="img-fluid center" alt="Creating a Kubernetes Operator with Kotlin" data-original-src="https://i.octopus.com/blog/2020-02/operators-with-kotlin/java-octopus.png"/>T2】</a></p>

<p>大多数环境最初会将其Kubernetes集群视为编排容器和配置容器间流量的工具。Kubernetes通过提供所需容器状态及其连接的声明性描述，很好地支持了这个用例。</p>

<p>当以这种方式使用时，开发人员和操作人员坐在集群之外，向内看。集群是通过对<code>kubectl</code>的调用来管理的，这些调用是以特别的方式或从CI/CD管道发出的。这意味着Kubernetes本身是相当天真的；它知道如何重新配置自己以匹配所需的状态，但它不知道该状态代表什么。</p>

<p>例如，一个常见的Kubernetes部署可能会创建三个pod:一个前端web应用程序、一个后端web服务和一个数据库。开发人员很好地理解了这些pod之间的关系，将它们部署为经典的三层架构，但是Kubernetes实际上只看到了三个要部署、监控和暴露于网络流量的pod。</p>

<p>operator模式已经发展成为一种在Kubernetes集群本身中封装业务知识和操作工作流的方式，允许一个集群使用公共的低级资源(如pods、服务和部署等)来实现高级的、特定于领域的概念。</p>

<p>该术语最初是由Brandon Philips在博客文章<a href="https://coreos.com/blog/introducing-operators.html" rel="nofollow">中提出的，他给出了如下定义:</a></p>

<blockquote class="blockquote">
<p>它建立在基本的Kubernetes资源和控制器概念的基础上，但是包含了用于自动化常见任务的领域或应用程序特定的知识。</p>
</blockquote>

<p>该定义中确定的三个关键组成部分是:</p>

<ul>
<li>资源</li>
<li>控制器</li>
<li>特定于领域或应用的知识</li>
</ul>

<p>实际上，<em>资源</em>意味着自定义资源定义(CRD)，<em>控制器</em>意味着集成到Kubernetes API并对其做出响应的应用，<em>应用特定知识</em>是在<em>控制器</em>中实现的逻辑，以具体化来自标准Kubernetes资源的高级概念。</p>

<p>为了理解操作符模式，让我们看一个用Kotlin编写的简单例子。这个操作符的代码可以从<a href="https://github.com/OctopusSamples/KotlinK8SOperator" rel="nofollow"> GitHub </a>获得，它基于这个<a href="https://developers.redhat.com/blog/2019/10/07/write-a-simple-kubernetes-operator-in-java-using-the-fabric8-kubernetes-client/" rel="nofollow"> RedHat博客</a>的代码。运营商将使用带有<code>WebServer</code> CRD的web服务器和控制器的概念来扩展Kubernetes集群，该控制器使用已知的映像来构建pod，以公开一个示例web服务器。</p>

<p>CRD满足<em>资源</em>需求，我们将编写的与Kubernetes API交互的代码满足<em>控制器</em>需求，并且特定Docker映像用于公开样本web服务器的知识是<em>应用特定知识</em>。</p>

<h2 id="the-pom.xml-file">pom.xml文件</h2>

<p>我们从Maven <code>pom.xml</code>文件开始。该文件定义了Kotlin本身和<a href="https://github.com/fabric8io/kubernetes-client" rel="nofollow"> fabric8 Kubernetes客户端库</a>所需的依赖关系。完整的<code>pom.xml</code>文件如下所示:</p>

<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.octopus&lt;/groupId&gt;
    &lt;artifactId&gt;kotlink8soperator&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;kotlin.version&gt;1.3.61&lt;/kotlin.version&gt;
        &lt;version.fabric8.client&gt;4.7.0&lt;/version.fabric8.client&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
            &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
            &lt;version&gt;${kotlin.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.fabric8&lt;/groupId&gt;
            &lt;artifactId&gt;kubernetes-client&lt;/artifactId&gt;
            &lt;version&gt;${version.fabric8.client}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;sourceDirectory&gt;${project.basedir}/src/main/kotlin&lt;/sourceDirectory&gt;
        &lt;testSourceDirectory&gt;${project.basedir}/src/test/kotlin&lt;/testSourceDirectory&gt;

        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
                &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;${kotlin.version}&lt;/version&gt;

                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;compile&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;

                    &lt;execution&gt;
                        &lt;id&gt;test-compile&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;test-compile&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<h2 id="anatomy-of-a-kubernetes-resource">剖析库伯内特斯资源</h2>

<p>在深入研究Kotlin代码之前，我们需要了解所有Kubernetes资源的公共结构。下面是YAML对部署资源的定义，我们将以此为例:</p>

<pre><code class="language-YAML">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
status:
  availableReplicas: 2
  observedGeneration: 1
  readyReplicas: 2
  replicas: 2
  updatedReplicas: 2
</code></pre>

<p>这种资源可以分为四个部分。</p>

<p>第一个组件是组、版本和种类(GVK)。部署资源有一组<code>apps</code>，一个版本的<code>v1</code>，一种<code>Deployment</code>:</p>

<pre><code class="language-YAML">apiVersion: apps/v1
kind: Deployment
</code></pre>

<p>第二个组成部分是元数据。这是定义标签、注释、名称和命名空间的地方:</p>

<pre><code class="language-YAML">metadata:
  name: nginx-deployment
  labels:
    app: nginx
</code></pre>

<p>第三个组件是规范，它定义了特定资源的属性:</p>

<pre><code class="language-YAML">spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
</code></pre>

<p>第四个组成部分是地位。该组件中的详细信息由Kubernetes生成，以反映资源的当前状态:</p>

<pre><code class="language-YAML">status:
  availableReplicas: 2
  observedGeneration: 1
  readyReplicas: 2
  replicas: 2
  updatedReplicas: 2
</code></pre>

<h2 id="the-crd-classes">CRD班级</h2>

<p>现在我们知道了构成Kubernetes资源的组件，我们可以看看反映由操作者实现的CRD的代码。</p>

<p>我们正在创建一个名为<code>WebServer</code>的新CRD，它由一个名为<code>WebServer</code>的类来表示。该类有两个定义规格和状态的属性:</p>

<pre><code class="language-Kotlin">package com.octopus.webserver.operator.crd

import io.fabric8.kubernetes.client.CustomResource

data class WebServer(var spec: WebServerSpec = WebServerSpec(),
                     var status: WebServerStatus = WebServerStatus()) : CustomResource()
</code></pre>

<p>我们的CRD的规格在<code>WebServerSpec</code>类中表示。它有一个名为<code>replicas</code>的字段，指示这个CRD负责创建多少个web服务器单元:</p>

<pre><code>package com.octopus.webserver.operator.crd

import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.fabric8.kubernetes.api.model.KubernetesResource

@JsonDeserialize
data class WebServerSpec(val replicas: Int = 0) : KubernetesResource
</code></pre>

<p>我们CRD的地位是在<code>WebServerStatus</code>类中表现出来的。它包含一个名为<code>count</code>的字段，报告已经创建了多少个pod:</p>

<pre><code>package com.octopus.webserver.operator.crd

import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import io.fabric8.kubernetes.api.model.KubernetesResource

@JsonDeserialize
data class WebServerStatus(var count: Int = 0) : KubernetesResource
</code></pre>

<p>最后两个类称为<code>WebServerList</code>和<code>DoneableWebServer</code>，不包含定制属性或逻辑，是fabric8库所需的样板代码:</p>

<pre><code>package com.octopus.webserver.operator.crd

import io.fabric8.kubernetes.client.CustomResourceList

class WebServerList : CustomResourceList&lt;WebServer&gt;()
</code></pre>

<pre><code>package com.octopus.webserver.operator.crd

import io.fabric8.kubernetes.client.CustomResourceDoneable
import io.fabric8.kubernetes.api.builder.Function

class DoneableWebServer(resource: WebServer, function: Function&lt;WebServer,WebServer&gt;) :
        CustomResourceDoneable&lt;WebServer&gt;(resource, function)
</code></pre>

<h2 id="the-main-function">主要功能</h2>

<p><code>main()</code>函数是我们控制器的入口点。以下是完整的代码:</p>

<pre><code>package com.octopus.webserver.operator

import com.octopus.webserver.operator.controller.WebServerController
import com.octopus.webserver.operator.crd.WebServer
import com.octopus.webserver.operator.crd.WebServerList
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.PodList
import io.fabric8.kubernetes.api.model.apiextensions.CustomResourceDefinitionBuilder
import io.fabric8.kubernetes.client.DefaultKubernetesClient
import io.fabric8.kubernetes.client.dsl.base.CustomResourceDefinitionContext


fun main(args: Array&lt;String&gt;) {
    val client = DefaultKubernetesClient()
    client.use {
        val namespace = client.namespace ?: "default"
        val podSetCustomResourceDefinition = CustomResourceDefinitionBuilder()
                .withNewMetadata().withName("webservers.demo.k8s.io").endMetadata()
                .withNewSpec()
                .withGroup("demo.k8s.io")
                .withVersion("v1alpha1")
                .withNewNames().withKind("WebServer").withPlural("webservers").endNames()
                .withScope("Namespaced")
                .endSpec()
                .build()
        val webServerCustomResourceDefinitionContext = CustomResourceDefinitionContext.Builder()
                .withVersion("v1alpha1")
                .withScope("Namespaced")
                .withGroup("demo.k8s.io")
                .withPlural("webservers")
                .build()
        val informerFactory = client.informers()
        val podSharedIndexInformer = informerFactory.sharedIndexInformerFor(
                Pod::class.java,
                PodList::class.java,
                10 * 60 * 1000.toLong())
        val webServerSharedIndexInformer = informerFactory.sharedIndexInformerForCustomResource(
                webServerCustomResourceDefinitionContext,
                WebServer::class.java,
                WebServerList::class.java,
                10 * 60 * 1000.toLong())
        val webServerController = WebServerController(
                client,
                podSharedIndexInformer,
                webServerSharedIndexInformer,
                podSetCustomResourceDefinition,
                namespace)

        webServerController.create()
        informerFactory.startAllRegisteredInformers()

        webServerController.run()
    }
}
</code></pre>

<p>我们创建了一个<code>DefaultKubernetesClient</code>，它允许我们访问Kubernetes API:</p>

<pre><code>val client = DefaultKubernetesClient()
</code></pre>

<p>客户机知道如何根据它执行的环境来配置自己。测试时，我们将在本地运行这段代码，这意味着客户端将从<code>~/.kube/config</code>文件中访问Kubernetes集群的详细信息。然后从客户端的配置中提取名称空间，或者如果没有找到名称空间设置，则设置为<code>default</code>:</p>

<pre><code>val namespace = client.namespace ?: "default"
</code></pre>

<p><code>CustomResourceDefinitionBuilder</code>定义了该控制器管理的<code>WebServer</code> CRD。这在与客户端一起更新群集中的资源时使用。</p>

<pre><code>val podSetCustomResourceDefinition = CustomResourceDefinitionBuilder()
        .withNewMetadata().withName("webservers.demo.k8s.io").endMetadata()
        .withNewSpec()
        .withGroup("demo.k8s.io")
        .withVersion("v1alpha1")
        .withNewNames().withKind("WebServer").withPlural("webservers").endNames()
        .withScope("Namespaced")
        .endSpec()
        .build()
</code></pre>

<p>控制器通过监听指示它应该管理的资源已经改变的事件来工作。为了监听与<code>WebServer</code> CRD相关的事件，我们创建了一个<code>CustomResourceDefinitionContext</code>:</p>

<pre><code>val webServerCustomResourceDefinitionContext = CustomResourceDefinitionContext.Builder()
        .withVersion("v1alpha1")
        .withScope("Namespaced")
        .withGroup("demo.k8s.io")
        .withPlural("webservers")
        .build()
</code></pre>

<p>我们通过通知者得到事件通知，而通知者是从客户提供的工厂创建的:</p>

<pre><code>val informerFactory = client.informers()
</code></pre>

<p>在这里，我们创建一个通知程序，通知我们与pod相关的事件。因为pods是Kubernetes中的标准资源，所以创建这个informer不需要<code>CustomResourceDefinitionContext</code>:</p>

<pre><code>val podSharedIndexInformer = informerFactory.sharedIndexInformerFor(
        Pod::class.java,
        PodList::class.java,
        10 * 60 * 1000.toLong())
</code></pre>

<p>在这里，我们创建一个线人，它会通知我们与CRD相关的事件。这需要之前创建的<code>CustomResourceDefinitionContext</code>:</p>

<pre><code>val webServerSharedIndexInformer = informerFactory.sharedIndexInformerForCustomResource(
        webServerCustomResourceDefinitionContext,
        WebServer::class.java,
        WebServerList::class.java,
        10 * 60 * 1000.toLong())
</code></pre>

<p>操作符的逻辑包含在控制器中。在这个项目中，<code>WebServerController</code>类完成了控制器的角色:</p>

<pre><code>val webServerController = WebServerController(
        client,
        podSharedIndexInformer,
        webServerSharedIndexInformer,
        podSetCustomResourceDefinition,
        namespace)
</code></pre>

<p>控制器在<code>create()</code>方法中链接事件处理程序，我们开始监听事件，然后通过调用<code>run()</code>方法进入协调循环:</p>

<pre><code>webServerController.create()
informerFactory.startAllRegisteredInformers()

webServerController.run()
</code></pre>

<h2 id="the-controller">控制器</h2>

<p><code>WebServerController</code>类在我们的操作符中实现控制器。它的工作是监听Kubernetes资源的变化，并使当前状态与期望状态相一致。该类的完整代码如下所示:</p>

<pre><code>package com.octopus.webserver.operator.controller

import com.octopus.webserver.operator.crd.DoneableWebServer
import com.octopus.webserver.operator.crd.WebServer
import com.octopus.webserver.operator.crd.WebServerList
import io.fabric8.kubernetes.api.model.OwnerReference
import io.fabric8.kubernetes.api.model.Pod
import io.fabric8.kubernetes.api.model.PodBuilder
import io.fabric8.kubernetes.api.model.apiextensions.CustomResourceDefinition
import io.fabric8.kubernetes.client.KubernetesClient
import io.fabric8.kubernetes.client.informers.ResourceEventHandler
import io.fabric8.kubernetes.client.informers.SharedIndexInformer
import io.fabric8.kubernetes.client.informers.cache.Cache
import io.fabric8.kubernetes.client.informers.cache.Lister
import java.util.*
import java.util.AbstractMap.SimpleEntry
import java.util.concurrent.ArrayBlockingQueue


class WebServerController(private val kubernetesClient: KubernetesClient,
                          private val podInformer: SharedIndexInformer&lt;Pod&gt;,
                          private val webServerInformer: SharedIndexInformer&lt;WebServer&gt;,
                          private val webServerResourceDefinition: CustomResourceDefinition,
                          private val namespace: String) {
    private val APP_LABEL = "app"
    private val webServerLister = Lister&lt;WebServer&gt;(webServerInformer.indexer, namespace)
    private val podLister = Lister&lt;Pod&gt;(podInformer.indexer, namespace)
    private val workQueue = ArrayBlockingQueue&lt;String&gt;(1024)

    fun create() {
        webServerInformer.addEventHandler(object : ResourceEventHandler&lt;WebServer&gt; {
            override fun onAdd(webServer: WebServer) {
                enqueueWebServer(webServer)
            }

            override fun onUpdate(webServer: WebServer, newWebServer: WebServer) {
                enqueueWebServer(newWebServer)
            }

            override fun onDelete(webServer: WebServer, b: Boolean) {}
        })

        podInformer.addEventHandler(object : ResourceEventHandler&lt;Pod&gt; {
            override fun onAdd(pod: Pod) {
                handlePodObject(pod)
            }

            override fun onUpdate(oldPod: Pod, newPod: Pod) {
                if (oldPod.metadata.resourceVersion == newPod.metadata.resourceVersion) {
                    return
                }
                handlePodObject(newPod)
            }

            override fun onDelete(pod: Pod, b: Boolean) {}
        })
    }

    private fun enqueueWebServer(webServer: WebServer) {
        val key: String = Cache.metaNamespaceKeyFunc(webServer)
        if (key.isNotEmpty()) {
            workQueue.add(key)
        }
    }

    private fun handlePodObject(pod: Pod) {
        val ownerReference = getControllerOf(pod)

        if (ownerReference?.kind?.equals("WebServer", ignoreCase = true) != true) {
            return
        }

        webServerLister
                .get(ownerReference.name)
                ?.also { enqueueWebServer(it) }
    }

    private fun getControllerOf(pod: Pod): OwnerReference? =
            pod.metadata.ownerReferences.firstOrNull { it.controller }

    private fun reconcile(webServer: WebServer) {
        val pods = podCountByLabel(APP_LABEL, webServer.metadata.name)
        val existingPods = pods.size

        webServer.status.count = existingPods
        updateStatus(webServer)

        if (existingPods &lt; webServer.spec.replicas) {
            createPod(webServer)
        } else if (existingPods &gt; webServer.spec.replicas) {
            kubernetesClient
                    .pods()
                    .inNamespace(webServer.metadata.namespace)
                    .withName(pods[0])
                    .delete()
        }
    }

    private fun updateStatus(webServer: WebServer) =
            kubernetesClient.customResources(webServerResourceDefinition, WebServer::class.java, WebServerList::class.java, DoneableWebServer::class.java)
                    .inNamespace(webServer.metadata.namespace)
                    .withName(webServer.metadata.name)
                    .updateStatus(webServer)

    private fun podCountByLabel(label: String, webServerName: String): List&lt;String&gt; =
            podLister.list()
                    .filter { it.metadata.labels.entries.contains(SimpleEntry(label, webServerName)) }
                    .filter { it.status.phase == "Running" || it.status.phase == "Pending" }
                    .map { it.metadata.name }

    private fun createPod(webServer: WebServer) =
            createNewPod(webServer).let { pod -&gt;
                kubernetesClient.pods().inNamespace(webServer.metadata.namespace).create(pod)
            }

    private fun createNewPod(webServer: WebServer): Pod =
            PodBuilder()
                    .withNewMetadata()
                    .withGenerateName(webServer.metadata.name.toString() + "-pod")
                    .withNamespace(webServer.metadata.namespace)
                    .withLabels(Collections.singletonMap(APP_LABEL, webServer.metadata.name))
                    .addNewOwnerReference()
                    .withController(true)
                    .withKind("WebServer")
                    .withApiVersion("demo.k8s.io/v1alpha1")
                    .withName(webServer.metadata.name)
                    .withNewUid(webServer.metadata.uid)
                    .endOwnerReference()
                    .endMetadata()
                    .withNewSpec()
                    .addNewContainer().withName("nginx").withImage("nginxdemos/hello").endContainer()
                    .endSpec()
                    .build()

    fun run() {
        blockUntilSynced()
        while (true) {
            try {
                workQueue
                        .take()
                        .split("/")
                        .toTypedArray()[1]
                        .let { webServerLister.get(it) }
                        ?.also { reconcile(it) }
            } catch (interruptedException: InterruptedException) {
                // ignored
            }
        }
    }

    private fun blockUntilSynced() {
        while (!podInformer.hasSynced() || !webServerInformer.hasSynced()) {}
    }
}
</code></pre>

<p><code>create()</code>方法将匿名类指定为informer事件处理程序。事件处理器通过调用<code>enqueueWebServer()</code>或<code>handlePodObject()</code>来识别需要处理的<code>WebServer</code> CRDs的实例:</p>

<pre><code>fun create() {
        webServerInformer.addEventHandler(object : ResourceEventHandler&lt;WebServer&gt; {
            override fun onAdd(webServer: WebServer) {
                enqueueWebServer(webServer)
            }

            override fun onUpdate(webServer: WebServer, newWebServer: WebServer) {
                enqueueWebServer(newWebServer)
            }

            override fun onDelete(webServer: WebServer, b: Boolean) {}
        })

        podInformer.addEventHandler(object : ResourceEventHandler&lt;Pod&gt; {
            override fun onAdd(pod: Pod) {
                handlePodObject(pod)
            }

            override fun onUpdate(oldPod: Pod, newPod: Pod) {
                if (oldPod.metadata.resourceVersion == newPod.metadata.resourceVersion) {
                    return
                }
                handlePodObject(newPod)
            }

            override fun onDelete(pod: Pod, b: Boolean) {}
        })
    }
</code></pre>

<p><code>enqueueWebServer()</code>创建一个标识<code>WebServer</code> CRD的关键字，并将其添加到<code>workQueue</code>:</p>

<pre><code>private fun enqueueWebServer(webServer: WebServer) {
    val key: String = Cache.metaNamespaceKeyFunc(webServer)
    if (key.isNotEmpty()) {
        workQueue.add(key)
    }
}
</code></pre>

<p><code>handlePodObject()</code>首先通过ownerReference确定pod是否由<code>WebServer</code>管理。如果是，通过调用<code>enqueueWebServer()</code>将所属<code>WebServer</code>添加到<code>workQueue</code>中:</p>

<pre><code>private fun handlePodObject(pod: Pod) {
    val ownerReference = getControllerOf(pod)

    if (ownerReference?.kind?.equals("WebServer", ignoreCase = true) != true) {
        return
    }

    webServerLister
            .get(ownerReference.name)
            ?.also { enqueueWebServer(it) }
}

private fun getControllerOf(pod: Pod): OwnerReference? =
        pod.metadata.ownerReferences.firstOrNull { it.controller }
</code></pre>

<p><code>reconcile()</code>提供逻辑，确保集群拥有与<code>WebServer</code> CRD所需数量一样多的机架。它调用<code>podCountByLabel()</code>来找出存在多少个pod，并通过调用<code>updateStatus()</code>来更新CRD的状态。如果满足要求的荚太少，就叫<code>createPod()</code>。如果有太多的pod，则删除一个。</p>

<p>通过不断地创建或删除pod来将集群推向期望的状态，我们将最终满足<code>WebServer</code> CRD的要求:</p>

<pre><code>private fun reconcile(webServer: WebServer) {
    val pods = podCountByLabel(APP_LABEL, webServer.metadata.name)
    val existingPods = pods.size

    webServer.status.count = existingPods
    updateStatus(webServer)

    if (existingPods &lt; webServer.spec.replicas) {
        createPod(webServer)
    } else if (existingPods &gt; webServer.spec.replicas) {
        kubernetesClient
                .pods()
                .inNamespace(webServer.metadata.namespace)
                .withName(pods[0])
                .delete()
    }
}
</code></pre>

<p>使用客户端更新我们的定制资源的状态组件。状态组件是唯一的，因为更新它不会在我们的代码中触发更新事件。只有控制器可以更新资源的状态组件，Kubernetes被设计为防止状态更新触发无限事件循环:</p>

<pre><code>private fun updateStatus(webServer: WebServer) =
        kubernetesClient.customResources(webServerResourceDefinition, WebServer::class.java, WebServerList::class.java, DoneableWebServer::class.java)
                .inNamespace(webServer.metadata.namespace)
                .withName(webServer.metadata.name)
                .updateStatus(webServer)
</code></pre>

<p><code>podCountByLabel()</code>返回由CRD管理的正在运行或正在创建的pod的名称:</p>

<pre><code>private fun podCountByLabel(label: String, webServerName: String): List&lt;String&gt; =
        podLister.list()
                .filter { it.metadata.labels.entries.contains(SimpleEntry(label, webServerName)) }
                .filter { it.status.phase == "Running" || it.status.phase == "Pending" }
                .map { it.metadata.name }
</code></pre>

<p><code>createPod()</code>和<code>createNewPod()</code>创建一个新的pod。正是在这里，我们的业务逻辑通过使用<code>nginxdemos/hello</code> Docker映像作为我们的测试web服务器而被编码:</p>

<pre><code>private fun createPod(webServer: WebServer) =
        createNewPod(webServer).let { pod -&gt;
            kubernetesClient.pods().inNamespace(webServer.metadata.namespace).create(pod)
        }

private fun createNewPod(webServer: WebServer): Pod =
        PodBuilder()
                .withNewMetadata()
                .withGenerateName(webServer.metadata.name.toString() + "-pod")
                .withNamespace(webServer.metadata.namespace)
                .withLabels(Collections.singletonMap(APP_LABEL, webServer.metadata.name))
                .addNewOwnerReference()
                .withController(true)
                .withKind("WebServer")
                .withApiVersion("demo.k8s.io/v1alpha1")
                .withName(webServer.metadata.name)
                .withNewUid(webServer.metadata.uid)
                .endOwnerReference()
                .endMetadata()
                .withNewSpec()
                .addNewContainer().withName("nginx").withImage("nginxdemos/hello").endContainer()
                .endSpec()
                .build()
</code></pre>

<p><code>run()</code>方法是一个无限循环，不断消耗由事件监听器添加到<code>workQueue</code>的web服务器资源ID，并将其传递给<code>reconcile()</code>方法:</p>

<pre><code>fun run() {
    blockUntilSynced()
    while (true) {
        try {
            workQueue
                    .take()
                    .split("/")
                    .toTypedArray()[1]
                    .let { webServerLister.get(it) }
                    ?.also { reconcile(it) }
        } catch (interruptedException: InterruptedException) {
            // ignored
        }
    }
}

private fun blockUntilSynced() {
    while (!podInformer.hasSynced() || !webServerInformer.hasSynced()) {}
}
</code></pre>

<h2 id="the-crd-yaml">CRD·YAML</h2>

<p>操作符的最后一部分是CRD本身。CRD是另一种Kubernetes资源，我们在以下YAML中对其进行了定义:</p>

<pre><code class="language-YAML">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: webservers.demo.k8s.io
spec:
  group: demo.k8s.io
  version: v1alpha1
  names:
    kind: WebServer
    plural: webservers
  scope: Namespaced
  subresources:
    status: {}
</code></pre>

<h2 id="putting-it-all-together">把所有的放在一起</h2>

<p>要运行该操作符，我们首先需要应用CRD YAML:</p>

<pre><code>kubectl apply -f crd.yml
</code></pre>

<p>然后，我们用YAML创建CRD的一个实例:</p>

<pre><code class="language-YAML">apiVersion: demo.k8s.io/v1alpha1
kind: WebServer
metadata:
  name: example-webserver
spec:
  replicas: 5
</code></pre>

<p>然后，控制器可以在本地运行。因为我们在代码中使用的客户端知道如何根据它运行的位置来配置自己，所以在本地执行我们的代码意味着客户端从<code>~/.kube/config</code>文件中配置自己。在下面的截图中，您可以看到控制器直接从我的IDE中运行:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-02/operators-with-kotlin/intellij.png" class="zoom" data-title=""><img src="../Images/83286912c0f41eb3917bc521471f359c.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-02/operators-with-kotlin/intellij.png"/>T2】</a></p>

<p>控制器响应新的web服务器CRD并创建所需的pod:</p>

<pre><code>$ kubectl get pods
NAME                         READY   STATUS    RESTARTS   AGE
example-webserver-pod92ht9   1/1     Running   0          54s
example-webserver-podgbz86   1/1     Running   0          54s
example-webserver-podk58gz   1/1     Running   0          54s
example-webserver-podkftmp   1/1     Running   0          54s
example-webserver-podpwzrt   1/1     Running   0          54s
</code></pre>

<p>web服务器资源的状态更新为其成功创建的pod的<code>count</code>:</p>

<pre><code>$ kubectl get webservers -n default -o yaml
apiVersion: v1
items:
- apiVersion: demo.k8s.io/v1alpha1
  kind: WebServer
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"demo.k8s.io/v1alpha1","kind":"WebServer","metadata":{"annotations":{},"name":"example-webserver","namespace":"default"},"spec":{"replicas":5}}
    creationTimestamp: "2020-01-16T20:19:23Z"
    generation: 1
    name: example-webserver
    namespace: default
    resourceVersion: "112308"
    selfLink: /apis/demo.k8s.io/v1alpha1/namespaces/default/webservers/example-webserver
    uid: 9eb08575-8fa1-4bc9-bb2b-6f11b7285b68
  spec:
    replicas: 5
  status:
    count: 5
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""
</code></pre>

<h2 id="the-power-of-operators">运营商的力量</h2>

<p>没有操作员，测试web服务器的概念就存在于集群之外。开发人员可能已经在他们用来创建测试舱的YAML周围发了电子邮件，但是更有可能的是，每个人都有自己对测试web服务器的看法。</p>

<p>我们创建的操作符用一个测试web服务器的特定实现扩展了我们的Kubernetes集群。封装这些业务知识允许集群创建和管理特定于我们环境的高级概念。</p>

<p>创建和管理新资源只是运营商可以做的事情的一个例子。像安全扫描、报告和负载测试这样的自动化任务对于操作员来说都是有效的用例。热门运营商列表可在<a href="https://github.com/operator-framework/awesome-operators" rel="nofollow">这里</a>获得。</p>

<h2 id="conclusion">结论</h2>

<p>操作符是一种被大肆宣传但通常很少被理解的模式。根据描述操作符的原始博客文章中的定义，我们看到了操作符的三个简单部分:定义它们的资源、作用于Kubernetes资源的控制器和实现特定于应用程序的知识的逻辑。然后，我们在Kotlin中实现了一个简单的操作符来创建测试web服务器。</p>

                    
                    
</body>
</html>