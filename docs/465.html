<html>
<head>
<title>Managing Ansible Deployments with Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Octopus - Octopus Deploy管理可行的部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octopus-ansible#2022-05-19">https://octopus.com/blog/octopus-ansible#2022-05-19</a></blockquote>
                        <p>您可能熟悉Octopus提供的管理和部署代码的特性。如今，像AWS这样的云服务和Ansible这样的工具也能把你的基础设施变成代码，那么为什么不用Octopus部署你的Ansible、Chef或Puppet脚本呢？</p>

<p>在这篇博文中，我将向你展示使用Ansible和Octopus Deploy在AWS中创建一个简单的Windows实例的过程。</p>

<h2 id="why-use-octopus-with-ansible">为什么要用带Ansible的Octopus？</h2>

<p>在我们进入在Octopus中运行Ansible脚本的细节之前，一个自然的问题是为什么要这样做？使用Octopus进行基础设施部署有几个好处。</p>

<ul>
<li>现在，您可以像现在处理应用程序代码一样，通过环境(如开发-&gt;测试-&gt;生产)来发展基础设施。</li>
<li>您的基础架构部署经过审核，因此您可以确切了解谁在何时部署了什么。</li>
<li>将可转换的代码包装在版本化的包中，可以很容易地恢复到基础设施的前一个版本。</li>
<li>这些可回答的日志由Octopus保存，便于日后查阅。</li>
<li>您的基础架构部署可以利用Octopus的安全特性，从而可以轻松定义谁可以在哪里部署什么基础架构。</li>
</ul>

<h2 id="getting-the-source-code">获取源代码</h2>

<p>这篇博文中使用的Ansible代码可以在<a href="https://github.com/OctopusDeploy/AnsibleDemo" rel="nofollow"> GitHub </a>中找到。</p>

<h2 id="preparing-the-aws-resources">准备AWS资源</h2>

<p>虽然Ansible支持配置Windows目标，但它不是为从Windows主机运行而设计的。<a href="http://docs.ansible.com/ansible/intro_windows.html" rel="nofollow">文档说</a>:</p>

<blockquote class="blockquote">
<p>直接从Windows控制机器上运行Ansible并不是这个项目的目标。</p>
</blockquote>

<p>这意味着我们需要创建一个代表Octopus运行Ansible脚本的Linux实例。</p>

<p>当然我们可以用Ansible来创建这个Linux主机！</p>

<p>但是在我们开始创建实例之前，我们首先需要一个名为<code>AnsibleWorker</code>的IAM角色，我们可以将它分配给代表我们运行Ansible的EC2实例。</p>

<p>这个角色需要能够创建、查询和销毁EC2实例。在这种情况下，我们只在<code>us-east-1</code>区域工作，所以我们只在该区域授予角色权限。此IAM策略将授予这些权限。</p>

<pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Action": "ec2:*",
            "Effect": "Allow",
            "Resource": "*",
            "Condition": {
                "StringEquals": {
                    "ec2:Region": "us-east-1"
                }
            }
        }
    ]
}
</code></pre>

<p>这些IAM策略总是让我困惑的是什么时候使用<code>"Resource": "*"</code>以及什么时候使用ARN。</p>
<p><a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-iam-actions-resources.html" class="alert-link" rel="nofollow">Amazon EC2 API动作支持的资源级权限</a>包含一个支持资源级权限的动作列表。如果Amazon EC2 API操作不支持资源级权限，您可以授予用户使用该操作的权限，但是您必须为策略语句的resource元素指定一个*。</p>


<p>我们还需要使用<a href="http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html" rel="nofollow"> AWS安全令牌服务</a>来承担这个角色。我们将利用Ansible中的STS来生成Ansible AWS步骤运行所需的令牌(即访问令牌、秘密令牌和会话令牌)。</p>

<p>将下面策略中的<code>accountid</code>替换为您的AWS帐户ID。</p>


<pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "sts:AssumeRole"
            ],
            "Resource": [
                "arn:aws:iam::accountid:instance-profile/AnsibleWorker"
            ]
        }
    ]
}
</code></pre>

<p>最后，为了生成STS令牌，角色需要信任自己。您可以通过AWS web控制台配置这种信任，方法是单击IAM角色中的<code>Trust relationships</code>选项卡，并允许角色信任本身运行<code>sts:AssumeRole</code>操作。</p>

<pre><code>{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    },
    {
      "Sid": "",
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:sts::accountid:assumed-role/AnsibleWorker/i-abcdef01234567890"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
</code></pre>

<h2 id="configuring-the-aws-credentials">配置AWS凭据</h2>

<p>首先，我们有一个先有鸡还是先有蛋的情况，我们希望运行一些Ansible来创建将用于运行一些Ansible的实例。</p>

<p>为了解决这个问题，我们将运行在本地创建Ansible worker的Ansible脚本。所以您需要一个Linux实例来运行这个初始的Ansible剧本。参见<a href="http://docs.ansible.com/ansible/intro_installation.html" rel="nofollow"> Ansible安装文档</a>来启动并运行您的本地环境。</p>

<p>尽管Windows Linux子系统(即Windows上的Bash)没有得到微软或Ansible的官方支持，但我已经在Ansible上广泛使用了它，没有出现任何问题。</p>


<p>您还需要安装<a href="https://aws.amazon.com/cli/" rel="nofollow"> AWS CLI工具</a>。</p>

<p>确保您已使用有权使用以下命令创建EC2实例的帐户配置了AWS凭据:</p>

<pre><code>aws configure
</code></pre>

<h2 id="creating-the-worker">创建工人</h2>

<p>下面显示的Ansible YML文件定义了一个角色运行的任务，该角色将在AWS中创建一个Centos 7 EC2实例，并为其配置运行Ansible脚本所需的一切。</p>

<p>在本例中，我将EC2实例放入默认的VPC中。如果你有一个自定义的VPC，你需要设置<code>vpc_subnet_id</code>选项，也许还需要添加<code>assign_public_ip</code>选项。</p>



<p>某些EC2实例类型仅在VPC内部可用。关于需要VPC的列表，参见本文件<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-vpc.html#vpc-only-instance-types" class="alert-link" rel="nofollow">。</a></p>


<pre><code>---
- name: Create Linux Server
  ec2:
    key_name: ThePrivateKeyName
    instance_type: m3.medium
    image: ami-ae7bfdb8
    wait: yes
    instance_profile_name: AnsibleWorker
    group: TheSecurityGroupName
    count: 1
    region: us-east-1
    wait_timeout: 3000
    volumes:
      - device_name: /dev/sda1
        volume_size: 80
        volume_type: gp2
        delete_on_termination: true
    instance_tags:
      Name: Ansible Worker
  register: linux_server_ec2

- name: Add Host to Inventory
  add_host:
    name: "{{ item.public_ip }}"
    groups:
      - centos_server
  with_items: "{{linux_server_ec2.instances}}"

- name: Wait for SSH to answer on all hosts
  wait_for:
    port: 22
    host: "{{ item.public_ip }}"
    timeout: 600
  with_items: "{{linux_server_ec2.instances}}"

- name: Pause for a bit
  pause:
    seconds: 30
</code></pre>

<p>一旦Centos实例启动并运行，我们就需要安装Octopus和Ansible所需的包。</p>

<p>您会注意到这个角色添加了一个名为<code>ansible_rsa.pub</code>的SSH密钥。您可以使用以下命令生成此文件:</p>

<pre><code>ssh-keygen -f ansible_rsa -t rsa -N ''
</code></pre>

<p>保存好<code>ansible_rsa</code>和<code>ansible_rsa.pub</code>文件，因为我们以后会用到它们。</p>

<p>示例GIT repo包含了<code>ansible_rsa.pub</code>文件，但是您实际上不能使用这个公钥，因为它不包含<code>ansible_rsa</code>私钥文件。您需要生成自己的密钥对，并替换公钥来登录Linux实例。</p>


<pre><code>---
- name: Add EPEL repository
  yum:
    name: https://s3.amazonaws.com/bamboo-support/epel-release-7-9.noarch.rpm
    state: present

- name: Install useful packages
  yum:
    name: wget,elinks,telnet,htop,mlocate,python-pip,vim,nano,jq,java-1.8.0-openjdk-devel,unzip,maven,libunwind,libicu,git,patch,zip

- name: Install mono key
  get_url:
      url: http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
      dest: /tmp/GPG-KEY-mono
      mode: 0440

- name: import mono key
  rpm_key:
    state: present
    key: /tmp/GPG-KEY-mono

- name: Add mono repo
  yum_repository:
    name: mono
    description: Mono repository
    baseurl: http://download.mono-project.com/repo/centos7/
    gpgkey: http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF
    gpgcheck: yes
    enabled: yes

- name: Install mono
  yum:
    name: mono-devel

- name: Set JAVA_HOME
  lineinfile: dest=/etc/environment state=present regexp='^JAVA_HOME' line='JAVA_HOME=/usr/lib/jvm/jre-1.8.0'

- name: Install the 'Development tools' package group
  yum:
    name: "@Development tools"
    state: present

- name: Install python pip and other development libraries
  yum:
    name: python-pip, python-devel, python-lxml, openssl-devel

- name: Install Ansible and the AWS boto library
  pip:
    name: ansible, boto, boto3, pywinrm, requests-credssp
    state: latest

- name: Creates directory for ansible scripts
  file:
    path: "/var/octopus/scripts"
    state: directory
    owner: centos
    group: centos
    mode: 0775

- name: Set authorized key
  authorized_key:
    user: centos
    state: present
    key: "{{ lookup('file', 'roles/linux-ansible-target/files/ansible_rsa.pub') }}"
</code></pre>

<p>为了与新的Linux实例进行真正的通信，Ansible需要知道使用什么SSH私有密钥文件。这在<code>group_vars\centos_server.yml</code>文件中定义。您需要将<code>ansible_ssh_private_key_file</code>设置指向与<code>roles\centos-7-server-instance\tasks\main.yml</code>文件中定义的<code>key_name</code>相匹配的PEM文件的位置。</p>

<pre><code>---
ansible_ssh_private_key_file: /tmp/aws.pem
</code></pre>

<p>然后，我们需要从剧本中运行这两个角色。</p>

<pre><code>---
- name: Linux Server
  hosts:
    - 127.0.0.1
  become: false
  gather_facts: false

  roles:
    - centos-7-server-instance

- name: Ansible setup
  hosts: centos_server
  remote_user: centos
  become: true
  become_user: root

  roles:
    - linux-ansible-worker
</code></pre>

<p>使用以下命令运行行动手册:</p>

<pre><code> ansible-playbook ansible-worker.yml
</code></pre>

<p>这个Ansible脚本的最终结果将是一个运行Centos的EC2实例，它安装了Mono和Ansible，可以作为Octopus中的一个worker使用。</p>

<h2 id="creating-a-windows-ec2-instance">创建Windows EC2实例</h2>

<p>出于演示目的，我们将使用Octopus和Ansible构建一个Windows 2016 server EC2实例。</p>

<p>这里的过程与创建Centos EC2实例非常相似，但是用户数据有一些有趣的步骤，使得使用Windows实例更加容易。</p>

<pre><code>---
  - name: Assume AWS Role
    sts_assume_role:
      role_arn: "arn:aws:iam::accountid:role/AnsibleWorker"
      role_session_name: "AnsibleBuild"
      region: us-east-1
    register: assumed_role

  - name: Create Windows Server
    ec2:
      aws_access_key: "{{ assumed_role.sts_creds.access_key }}"
      aws_secret_key: "{{ assumed_role.sts_creds.secret_key }}"
      security_token: "{{ assumed_role.sts_creds.session_token }}"
      key_name: OctopusVirginia
      instance_type: m3.large
      image: ami-f1b5cfe7
      wait: yes
      wait_timeout: 600
      group: SecurityGroupName
      count: 1
      region: us-east-1
      user_data: "{{ lookup('template', 'templates/userdata.txt.j2') }}"
      volumes:
        - device_name: /dev/sda1
          volume_size: 80
          volume_type: gp2
          delete_on_termination: true
      instance_tags:
        Name: Windows Server
    register: windows_server_ec2

  - name: Add Host to Inventory
    add_host:
      name: "{{ windows_server_ec2.instances[0].public_ip }}"
      groups: windows_server

  - name: Wait for WinRM to answer on all hosts
    wait_for:
      port: 5986
      host: "{{ windows_server_ec2.instances[0].public_ip }}"
      timeout: 6000
</code></pre>

<p><code>userdata.txt.j2</code>模板包含一个Powershell脚本，该脚本在创建时由Windows实例运行。我们使用这个脚本准备由Ansible管理的Windows实例，并设置初始管理员密码。</p>

<p>你可以在这里找到更多关于Windows系统准备工作的细节。</p>

<p>我们还为winrm启用了服务器端SSP(即<a href="https://blogs.msdn.microsoft.com/powershell/2008/06/05/credssp-for-second-hop-remoting/" rel="nofollow">CredSSP for second-hop remoting</a>)，这在安装SQL Server等应用程序时是必需的。</p>

<p>将<code>TheWindowsPassword</code>改为符合所需密码复杂性规则的值。如果您将密码保留为默认密码，Powershell脚本将不会按预期运行。</p>


<pre><code>&lt;powershell&gt;
Enable-WSManCredSSP -Role Server -Force
Set-Item -Path "WSMan:\localhost\Service\Auth\CredSSP" -Value $true
Invoke-Expression ((New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1'))
$user=[adsi]"WinNT://localhost/Administrator,user"
$user.SetPassword("TheWindowsPassword")
$user.SetInfo()
&lt;/powershell&gt;
</code></pre>

<p>需要定义一些额外的组变量，以允许Ansible与新创建的Windows实例进行交互。这些在<code>group_vars\windows_server.yml</code>文件中定义。</p>

<pre><code>---
ansible_user: Administrator
ansible_port: 5986
ansible_connection: winrm
ansible_password: TheWindowsPassword
ansible_winrm_server_cert_validation: ignore
ansible_winrm_transport: credssp
</code></pre>

<p>我们将在这台服务器上安装Chrome，因为我真的讨厌在新安装的Windows服务器上试图在IE中做任何事情。</p>

<pre><code>---
- name: Install Chrome
  win_chocolatey:
    name: googlechrome
    state: present
</code></pre>

<p>该角色与<code>windows-server.yml</code>剧本一起运行。</p>

<pre><code>---
- name: Create Windows Server
  hosts:
    - 127.0.0.1
  become: false
  gather_facts: false

  roles:
    - win-server-instance

- name: Configure Windows
  hosts: windows_server
  become: false
  gather_facts: false

  roles:
    - configure-windows
</code></pre>

<p>可以使用以下命令运行本行动手册:</p>

<pre><code>ansible-playbook windows-server.yml
</code></pre>

<h2 id="creating-an-ansible-package">创建可解析的包</h2>

<p>现在我们已经有了Ansible脚本，我们可以创建一个版本化的包，可以推送到Octopus Deploy。</p>

<p>因为这些脚本托管在GIT中，所以我们可以使用GIT创建一个ZIP文件。这样做的好处是不包括<code>.git</code>目录，也不包括GIT没有跟踪的任何文件。</p>

<pre><code>git archive -o AnsibleInfrastructure.1.0.0.0.zip HEAD
</code></pre>

<p>然后可以使用CLI工具将这个包推送到Octopus。</p>

<pre><code>octo push --package AnsibleInfrastructure.1.0.0.0.zip --apiKey API-YOURAPIKEYGOESHERE --server https://octopus.hostname
</code></pre>

<h2 id="adding-the-ansible-worker">添加可负责的工人</h2>

<p>我们在博客开始时创建的EC2实例现在需要在Octopus中进行配置。我们将把它添加为一个<a href="https://octopus.com/docs/deployment-targets/ssh-targets"> SSH目标</a>，使用<code>ansible_rsa</code>私钥建立连接。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-06/centos-account.png" class="zoom" data-title=""><img src="../Images/169113d0f35dbe0ca9de99dcf00bd4c4.png" class="img-fluid center" alt="Centos SSH Account" data-original-src="https://i.octopus.com/blog/2017-06/centos-account.png"/>T2】</a></p>

<p>对于像Bamboo这样的CI服务器，您通常会有一个工人池，并且可以将一个作业发送给任何自由工人实例。因此，一个工作单元(通常是用Bamboo构建的应用程序)被分配给一个工人。</p>
<p>由于主要关注部署，Octopus将获取一个包并将其安装在所有目标上。所以一个工作单元(Octopus中的一个部署)被分配给所有的目标。</p>
<p>在这里，我们正在创建一个章鱼目标，并将其称为“工人”。这是可行的，因为我们有一个目标，Octopus会将部署(或者在本例中执行Ansible剧本)排队到这个目标。</p>
<p>今天，Octopus没有工人池的概念，其中一个工人可以被选择来运行一个单独的工作单元。但是，如果我们只有一个“worker”目标，那么作业就会像我们预期的那样排队。</p>


<h2 id="running-the-ansible-playbook">运行Ansible行动手册</h2>

<p>运行Ansible行动手册分为两步。</p>



<p>首先，我们提取包含Ansible代码的包，这些代码在前面的步骤中被推送到Octopus。这是通过<code>Deploy a package</code>步骤完成的，其中Ansible包被提取到worker上的<code>/var/octopus/scripts</code>目录中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-06/ansible-package.png" class="zoom" data-title=""><img src="../Images/f27b4bad0b607fa5913c091aac82349e.png" class="img-fluid center" alt="Ansible Package" data-original-src="https://i.octopus.com/blog/2017-06/ansible-package.png"/>T2】</a></p>

<h3 id="run-the-playbook">运行剧本</h3>

<p>接下来我们运行Ansible剧本。这是通过一个<code>Run a Script</code>步骤完成的。</p>

<pre><code>cd /var/octopus/scripts
ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook windows-server.yml
</code></pre>

<p><code>ANSIBLE_HOST_KEY_CHECKING=False</code>用于防止SSH提示信任SSL目标。它实际上并不与Windows目标一起使用，但是您会希望将它与Linux目标一起使用。</p>


<h2 id="conclusion">结论</h2>

<p>这个过程的最终结果是一个EC2“worker”实例，可以用来代表Octopus运行Ansible脚本，以及一个部署Windows server实例的Ansible脚本示例。</p>

<p>我希望您能看到将您的基础设施作为代码部署是多么容易，以及您如何在此基础上利用开发人员认为理所当然的Octopus中的所有管理特性。</p>

                    
                    
</body>
</html>