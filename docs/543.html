<html>
<head>
<title>Lessons learned porting Octopus Server to .NET Core 3.1 - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将Octopus服务器移植到。网络核心3.1 -八达通部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/octopus-server-dotnet-core-lessons-learned#2021-08-12">https://octopus.com/blog/octopus-server-dotnet-core-lessons-learned#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-03/octopus-server-dotnet-core-lessons-learned/eskimo-octopus-linux-land.png" class="zoom" data-title=""><img src="../Images/d474ecc0ec20eb01580b0656146e3e93.png" class="img-fluid center" alt="Lessons learned porting Octopus Server to .NET Core 3.1" data-original-src="https://i.octopus.com/blog/2020-03/octopus-server-dotnet-core-lessons-learned/eskimo-octopus-linux-land.png"/>T2】</a></p>

<p>随着Octopus 2020.1的发布，Octopus Server现在运行于。NET Core 3.1，这意味着它可以安装在Linux、Docker容器和Kubernetes上。这是一项重大的努力，我们已经分享了我们对推出章鱼云1.0 的<a href="/blog/octopus-cloud-1.0-reflections">思考，以及</a><a href="/blog/octopus-cloud-v2-why-kubernetes">我们为什么选择Kubernetes、Linux和。NET Core for Octopus Cloud 2.0 </a>，在本帖中，我们分享了这一变化的好处以及我们学到的三大经验教训。</p>

<h2 id="benefits">利益</h2>

<p>在我们分享经验教训之前，先来看看将Octopus Server移植到。网络核心:</p>

<ul>
<li>现代开发环境、框架和工具。</li>
<li>对Windows和Linux的跨平台支持。</li>
<li>在Kubernetes中访问运行Linux容器的成熟生态系统。</li>
<li>选择和灵活性:我们的客户可以选择在Windows或Linux上运行Octopus，也可以使用Octopus Cloud。</li>
<li>Octopus Cloud提高了性能，降低了运营成本。具体数字见上面的链接。</li>
</ul>

<p>这也使得我们的开发环境更加高效，因为我们的工程团队现在可以选择在Windows或Linux上进行开发。</p>

<h2 id="top-three-lessons-learned">三大经验教训</h2>

<p>通过这个过程，我们学到了很多东西；然而，我们学到了三大教训。</p>

<h3 id="know-and-plan-for-differences-between-windows-and-linux">1.了解并计划Windows和Linux之间的差异</h3>

<p>在的实现中存在特定于平台的差异。Windows和Linux上的NET Core。大多数问题都很小，有简单的解决方法，但我们确实发现了一些值得分享的重大问题。</p>

<p><strong>配置设置和Windows注册表</strong></p>

<p>为了同时支持Windows和Linux平台，我们必须删除任何特定于Windows的代码。Octopus Server一开始是Windows产品，它遵循平台约定，在Windows注册表中存储了一些配置设置，这对Linux来说是个问题。</p>

<p><strong>解决方案</strong>:</p>

<p>我们将注册表中存储的所有内容都转移到文件系统或Octopus数据库中。这是一个简单的任务，但需要时间和测试才能做好。</p>

<p><strong>数据库性能问题</strong></p>

<p>我们遇到的最大问题是糟糕的数据库性能，这是由于在Windows和Linux上处理数据库查询的方式不同。Octopus使用Microsoft SQL Server作为其数据存储，我们在。NET核心SQL客户端库。如果我们将<code>MultipleActiveResultSets</code>设置为<code>True</code>，我们会得到异常和数据库超时。上面链接的GitHub问题分享了完整的细节和一个简单的代码样本来重现问题。</p>

<p><strong>解决方案</strong>:</p>

<p>我们的短期解决方案是禁用<code>MultipleActiveResultSets</code>设置，并尽量少用。通常，我们打开两个到数据库的连接，一个启用这个设置，另一个禁用它。我们主要使用禁用的连接，仅在需要时使用启用的连接。</p>

<p>我们一直在与微软合作，以帮助提供信息来解决这个问题，我们希望在未来看到一个适当的修复。</p>

<p><strong>认证提供者</strong></p>

<p>我们还遇到了在每个平台上托管不同的Octopus服务器web主机的需求。我们在Windows上使用<code>HttpSys</code>,在Linux上使用<em> Kestrel </em>,这使得我们的认证很有挑战性。Octopus需要支持多种身份验证方案，包括基于cookies的身份验证，以及用户登录和注销并同时启用多个身份验证提供者的能力。</p>

<p>我们遇到的核心问题是<code>HttpSys</code>支持集成认证(即Windows认证)，但它是主机中每个端点的二进制开/关设置。这是不灵活的，这是从我们的非。NET核心代码库。用户可以自动登录，但永远无法注销。</p>

<p>注意:我们不在Windows上使用Kestrel，因为它不支持虚拟目录，而且我们的客户与其他服务共享同一个端口。因此，为了确保我们保持向后兼容性，我们决定只对Windows使用<code>HttpSys</code>。</p>

<p><strong>解决方案</strong>:</p>

<p>我们考虑了几个选项，但是在经历了这个<a href="https://github.com/dotnet/aspnetcore/issues/5888" rel="nofollow">ASP.NET核心问题</a>之后，我们决定遵循那里的建议，使用两台主机。一个标准web主机，另一个主机看起来/表现得像主API站点根目录下的虚拟目录，即<code>/integrate-challenge</code>，因此与Octopus Server早期版本中的位置一致。主机只有这一条路由，当用户尚未通过身份验证时，它使用401响应发起登录质询。</p>

<h3 id="sharpen-your-debugging-skills-for-linux-and-docker">2.提高您的Linux和Docker调试技能</h3>

<p>当我们穿过。NET核心端口，我们还学习了如何编码、测试和调试Windows、Windows Subsystem for Linux (WSL)、Linux和Docker的问题。从历史上看，我们的团队都是在Windows上开发的，但这已经演变为个人在Windows、Linux和macOS上编码，因此，我们学到了几个教训:</p>

<p><strong>以非超级用户或非管理员身份运行</strong></p>

<p>我们发现在Linux上以非root或非sudo身份运行所有构建和测试Octopus Server要容易得多，以限制基于权限的错误和问题。也就是说，我们有时需要使用<code>sudo</code>以root用户身份运行命令，然后用<code>chown</code>修改在这些命令中创建的文件的所有权，比如<code>sudo chown -R $user:$user ~/Octopus/MyInstance</code>。这有点快和脏，但它做的工作。</p>

<p>我们计划在未来改变这一点，例如octopus作为一个组的成员运行，在安装期间我们将<code>/etc/octopus</code>的组所有者配置为该组。</p>

<p><strong>证书管理</strong></p>

<p>我们的端到端(E2E)测试套件运行了一系列针对Octopus服务器监听HTTPS(即端口443)的测试。这需要我们将一些自签名证书转换并导入到Linux机器上<code>/etc/</code>的本地证书存储中。为了解决这个问题，我们编写了以下脚本:</p>

<pre><code class="language-bash">#!/bin/bash
echo "Setup certificates"
CERTS_PATH_DEST="/usr/local/share/ca-certificates"
if [ ! -d "$CERTS_PATH_DEST" ]
then
    echo "Creating $CERTS_PATH_DEST"
    mkdir ${CERTS_PATH_DEST}
fi
MY_PATH="`dirname \"$0\"`"
CERT_PFX_FILES=(${PWD}/${MY_PATH}/../Octopus.E2ETests/Universe/*.pfx)
for CERT_PFX in "${CERT_PFX_FILES[@]}"
do
    FILE_NAME=$(basename "$CERT_PFX")
    CERT_CRT="${CERTS_PATH_DEST}/${FILE_NAME%.*}.crt"
    if [ ! -e "${CERT_CRT}" ]
    then
        echo "Converting '${CERT_PFX}' to '${CERT_CRT}'"
        openssl pkcs12 -in "${CERT_PFX}" -clcerts -nokeys -out "${CERT_CRT}" -passin pass:password
    fi
done
update-ca-certificates
</code></pre>

<p><strong>连接到SQL Server数据库</strong></p>

<p>Octopus使用Microsoft SQL Server作为其数据库，团队一般通过Windows服务器上的集成Windows身份验证连接到它。这不再管用了。我们这里的解决方案是切换到基于用户名和密码的身份验证。</p>

<p>此外，我们发现在关闭数据库连接池的情况下，我们的端到端(E2E)测试套件运行得更快、更可靠。我们还没有找到问题的根源，但是这可能是一个与上面提到的数据库性能问题相关的特定于平台的问题。</p>

<p><strong>用Visual Studio代码调试Linux上的Octopus服务器</strong></p>

<p>我们的团队使用各种工具编写代码，包括:</p>



<p>目前最流行的是带有<a href="https://aka.ms/vscode-remote/download/extension" rel="nofollow">远程开发扩展</a>的<a href="https://code.visualstudio.com/" rel="nofollow"> Visual Studio代码</a>。这个扩展仍然是在预览，但我们发现它工作得很好。</p>

<p>使用Visual Studio代码和远程开发扩展，我们可以运行应用程序、测试和调试它们，以及在Linux(或Docker容器)中编辑代码。只需将VS Code指向包含Octopus服务器代码的文件夹，然后只需按F5即可。就这么简单！</p>

<h3 id="simplify-with-self-contained-packages">3.使用独立的包进行简化</h3>

<p>把章鱼移植到。NET Core允许我们发布<a href="https://www.hanselman.com/blog/MakingATinyNETCore30EntirelySelfcontainedSingleExecutable.aspx" rel="nofollow">自包含包</a>，这带来了多重好处。</p>

<ul>
<li><strong>更少的依赖性</strong>:发布一个独立的可执行文件意味着我们不再需要。NET Core安装在八达通服务器上。其结果是降低了安装要求，使八达通更容易安装。这是一个巨大的胜利。</li>
<li><strong>改进的可支持性</strong>:简而言之，更少的依赖使得Octopus更容易安装和支持。零部件少了，能不小心改动的东西也少了。面向<a href="https://hub.docker.com/r/octopusdeploy/octopusdeploy" rel="nofollow"> Windows </a>和Linux(即将推出)的Docker容器映像消除了更多的依赖，因为更多的依赖被内置到容器中。</li>
<li><strong>现代软件和工具</strong>:使用现代工具和框架使我们的团队能够继续创新，并为我们的客户快速发布具有有用特性的软件。</li>
</ul>

<p>不幸的是，这也有一些权衡。NET Core 3.1要求我们<a href="/blog/raising-minimum-requirements-for-octopus-server">放弃对旧操作系统的支持</a>，包括Windows Server 2008-2012和一些Linux发行版。支持旧的服务器和浏览器消耗了我们的时间和注意力，使我们更难创新和推动Octopus生态系统向前发展。</p>

<h2 id="conclusion">结论</h2>

<p>我们把章鱼服务器移植到了。NET Core 3.1，以便服务器可以在Linux、Docker容器和Kubernetes上运行。我们作出这一改变是为了降低成本和提高我们的八达通云SaaS产品的性能，它取得了巨大的成功。</p>

<p>这不是一次简单的旅行，但我们在途中学到了很多东西。</p>

<ol>
<li>了解并计划Windows和Linux之间的差异</li>
<li>提高您的Linux和Docker调试技能</li>
<li>使用独立的包进行简化</li>
</ol>

<h2 id="related-posts">相关职位</h2>



                    
                    
</body>
</html>