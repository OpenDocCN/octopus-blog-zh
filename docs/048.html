<html>
<head>
<title>Walkthrough: Automated deployment to Amazon EC2 with TFS Preview, MyGet and Octopus Deploy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>演练:通过TFS预览版、MyGet和Octopus Deploy - Octopus Deploy自动部署到Amazon EC2</h1>
<blockquote>原文：<a href="https://octopus.com/blog/automated-deployment-with-tfspreview-octopack-myget#2015-09-25">https://octopus.com/blog/automated-deployment-with-tfspreview-octopack-myget#2015-09-25</a></blockquote>
                        <p><a href="http://tfspreview.com/" title="TFSPreview"> TFS预览版</a>是微软新推出的云托管Team Foundation Server即服务解决方案(TFSaaS？).您将获得一个Team Foundation Server实例，带有团队构建(持续集成)和工作项跟踪。</p>

<p>微软把TFS不仅仅作为一个源代码控制系统来推销，而是作为一个应用程序生命周期管理解决方案。这张来自TFS预览主页的图片很好地概括了这一点:</p>

<p><img src="../Images/341d7aba3e2610bfe7f44ef5f28dbbe4.png" alt="TFS and ALM" data-original-src="https://i.octopus.com/blog/migrated/11tfs1.PNG"/></p>

<p>右边的箭头代表不同渠道的“部署”——毕竟，“应用程序生命周期管理”确实应该包括某种部署能力。然而，问题是在TFS预览版的情况下，箭头实际上只是意味着“自动部署到Azure”。这绝对是一个很酷的特性，但是如果你的目标服务器没有运行在Azure上呢？如果您使用的是Amazon EC2，或者您的服务需要在数据中心的一些本地服务器上运行，该怎么办？</p>

<p>不要担心，Octopus在这里将“部署”放在应用程序生命周期管理中。我们将扩展图像，如下所示:</p>

<p><img src="../Images/98e0d0879e90e9cfc923888b522aa8f8.png" alt="TFS and ALM" data-original-src="https://i.octopus.com/blog/migrated/11tfs2.PNG"/></p>

<p>在这篇文章中，我将采用ASP.NET网站，并让它在TFS预览下建设。我需要做几件事:</p>

<ul>
<li>创建一个<a href="http://tfspreview.com/" title="TFS Preview"> TFS预览</a>账户</li>
<li>创建一个<a href="http://myget.org/" title="MyGet"> MyGet </a>账户。我们将使用MyGet来托管我们的NuGet包。</li>
<li>创建ASP.NET站点，并使用<a href="https://github.com/OctopusDeploy/OctoPack"> OctoPack </a>对其进行打包</li>
<li>建立一个团队构建来构建包并将它们发布到MyGet</li>
<li>配置Octopus使用MyGet并部署应用程序</li>
</ul>

<p>虽然我将在本例中使用TFS预览版，但这些步骤(或类似步骤)中的大部分也适用于内部TFS安装。</p>

<h2>步骤1:创建项目</h2>

<p>访问<a href="https://tfspreview.com/" title="TFSPreview"> TFS预览版</a>主页，注册账号。这是免费的，而且只需要几分钟，挺好的。完成后，您将被带到一个帐户控制面板:</p>

<p><img src="../Images/00e9e989310fe34775eee47d8ec5d26e.png" alt="TFS Preview home" data-original-src="https://i.octopus.com/blog/migrated/11tfspreview1.PNG"/></p>

<p>我将创建一个新的团队项目:</p>

<p><img src="../Images/613da9b6fb5336c8b6fd345f15d5c5c0.png" alt="Creating a TFS Preview project" data-original-src="https://i.octopus.com/blog/migrated/11create-project.PNG"/></p>

<p>创建项目大约需要一分钟，之后您将看到项目主页:</p>

<p><img src="../Images/88ca6ad573fad1e17c49a1c6dcd8a828.png" alt="TFS Preview project dashboard" data-original-src="https://i.octopus.com/blog/migrated/11project-home.PNG"/></p>

<p>接下来，我将把TFS服务器添加到我的Visual Studio团队资源管理器中:</p>

<p><img src="../Images/b07d76b8dbd18427cba25385306e8709.png" alt="Add to Team Explorer" data-original-src="https://i.octopus.com/blog/migrated/11add-to-tfs.PNG"/></p>

<p>现在，我将创建一个ASP.NET MVC 4项目，并勾选“添加到源代码控制”。我将使用互联网模板，我也将添加一个单元测试项目。</p>

<p><img src="../Images/415d2a5363dcdfbe519249efbbfb55c1.png" alt="Creating the VS project" data-original-src="https://i.octopus.com/blog/migrated/11create-vs-project.PNG"/></p>

<p>项目创建完成后，我会被问到代码应该在TFS的什么地方。我添加了一个<code>Trunk\Source</code>文件夹:</p>

<p><img src="../Images/6a40a95d5e699ec72deb89f102c06b15.png" alt="Add project to source control" data-original-src="https://i.octopus.com/blog/migrated/11add-to-source.PNG"/></p>

<p>在我签入之前，我将在解决方案上启用<a href="http://docs.nuget.org/docs/workflows/using-nuget-without-committing-packages"> NuGet包恢复</a>，这样我就不必签入我的所有NuGet包:</p>

<p><img src="../Images/e0aaa03d86a00e4df4a4ade83e37789a.png" alt="Enable NuGet package restore" data-original-src="https://i.octopus.com/blog/migrated/11enable-package-restore.PNG"/></p>

<p>从pending changes窗口中，我将排除<code>packages</code>目录，并签入我的代码:</p>

<p><img src="../Images/da112ba30c6c2ecba2a50803e8189c53.png" alt="Exclude packages folder" data-original-src="https://i.octopus.com/blog/migrated/11exclude-packages.PNG"/></p>

<p>通过互联网办理入住手续出奇的快。我过去在互联网上使用TFS 2010有过不好的经历，但是这个非常快。</p>

<h2>步骤2:持续集成</h2>

<p>签入我的初始代码后，是时候建立团队构建了。我将创建一个名为“CI”的新团队构建定义。在“Trigger”选项卡上，我将选择“CI”选项:</p>

<p><img src="../Images/d26354d7d371a86262495d8ef89300e3.png" alt="Setting up team build" data-original-src="https://i.octopus.com/blog/migrated/11ci.PNG"/></p>

<p>在“过程”选项卡上，Team Build会自动找到我的解决方案。我要做的唯一更改是显式指定发布配置:</p>

<p><img src="../Images/d3c812348651a8e4aaf163f967ce7f57.png" alt="Release build" data-original-src="https://i.octopus.com/blog/migrated/11def-2.PNG"/></p>

<p>我将保存构建配置，然后让它排队运行:</p>

<p><img src="../Images/6ae9ac091efe1bb5ad65c9c5890589a9.png" alt="Queue build" data-original-src="https://i.octopus.com/blog/migrated/11queue-build.PNG"/></p>

<p>构建在运行之前在队列中停留了大约一分钟，大概是构建机器正在被提供或者其他什么。实际构建花费了大约2.5分钟，并成功完成:</p>

<p><img src="../Images/6daf9b7282f4861ed19a84124bc55946.png" alt="Build complete" data-original-src="https://i.octopus.com/blog/migrated/11build-complete.PNG"/></p>

<p>如果我在Visual Studio中使用源代码管理器窗口，我可以看到构建的输出。在一个<code>_PublishedWebsites</code>目录下是我的项目的目录，其中包含了我运行我的ASP.NET网站所需的所有文件。</p>

<p><img src="../Images/85eb4ec14f2bd405fef51b4be255b167.png" alt="Published web site" data-original-src="https://i.octopus.com/blog/migrated/11drop.PNG"/></p>

<p>这是TFS的一个特色，很不错，但是我该拿它怎么办呢？手动下载文件，然后像1998年一样用FTP传输到某个地方？不，我们可以做得更好！</p>

<h2>步骤3:打包网站</h2>

<p>到目前为止，我有一个使用Team Build构建的ASP.NET站点，该站点的内容被发布到<code>_PublishedWebsites</code>文件夹中。现在，我将这个文件夹压缩到一个NuGet包中，这样我就可以使用<a href="http://octopusdeploy.com"> OctopusDeploy </a>来部署它。</p>

<p>为此，我将使用<a href="https://github.com/OctopusDeploy/OctoPack"> OctoPack </a>，这是一个特殊的NuGet包，它将为我处理这个问题。我将在软件包管理器控制台中发出<code>install-package OctoPack</code>命令，注意选择我的网站作为目标项目:</p>

<p><img src="../Images/702e72346caea35522d0e478ee97bd2a.png" alt="Add OctoPack" data-original-src="https://i.octopus.com/blog/migrated/11install-package.PNG"/></p>

<p>OctoPack修改网站的<code>.csproj</code>文件，添加一个特殊目标文件的链接。这个目标文件将在发布构建完成后负责打包。</p>

<p>由于我使用的是NuGet包恢复，OctoPack在我的解决方案的根目录下添加了一个<code>.octopack</code>文件夹，紧挨着<code>.nuget</code>文件夹，这就是保存目标文件的地方。令人烦恼的是，这并没有出现在团队资源管理器的Pending Changes窗口中，所以我将使用Source Explorer手动添加它。</p>

<p>我还将在我的项目中添加一个<code>.nuspec</code>文件，这是OctoPack所需要的。这将作为我的包裹的舱单。</p>

<pre><code>&lt;?xml version="1.0"?&gt;
&lt;package &gt;
  &lt;metadata&gt;
    &lt;id&gt;Columbia&lt;/id&gt;
    &lt;title&gt;A sample web application&lt;/title&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;authors&gt;Paul Stovell&lt;/authors&gt;
    &lt;owners&gt;Paul Stovell&lt;/owners&gt;
    &lt;licenseUrl&gt;http://octopusdeploy.com&lt;/licenseUrl&gt;
    &lt;projectUrl&gt;http://octopusdeploy.com&lt;/projectUrl&gt;
    &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt;
    &lt;description&gt;A sample project&lt;/description&gt;
    &lt;releaseNotes&gt;This release contains the following changes...&lt;/releaseNotes&gt;
  &lt;/metadata&gt;
&lt;/package&gt;
</code></pre>

<p>这将被添加到我的web项目的根目录，我将把构建操作设置为None:</p>

<p><img src="../Images/3851d4adb4756134d55ef7edbcec30b1.png" alt="Add NuSpec" data-original-src="https://i.octopus.com/blog/migrated/11build-action.PNG"/></p>

<p>最后，我将提交更改，再次确保不要添加NuGet packages文件夹(我认为待定更改需要一个‘永久忽略’按钮)。</p>

<p><img src="../Images/702e72346caea35522d0e478ee97bd2a.png" alt="Add OctoPack" data-original-src="https://i.octopus.com/blog/migrated/11install-package.PNG"/></p>

<p>签入后，我的团队构建被自动触发。我在准备这个演示时犯了一个错误(忘记添加<code>.nuspec</code>)，这就是为什么会有一个代表以前失败构建的条。添加它修复了构建:</p>

<p><img src="../Images/c0fd0dbfe2bb013868b06c87c4ac115c.png" alt="Build finished" data-original-src="https://i.octopus.com/blog/migrated/11build-finished.PNG"/></p>

<p>现在，如果我检查drops文件夹，我会发现一个<code>Columbia.1.0.0.0.nupkg</code>文件:</p>

<p><img src="../Images/90919d3433bd6f94b9d1f64882d0d6b4.png" alt="Drop folder with package" data-original-src="https://i.octopus.com/blog/migrated/11drop-with-package.PNG"/></p>

<p>如果我使用<a href="http://npe.codeplex.com/"> NuGet包浏览器</a>，我可以看到它包含了我运行网站所需的文件，以及来自我的<code>.nuspec</code>的清单信息:</p>

<p><img src="../Images/e510dc1363356515e403712b4abdc4cf.png" alt="NuGet package explorer contents" data-original-src="https://i.octopus.com/blog/migrated/11package-contents.PNG"/></p>

<h2>步骤4:增加版本号</h2>

<p>NuGet包从项目的输出程序集的<code>[assembly: AssemblyVersion]</code>属性中获取它的版本号，这个属性默认设置为<code>1.0.0.0</code>。我们可以在<code>AssemblyInfo.cs</code>文件中改变这一点，给每个包一个唯一的版本号:</p>

<pre><code>[assembly: AssemblyVersion("1.0.*")]
</code></pre>

<p>我将签入它，并让CI构建再次运行，几分钟后，我有了一个新的drops文件夹，其中包含一个新的包:</p>

<p><img src="../Images/bc0778fc41ca8ebca278bb3170eec12d.png" alt="Package with version stamp" data-original-src="https://i.octopus.com/blog/migrated/11package-2.PNG"/></p>

<h2>步骤5:托管NuGet包</h2>

<p>我的CI构建现在正在生成与Octopus兼容的NuGet包。在部署它们之前，我需要将NuGet包托管在Octopus可以访问它们的地方。不幸的是，TFS预览版不能兼作NuGet包库，所以我们必须看看外面。</p>

<p>Octopus <a href="http://octopusdeploy.com/documentation/packaging">支持任何NuGet存储库</a>，所以一种选择是手动将每个包复制到Octopus可以引用的本地文件共享。如果我们只是偶尔进行部署，这可能是一个不错的选择，但它并不是完全自动化的。</p>

<p>另一个选择是将我们的包发布到NuGet服务器上。我们可以通过设置一个运行<a href="https://github.com/NuGet/NuGetGallery"> NuGet Gallery </a>的虚拟机来托管它，但这需要一些努力。一种更简单的方法是使用<a href="http://www.myget.org/">MyGet.org</a>，一种“NuGet即服务”的解决方案。</p>

<p>我将使用我的Live ID创建一个帐户，然后填写注册页面:</p>

<p><img src="../Images/99d3299712fa4a5448cf92423c8a38ac.png" alt="MyGet signup" data-original-src="https://i.octopus.com/blog/migrated/11myget-signup.PNG"/></p>

<p>接下来，我将创建一个由MyGet托管的NuGet提要。在这个例子中，我将使用公共提要，但是您也可以选择使用私有提要:</p>

<p><img src="../Images/e4df4fbe6d1619cca0fc150b16a6e67f.png" alt="MyGet feed" data-original-src="https://i.octopus.com/blog/migrated/11myget-feed.PNG"/></p>

<p>创建了我的feed后，我可以使用MyGet Feed Details选项卡来获取Feed的信息:</p>

<p><img src="../Images/18d713af463feaa4dd9933657811da47.png" alt="MyGet details" data-original-src="https://i.octopus.com/blog/migrated/11myget-details.PNG"/></p>

<h2>步骤6:将包推送到MyGet</h2>

<p>现在，我将设置Team Build来自动将我的包推送到MyGet提要。我将从编辑团队构建定义开始:</p>

<p><img src="../Images/c43e4b17253b044acfa5b795be9301f5.png" alt="Edit build definition" data-original-src="https://i.octopus.com/blog/migrated/11edit-build-def.PNG"/></p>

<p>在<strong>进程</strong>选项卡上，我将展开高级部分并设置MSBuild Arguments属性:</p>

<p><img src="../Images/7a8dc7bda56d1017cbc370af784509aa.png" alt="MSBuild arguments" data-original-src="https://i.octopus.com/blog/migrated/11msbuild-args.PNG"/></p>

<p>我已经设置为:</p>

<pre><code>/p:OctopusPublishPackageToHttp=http://www.myget.org/F/columbia/api/v2/package /p:OctopusPublishApiKey=156372ea-b731-42f6-ba3d-65269e7b01a8
</code></pre>


<p>注意:这些变量在OctoPack 2.0中已经改变——它们现在是<code>Octo<strong>Pack</strong>PublishPackageToHttp</code>和<code>Octo<strong>Pack</strong>PublishApiKey</code>。</p>


<p>我正在使用几天前<a href="http://octopusdeploy.com/blog/publishing-with-octopack">引入OctoPack的两个属性</a>。第一个设置要发布到的URI——在本例中是我的MyGet提要——第二个是要使用的API键。我从MyGet.org Feed详细信息页面获得了这两个值。</p>

<p>再次排队我的构建，它通过:</p>

<p><img src="../Images/55240961cbfd80d67dd715cb7b6c10ee.png" alt="Build passes" data-original-src="https://i.octopus.com/blog/migrated/11published-to-myget-success.PNG"/></p>

<p>如果我检查“我的获取包”选项卡:</p>

<p><img src="../Images/0028690437b37c6ac733d2a0c85153ed.png" alt="MyGet package listing" data-original-src="https://i.octopus.com/blog/migrated/11myget-package.PNG"/></p>

<p>呜哇！</p>

<h2>步骤7:向Octopus添加MyGet提要</h2>

<p>让我们回顾一下我们的现状:</p>

<ol>
<li>我们有一个网站</li>
<li>我们有一个CI构建</li>
<li>我们已经把网站打包了</li>
<li>我们把这个包发布到了一个NuGet服务器上</li>
<li>现在我们需要部署这个包</li>
</ol>

<p>我已经安装了一个Octopus Deploy服务器(<a href="http://octopusdeploy.com/documentation/install">参见安装指南</a>了解如何安装的细节)，我有三个服务器，都运行在Amazon EC2上。一台服务器位于暂存环境中，另外两台位于生产环境中:</p>

<p><img src="../Images/321d599570e66b26dae79e20a1d292d4.png" alt="Octopus machines and environments" data-original-src="https://i.octopus.com/blog/migrated/11octo-envs.PNG"/></p>

<p>这些机器是Amazon EC2 Windows Server 2008 R2映像，我已经安装了IIS组件以及在本地运行的Octopus部署代理。我已经使用Octopus内置的公钥加密支持建立了一个<a href="http://octopusdeploy.com/documentation/security/octopus-tentacle">信任关系</a>，这允许我安全地将包从我的Octopus服务器推送到我的机器上。</p>

<p>在Octopus web portal配置区域，我将转到NuGet选项卡，添加一个新的提要，粘贴我的MyGet提要的详细信息:</p>

<p><img src="../Images/42546882f81af528008c189a7c5ebbbb.png" alt="Adding the feed" data-original-src="https://i.octopus.com/blog/migrated/11create-feed.PNG"/></p>

<p>如果我使用的是私人的MyGet feed，或者TeamCity feed，我会在下面的框中添加用户名/密码。在这种情况下，我使用的是公共提要，所以我将它们留空。</p>

<p>添加提要后，我可以通过单击Test并执行搜索以列出包来验证它是否工作:</p>

<p><img src="../Images/eee31d7c39df72770dc49409d3aba0e7.png" alt="Testing the feed" data-original-src="https://i.octopus.com/blog/migrated/11search.PNG"/></p>

<h2>步骤8:在Octopus中定义项目</h2>

<p>接下来，我将在Octopus UI中创建新项目:</p>

<p><img src="../Images/e888f7deeb47cfbefcc4f6a3fbc1125b.png" alt="Creating an Octopus project" data-original-src="https://i.octopus.com/blog/migrated/11octo-proj.PNG"/></p>

<p>在步骤选项卡上，我将单击<strong>添加包步骤</strong>。在这个页面上，我将输入我的NuGet包的ID，选择提要，并选择应该将它部署到哪些机器上:</p>

<p><img src="../Images/d451f3a678b16ba129e3bfcd6ae4933f.png" alt="Adding a step" data-original-src="https://i.octopus.com/blog/migrated/11octo-add-step.PNG"/></p>

<p>定义好我的项目后，我将创建一个新的版本，选择要部署的NuGet包的版本:</p>

<p><img src="../Images/b39d917b4c16ebbc16bf8624f6c6708e.png" alt="Creating a release" data-original-src="https://i.octopus.com/blog/migrated/11octo-create-release.PNG"/></p>

<p>在release details页面上，我有一个中心位置，在这里我可以看到我的发行说明，以及关于该版本中包含的NuGet包的信息。</p>

<p><img src="../Images/2c447d1ef250363518e9a9cb0ff6319c.png" alt="Release details" data-original-src="https://i.octopus.com/blog/migrated/11release-details2.PNG"/></p>

<p>接下来，我将单击<strong>部署该版本...</strong>并选择要部署到的环境:</p>

<p><img src="../Images/7a488796a0e85a5b7ac0fc7857b82d6c.png" alt="Deploy release" data-original-src="https://i.octopus.com/blog/migrated/11deploy.PNG"/></p>

<p>部署将会运行。在这个阶段，Octopus通过几个步骤工作:</p>

<ol>
<li>它从MyGet提要下载包，并验证散列</li>
<li>它将它上传到目标机器</li>
<li>它告诉目标机器上的部署代理安装软件包</li>
</ol>

<p>部署成功:</p>

<p><img src="../Images/ea41df60665d666c45f3648b0d3bde7e.png" alt="Deploy success" data-original-src="https://i.octopus.com/blog/migrated/11deploy-success.PNG"/></p>

<h2>步骤8:配置IIS</h2>

<p>Octopus提取了NuGet包，但是还没有修改IIS。如果我浏览部署日志，我会看到:</p>

<blockquote>
  <p>WARN在本地计算机上找不到名为“Columbia”的IIS网站或虚拟目录。如果你希望Octopus为你更新，你应该手动创建站点和/或虚拟目录。否则，您可以忽略此消息。</p>
</blockquote>

<p>在这个阶段，我有两个选择。我可以远程桌面到我的所有三台机器上，并用正确的应用程序池设置创建一个名为Columbia的新IIS站点。Octopus然后会自动找到这个IIS站点(因为它与NuGet包同名)并改变主目录指向它提取NuGet包的路径。</p>

<p>但是，我懒。因此，我将把一个<a href="http://octopusdeploy.com/documentation/features/powershell" title="PowerShell support in Octopus"> PostDeploy.ps1文件</a>添加到我的项目中。这是一个PowerShell脚本，因为它被命名为<em> PostDeploy.ps1 </em>，运行在远程机器上的触手代理将<em>自动</em>为我执行它。我不需要摆弄PowerShell remoting，我的机器也不需要在同一个Active Directory域上；是automagic！</p>

<p>我将在Visual Studio的项目中创建该文件，以便我团队中的开发人员可以看到它。我还会将它标记为Content，这样它就会包含在NuGet包的文件列表中:</p>

<p><img src="../Images/17929539ac41e5c611ed2b92fffcddab.png" alt="PostDeploy.ps1 PowerShell" data-original-src="https://i.octopus.com/blog/migrated/11postdeploy.PNG"/></p>

<p>该脚本将如下所示:</p>

<pre><code># Define the following variables in the Octopus web portal:
#
#   $ColumbiaIisBindings = ":80:columbia.octopusdeploy.com"
#
# Settings
#---------------
$appPoolName = ("Columbia-" + $OctopusEnvironmentName)
$siteName = ("Columbia - " + $OctopusEnvironmentName) 
$siteBindings = $ColumbiaIisBindings
$appPoolFrameworkVersion = "v4.0"
$webRoot = (resolve-path .)

# Installation
#---------------
Import-Module WebAdministration

cd IIS:\

$appPoolPath = ("IIS:\AppPools\" + $appPoolName)
$pool = Get-Item $appPoolPath -ErrorAction SilentlyContinue
if (!$pool) { 
    Write-Host "App pool does not exist, creating..." 
    new-item $appPoolPath
    $pool = Get-Item $appPoolPath
} else {
    Write-Host "App pool exists." 
}

Write-Host "Set .NET framework version:" $appPoolFrameworkVersion
Set-ItemProperty $appPoolPath managedRuntimeVersion $appPoolFrameworkVersion

Write-Host "Set identity..."
Set-ItemProperty $appPoolPath -name processModel -value @{identitytype="NetworkService"}

Write-Host "Checking site..."
$sitePath = ("IIS:\Sites\" + $siteName)
$site = Get-Item $sitePath -ErrorAction SilentlyContinue
if (!$site) { 
    Write-Host "Site does not exist, creating..." 
    $id = (dir iis:\sites | foreach {$_.id} | sort -Descending | select -first 1) + 1
    new-item $sitePath -bindings @{protocol="http";bindingInformation=$siteBindings} -id $id -physicalPath $webRoot
} else {
    Set-ItemProperty $sitePath -name physicalPath -value "$webRoot"
    Write-Host "Site exists. Complete"
}

Write-Host "Set app pool..."
Set-ItemProperty $sitePath -name applicationPool -value $appPoolName

Write-Host "Set bindings..."
Set-ItemProperty $sitePath -name bindings -value @{protocol="http";bindingInformation=$siteBindings}

Write-Host "IIS configuration complete!"
</code></pre>

<p>这个脚本看起来很长，但是阅读起来非常简单——它检查应用程序池是否存在，然后创建或更新它，然后对web站点做同样的事情。这些都是使用IIS PowerShell模块完成的。</p>

<p>该脚本使用了两个变量。第一个是<code>$OctopusEnvironmentName</code>，它由触手部署代理自动传递给脚本，在这个例子中它将是“Staging”或“Production”(顺便说一下，您可以在Octopus Deploy中创建任意多个环境)。</p>

<p>第二个变量是一个自定义变量，<code>$ColumbiaIisBindings</code>。我使用我的web服务器来托管多个站点，所以我将配置IIS绑定来只监听一个主机名。</p>

<ul>
<li>在制作中，我会使用<code>"columbia.octopusdeploy.com"</code></li>
<li>在Staging中，我将使用<code>"staging.columbia.octopusdeploy.com"</code></li>
</ul>

<p>在PowerShell脚本中，您会注意到我实际上没有为这个PowerShell变量设置值。既然每个环境都不一样，我该如何设置呢？答案是<a href="http://octopusdeploy.com/documentation/features/variables">章鱼变量</a>。</p>

<p>我将在Octopus UI中定义两个变量，并为每个变量设置环境:</p>

<p><img src="../Images/56bbb0ff70f120404d17a821aacd7a18.png" alt="Add variables" data-original-src="https://i.octopus.com/blog/migrated/11add-variables.PNG"/></p>

<p>最后，我将创建一个新版本，并选择新的包版本:</p>

<p><img src="../Images/5ae66d1e072dfc98928afc7b75777cd3.png" alt="Create new release" data-original-src="https://i.octopus.com/blog/migrated/11octo-create-release-2.PNG"/></p>

<h2>步骤9:重新部署到暂存</h2>

<p>我将再次将其部署到暂存:</p>

<p><img src="../Images/3fc71829df6c0765de2e1b56d13762b8.png" alt="Staging successful" data-original-src="https://i.octopus.com/blog/migrated/11stage-success-3.PNG"/></p>

<p>展开部署日志，我可以看到PowerShell脚本的输出:</p>

<pre><code>2012-07-18 13:05:22 INFO   Calling PowerShell script: 'C:\Apps\Staging\Columbia\1.0.4582.23418\PostDeploy.ps1'
2012-07-18 13:05:37 DEBUG  Script 'C:\Apps\Staging\Columbia\1.0.4582.23418\PostDeploy.ps1' completed.
2012-07-18 13:05:37 DEBUG  Script output:
2012-07-18 13:05:37 DEBUG  App pool does not exist, creating...

Name                     State        Applications
----                     -----        ------------
Columbia-Staging         Started
Set .NET framework version: v4.0
Set identity...
Checking site...
Site does not exist, creating...

Name         : Columbia - Staging
ID           : 2
State        : Started
PhysicalPath : C:\Apps\Staging\Columbia\1.0.4582.23418
Bindings     : Microsoft.IIs.PowerShell.Framework.ConfigurationElement

Set app pool...
Set bindings...
IIS configuration complete!
</code></pre>

<p>如果我浏览网站，我会看到:</p>

<p><img src="../Images/84086b73693d2e856668f6e98b68a0f5.png" alt="Staging preview" data-original-src="https://i.octopus.com/blog/migrated/11staging-preview.PNG"/></p>

<h2>步骤10:部署到生产环境</h2>

<p>既然我们已经验证了试运行部署可以工作，那么让我们将其部署到生产环境中。当一个环境的部署完成时，会出现一个升级按钮:</p>

<p><img src="../Images/eb1b0d855f9dc8de9f62241defdbbbf5.png" alt="Promote" data-original-src="https://i.octopus.com/blog/migrated/11promote.PNG"/></p>

<p>点击它，让我们选择生产:</p>

<p><img src="../Images/bfacc10e67931ff388055f9e4be97d20.png" alt="Promote to prod" data-original-src="https://i.octopus.com/blog/migrated/11promote-to-prod.PNG"/></p>

<p>当部署完成时，我们可以展开第三步来查看包实际上被部署到两台机器上，它们位于Amazon负载平衡器的后面:</p>

<p><img src="../Images/e77d5e50ee9838d889f342e1bc1946f3.png" alt="Deploy to production" data-original-src="https://i.octopus.com/blog/migrated/11deploy-to-prod2.PNG"/></p>

<p>让我们来看看生产现场:</p>

<p><img src="../Images/a4f4ebbcb3be28712ca715bc751cf3c5.png" alt="Production preview" data-original-src="https://i.octopus.com/blog/migrated/11prod-preview.PNG"/></p>

<h2>摘要</h2>

<p>在这篇文章中，我创建了一个ASP.NET MVC 4站点，并将其签入到我托管的TFS预览实例中。然后，我使用OctoPack从Team Build创建NuGet包，使用MyGet托管包。最后，我配置Octopus将应用程序部署到一台登台机器和两台生产机器上。</p>

<p><img src="../Images/98e0d0879e90e9cfc923888b522aa8f8.png" alt="TFS and ALM" data-original-src="https://i.octopus.com/blog/migrated/11tfs2.PNG"/></p>

<p>结合我之前的图片，我们已经使用Octopus扩展了TFS预览版以部署到EC2。但不止于此。Octopus被设计成能够部署到云中、私有数据中心的虚拟机上，甚至部署到你桌子下面的机器上。我们已经扩展了ALM，使其不仅仅意味着“部署到Azure web角色”。我们现在能够部署到托管在任何地方的虚拟机，并跨环境推广我们的产品。现在<strong>即</strong>是连续交货。</p>

<h2>关于TFS预演的最后想法</h2>

<p>正如我所说，我以前使用过TFS 2010的主机版本，体验并不好。然而，TFS预览版已经走过了漫长的道路。源代码控制有了很大的改进，一旦我习惯了UI，使用起来真的很棒。我可能会继续使用GitHub和TeamCity来完成我的大部分个人工作，但我认为微软已经为企业开发者创造了一个非常好的解决方案。试试看。</p>

                    
                    
</body>
</html>