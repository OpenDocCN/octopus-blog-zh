<html>
<head>
<title>Testing Terraform code - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>测试地形代码- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/testing-terraform-code#2021-08-12">https://octopus.com/blog/testing-terraform-code#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/testing-terraform-code/testing-terraform.png" class="zoom" data-title=""><img src="../Images/4ac77dac2d63194f1c14b3cd43d3281d.png" class="img-fluid center" alt="Testing Terraform code" data-original-src="https://i.octopus.com/blog/2020-07/testing-terraform-code/testing-terraform.png"/>T2】</a></p>

<p>测试代码是开发人员能做的最重要的事情之一。事实上，有一种叫做测试驱动开发(<a href="http://agiledata.org/essays/tdd.html" rel="nofollow"> TDD </a>)的编码实践是基于先写测试，然后基于测试写代码。即使你不遵循测试驱动开发，考虑在代码中实现单元测试和模拟测试仍然是极其重要的。没有测试，您实际上是在部署代码，并希望它会按照您认为应该的方式工作。即使代码部署得很好，如果代码被修改了，你也不知道会有什么结果。</p>

<p>在这篇文章中，你将关注用一个叫做Terratest的框架来测试Terraform代码。Terratest是最受欢迎的Terraform测试框架之一，具有许多不同的工具集，功能丰富。</p>

<h2 id="prerequisites">先决条件</h2>

<p>要跟进这篇文章，您应该具备以下条件:</p>

<ul>
<li>对编程的理解。虽然你不会深入Golang的基础知识，但如果你过去编程过，你应该会看到熟悉的概念(方法、函数等。).</li>
<li>关于地形的中级知识。</li>
<li>Azure订阅。如果你没有，你可以注册一个<a href="https://azure.microsoft.com/en-us/free/" rel="nofollow"> 30天的免费试用</a>。</li>
<li>文本编辑器。出于本文的目的，您将使用Visual Studio代码(<a href="https://code.visualstudio.com/download" rel="nofollow"> VS代码</a>)。</li>
<li>Golang已安装。根据操作系统的不同，您可以找到<a href="https://golang.org/doc/install" rel="nofollow">安装说明</a>。</li>
</ul>

<h2 id="unit-tests-and-mock-tests">单元测试和模拟测试</h2>

<p>在进入测试部分之前，让我们回顾一下测试到底是什么。您通常会使用的两个主要测试是:</p>



<h3 id="unit-tests">单元测试</h3>

<p>单元测试是一种用于测试特定代码单元的软件测试方法。例如，假设您有一个名为<code>Car</code>的类和该类中一个名为<code>Ford</code>的方法。<code>Ford</code>方法返回几个值；福特是什么颜色，福特是什么型号，福特是哪一年的。您可以运行该代码来查看结果是否正确，但是如果您不想创建任何特定的东西，而只想查看代码是如何构建的呢？这就是单元测试的用武之地。单元测试可以测试值应该是什么。</p>

<p>假设结果应该是以下值:</p>

<ul>
<li>年份= 2020年</li>
<li>型号= F150套索</li>
<li>颜色=铂。</li>
</ul>

<p>当单元测试运行时，如果这些值返回true，则单元测试通过。如果结果返回为false，则单元测试失败，它会让您知道失败在哪里。</p>

<h3 id="mock-test">模拟测试</h3>

<p>模拟测试是另一种软件测试方法，它可以伪造资源的创建，也可以实际创建资源。假设您有一些C#代码，您想为一个前端web应用程序进行测试。单元测试可以很好地确认方法在C#代码中实际工作，但是如果您想测试实际的部署呢？您可以实现一个模拟测试，而不是一次又一次地手工部署测试，或者创建一个连续的交付管道来测试代码。模拟测试将部署代码，确认代码工作正常，或者保持部署不变，或者删除部署。在典型的模拟测试中，资源在模拟成功运行后立即被删除。</p>

<h2 id="writing-the-terraform-code-to-test">编写要测试的Terraform代码</h2>

<p>在上一节中，您学习了什么是单元测试和模拟测试。在本节中，您将创建一个Terraform模块，该模块将在Azure中部署一个虚拟网络。您编写的代码将是用于测试目的的代码。</p>

<p>让我们检查一下Terraform代码的每个部分，以确认正在部署什么。要了解这一部分，您应该打开一个文本编辑器，如Visual Studio代码。</p>

<h3 id="the-main.tf-configuration">main.tf配置</h3>

<p>第一部分将是<code>azurerm</code>提供者。<code>azurerm</code>提供者对Azure进行API调用来创建资源:</p>

<pre><code>provider "azurerm" {
    version = "2.0.0"
    subscription_id = var.subscriptionID
}
</code></pre>

<p>第二部分是第一个资源。第一个资源在Azure中创建了一个网络安全组(NSG)。NSG非常类似于防火墙:</p>

<pre><code>resource "azurerm_network_security_group" "OctopusSG" {
  name                = "OctopusSG"
  location            = "eastus"
  resource_group_name = var.resourceGroupName
}
</code></pre>

<p>第三部分将创建第一个网络安全规则。可以把网络安全规则想象成防火墙上的端口规则。第一个端口规则是端口80对世界开放:</p>

<pre><code>resource "azurerm_network_security_rule" "Port80" {
  name                        = "Allow80"
  priority                    = 102
  direction                   = "Inbound"
  access                      = "Allow"
  protocol                    = "Tcp"
  source_port_range           = "*"
  destination_port_range      = "80"
  source_address_prefix       = "*"
  destination_address_prefix  = "*"
  resource_group_name         = azurerm_network_security_group.OctopusSG.resource_group_name
  network_security_group_name = azurerm_network_security_group.OctopusSG.name
}
</code></pre>

<p>第二个网络安全规则针对端口22，它将允许安全外壳(SSH)连接到网络安全组中的任何虚拟机:</p>

<pre><code>resource "azurerm_network_security_rule" "Port22" {
  name                        = "Allow22"
  priority                    = 100
  direction                   = "Inbound"
  access                      = "Allow"
  protocol                    = "Tcp"
  source_port_range           = "*"
  destination_port_range      = "443"
  source_address_prefix       = "*"
  destination_address_prefix  = "*"
  resource_group_name         = azurerm_network_security_group.OctopusSG.resource_group_name
  network_security_group_name = azurerm_network_security_group.OctopusSG.name
}
</code></pre>

<p>正在创建的第四个资源是Azure虚拟网络本身。虚拟网络将有一个地址空间(CIDR范围)为<code>10.0.0.0/16</code>和两个DNS服务器<code>8.8.8.8</code>和<code>8.8.4.4</code>:</p>

<pre><code>resource "azurerm_virtual_network" "octopus-vnet" {
  name                = "octopus-vnet"
  location            = var.location
  resource_group_name = var.resourceGroupName
  address_space       = ["10.0.0.0/16"]
  dns_servers         = ["8.8.8.8", "8.8.4.4"]
}
</code></pre>

<p>第五个也是最后一个资源是为虚拟网络内部的子网创建的。子网将有一个地址前缀(子网范围)为<code>10.0.1.0/24</code>:</p>

<pre><code>resource "azurerm_subnet" "octopus-sub" {
  name                 = "testsubnet"
  resource_group_name  = azurerm_network_security_group.OctopusSG.resource_group_name
  virtual_network_name = azurerm_virtual_network.octopus-vnet.name
  address_prefix = "10.0.1.0/24"
}
</code></pre>

<h3 id="the-variable-configuration">可变配置</h3>

<p>变量将由三个值组成:</p>

<ul>
<li>订阅ID</li>
<li>资源组名</li>
<li>位置</li>
</ul>

<p>下面是没有任何默认值的变量配置。这使得代码可重用，并且在大多数环境中更容易实现:</p>

<pre><code>variable "subscriptionID" {
    type = string
    description = "Variable for our resource group"
}

variable "resourceGroupName" {
    type = string
    description = "name of resource group"
}

variable "location" {
    type = string
    description = "location of your resource group"
}
</code></pre>

<h3 id="the-tfvars-configuration">Tfvars配置</h3>

<p>为了在运行时传递变量，您将使用一个<code>terraform.tfvars</code>配置来尽可能地保持代码的可重用性。</p>

<p>下面是将要使用的<code>tfvars</code>配置:</p>

<pre><code>subscriptionID = value_here
resourceGroupName = "OctopusRG"
location = value_here
</code></pre>

<p>有了<code>main.tf</code>、<code>variables.tf</code>和<code>terraform.tfvars</code>，您就可以开始查看Terratest来测试您编写的代码了。</p>

<h2 id="first-look-at-terratest">首先看TerraTest</h2>

<p>在上一节中，您编写了将用Terratest测试的代码。在本节中，您将了解Terratest如何与Terraform一起使用。</p>

<p>Terratest框架可以在<a href="https://github.com/newcontext-oss/kitchen-terraform" rel="nofollow"> GitHub </a>找到。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/testing-terraform-code/1.png" class="zoom" data-title=""> <img src="../Images/ae54fabe8977668377d56c0b9e352bec.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/testing-terraform-code/1.png"/> </a> Terratest是一个Go库，帮助你实现基础设施即代码测试。Terratest由Gruntwork创建和维护，这是一个提供DevOps即服务的平台。你可以了解更多关于<a href="https://gruntwork.io/" rel="nofollow"> Gruntwork </a>。</p>

<p>在Terratest GitHub上的examples目录下，可以看到几个不同的例子。让我们来看看<strong>docker-hello-world-example</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/testing-terraform-code/2.png" class="zoom" data-title=""><img src="../Images/336e6fa175d02d1fb4c35d0e1e621bdf.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/testing-terraform-code/2.png"/>T2】</a></p>

<p>正如您从下面的截图中看到的，可以通过运行<code>build</code>和<code>run</code>命令以标准方式构建Docker映像。</p>

<p>当Docker容器运行时，您可以使用Golang命令行来运行测试。您使用的命令行工具是<code>go test</code>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/testing-terraform-code/3.png" class="zoom" data-title=""><img src="../Images/07958089427e1019c9b457f2ef70c794.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/testing-terraform-code/3.png"/>T2】</a></p>

<p>测试运行后，您将看到一个输出，告诉您测试是否成功完成。</p>

<h2 id="writing-the-test-in-terratest">在Terratest中编写测试</h2>

<p>既然您已经了解了将要测试的代码和Terratest框架，那么是时候使用Golang创建一个新的测试了。</p>

<p>对于本节，您应该打开Visual Studio代码，并在与Terraform代码相同的目录中创建新文件。新文件可以随意命名，例如<code>terraform-test.go</code>。</p>

<p>让我们首先设置<code>package</code>并将其称为<strong>测试</strong>:</p>

<pre><code class="language-go">package test

}
</code></pre>

<p>接下来，您需要指定几个不同的Golang库。将使用的两个Golang库是:</p>



<pre><code class="language-go">package test

import (
  "github.com/gruntwork-io/terratest/modules/terraform"
  "testing"
)
</code></pre>

<p>当库在导入块中之后，设置新的函数。这个函数可以被命名为任何你喜欢的名字，但是在这篇文章中，我们称它为<code>vnet_test</code>。通过在新创建的函数中调用<code>testing</code>库来使用它:</p>

<pre><code class="language-go">package test

import (
  "github.com/gruntwork-io/terratest/modules/terraform"
  "testing"
)

func vnet_test(t *testing.T) {
    }
}
</code></pre>

<p>最后，您需要添加测试本身。首先，将创建一个名为<code>terraformOptions</code>的变量，它利用了<code>terraform.Options()</code>。然后，代码使用一个名为<code>defer</code>的语句，在虚拟网络被测试和创建后立即销毁它。在defer语句之后，您将看到用Terraform初始化和创建虚拟网络的<code>.InitAndApply</code>方法:</p>

<pre><code class="language-go">package test

import (
  "github.com/gruntwork-io/terratest/modules/terraform"
  "testing"
)

func vnet_test(t *testing.T) {

    terraformOptions := &amp;terraform.Options{
    }

    defer terraform.Destroy(t, terraformOptions)

    terraform.InitAndApply(t, terraformOptions)

}
</code></pre>

<p>当您有了<code>terraform-test.go</code>文件中的代码后，在命令行上运行以下命令:</p>

<pre><code class="language-go">go test -v terraform-test.go
</code></pre>

<p>恭喜你！您已经使用Terratest成功创建了一个Terraform测试。</p>

<h2 id="conclusion">结论</h2>

<p>在这篇文章中，您了解了测试的关键概念，以及为什么在任何代码中实现测试如此重要。无论是后端代码，前端代码，还是基础设施代码。您首先了解了两种关键的测试类型，单元测试和模拟测试。然后，您编写了一些Terraform代码，开始测试创建Azure虚拟网络。之后，您先看了一下Terratest框架及其提供的功能。最后，您编写了一个Terratest来测试Azure虚拟网络的创建，并在创建成功后销毁它。</p>

<p>对于你的下一个挑战，尽管在这篇文章中没有解释，看看<a href="https://github.com/newcontext-oss/kitchen-terraform" rel="nofollow">厨房平台</a>。Kitchen-terraform是另一个即将推出并越来越受欢迎的测试框架。</p>

                    
                    
</body>
</html>