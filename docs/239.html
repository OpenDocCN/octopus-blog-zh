<html>
<head>
<title>Docker Compose RFC - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Docker编写RFC - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/docker-compose-naming#2017-09-29">https://octopus.com/blog/docker-compose-naming#2017-09-29</a></blockquote>
                        

<p>在Octopus Deploy <code>3.5.1</code> build中发布了对<a href="https://octopus.com/blog/docker-engine-in-octopus-deploy"> Docker引擎步骤</a>的一些基本支持之后，我们将注意力转向了下一个抽象层次...<em>码头工人作曲</em></p>

<blockquote>
  <p>现在已经开始为Docker <strong>提供一流的支持，我们仍然希望您对下一步的反馈(双关语)。</strong></p>
</blockquote>

<h2>命名很难</h2>

<p><a href="https://docs.docker.com/compose/overview/"> Docker Compose </a>允许你通过一个<code>docker-compose.yml</code>配置文件管理多个容器、网络和卷。它使用一个名为的<a href="https://docs.docker.com/compose/reference/envvars/#compose-project-name">项目来隔离资源组，以允许在单个主机内管理多个环境，通过这种方式，您可以让几个Docker组合应用程序在给定的主机上运行，并在它们自己的网络内隔离。<img src="../Images/d8db25f7771ffc8f9d7914619954cb3a.png" alt="Multiple Docker apps per host" data-original-src="https://i.octopus.com/blog/201611-compose-SWZP.png"/></a></p>

<p>我们正在尝试的一个想法是在部署时根据Octopus Deploy <code>project</code> + <code>step</code> + <code>environment</code>的组合来命名这些应用。这将允许部署跨Octopus环境启动多个Docker Compose应用程序，但是确保当部署发生并且我们只想更新现有服务时，只有那些容器得到更新和重新启动(根据对配置文件的更改，如映像版本更新的定义)。例如，下一个版本可能涉及更新用于web容器的图像版本，以及增加该应用程序中web容器的数量。那么理想情况下，只有相关Docker Compose应用程序中的web容器会受到该部署的影响。Docker Compose为我们提供了这样一种能力，即针对一组容器，一次性更新它们，而不是分别执行多个停止/运行步骤，但是要实现这一点，需要一些命名约定。<img src="../Images/6c4345b2484e1d62a094804262549e4a.png" alt="Compose step only updates app scoped with same namespace" data-original-src="https://i.octopus.com/blog/201611-compose-update-L24R.png"/></p>

<p>另一方面，这与Octopus Deploy使用的标准包提取略有不同，在这种情况下，部署项目的多个版本可能同时存在于同一个环境中，因为它们只是存储在文件系统的不同位置。如果需要，潜在地向标识符提供用户提供的元素(例如频道名称)将允许类似的行为。</p>

<h2>配置源</h2>

<p><img src="../Images/1dfb857a41fef9acae5227c801cd01a6.png" data-original-src="https://i.octopus.com/blog/201611-octopuscomposestep-X6W9.png"/>如上所述，Docker编写步骤的必需元素是描述应用程序的<a href="https://docs.docker.com/compose/compose-file/"> docker-compose.yml </a>文件。为了提供与Octopus部署包生命周期的集成，我们希望用户通过Octopus部署包选择过程将一个或多个映像绑定到Docker映像。当一个发布被创建时，在该步骤中绑定到服务的所有包版本将可供用户选择。该配置还能够与标准变量替换一起工作，以允许在部署时解析的特定于环境的配置。<em>如果支持变量替换，你认为你会需要使用<a href="https://docs.docker.com/compose/extends/#/multiple-compose-files">多个合成文件</a>？</em></p>

<p><em>也许从一个版本化的包中提取配置文件会更好</em>(类似于来自包的<a href="http://docs.octopusdeploy.com/display/OD/Standalone+scripts">脚本当前的工作方式)？在这种情况下，您可能需要提供在版本创建时选择的映像列表的选项<em>，而不需要从配置中自动提取服务列表。</em></a></p>

<h2>部署时构建</h2>

<p>通过提供一种从单独的包中获取配置的机制，它可能会额外提供提供<code>Dockerfiles</code>的能力，该能力可用于在部署时作为<code>docker-compose</code>过程的一部分<a href="https://docs.docker.com/compose/compose-file/#/build">构建映像</a>。我们有意避免在我们的第一个<code>3.5.1</code>版本中提供一个<code>docker build</code>步骤，因为这感觉像是一个应该在CI渠道的构建阶段进行的过程。单一的不可变构建工件，即映像，应该被创建一次，并在相关的环境中进行。<em>考虑到Octopus Deploy和Docker的理念，您认为创建映像在部署过程中有用吗？</em> <br/></p>

<blockquote>
  <p>微软也落后于Docker，并宣布在Visual Studio 2017中为直接部署到容器的<a href="https://blogs.msdn.microsoft.com/webdev/2016/11/16/new-docker-tools-for-visual-studio/">提供一流的支持</a>(因此仅比我们和我们的第一个Docker集成落后一点点；))<em>...Docker可能很快会在您的CI/CD渠道中扮演更重要的角色。</em></p>
</blockquote>

<h2>征求意见</h2>

<p>希望你有机会尝试一下<code>3.5.1</code>中提供的新Docker步骤，感受一下我们在Octopus Deploy中的这些特性。最终，这项工作是为了让您在部署应用程序时更加轻松，所以您的意见最重要。</p>

<ul>
<li>你如何看待Docker编写组的命名空间，以便在升级时方便修改？</li>
<li>您首选的提供配置文件的机制是什么，内联还是包源？</li>
<li>您认为提供映像构建功能有意义吗？</li>
<li>我们还完全错过了什么？</li>
</ul>

<p>如果您对Docker Compose的外观有任何其他想法或意见，请在下面添加您的评论或评论并关注开放的<a href="https://github.com/OctopusDeploy/Issues/issues/2875"> GitHub ticket #2875 </a>。</p>

                    
                    
</body>
</html>