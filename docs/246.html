<html>
<head>
<title>Invoking an executable from PowerShell with a dynamic number of parameters - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用动态数量的参数从PowerShell调用可执行文件——Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/dynamic-argument-list-when-calling-executable-from-powershell#2015-09-17">https://octopus.com/blog/dynamic-argument-list-when-calling-executable-from-powershell#2015-09-17</a></blockquote>
                        <p>从PowerShell调用可执行文件很容易——大多数时候，您只需在前面加上一个<code>&amp;</code>。为了说明，让我们看看这个C#可执行文件:</p>

<pre><code>static void Main(string[] args)
{
    for (int i = 0; i &lt; args.Length; i++)
    {
        Console.WriteLine("[" + i + "] = '" + args[i] + "'");
    }
}
</code></pre>

<p>如果我们这样称呼它:</p>

<pre><code>&amp; .\Argsy.exe arg1 "argument 2"
</code></pre>

<p>我们得到:</p>

<pre><code>[0] = 'arg1'
[1] = 'argument 2'
</code></pre>

<p>PowerShell变量也可以传递给参数:</p>

<pre><code>$myvariable = "argument 2"
&amp; .\Argsy.exe arg1 $myvariable

# Output:
[0] = 'arg1'
[1] = 'argument 2'
</code></pre>

<p>注意,<code>$myvariable</code>的值包含一个空格，但是PowerShell很聪明，将整个值作为一个参数传递。</p>

<p>当您想要有条件地或动态地添加参数时，这就变得棘手了。例如，您可能会尝试这样做:</p>

<pre><code>$args = ""
$environments = @("My Environment", "Production")
foreach ($environment in $environments) 
{
    $args += "--environment "
    $args += $environment + " "
}

&amp; .\Argsy.exe $args
</code></pre>

<p>然而，您会对输出感到失望:</p>

<pre><code>[0] = '--environment My Environment --environment Production '
</code></pre>

<h2>正确的方式</h2>

<p>相反，这样做的方法是创建一个数组。您仍然可以在PowerShell中使用<code>+=</code>语法来构建阵列:</p>

<pre><code>$args = @() # Empty array
$environments = @("My Environment", "Production")
foreach ($environment in $environments) 
{
    $args += "--environment"
    $args += $environment
}
&amp; .\Argsy.exe $args
</code></pre>

<p>它输出了我们期望的结果:</p>

<pre><code>[0] = '--environment'
[1] = 'My Environment'
[2] = '--environment'
[3] = 'Production'
</code></pre>

<p>您也可以将常规字符串与数组混合使用:</p>

<pre><code>&amp; .\Argsy.exe arg1 "argument 2" $args

# Output:
[0] = 'arg1'
[1] = 'argument 2'
[2] = '--environment'
[3] = 'MyEnvironment'
[4] = '--environment'
[5] = 'Production'
</code></pre>

<h2>边缘情况</h2>

<p>对于我上面所说的传递一个带有所有参数的字符串，有一种非常奇怪的情况。以这个例子为例，它与上面的例子相似:</p>

<pre><code>$args = "--project Foo --environment My Environment --environment Production"
&amp; .\Argsy.exe $args

# Output: 
[0] = '--project Foo --environment My Environment --environment Production'
</code></pre>

<p>要使它按预期工作，只需在第一个参数的<strong>两边加上引号，行为就会完全改变！(反勾号是PowerShell的转义字符)</strong></p>

<pre><code>$args = "`"--project`" Foo --environment My Environment --environment Production"
&amp; .\Argsy.exe $args

# Output: 
[0] = '--project'
[1] = 'Foo'
[2] = '--environment'
[3] = 'My'
[4] = 'Environment'
[5] = '--environment'
[6] = 'Production'
</code></pre>

<p>如果不引用第一个参数，行为不会改变:</p>

<pre><code>$args = "--project `"Foo`" --environment My Environment --environment Production"
&amp; .\Argsy.exe $args

# Output: 
[0] = '--project Foo --environment My Environment --environment Production'
</code></pre>

<p>啊，PowerShell。总是充满惊喜！</p>

                    
                    
</body>
</html>