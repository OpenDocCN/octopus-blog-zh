<html>
<head>
<title>Importing Kubernetes YAML in Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Octopus - Octopus Deploy中导入Kubernetes YAML</h1>
<blockquote>原文：<a href="https://octopus.com/blog/importing-kubernetes-yaml-in-octopus#2021-08-12">https://octopus.com/blog/importing-kubernetes-yaml-in-octopus#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/kubernetes-yaml-octopus.png" class="zoom" data-title=""><img src="../Images/407e0fa949ab6a31755cf4d5709de748.png" class="img-fluid center" alt="Importing Kubernetes YAML in Octopus" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/kubernetes-yaml-octopus.png"/>T2】</a></p>

<p>如果您在Octopus之外使用Kubernetes已经有一段时间了，那么您可能已经有了YAML资源定义。由于Octopus 2020.2中引入的新功能，将此YAML迁移到Octopus很容易，这为您提供了导入、导出和编辑原始YAML的两全其美的能力，同时让您的Kubernetes资源由Octopus以自以为是的方式进行管理。</p>

<p>在这篇博文中，我将向您展示如何将现有的YAML定义迁移到Octopus部署中。</p>

<h2 id="the-sample-yaml">样本YAML</h2>

<p>下面是YAML，它定义了一个部署资源和一个服务来公开Docker映像包含的web应用程序:</p>

<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: randomquotes
spec:
  selector:
    matchLabels:
      app: randomquotes
  replicas: 1
  strategy:
    type: RollingUpdate
  template:
    metadata:
      labels:
        app: randomquotes
    spec:
      containers:
        - name: randomquotes
          image: mcasperson/mywebapp:0.1.7
          ports:
            - name: web
              containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: randomquotes
spec:
  selector:
    app: randomquotes
  ports:
    - name: web
      port: 80
</code></pre>

<p>Kubernetes中的一个常见模式是让服务公开一个部署，然后潜在地让web流量通过入口指向它。上面的YAML是部署和服务模式的一个简单例子。</p>

<p>Octopus中的Kubernetes步骤提供了一种在单个步骤中捕获这种模式的方法，抽象出了一些将这些资源链接在一起的管道。让我们把我们的原始YAML，并用它来建立一个章鱼的步骤。</p>

<h2 id="create-the-octopus-step">创建章鱼步骤</h2>

<p>我们将使用<strong>部署Kubernetes容器</strong>步骤来定义上面YAML中的部署和服务。该步骤是部署与可选服务、入口、秘密和配置映射的自以为是的组合，并处理将所有内容链接在一起所需的管道:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deploy-containers.png" class="zoom" data-title=""><img src="../Images/964716fd41ed22a69f6da18c5a3d2ed0.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deploy-containers.png"/>T2】</a></p>

<p>因为我们不部署入口、机密或配置映射，所以我们可以从该步骤中删除这些功能。这简化了用户界面，使我们能够专注于正在创建的资源:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/disable-features.png" class="zoom" data-title=""><img src="../Images/833e3c43de749264f5fd9fe4b0f6961e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/disable-features.png"/>T2】</a></p>

<p><strong>编辑YAML </strong>部分是Octopus 2020.2中的新增功能，它允许将该步骤创建的Kubernetes资源编辑为YAML:</p>

<p>【T2 <img src="../Images/e96a7eb383a0671f3c600ca4caf5a2aa.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-edit-yaml.png"/></p>

<p>点击<strong>编辑YAML </strong>按钮显示该步骤中当前设置的YAML表示。因为我们刚刚添加了步骤，所以显示的值只是默认值或占位符:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-default-yaml.png" class="zoom" data-title=""><img src="../Images/d67b5aefa919e37ac76608a7b2ce7880.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-default-yaml.png"/>T2】</a></p>

<p>我们可以用上面示例中的部署YAML覆盖这些值:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-paste-yaml.png" class="zoom" data-title=""><img src="../Images/61ffd00c5d64612431071a22cf936062.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-paste-yaml.png"/>T2】</a></p>

<p>然后在表单中填充部署属性和容器定义。请注意，映像版本(或标记)已被删除，因为在创建部署时应该选择它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/populated-deployment.png" class="zoom" data-title=""><img src="../Images/b70656e8482ac7bec7716463475db99b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/populated-deployment.png"/>T2】</a></p>

<p>然后我们可以为服务重复这个过程，它有自己的<strong>编辑YAML </strong>部分:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/service-edit-yaml.png" class="zoom" data-title=""><img src="../Images/99b7450edb9668788372196290358fb5.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/service-edit-yaml.png"/>T2】</a></p>

<p>保存详细信息后，将使用服务属性和端口填充服务:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/service-pasted-yaml.png" class="zoom" data-title=""><img src="../Images/573636c13c20a08b6f1034c433653359.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/service-pasted-yaml.png"/>T2】</a></p>

<p>需要注意的一点是，服务标签没有被导入，因为它们没有被步骤公开。这一步的观点之一是所有资源(在我们的例子中是部署和服务)共享部署上定义的标签。通过Octopus自动添加的附加标签，在部署时将服务和部署联系起来，使我们无需在服务上维护选择器标签:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/populated-service.png" class="zoom" data-title=""><img src="../Images/4993ed56fa9be9c28e60d460f517ba2e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/populated-service.png"/>T2】</a></p>

<h2 id="export-the-yaml">出口YAML</h2>

<p>在前面的部分中，我们使用了<strong>编辑YAML </strong>部分来导入我们现有的YAML。这进而用我们现有资源定义的细节填充了该步骤。</p>

<p>现在该步骤已经填充完毕，可以使用<strong>编辑YAML </strong>部分来导出YAML。单击部署或服务部分中的<strong>编辑YAML </strong>按钮，将在表单中显示作为标准YAML资源的详细信息。值得注意的是，输出的YAML与之前粘贴的并不完全相同。一些名为<code>octopusexport</code>的默认标签已被添加到部署和pod规范中，以将两者链接在一起:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-export.png" class="zoom" data-title=""><img src="../Images/c152a2def48a85c5d01131401441414e.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/deployment-export.png"/>T2】</a></p>

<p>同样，服务YAML还包括一些默认标签，用于将服务链接到pod:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/service-export.png" class="zoom" data-title=""><img src="../Images/ca7e33c0280dea4ab4ac4222598ad39d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-08/importing-kubernetes-yaml-in-octopus/service-export.png"/>T2】</a></p>

<p>但是，除了资源如何相互引用的一些小变化之外，生成的YAML保留了最初导入的YAML的所有重要细节。这使得在固执己见的Octopus步骤中复制Kubernetes YAML定义变得很容易，或者如果您发现这比通过UI编辑值更容易，就简单地就地编辑YAML。</p>

<h2 id="limitations-of-yaml-importing">YAML进口的局限性</h2>

<p>需要注意的是，该步骤将仅导入其认可的YAML值。如果您的部署YAML包含一个无法识别的字段，它将被忽略。此功能不提供将未识别的值与UI公开的值合并的方法。</p>

<p>如果您有无法识别的值，您可以利用<strong>部署原始Kubernetes YAML </strong>步骤，该步骤将按原样将YAML部署到Kubernetes，并且将仅基于<a href="https://octopus.com/docs/projects/variables/variable-substitutions">章鱼变量语法</a>执行变量替换。</p>

<p>但是，如果您发现自己遇到了固执己见步骤的限制，复制并粘贴它生成的YAML是一种简单的方法，可以转到原始的YAML步骤。</p>

<h2 id="conclusion">结论</h2>

<p>很容易找到Kubernetes资源，比如与服务、入口、秘密和配置图相结合的部署。Octopus通过<strong>部署Kubernetes容器</strong>步骤捕获了这种资源组合。</p>

<p>如果您已经有了现有的Kubernetes YAML，那么<strong>部署Kubernetes容器</strong>步骤允许您通过将YAML复制并粘贴到<strong>编辑YAML </strong>部分来快速填充其值。</p>

<p><strong>部署Kubernetes容器</strong>步骤不会(也永远不会)暴露底层Kubernetes资源可用的每一个可能的值，如果您发现自己已经超越了这个固执己见的步骤，那么<strong>编辑YAML </strong>部分提供了一个快速的方法来提取该步骤产生的YAML，用于一般步骤，如<strong>部署原始Kubernetes YAML </strong>。</p>

                    
                    
</body>
</html>