<html>
<head>
<title>Using the WildFly CLI - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用WildFly CLI - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/using-the-wildfly-cli#2022-08-09">https://octopus.com/blog/using-the-wildfly-cli#2022-08-09</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-the-wildfly-cli/java-octopus.png" class="zoom" data-title=""><img src="../Images/cbc9a154e1f6a27953fd665b9f63fafa.png" class="img-fluid center" alt="Using the WildFly CLI" data-original-src="https://i.octopus.com/blog/2020-07/using-the-wildfly-cli/java-octopus.png"/>T2】</a></p>

<p>WildFly CLI是一个强大的管理工具，它提供了交互式控制台和脚本功能。CLI可用于查询和配置WildFly应用服务器的所有方面，在这篇文章中，我将从较高的层次来看如何使用CLI。</p>

<h2 id="logging-in">登录</h2>

<p>下载WildFly 11，解压，运行<code>bin/standalone.sh</code>或者<code>bin\standalone.bat</code>。这将以默认配置开始，即将管理接口绑定到端口9990上的本地主机。</p>

<p>在另一个控制台中，使用<code>--connect</code>参数运行<code>bin/jboss-cli.sh</code>或<code>bin\jboss-cli.bat</code>。您将登录到CLI:</p>

<pre><code>$ ./jboss-cli.sh --connect
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.wildfly.security.manager.GetAccessibleDeclaredFieldAction (jar:file:/Users/matthewcasperson/Downloads/wildfly-11.0.0.Final/modules/system/layers/base/org/wildfly/security/elytron-private/main/wildfly-elytron-1.1.6.Final.jar!/) to field java.security.AccessControlContext.context
WARNING: Please consider reporting this to the maintainers of org.wildfly.security.manager.GetAccessibleDeclaredFieldAction
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
[standalone@localhost:9990 /]
</code></pre>

<p>从上面的输出示例中，我们可以看到发生了三件重要的事情。</p>

<p>首先，Java 9已经报告了一些<em>非法反射访问</em>警告。这听起来很可怕，但这是因为Java 9模块系统引入了一些有意的变化(被称为<a href="http://www.baeldung.com/project-jigsaw-java-modularity" rel="nofollow">拼图</a>)。我希望随着时间的推移，这些警告会得到解决，但现在可以忽略它们。</p>

<p>其次，我们已经使用默认协议(remote+http)连接到默认主机(localhost)和端口(9990)。这些可以通过<code>--controller</code>选项手动指定:</p>

<pre><code>./jboss-cli.sh --connect --controller=remote+http://localhost:9990
</code></pre>

<p>CLI接受许多不同的协议。默认情况下，可以使用<code>remote+http</code>或<code>http-remoting</code>。如果管理接口受SSL保护，则可以使用协议<code>remote+https</code>或<code>https-remoting</code>。</p>
<p>WildFly的旧版本默认在<code>9999</code>上公开了一个本地管理端口，这需要协议<code>remoting</code>。WildFly 11默认不公开本机管理端口。</p>


<p>第三，我们设法在没有提供任何凭证的情况下登录。这得益于一项名为<a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html-single/how_to_configure_server_security/#silent_authentication" rel="nofollow">静默认证</a>的功能。</p>

<p>静默认证依赖于对<code>standalone/tmp/auth</code>或<code>domain/tmp/auth</code>目录的访问。这个想法是，如果一个用户有权访问这个目录，他们可能有权创建新的用户，所以静默认证给你访问权。</p>

<p>如果您拒绝对<code>auth</code>目录的写访问，静默认证将会失败，并且会提示您输入凭据。</p>



<h2 id="looking-around">环顾四周</h2>

<p>CLI的结构类似于文件系统，可以使用与Bash等shell中相同的命令进行导航。</p>

<p><code>ls</code>命令将列出当前目录的内容:</p>

<pre><code>[standalone@localhost:9990 /] ls
core-service                               subsystem                                  namespaces=[]                              release-version=3.0.8.Final                
deployment                                 system-property                            organization=undefined                     running-mode=NORMAL                        
deployment-overlay                         launch-type=STANDALONE                     process-type=Server                        runtime-configuration-state=ok             
extension                                  management-major-version=5                 product-name=WildFly Full                  schema-locations=[]                        
interface                                  management-micro-version=0                 product-version=11.0.0.Final               server-state=running                       
path                                       management-minor-version=0                 profile-name=undefined                     suspend-state=RUNNING                      
socket-binding-group                       name=matthews-mbp                          release-codename=Kenny                     uuid=ca421018-3df9-43e1-8b3f-ff843ebd38ee  
</code></pre>

<p><code>pwd</code>命令显示当前工作目录:</p>

<pre><code>[standalone@localhost:9990 /] pwd
/
</code></pre>

<p><code>cd</code>命令将改变当前目录。通常目录会是一个类似于<code>subsystem</code>的类别和一个类似于<code>undertow</code>的实例，中间有一个等号:</p>

<pre><code>[standalone@localhost:9990 /] cd subsystem=undertow
[standalone@localhost:9990 subsystem=undertow] ls
application-security-domain        server                             default-server=default-server      instance-id=${jboss.node.name}     
buffer-cache                       servlet-container                  default-servlet-container=default  statistics-enabled=false           
configuration                      default-security-domain=other      default-virtual-host=default-host  
</code></pre>

<p><code>help</code>命令显示了可用命令的列表:</p>

<pre><code>[standalone@localhost:9990 subsystem=undertow] help
Usage:

  jboss-cli.sh/jboss-cli.bat [--help] [--version]
                     [--bind=client_bind_address]
                     [--controller=(controller_alias | [protocol://][host][:port])]
                     [--connect] [--file=file_path]
                     [--commands=command_or_operation(,command_or_operation)*]
                     [--command=command_or_operation]
                     [--user=username --password=password]
                     [--properties=file_path]
                     [--no-local-auth]
                     [--error-on-interact]
                     [--timeout=timeout]
                     [--echo-command]
                     [--command-timeout=timeout]

 --help (-h)     - prints (this) basic description of the command line utility.
 ...
</code></pre>

<p><code>quit</code>命令将退出CLI。</p>

<h2 id="tab-completion">制表符结束</h2>

<p>这些命令也有许多选项。查看这些选项的最简单方法是使用tab complete。在这里，我输入了<code>ls</code>(末尾的空格很重要)，然后按tab键查看还有哪些选项可用:</p>

<pre><code>[standalone@localhost:9990 subsystem=undertow] ls
--headers                    --resolve-expressions        application-security-domain  configuration                servlet-container            
--help                       -l                           buffer-cache                 server             
</code></pre>

<h2 id="performing-operations">执行操作</h2>

<p>在任何给定的目录中，都有许多可以执行的操作。操作以<code>:</code>字符开始。使用制表符结束，我们可以看到可用操作的列表:</p>

<pre><code>[standalone@localhost:9990 http-listener=default] :
add                         map-clear                   read-attribute              read-children-types         remove                      
list-add                    map-get                     read-attribute-group        read-operation-description  reset-statistics            
list-clear                  map-put                     read-attribute-group-names  read-operation-names        undefine-attribute          
list-get                    map-remove                  read-children-names         read-resource               whoami                      
list-remove                 query                       read-children-resources     read-resource-description   write-attribute   
</code></pre>

<p><code>:read-operation-names</code>操作显示与制表完成相同的列表:</p>

<pre><code>[standalone@localhost:9990 http-listener=default] :read-operation-names
{
    "outcome" =&gt; "success",
    "result" =&gt; [
        "add",
        "list-add",
        "list-clear",
        "list-get",
        "list-remove",
        "map-clear",
        "map-get",
        "map-put",
        "map-remove",
        "query",
        "read-attribute",
        "read-attribute-group",
        "read-attribute-group-names",
        "read-children-names",
        "read-children-resources",
        "read-children-types",
        "read-operation-description",
        "read-operation-names",
        "read-resource",
        "read-resource-description",
        "remove",
        "reset-statistics",
        "undefine-attribute",
        "whoami",
        "write-attribute"
    ]
}
</code></pre>

<p>可以在当前目录中执行操作(就像我们在上面的例子中所做的那样)，或者使用类似<code>/:read-operation-names</code>或<code>/subsystem=undertow:read-operation-names</code>的命令在特定目录上执行操作。</p>


<p><code>:read-resource</code>操作是列出当前目录详细信息的常用方法。</p>

<p>WildFly使用动态模型表示(DMR)格式表示对象。</p>


<pre><code>[standalone@localhost:9990 http-listener=default] :read-resource
{
    "outcome" =&gt; "success",
    "result" =&gt; {
        "allow-encoded-slash" =&gt; false,
        "allow-equals-in-cookie-value" =&gt; false,
        "always-set-keep-alive" =&gt; true,
        "buffer-pipelined-data" =&gt; false,
        "buffer-pool" =&gt; "default",
        "certificate-forwarding" =&gt; false,
        "decode-url" =&gt; true,
        "disallowed-methods" =&gt; ["TRACE"],
        "enable-http2" =&gt; true,
        "enabled" =&gt; true,
        "http2-enable-push" =&gt; true,
        "http2-header-table-size" =&gt; 4096,
        "http2-initial-window-size" =&gt; 65535,
        "http2-max-concurrent-streams" =&gt; undefined,
        "http2-max-frame-size" =&gt; 16384,
        "http2-max-header-list-size" =&gt; undefined,
        "max-buffered-request-size" =&gt; 16384,
        "max-connections" =&gt; undefined,
        "max-cookies" =&gt; 200,
        "max-header-size" =&gt; 1048576,
        "max-headers" =&gt; 200,
        "max-parameters" =&gt; 1000,
        "max-post-size" =&gt; 10485760L,
        "no-request-timeout" =&gt; 60000,
        "proxy-address-forwarding" =&gt; false,
        "read-timeout" =&gt; undefined,
        "receive-buffer" =&gt; undefined,
        "record-request-start-time" =&gt; false,
        "redirect-socket" =&gt; "https",
        "request-parse-timeout" =&gt; undefined,
        "require-host-http11" =&gt; false,
        "resolve-peer-address" =&gt; false,
        "rfc6265-cookie-validation" =&gt; false,
        "secure" =&gt; false,
        "send-buffer" =&gt; undefined,
        "socket-binding" =&gt; "http",
        "tcp-backlog" =&gt; 10000,
        "tcp-keep-alive" =&gt; undefined,
        "url-charset" =&gt; "UTF-8",
        "worker" =&gt; "default",
        "write-timeout" =&gt; undefined
    }
}
</code></pre>

<p>使用<code>:read-attribute</code>操作可以读取单个属性:</p>

<pre><code>[standalone@localhost:9990 http-listener=default] :read-attribute(name=enabled)
{
    "outcome" =&gt; "success",
    "result" =&gt; true
}
</code></pre>

<p>可以通过<code>:write-attribute</code>操作写入属性:</p>

<pre><code>[standalone@localhost:9990 http-listener=default] :write-attribute(name=enabled, value=false)
{"outcome" =&gt; "success"}
</code></pre>

<p>使用<code>:undefine-attribute</code>操作可以不定义属性:</p>

<pre><code>[standalone@localhost:9990 http-listener=default] :undefine-attribute(name=write-timeout)
{"outcome" =&gt; "success"}
</code></pre>

<h2 id="special-characters">特殊字符</h2>

<p>要定义带空格的值，请用引号将字符串括起来:</p>

<pre><code>[standalone@localhost:9990 /] /system-property=test:write-attribute(name=value, value="value with space")
{"outcome" =&gt; "success"}
[standalone@localhost:9990 /] /system-property=test:read-attribute(name=value)
{
    "outcome" =&gt; "success",
    "result" =&gt; "value with space"
}
</code></pre>

<p>要使用引号，请用反斜杠将其转义:</p>

<pre><code>[standalone@localhost:9990 /] /system-property=test:write-attribute(name=value, value="\"quoted value with space\"")
{"outcome" =&gt; "success"}
[standalone@localhost:9990 /] /system-property=test:read-attribute(name=value)
{
    "outcome" =&gt; "success",
    "result" =&gt; "\"quoted value with space\""
}
</code></pre>

<p>反斜杠本身用反斜杠转义:</p>

<pre><code>[standalone@localhost:9990 /] /system-property=test:write-attribute(name=value, value="\"quoted value with space and a backslash \\\"")
{"outcome" =&gt; "success"}
[standalone@localhost:9990 /] /system-property=test:read-attribute(name=value)
{
    "outcome" =&gt; "success",
    "result" =&gt; "\"quoted value with space and a backslash \\\""
}
</code></pre>

<h2 id="reloading-the-server">重新加载服务器</h2>

<p>更改某些设置需要重新加载服务器。您可以通过读取根目录中的<code>server-state</code>属性来检查服务器的状态。在本例中，我们有一些需要重新加载的设置:</p>

<pre><code>[standalone@localhost:9990 /] :read-attribute(name=server-state)
{
    "outcome" =&gt; "success",
    "result" =&gt; "reload-required",
    "response-headers" =&gt; {"process-state" =&gt; "reload-required"}
}
</code></pre>

<p><code>:reload</code>操作将重新加载服务器:</p>

<pre><code>[standalone@localhost:9990 /] :reload
{
    "outcome" =&gt; "success",
    "result" =&gt; undefined
}
</code></pre>

<h2 id="batching-operations">批处理操作</h2>

<p>WildFly中的一些操作需要作为一个原子单元运行，或者您可能希望所有命令作为一个整体成功或失败。<code>batch</code>和<code>run-batch</code>命令提供该功能。</p>

<p>在批处理模式下，一个<code>#</code>字符会出现在提示中。</p>


<pre><code>[standalone@localhost:9990 /] batch
[standalone@localhost:9990 / #] /subsystem=undertow/server=default-server/http-listener=default:undefine-attribute(name=write-timeout)
[standalone@localhost:9990 / #] /subsystem=undertow/server=default-server/http-listener=default:write-attribute(name=enabled, value=false)
[standalone@localhost:9990 / #] run-batch
The batch executed successfully
</code></pre>

<p><code>discard-batch</code>命令将放弃所有批处理命令并退出批处理模式:</p>

<pre><code>[standalone@localhost:9990 /] batch
[standalone@localhost:9990 / #] /subsystem=undertow/server=default-server/http-listener=default:write-attribute(name=enabled, value=false)
[standalone@localhost:9990 / #] discard-batch
[standalone@localhost:9990 /]
</code></pre>

<p><code>list-batch</code>命令将显示未决的批处理命令，而<code>clear-batch</code>命令将清除任何批处理命令，但使您处于批处理模式:</p>

<pre><code>[standalone@localhost:9990 /] batch
[standalone@localhost:9990 / #] /subsystem=undertow/server=default-server/http-listener=default:write-attribute(name=enabled, value=false)
[standalone@localhost:9990 / #] list-batch
#1 /subsystem=undertow/server=default-server/http-listener=default:write-attribute(name=enabled, value=false)
[standalone@localhost:9990 / #] clear-batch
[standalone@localhost:9990 / #] list-batch
The batch is empty.
[standalone@localhost:9990 / #] discard-batch
</code></pre>

<h2 id="backing-up-the-configuration">备份配置</h2>

<p>您可能希望在进行任何更改之前备份当前配置。这可以通过<code>:take-snapshot</code>操作来实现。</p>

<p>此操作的结果会告诉您备份保存的位置:</p>

<pre><code>[standalone@localhost:9990 /] :take-snapshot
{
    "outcome" =&gt; "success",
    "result" =&gt; "C:\\Users\\matth\\Downloads\\wildfly-11.0.0.Final\\wildfly-11.0.0.Final\\standalone\\configuration\\standalone_xml_history\\snapshot\\20171108-082107378standalone.xml"
}
</code></pre>

<h2 id="running-cli-scripts">运行CLI脚本</h2>

<p>CLI命令可以添加到脚本文件中，并以非交互方式运行。</p>

<p>例如，将这个脚本保存到名为<code>test.cli</code>的文件中:</p>

<pre><code>connect
batch
/subsystem=undertow/server=default-server/http-listener=default:undefine-attribute(name=write-timeout)
/subsystem=undertow/server=default-server/http-listener=default:write-attribute(name=enabled, value=false)
run-batch
</code></pre>

<p>然后可以使用<code>--file</code>命令行选项运行它:</p>

<pre><code>./jboss-cli.sh --file=test.cli
</code></pre>

<p>在这个测试脚本中，我们使用<code>connect</code>命令从脚本内部连接到WildFly实例，而不是传递<code>--connect</code>命令行选项。</p>


<p>要在Windows中运行<code>jboss-cli.bat</code>文件时禁用<code>Press any key to continue ...</code>提示符，请将<code>NOPAUSE</code>环境变量设置为<code>true</code>:</p>

<pre><code>PS C:\Users\matth\Downloads\wildfly-11.0.0.Final\bin&gt; $env:NOPAUSE="true"
PS C:\Users\matth\Downloads\wildfly-11.0.0.Final\bin&gt; .\jboss-cli.bat --connect
[standalone@localhost:9990 /] quit
PS C:\Users\matth\Downloads\wildfly-11.0.0.Final\bin&gt;
</code></pre>

<h2 id="flow-control-statements">流量控制语句</h2>

<p>CLI支持if/else和try/catch/finally之类的流控制语句。</p>

<p>例如，您可以将以下代码添加到CLI脚本中，如果尚未定义，它会将系统属性<code>test</code>设置为<code>true</code>:</p>

<pre><code>if (outcome != success) of /system-property=test:read-resource
    /system-property=test:add(value=true)
end-if
</code></pre>

<p>您也可以在交互模式下运行相同的命令:</p>

<pre><code>[standalone@localhost:9990 /] if (outcome != success) of /system-property=test:read-resource
[standalone@localhost:9990 /] /system-property=test:add(value=true)
[standalone@localhost:9990 /] end-if
{"outcome" =&gt; "success"}
</code></pre>

<p>try/catch/finally流控制的工作方式与Java中的非常相似。下面将尝试添加数据源，如果出现异常，将移除并添加数据源。最后，数据源被启用:</p>

<pre><code>try
  /subsystem=datasources/data-source=myds:add(connection-url=xxx,jndi-name=java:/myds,driver-name=h2)
catch
  /subsystem=datasources/data-source=myds:remove
  /subsystem=datasources/data-source=myds:add(connection-url=xxx,jndi-name=java:/myds,driver-name=h2)
finally
  /subsystem=datasources/data-source=myds:enable
end-try
</code></pre>

<h2 id="multiline-commands">多行命令</h2>

<p>通过用一个<code>\</code>字符结束每一行，命令可以分成多行:</p>

<pre><code>[standalone@localhost:9990 /] /subsystem=datasources/data-source=myds:add( \
&gt;   connection-url=xxx, \
&gt;   jndi-name=java:/myds, \
&gt;   driver-name=h2)
{"outcome" =&gt; "success"}
</code></pre>

<h2 id="running-the-cli-gui">运行CLI GUI</h2>

<p>CLI有一个GUI模式，该模式提供了一个类似文件浏览器的界面，用于在WildFly设置目录结构中导航:</p>

<pre><code>./jboss-cli.sh --gui
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-the-wildfly-cli/wildfly-cli-gui.png" class="zoom" data-title=""><img src="../Images/1b95b26e9514fec45fb8a6b9ad1851be.png" class="img-fluid center" alt="WildFly CLI GUI" data-original-src="https://i.octopus.com/blog/2020-07/using-the-wildfly-cli/wildfly-cli-gui.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>在这篇文章中，我们从较高的层次上了解了CLI的工作原理以及您可以用它做些什么。如果您对Java应用程序的自动化部署感兴趣，请尝试免费的开始版本的<a href="https://octopus.com/free"> Octopus Deploy </a>，并看看<a href="https://octopus.com/docs/deployments/java/deploying-java-applications">我们的文档</a>。</p>

                    
                    
</body>
</html>