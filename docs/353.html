<html>
<head>
<title>A first look at Tekton Pipelines - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Tekton管道初步观察——Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/introduction-to-tekton-pipelines#2021-08-12">https://octopus.com/blog/introduction-to-tekton-pipelines#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-05/introduction-to-tekton-pipelines/tekton-pipelines.png" class="zoom" data-title=""><img src="../Images/67b3a17df8e59be506cb66b9d5422d77.png" class="img-fluid center" alt="A first look at Tekton Pipelines" data-original-src="https://i.octopus.com/blog/2020-05/introduction-to-tekton-pipelines/tekton-pipelines.png"/>T2】</a></p>

<p>Kubernetes正在迅速从Docker编排平台演变为通用云操作系统。通过<a href="https://octopus.com/blog/operators-with-kotlin"> operators </a> Kubernetes获得了本地管理高级概念和业务流程的能力，这意味着您不再管理pod、服务和部署的构建模块，而是描述这些构建模块可以创建的东西，如web服务器、数据库、连续部署、证书管理等。</p>

<p>当部署到Kubernetes集群时，Tekton管道能够以简单值或Docker图像等复杂对象的形式定义和执行构建任务、输入和输出，并在管道中组合这些资源。这些新的Kubernetes资源和管理它们的控制器导致了一个由Kubernetes集群托管的无头CI/CD平台。</p>

<p>在这篇文章中，我们将看看一个运行在MicroK8S上的简单构建管道。</p>

<h2 id="preparing-the-test-kubernetes-cluster">准备测试Kubernetes集群</h2>

<p>在这篇文章中，我使用<a href="https://microk8s.io/" rel="nofollow"> MicroK8S </a>来提供Kubernetes集群。MicroK8S在这里很有用，因为它提供了一系列<a href="https://microk8s.io/docs/addons" rel="nofollow">官方插件</a>，其中一个是Docker图像注册表。因为我们的管道构建了一个Docker映像，所以我们需要一个地方来托管它，而MicroK8S registry插件只需一个命令就能为我们提供该功能:</p>

<pre><code>microk8s.enable registry
</code></pre>

<p>我们还需要从MicroK8S集群内部启用DNS查找。这是通过启用DNS插件来实现的:</p>

<pre><code>microk8s.enable dns
</code></pre>

<h2 id="installing-tekton-pipelines">安装Tekton管道</h2>

<p>Tekton管道的安装很简单，只需一个<code>kubectl</code>(或本例中的<code>microk8s.kubectl</code>)命令:</p>

<pre><code>microk8s.kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml
</code></pre>

<p>我们现在可以在Kubernetes集群中创建Tekton资源。</p>

<h2 id="a-hello-world-task">“Hello World”任务</h2>

<p>任务包含为完成工作而执行的各个步骤。在下面的例子中，我们有一个单步执行的任务，它在一个从<code>ubuntu</code>图像构建的容器中执行带有参数<code>Hello World</code>的<code>echo</code>命令。</p>

<p>下面的YAML显示了我们的<code>helloworldtask.yml</code>文件:</p>

<pre><code>apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: echo-hello-world
spec:
  steps:
    - name: echo
      image: ubuntu
      command:
        - echo
      args:
        - "Hello World"
</code></pre>

<p>使用以下命令在Kubernetes集群中创建任务资源:</p>

<pre><code>microk8s.kubectl apply -f helloworldtask.yml
</code></pre>

<p>任务描述了如何完成工作，但是创建任务资源并不会导致采取任何操作。任务运行资源引用任务，任务运行资源的创建触发Tekton执行被引用任务中的步骤。</p>

<p>下面的YAML显示了我们的<code>helloworldtaskrun.yml</code>文件:</p>

<pre><code>apiVersion: tekton.dev/v1alpha1
kind: TaskRun
metadata:
  name: echo-hello-world-task-run
spec:
  taskRef:
    name: echo-hello-world
</code></pre>

<p>使用以下命令在Kubernetes集群中创建任务运行资源:</p>

<pre><code>microk8s.kubectl apply -f helloworldtaskrun.yml
</code></pre>

<h2 id="building-a-docker-image">建立码头工人形象</h2>

<p>为了超越这个hello world示例，我们将看看Tekton构建管道的典型用例，即编译和推送Docker映像。为了演示这个功能，我们将构建我们的<a href="https://github.com/OctopusSamples/RandomQuotes-Java" rel="nofollow"> RandomQuotes </a>示例应用程序。</p>

<p>我们从管道资源开始管道。管道资源提供了一种为构建过程定义输入的解耦方法。</p>

<p>我们需要的第一个输入是保存代码的Git存储库。管道资源有许多已知的类型，这里我们定义了一个<code>git</code>管道资源，指定保存代码的URL和分支:</p>

<pre><code class="language-YAML">apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
  name: randomquotes-git
spec:
  type: git
  params:
    - name: revision
      value: master
    - name: url
      value: https://github.com/OctopusSamples/RandomQuotes-Java.git
</code></pre>

<p>接下来，我们定义存放编译图像的Docker注册表。这就是MicroK8S注册表插件有用的地方，因为它在http://registry . container-registry . SVC . cluster . local:5000公开了一个Docker注册表。</p>

<p>下面是类型为<code>image</code>的管道资源，它定义了我们将创建为<code>registry.container-registry.svc.cluster.local:5000/randomquotes</code>的Docker映像:</p>

<pre><code class="language-YAML">apiVersion: tekton.dev/v1alpha1
kind: PipelineResource
metadata:
  name: randomquotes-image
spec:
  type: image
  params:
    - name: url
      value: registry.container-registry.svc.cluster.local:5000/randomquotes
</code></pre>

<p>定义了输入源代码和目的Docker映像后，我们可以创建一个任务来创建Docker映像并将其推送到存储库。</p>

<p>传统上，Docker客户机直接在主机操作系统上构建Docker映像。然而，在Kubernetes中，一切都是在Docker内部运行的，这就引出了一个问题:如何在Docker内部运行Docker？</p>

<p>在过去的几年中，出现了大量的工具来执行Docker CLI和daemon提供的过程，但不依赖于Docker本身。这些工具包括用于解包和重新打包Docker映像的<a href="https://github.com/openSUSE/umoci" rel="nofollow"> umoci </a>，用于从Docker文件构建Docker映像的<a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow"> Kaniko </a>和<a href="https://github.com/containers/buildah" rel="nofollow"> Buildah </a>，以及用于运行Docker映像的<a href="https://podman.io/" rel="nofollow"> Podman </a>。</p>

<p>我们将在Tekton任务中使用Kaniko在Kubernetes提供的Docker容器中构建Docker映像。下面的YAML显示了完整的任务:</p>

<pre><code class="language-YAML">apiVersion: tekton.dev/v1alpha1
kind: Task
metadata:
  name: build-docker-image-from-git-source
spec:
  inputs:
    resources:
      - name: docker-source
        type: git
    params:
      - name: pathToDockerFile
        type: string
        description: The path to the dockerfile to build
        default: /workspace/docker-source/Dockerfile
      - name: pathToContext
        type: string
        description:
          The build context used by Kaniko
          (https://github.com/GoogleContainerTools/kaniko#kaniko-build-contexts)
        default: /workspace/docker-source
  outputs:
    resources:
      - name: builtImage
        type: image
  steps:
    - name: build-and-push
      image: gcr.io/kaniko-project/executor:v0.17.1
      # specifying DOCKER_CONFIG is required to allow kaniko to detect docker credential
      env:
        - name: "DOCKER_CONFIG"
          value: "/tekton/home/.docker/"
      command:
        - /kaniko/executor
      args:
        - --dockerfile=$(inputs.params.pathToDockerFile)
        - --destination=$(outputs.resources.builtImage.url)
        - --context=$(inputs.params.pathToContext)
</code></pre>

<p>这项任务有一些重要的方面值得指出。</p>

<p>该任务中有两个属性与我们上面创建的管道资源相关。</p>

<p><code>git</code>类型的输入资源:</p>

<pre><code class="language-YAML">inputs:
    resources:
      - name: docker-source
        type: git
</code></pre>

<p>和类型<code>image</code>的输出:</p>

<pre><code class="language-YAML">outputs:
  resources:
    - name: builtImage
      type: image
</code></pre>

<p>有两个额外的输入参数定义Docker构建过程使用的路径:</p>

<pre><code class="language-YAML">spec:
  inputs:
    params:
      - name: pathToDockerFile
        type: string
        description: The path to the dockerfile to build
        default: /workspace/docker-source/Dockerfile
      - name: pathToContext
        type: string
        description:
          The build context used by Kaniko
          (https://github.com/GoogleContainerTools/kaniko#kaniko-build-contexts)
        default: /workspace/docker-source
</code></pre>

<p>注意路径<code>/workspace/docker-source</code>是<code>git</code>资源使用的约定，其中<code>docker-source</code>目录匹配输入的名称。</p>

<p>然后我们有一个构建Docker映像的单一步骤。构建在从<code>gcr.io/kaniko-project/executor:v0.17.1</code>映像创建的容器中执行，该容器提供Kaniko:</p>

<pre><code class="language-YAML">spec:
  steps:
    - name: build-and-push
      image: gcr.io/kaniko-project/executor:v0.17.1
      # specifying DOCKER_CONFIG is required to allow kaniko to detect docker credential
      env:
        - name: "DOCKER_CONFIG"
          value: "/tekton/home/.docker/"
      command:
        - /kaniko/executor
      args:
        - --dockerfile=$(inputs.params.pathToDockerFile)
        - --destination=$(outputs.resources.builtImage.url)
        - --context=$(inputs.params.pathToContext)
</code></pre>

<p>最后，任务运行用于将任务和管道资源绑定在一起。该资源将任务<code>docker-source</code>输入映射到<code>randomquotes-git</code>管道资源，将<code>builtImage</code>输出映射到<code>randomquotes-image</code>管道资源。</p>

<p>创建此资源会触发构建的发生:</p>

<pre><code class="language-YAML">apiVersion: tekton.dev/v1alpha1
kind: TaskRun
metadata:
  name: build-docker-image-from-git-source-task-run
spec:
  taskRef:
    name: build-docker-image-from-git-source
  inputs:
    resources:
      - name: docker-source
        resourceRef:
          name: randomquotes-git
    params:
      - name: pathToDockerFile
        value: Dockerfile
      - name: pathToContext
        value: /workspace/docker-source
  outputs:
    resources:
      - name: builtImage
        resourceRef:
          name: randomquotes-image
</code></pre>

<h2 id="interacting-with-builds">与构件交互</h2>

<p>Tekton本身并不提供任何与作业交互的仪表板或GUI。但是，有一个<a href="https://github.com/tektoncd/cli" rel="nofollow"> CLI工具</a>用于管理Tekton作业。</p>

<p>Tekton CLI工具假设配置了<code>kubectl</code>，但是MicroK8S维护了一个名为<code>microk8s.kubectl</code>的独立工具。配置<code>kubectl</code>最简单的方法是使用以下命令，该命令将MicroK8S配置文件复制到<code>kubectl</code>的标准位置:</p>

<pre><code>sudo microk8s.kubectl config view --raw &gt; $HOME/.kube/config
</code></pre>

<p>此时，我们可以使用以下命令获得任务的状态:</p>

<pre><code>tkn taskrun logs build-docker-image-from-git-source-task-run
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-05/introduction-to-tekton-pipelines/tekton-logs.png" class="zoom" data-title=""><img src="../Images/ae00d926f44e6d648a3550c9d9952eed.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-05/introduction-to-tekton-pipelines/tekton-logs.png"/>T2】</a></p>

<h2 id="is-tekton-for-you">泰克顿适合你吗？</h2>

<p>无头构建服务器的想法很有意思。</p>

<p>通过用Docker映像构建构建，Tekton消除了维护一套专用构建代理的开销。如今，每种工具和语言都提供了一个受支持的Docker映像，使得跟上主流语言版本六个月发布周期的新常态变得更加容易。</p>

<p>Kubernetes也是服务于软件构建的弹性和短期需求的天然平台。当您可以有五个节点在它们之间调度构建时，为什么有十个专门的代理处于空闲状态？</p>

<p>但是，我怀疑Tekton本身对于大多数工程团队来说太低级了。任何以前使用过<code>kubectl</code>的人都会熟悉<code>tkn</code> CLI工具，但是很难从终端理解构建的整体状态。更不用说用<code>kubectl create -f taskrun.yml</code>创建的版本很快就过时了。</p>

<p>有一个<a href="https://github.com/tektoncd/dashboard" rel="nofollow">仪表板</a>可用，但与现有的CI工具相比，它是一个基本的用户界面。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-05/introduction-to-tekton-pipelines/dashboard.png" class="zoom" data-title=""><img src="../Images/f51e206b180d6488a533f56d5e0c4d97.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-05/introduction-to-tekton-pipelines/dashboard.png"/></a>T2】</p>

<p>也就是说，Tekton是构建面向开发人员的工具的强大基础。<a href="https://jenkins-x.io/" rel="nofollow"> Jenkins X </a>和<a href="https://www.openshift.com/learn/topics/pipelines" rel="nofollow"> OpenShift Pipelines </a>就是这样两个利用Tekton的平台。</p>

<h2 id="conclusion">结论</h2>

<p>Kubernetes解决了运行应用程序的许多需求，如身份验证、授权、CLI工具、资源管理、健康检查等等。Kubernetes集群可以通过一个命令托管一个全功能的CI服务器，这一事实证明了Kubernetes的灵活性。</p>

<p>有了像<a href="https://jenkins-x.io/" rel="nofollow"> Jenkins X </a>和<a href="https://www.openshift.com/learn/topics/pipelines" rel="nofollow"> OpenShift Pipelines </a>这样的项目，Tekton开始了进入主流开发工作流的旅程。但是作为一个独立的项目，Tekton有点太接近金属了，以至于大多数开发团队都无法使用，仅仅是因为很少有人有经验来支持它。</p>

                    
                    
</body>
</html>