<html>
<head>
<title>Selenium series: running tests on mobile devices - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:在移动设备上运行测试- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/18-running-tests-on-mobile-devices/running-tests-on-mobile-devices#2021-07-07">https://octopus.com/blog/selenium/18-running-tests-on-mobile-devices/running-tests-on-mobile-devices#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>到目前为止，我们的测试仅限于桌面浏览器，但是如果没有测试移动浏览器的方法，任何测试策略都是不完整的。移动浏览器测试是BrowserStack等服务的主要功能之一。使用我们在桌面浏览器上开发和运行的相同代码，在各种各样的移动浏览器上运行测试是非常容易的。</p>

<p>让我们看看如何在三星Galaxy Note 8移动设备上测试Chrome。</p>

<p>首先，我们需要构建所需的capabilities对象来指示BrowserStack对Samsung设备运行测试。如前所述，我们可以通过在<a href="https://www.browserstack.com/automate/capabilities" rel="nofollow">https://www.browserstack.com/automate/capabilities</a>提供的表格获得这些细节。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image1.png" class="zoom" data-title=""><img src="../Images/bb0cdbbccb51eeaf6d5aac04b05b5e45.png" class="img-fluid center" alt="C:\2713f257ba961d58a8316e44e3691666" data-original-src="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image1.png"/>T2】</a></p>

<p>然后我们获取这些设置，并使用它们来构建一个名为<code>BrowserStackAndroidDecorator</code>的新装饰器类:</p>

<pre><code class="language-java">package com.octopus.decorators;

import com.octopus.AutomatedBrowser;
import com.octopus.decoratorbase.AutomatedBrowserBase;
import org.openqa.selenium.remote.DesiredCapabilities;

public class BrowserStackAndroidDecorator extends AutomatedBrowserBase {
  public BrowserStackAndroidDecorator(final AutomatedBrowser automatedBrowser) {

  super(automatedBrowser);

  }

  @Override
  public DesiredCapabilities getDesiredCapabilities() {

    final DesiredCapabilities caps = getAutomatedBrowser().getDesiredCapabilities();

    caps.setCapability("os_version", "7.1");
    caps.setCapability("device", "Samsung Galaxy Note 8");
    caps.setCapability("real_mobile", "true");
    caps.setCapability("browserstack.local", "false");

    return caps;
  }
}
</code></pre>

<p>然后我们在<code>AutomatedBrowserFactory</code>中使用这个类:</p>

<pre><code class="language-java">package com.octopus;

import com.octopus.decorators.*;

public class AutomatedBrowserFactory {

  public AutomatedBrowser getAutomatedBrowser(String browser) {

  // ...

  if ("BrowserStackAndroid".equalsIgnoreCase(browser)) {
      return getBrowserStackAndroid();
  }

  if ("BrowserStackAndroidNoImplicitWait".equalsIgnoreCase(browser)) {
      return getBrowserStackAndroidNoImplicitWait();
  }

  throw new IllegalArgumentException("Unknown browser " + browser);

  }

  // ...

  private AutomatedBrowser getBrowserStackAndroid() {
    return new BrowserStackDecorator(
      new BrowserStackAndroidDecorator(
        new ImplicitWaitDecorator(10,
          new WebDriverDecorator()
        )
      )
    );
  }

  private AutomatedBrowser getBrowserStackAndroidNoImplicitWait() {
    return new BrowserStackDecorator(
      new BrowserStackAndroidDecorator(
        new WebDriverDecorator()
      )
    );
  }
}
</code></pre>

<p>然后，我们可以在测试中使用这个新的<code>AutomatedBrowser</code>实例:</p>

<pre><code class="language-java">@Test
public void browserStackAndroidTest() {

  final AutomatedBrowser automatedBrowser =
    AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser("BrowserStackAndroid");

  final String formButtonLocator = "button_element";
  final String formTextBoxLocator = "text_element";
  final String formTextAreaLocator = "textarea_element";
  final String formDropDownListLocator = "[name=select_element]";
  final String formCheckboxLocator = "//*[@name=\"checkbox1_element\"]";
  final String messageLocator = "message";

  try {
    automatedBrowser.init();

    automatedBrowser.goTo("https://s3.amazonaws.com/webdriver-testing-website/form.html");

    automatedBrowser.clickElement(formButtonLocator);
    assertEquals("Button Clicked", automatedBrowser.getTextFromElement(messageLocator));

    automatedBrowser.populateElement(formTextBoxLocator, "test text");
    assertEquals("Text Input Changed", automatedBrowser.getTextFromElement(messageLocator));

    automatedBrowser.populateElement(formTextAreaLocator, "test text");
    assertEquals("Text Area Changed", automatedBrowser.getTextFromElement(messageLocator));

    automatedBrowser.selectOptionByTextFromSelect("Option 2.1",
    formDropDownListLocator);
    assertEquals("Select Changed", automatedBrowser.getTextFromElement(messageLocator));

    automatedBrowser.clickElement(formCheckboxLocator);
    assertEquals("Checkbox Changed", automatedBrowser.getTextFromElement(messageLocator));
  } finally {
    automatedBrowser.destroy();
  }
}
</code></pre>

<p>如果我们运行这个测试，可能会再次生成关于无效凭据的异常。如果您还记得，我们之前将BrowserStack凭证定义为环境变量，但是我们只针对单个测试这样做。将这些变量添加到每一个新的测试配置中会很繁琐，所以要将这些环境变量添加到所有测试中，我们需要为IntelliJ运行的所有JUnit测试配置默认设置。</p>

<p>点击配置下拉列表并选择<code>Edit Configurations...</code></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image2.png" class="zoom" data-title=""><img src="../Images/d45a8dbbe161e88078bc50e722587ef8.png" class="img-fluid center" alt="C:\164b6a7a999aea368f833df845efd42f" data-original-src="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image2.png"/>T2】</a></p>

<p>这一次，我们没有将环境变量添加到单个测试的配置中，而是将它们添加为任何JUnit配置的缺省值。</p>

<p>展开左侧的<code>Defaults</code>菜单，选择<code>JUnit</code>选项，将<code>BROWSERSTACK_USERNAME</code>和<code>BROWSERSTACK_KEY</code>添加到<code>Environment variables</code>中。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image3.png" class="zoom" data-title=""><img src="../Images/3e3139063aa5d687165a707df5d446c8.png" class="img-fluid center" alt="C:\5f0645e9d5db5ef6ccd5390caacfd309" data-original-src="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image3.png"/>T2】</a></p>

<p>您可能需要删除运行测试时创建的JUnit配置。这将在左侧菜单中的<code>JUnit</code>选项下找到。选择配置，然后单击减号按钮。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image4.png" class="zoom" data-title=""><img src="../Images/879d27fa35e6b3e9bbd945f0a49ad8e7.png" class="img-fluid center" alt="C:\fd113ade73cde35a8d343177545f4022" data-original-src="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image4.png"/>T2】</a></p>

<p>当您再次运行单元测试时，IntelliJ将创建一个新的JUnit配置，这将使用默认值填充环境变量。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image5.png" class="zoom" data-title=""><img src="../Images/736a03cdff8cca2b51068744078a7acc.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2018-10/selenium/18-running-tests-on-mobile-devices/image5.png"/>T2】</a></p>

<p>再次运行测试，将创建一个新的BrowserStack会话，可通过点击BrowserStack中的<span class="path">产品➜自动化</span>进行查看。该测试将在三星移动设备上运行。</p>

<p>在大量设备上运行我们的测试的能力显示了WebDriver是多么的灵活。通过几个简单的装饰器，我们可以配置我们的测试在BrowserStack支持的数百个设备上运行。但是在编写跨桌面和移动浏览器的测试时，我们仍然需要注意一些边缘情况，在下一篇文章中，我们将看到一个例子，我们需要解决环境之间的一些差异。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>