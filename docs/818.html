<html>
<head>
<title>Creating a WildFly cluster - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>创建一个WildFly集群- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/wildfly-jdbc-ping#2022-07-15">https://octopus.com/blog/wildfly-jdbc-ping#2022-07-15</a></blockquote>
                        <p>在<a href="https://octopus.com/blog/wildfly-s3-domain-discovery">之前的博客文章</a>中，我们看到了在没有固定IP地址或网络广播的AWS环境中，如何通过将配置设置集中在S3桶中来配置WildFly域。</p>

<p>在这篇博文中，我们将通过在AWS中配置一个WildFly实例集群来进一步进行配置。</p>

<h2 id="domain-vs-cluster">域与集群</h2>

<p>在我们开始配置集群之前，有必要花点时间讨论一下域和集群之间的区别。</p>

<p>一个域由一个域控制器和一个或多个域从属设备组成。域控制器将设置和应用程序分发给域从属服务器，并提供启动、停止和重新启动从属服务器实例的方法。</p>

<p>域只是一个管理工具。除了简化的管理之外，您不会获得任何额外的功能，因为实例是域的一部分。事实上，您可以使用类似于<a href="https://www.redhat.com/en/technologies/jboss-middleware/operations-network" rel="nofollow">JBoss Operations Network(JON)</a>的工具来替换一个域。</p>

<p>术语集群可能有歧义，因此对于这篇博文来说，集群意味着共享Servlet会话状态的两个或更多WildFly实例。共享此状态意味着服务器端web应用程序可以由集群中的任何节点提供，如果其中一个节点关闭，请求将由拥有会话状态副本的另一个节点来完成。</p>

<p>尽管从理论上讲，集群允许任何节点响应有状态web应用程序的请求，但在实践中，您通常会实现粘性会话来将流量从一个会话定向到单个服务器(只要它可用)。Infinispan文档谈到了使用粘性会话的性能优势。</p>


<p>域可用于将从属实例配置为集群的一部分，或者域可由不构成集群的多个独立节点组成。同样，WildFly的多个独立实例可以配置成一个集群。</p>

<p>因此，虽然域和集群都是以某种方式协调的WildFly实例组，但这两个术语指的是不同的东西。</p>

<h2 id="configuring-a-cluster">配置集群</h2>

<p>虽然我们不需要域来配置集群，但域是将公共设置分发到多个WildFly从属服务器的一种便捷方式，因此我们将使用域来构建我们的集群。我们将在之前的博文中已经完成的工作的基础上构建一个野域名。</p>

<p>扩展域以支持集群需要许多步骤。</p>

<h3 id="define-a-central-configuration-database">定义中央配置数据库</h3>

<p>在构建域时，我们使用了一个共享的S3存储桶来帮助发现域控制器。以类似的方式，我们将使用共享数据库来促进集群节点的发现。</p>

<p>因为我们正在AWS中部署WildFly实例，所以我们将使用Aurora数据库作为集群配置的中心点。Aurora与MySQL兼容，这意味着我们将配置WildFly，就像它正在与MySQL数据库通信一样。</p>

<h3 id="adding-the-schema">添加模式</h3>

<p>使用MySQL客户端工具，登录RDS实例，并创建一个名为<code>jgroups</code>的模式。这是通过命令<code>create database jgroups;</code>完成的:</p>

<pre><code>[ec2-user@ip-172-30-0-89 configuration]$ mysql -ujgroups -p -hyour-rds-hostname.cluster-c1ufrgizkeyf.us-east-1.rds.amazonaws.com
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 15
Server version: 5.6.10 MySQL Community Server (GPL)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; create database jgroups;

Query OK, 1 row affected (0.04 sec)
</code></pre>

<h3 id="adding-the-mysql-drivers">添加MySQL驱动程序</h3>

<p>在每个WildFly从属服务器上，我们需要添加一个包含MySQL驱动程序的模块。一个模块只是一个JAR文件和一些WildFly可以用来加载它们的元数据的集合。</p>

<p>首先创建一个名为<code>modules/system/layers/base/com/mysql/driver/main</code>的目录。在这个目录中，创建一个名为<code>module.xml</code>的文件，内容如下:</p>

<pre><code class="language-xml">&lt;module  name="com.mysql.driver"&gt;
    &lt;resources&gt;
        &lt;resource-root path="mysql-connector-java-5.1.44.jar" /&gt;
    &lt;/resources&gt;
    &lt;dependencies&gt;
        &lt;module name="javax.api"/&gt;
        &lt;module name="javax.transaction.api"/&gt;
    &lt;/dependencies&gt;
&lt;/module&gt;
</code></pre>

<p>然后将<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java/5.1.44" rel="nofollow"> MySQL驱动JAR文件</a>保存到<code>mysql-connector-java-5.1.44.jar</code>目录下。</p>

<h3 id="adding-the-datasource">添加数据源</h3>

<p>RDS实例将通过数据源进行访问。这在<code>ha</code>轮廓下的<code>domain/confguration/domain.xml</code>文件中定义。<code>&lt;profile name="ha"&gt;</code>元素的所有子元素组成了<code>ha</code>概要文件。</p>

<p>为了定义我们的数据源，我们需要一个<code>&lt;datasource&gt;</code>元素(定义数据库连接)和一个<code>&lt;driver&gt;</code>元素(定义MySQL JDBC驱动程序细节)。</p>

<p>在本例中，我们将数据源指向一个名为<code>jgroups</code>的模式，并连接一个名为<code>jgroups</code>的用户(尽管这两个值不需要相同):</p>

<pre><code class="language-xml">&lt;subsystem &gt;
  &lt;datasources&gt;
      &lt;datasource jndi-name="java:jboss/datasources/JGroups" pool-name="JGroupsDS"&gt;
          &lt;connection-property name="url"&gt;
              jdbc:mysql://your-rds-hostname.cluster-c1ufrgizkeyf.us-east-1.rds.amazonaws.com/jgroups
          &lt;/connection-property&gt;
          &lt;driver&gt;mysql&lt;/driver&gt;
          &lt;security&gt;
              &lt;user-name&gt;jgroups&lt;/user-name&gt;
              &lt;password&gt;yourpassword&lt;/password&gt;
          &lt;/security&gt;
      &lt;/datasource&gt;
      &lt;drivers&gt;
          &lt;driver name="mysql" module="com.mysql.driver"&gt;
              &lt;xa-datasource-class&gt;com.mysql.jdbc.jdbc2.optional.MysqlXADataSource&lt;/xa-datasource-class&gt;
              &lt;datasource-class&gt;com.mysql.jdbc.jdbc2.optional.MysqlDataSource&lt;/datasource-class&gt;
          &lt;/driver&gt;
      &lt;/drivers&gt;
  &lt;/datasources&gt;
&lt;/subsystem&gt;
</code></pre>

<h3 id="define-the-jgroups-stack">定义JGroups堆栈</h3>

<p>JGroups是WildFly用来连接集群成员的库。默认情况下，JGroups被配置为使用UDP和多播，但是Amazon不支持UDP和多播。</p>

<p>相反，我们将配置WildFly使用TCP，并利用中央数据库作为发现对等点的方式。</p>

<p>在JGroups子系统中，我们将通过更改<code>&lt;channel&gt;</code>元素上的<code>stack</code>属性来切换到<code>tcp</code>堆栈:</p>

<pre><code class="language-xml">&lt;channel name="ee" stack="tcp" cluster="ejb"/&gt;
</code></pre>

<p>然后我们需要用<code>JDBC_PING</code>替换<code>MPING</code>协议:</p>

<pre><code class="language-xml">&lt;protocol type="org.jgroups.protocols.JDBC_PING"&gt;
    &lt;property name="datasource_jndi_name"&gt;
        java:jboss/datasources/JGroups
    &lt;/property&gt;
&lt;/protocol&gt;
</code></pre>

<p>完整的堆栈现在是这样的:</p>

<pre><code class="language-xml">&lt;subsystem &gt;
    &lt;channels default="ee"&gt;
        &lt;!-- We are now using the tcp stack --&gt;
        &lt;channel name="ee" stack="tcp" cluster="ejb"/&gt;
    &lt;/channels&gt;
    &lt;stacks&gt;
        &lt;stack name="udp"&gt;
            &lt;transport type="UDP" socket-binding="jgroups-udp"/&gt;
            &lt;protocol type="PING"/&gt;
            &lt;protocol type="MERGE3"/&gt;
            &lt;protocol type="FD_SOCK"/&gt;
            &lt;protocol type="FD_ALL"/&gt;
            &lt;protocol type="VERIFY_SUSPECT"/&gt;
            &lt;protocol type="pbcast.NAKACK2"/&gt;
            &lt;protocol type="UNICAST3"/&gt;
            &lt;protocol type="pbcast.STABLE"/&gt;
            &lt;protocol type="pbcast.GMS"/&gt;
            &lt;protocol type="UFC"/&gt;
            &lt;protocol type="MFC"/&gt;
            &lt;protocol type="FRAG2"/&gt;
        &lt;/stack&gt;
        &lt;stack name="tcp"&gt;
            &lt;transport type="TCP" socket-binding="jgroups-tcp"/&gt;
            &lt;!-- MPING has been replaced with JDBC_PING --&gt;
            &lt;protocol type="org.jgroups.protocols.JDBC_PING"&gt;
                &lt;property name="datasource_jndi_name"&gt;
                    java:jboss/datasources/JGroups
                &lt;/property&gt;
            &lt;/protocol&gt;
            &lt;protocol type="MERGE3"/&gt;
            &lt;protocol type="FD_SOCK"/&gt;
            &lt;protocol type="FD_ALL"/&gt;
            &lt;protocol type="VERIFY_SUSPECT"/&gt;
            &lt;protocol type="pbcast.NAKACK2"/&gt;
            &lt;protocol type="UNICAST3"/&gt;
            &lt;protocol type="pbcast.STABLE"/&gt;
            &lt;protocol type="pbcast.GMS"/&gt;
            &lt;protocol type="MFC"/&gt;
            &lt;protocol type="FRAG2"/&gt;
        &lt;/stack&gt;
    &lt;/stacks&gt;
&lt;/subsystem&gt;
</code></pre>

<h3 id="use-the-ha-profile">使用<code>ha</code>轮廓</h3>

<p>为了利用我们对<code>ha</code>概要文件的更改，需要配置从属实例来使用它。这在<code>&lt;server-groups&gt;</code>元件中进行配置。</p>

<p>更改<code>main-server-group</code>以使用<code>ha</code>轮廓:</p>

<pre><code class="language-xml">&lt;server-group name="main-server-group" profile="ha"&gt;
</code></pre>

<p>还将服务器组更改为使用<code>full-ha-scokets</code>套接字绑定组:</p>

<pre><code class="language-xml">&lt;socket-binding-group ref="full-ha-sockets"/&gt;
</code></pre>

<p>完整的<code>&lt;server-groups&gt;</code>元素现在看起来像这样:</p>

<pre><code class="language-xml">&lt;server-groups&gt;
    &lt;!-- main-server-group uses the ha profile --&gt;
     &lt;server-group name="main-server-group" profile="ha"&gt;
         &lt;jvm name="default"&gt;
             &lt;heap size="64m" max-size="512m"/&gt;
         &lt;/jvm&gt;
         &lt;!-- main-server-group uses the full-ha-sockets socket binding group --&gt;
         &lt;socket-binding-group ref="full-ha-sockets"/&gt;
     &lt;/server-group&gt;
     &lt;server-group name="other-server-group" profile="full-ha"&gt;
         &lt;jvm name="default"&gt;
             &lt;heap size="64m" max-size="512m"/&gt;
         &lt;/jvm&gt;
         &lt;socket-binding-group ref="full-ha-sockets"/&gt;
     &lt;/server-group&gt;
 &lt;/server-groups&gt;
</code></pre>

<h2 id="open-the-firewall">打开防火墙</h2>

<p>套接字绑定组为JGroups使用端口<code>7600</code>，所以这个端口需要在我们的防火墙上打开。</p>

<h2 id="starting-the-slaves">启动奴隶</h2>

<p>为了在数据库中注册正确的地址，WildFly从属实例需要将<code>private</code>接口绑定到外部NIC的IP地址。这是通过将<code>-bprivate=&lt;ip address&gt;</code>参数传递给<code>domain.sh</code>来完成的。</p>

<p>因为这些从属实例需要为外部世界的流量提供服务，我们还需要将<code>public</code>接口绑定到外部NIC的IP地址。这是通过将参数<code>-b=&lt;ip address&gt;</code>传递给<code>domain.sh</code>来完成的。</p>

<p>例如，这个命令在IP地址为<code>172.30.0.88</code>的EC2实例上启动一个从属服务器:</p>

<pre><code>[ec2-user@ip-172-30-0-88 bin]$ ./domain.sh --host-config host-slave.xml -bprivate=172.30.0.88 -b=172.30.0.88
</code></pre>

<p>我们不绑定到EC2实例的公共IP地址(如果它甚至有一个公共IP地址的话)。负载均衡器将获取公共互联网流量，并将其定向到WildFly绑定的本地子网IP地址。</p>


<h2 id="creating-a-load-balancer">创建负载平衡器</h2>

<p>至此，我们已经有了一个配置集群的域。WildFly slave实例将从域控制器获取它们的配置(通过共享的S3桶发现)，该配置包括一个JGroups堆栈，允许形成一个集群(通过查询一个共享的数据库)。</p>

<p>为了真正利用集群，我们需要一个集中的负载均衡器来在从设备之间分配请求。这很重要，因为代表会话的cookie将被绑定到负载平衡器的地址，而不是任何单个节点的地址。这样，由单个cookie表示的单个会话在集群成员之间共享。</p>

<p>AWS提供了一个负载平衡器来完成这项工作。</p>

<p>我们的负载平衡器将针对<code>WildFly</code>目标群体:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-11/aws-load-balancer-listener.png" class="zoom" data-title=""><img src="../Images/21c51e66156d1ae8852040a900dd084f.png" class="img-fluid center" alt="AWS Load Balancer Listener" data-original-src="https://i.octopus.com/blog/2017-11/aws-load-balancer-listener.png"/>T2】</a></p>

<p>该目标组有两个WildFly从属实例，并将流量定向到端口<code>8080</code>(wild fly的默认HTTP端口):</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-11/aws-target-targets.png" class="zoom" data-title=""><img src="../Images/c297d193689d8c315a984169cb3d4132.png" class="img-fluid center" alt="AWS Target Targets" data-original-src="https://i.octopus.com/blog/2017-11/aws-target-targets.png"/>T2】</a></p>

<p>我们将使用默认的WildFly欢迎页面作为健康检查:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-11/aws-target-health-checks.png" class="zoom" data-title=""><img src="../Images/c20c2138cc0d78b14d885275f662f946.png" class="img-fluid center" alt="AWS Target Health Check" data-original-src="https://i.octopus.com/blog/2017-11/aws-target-health-checks.png"/>T2】</a></p>

<h2 id="deploying-a-distributable-web-application">部署可分发的web应用程序</h2>

<p>为了利用复制会话状态，我们的Java web应用程序需要标记为可分发的。这是在带有<code>&lt;distributable/&gt;</code>元素的<code>web.xml</code>文件中完成的。这个<a href="https://github.com/OctopusDeploy/ThymeleafSpringDemo/blob/master/src/main/webapp/WEB-INF/web.xml#L6" rel="nofollow">示例web应用程序</a>已经被配置为可分发的。</p>

<p>这个示例应用程序在会话存储中维护一个页面计数，我们可以使用这个值来确保我们的会话数据实际上是跨集群复制的。</p>

<p>我们将构建这个应用程序，并在整个域中部署它:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-11/deployed-app.png" class="zoom" data-title=""><img src="../Images/7359ae9e45794e4994c2a091a0d8bf9f.png" class="img-fluid center" alt="Deployed App" data-original-src="https://i.octopus.com/blog/2017-11/deployed-app.png"/>T2】</a></p>

<h2 id="opening-the-app">打开应用程序</h2>

<p>部署好应用程序和我们的负载平衡器后，我们就可以打开应用程序了。每次我们刷新页面，<code>Page count</code>就会增加。这是通过增加会话存储中的值来实现的，会话存储是我们的集群正在复制的存储:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-11/load-balanced-request.png" class="zoom" data-title=""><img src="../Images/cea56b57dea65aacf32a86261c7dbb87.png" class="img-fluid center" alt="Load Balanced Request" data-original-src="https://i.octopus.com/blog/2017-11/load-balanced-request.png"/>T2】</a></p>

<p>如果我们看一下<code>JSESSIONID</code> cookie，我们可以看到它被绑定到负载平衡器域。这很重要，因为这个cookie是我们跟踪会话的方式，而且由于浏览器的工作方式，这个cookie只会被发送到创建它的域。通过将WildFly服务器隐藏在负载平衡器之后，浏览器不知道哪个集群实例正在响应请求。</p>

<p>然而，如果我们仔细观察cookie的值，我们可以看到发起会话的从属实例的IP地址是<code>172.30.0.88</code>。该值仅代表启动会话的集群成员，如果不同的集群成员响应后续请求，该值不会改变:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2017-11/jsessionid.png" class="zoom" data-title=""><img src="../Images/7a87201efc8b2ee2065c3ca94573d3e9.png" class="img-fluid center" alt="JSESSIONID" data-original-src="https://i.octopus.com/blog/2017-11/jsessionid.png"/>T2】</a></p>

<p>我们可以使用这些信息来关闭托管我们会话的从属服务器，将流量强制转移到第二个从属服务器上。</p>

<p>通过定义<code>host-slave.xml</code>文件中<code>&lt;host&gt;</code>元素的<code>name</code>属性，可以避免从机IP地址泄露；</p>
<pre><code class="language-xml">&lt;host name="Slave Name" &gt;
</code></pre>


<p>启动会话的群集节点现在关闭，所有流量都转移到群集的另一个成员。但是页面计数将继续从其先前的值攀升，而不会重置为1，因为复制的会话意味着最终用户可以像什么都没发生一样继续。</p>

<h2 id="verifying-the-cluster-configuration">验证集群配置</h2>

<p>部署了可分发的应用程序后，JGroups将开始在共享数据库中注册信息。使用MySQL客户端，我们可以用<code>show tables;</code>命令登录回数据库并列出我们的<code>jgroups</code>模式中的表。</p>

<p>这里我们可以看到<code>JGROUPSPING</code>表已经创建:</p>

<pre><code>[ec2-user@ip-172-30-0-88 log]$ mysql -u jgroups -p -hyour-rds-hostname.cluster-c1ufrgizkeyf.us-east-1.rds.amazonaws.com
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 22
Server version: 5.6.10 MySQL Community Server (GPL)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; use jgroups;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; show tables;
+-------------------+
| Tables_in_jgroups |
+-------------------+
| JGROUPSPING       |
+-------------------+
1 row in set (0.00 sec)

mysql&gt;

</code></pre>

<h2 id="conclusion">结论</h2>

<p>在这篇文章中，我们看到了如何配置一个域来创建一个集群，以及如何允许该集群通过一个共享数据库来识别对等体。然后，该集群通过AWS负载平衡器公开。</p>

<p>然后，我们将一个可分发的web应用程序部署到域中，并通过关闭创建原始会话的实例，将流量转移到一个新的集群节点上。</p>

<p>如果您对Java应用程序的自动化部署感兴趣，<a href="https://octopus.com/downloads">下载Octopus Deploy </a>的试用版，并查看我们的文档。</p>

<h2 id="learn-more">了解更多信息</h2>



                    
                    
</body>
</html>