<html>
<head>
<title>Java CI/CD: From local build to Jenkins Continuous Integration - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Java CI/CD:从本地构建到Jenkins持续集成——Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/java-ci-cd-co/from-local-to-ci#2022-12-20">https://octopus.com/blog/java-ci-cd-co/from-local-to-ci#2022-12-20</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/blogimage-java-blog-series-3.png" class="zoom" data-title=""><img src="../Images/067712f83d0d783fbfc220b1b4b19007.png" class="img-fluid center" alt="Java CI/CD: From local build to Jenkins Continuous Integration" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/blogimage-java-blog-series-3.png"/>T2】</a></p>

<p>本文是展示Jenkins、Docker和Octopus示例部署管道系列的一部分:</p>



<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/buildtest.svg" class="zoom" data-title=""><img src="../Images/ca91600ac5650ee7060723ab9534d888.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/buildtest.svg"/>T2】</a></p>

<p><a href="/blog/java-ci-cd-co/from-jar-to-docker">在之前的文章</a>中，我们采用了一个典型的Java应用程序，并创建了一个<code>Dockerfile</code>，负责构建代码并运行生成的JAR文件。通过利用Maven和Java本身等工具提供的现有Docker映像，我们创建了一个可重复和自包含的构建过程，并且生成的Docker映像可以由只安装了Docker的任何人执行。</p>

<p>这是我们构建过程的坚实基础。然而，随着越来越多的开发人员开始在共享代码库上工作，测试需求增加，产生的包变大，团队需要一个中央共享服务器来管理构建。这就是持续集成(CI)服务器的作用。</p>

<p>有许多CI服务器可用。其中最流行的是<a href="https://www.jenkins.io/" rel="nofollow"> Jenkins </a>，免费开源。在这篇博文中，我们将学习如何配置Jenkins来构建和发布我们的Docker映像。</p>

<h2 id="getting-started-with-jenkins">Jenkins入门</h2>

<p>开始使用Jenkins最简单的方法是使用他们的<a href="https://hub.docker.com/r/jenkins/jenkins/" rel="nofollow"> Docker图像</a>。正如我们在上一篇博文中为自己的应用程序创建了一个自包含映像一样，Jenkins Docker映像为我们提供了在预配置的自包含环境中启动Jenkins的能力，只需几个命令。</p>

<p>首先，我们使用以下命令下载Jenkins Docker映像的最新长期支持(LTS)版本:</p>

<pre><code>docker pull jenkins/jenkins:lts
</code></pre>

<p>然后，我们用命令启动Jenkins:</p>

<pre><code>docker run -p 8081:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts
</code></pre>

<p><code>-p</code>参数将本地工作站的一个端口绑定到映像公开的一个端口。这里我们使用参数<code>-p 8081:8080</code>将本地端口<code>8081</code>绑定到容器端口<code>8080</code>。注意，因为我们自己的PetClinic应用程序在默认情况下也监听端口<code>8080</code>，所以我们为Jenkins选择了下一个可用的端口<code>8081</code>。将哪个本地端口映射到容器端口完全取决于您。参数<code>-p 50000:50000</code>公开了Jenkins代理使用的一个端口，我们将在后面的文章中配置这个端口来执行我们的构建。</p>

<p><code>-v</code>参数将<a href="https://docs.docker.com/storage/volumes/" rel="nofollow"> Docker卷</a>挂载到容器中的路径。虽然Docker容器可以在运行时修改数据，但最好假设您将无法保留这些更改。例如，每次您调用<code>docker run</code>(您可以使用Jenkins Docker映像的更新版本)时，都会创建一个新的容器，其中没有任何被之前的容器修改过的数据。Docker卷允许我们通过公开可以在容器之间共享的持久文件系统来保留修改过的数据。在本例中，我们创建了一个名为<code>jenkins_home</code>的卷，并将其挂载到目录<code>/var/jenkins_home</code>中。这意味着所有的Jenkins数据都是在一个永久卷中捕获的。</p>

<p>当Docker映像运行时，您将看到日志输出。作为初始引导的一部分，Jenkins生成一个随机密码，并在日志中显示如下:</p>

<pre><code>*************************************************************
*************************************************************
*************************************************************

Jenkins initial setup is required. An admin user has been created and a password generated.
Please use the following password to proceed to installation:

4b9e47bcd9ea469687dc39f23b0adb08

This may also be found at: /var/jenkins_home/secrets/initialAdminPassword

*************************************************************
*************************************************************
*************************************************************
</code></pre>

<p>当您打开http://localhost:8081时，系统会提示您输入此密码来解锁Jenkins:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/unlock.png" class="zoom" data-title=""> <img src="../Images/9604ba2d9166377adc36cd5a65b83e16.png" class="img-fluid center" alt="Unlock Jenkins with the generated password" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/unlock.png"/> </a> <em>用生成的密码解锁詹金斯。</em></p>

<p>Jenkins会提示你要么安装一个常用插件列表，要么只安装你选择的插件。<strong>安装推荐插件</strong>选项包含了我们需要的大部分插件。</p>

<p>插件下载需要一分钟左右的时间:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/downloading.png" class="zoom" data-title=""> <img src="../Images/7b8a1e6d9270f3cd29284f3668ffbc07.png" class="img-fluid center" alt="The plugins installing" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/downloading.png"/> </a> <em>插件安装。</em></p>

<p>完成后，创建第一个管理员用户，点击<strong>保存并继续</strong>。</p>

<p>最后，定义Jenkins URL并点击<strong>保存并完成</strong>。</p>

<p>Jenkins现在已经配置好并可以使用了，只需点击<strong>开始使用Jenkins </strong>。</p>

<h2 id="create-an-agent">创建代理</h2>

<p>我们需要解决的一个问题是，我们在Docker容器中运行Jenkins，并且还希望Jenkins自己使用Docker来构建Docker映像。这就产生了一个我们想在Docker中使用Docker的场景。</p>

<p>在Docker 中运行<a href="https://hub.docker.com/_/docker" rel="nofollow"> Docker是可能的，但是我们已经运行的Jenkins映像不支持开箱即用。已经创建了许多第三方工具，如</a><a href="https://github.com/GoogleContainerTools/kaniko" rel="nofollow"> Kaniko </a>和<a href="https://github.com/containers/buildah" rel="nofollow"> Buildah </a>，它们支持在不依赖Docker守护进程的情况下构建Docker映像。尽管这些解决方案相当先进。</p>

<p>一个更简单的解决方案是在Jenkins Docker容器之外运行Jenkins代理。该代理将在主机操作系统上运行，并有权访问Docker守护程序来创建Docker映像。</p>

<p>要创建代理，请单击<strong> <span class="path">管理詹金斯➜管理节点和云</span> </strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/nodes.png" class="zoom" data-title=""> <img src="../Images/7a78d876a51af78a9fb8661f1becf140.png" class="img-fluid center" alt="Jenkins Management options" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/nodes.png"/> </a> <em>詹金斯管理选项。</em></p>

<p>点击<strong>新节点</strong>链接，给新节点起一个名字，比如<em> Builder </em>，点击<strong> OK </strong>:</p>

<p>输入<strong>远程根目录</strong>的路径。因为我在Windows上运行节点，所以路径类似于<code>C:\JenkinsAgent</code>。然后输入<code>docker</code>作为节点标签，点击<strong>保存</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/newnodewithlabel.png" class="zoom" data-title=""> <img src="../Images/4a3f04468d3025742ea5b77dea9bd997.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/newnodewithlabel.png"/> </a> <em>配置新节点。</em></p>

<p>该节点现在在Jenkins中进行了配置，但是由于没有节点在运行，所以它显示为断开连接。</p>

<p>如果单击新节点，您将看到一个屏幕，其中提供了运行代理的说明。单击<strong> agent.jar </strong>链接下载代理文件，并运行屏幕上显示的命令将代理连接到Jenkins:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/agentdownload.png" class="zoom" data-title=""> <img src="../Images/ac4ccc41693f40a45fd88a299d62c783.png" class="img-fluid center" alt="Instructions for connecting a node" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/agentdownload.png"/> </a> <em>连接一个节点的指令。</em></p>

<p>现在，节点已连接，我们有一个连接到Jenkins的代理，它能够构建Docker映像。</p>

<h2 id="install-the-docker-pipeline-plugin">安装Docker管道插件</h2>

<p>詹金斯的初始配置安装了一些常用插件。然而，为了构建Docker镜像，我们还需要一个叫做<strong> Docker Pipeline </strong>的插件。这是通过<strong> <span class="path">管理詹金斯➜管理插件</span> </strong>并在<strong>可用</strong>选项卡中搜索<strong> Docker管道</strong>插件来完成的。</p>

<p>下载和安装该插件需要几秒钟时间:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/plugindownload.png" class="zoom" data-title=""> <img src="../Images/9555ccba154f4d49d02f654960ac2e02.png" class="img-fluid center" alt="Downloading the plugin" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/plugindownload.png"/> </a> <em>下载插件。</em></p>

<h2 id="add-the-dockerhub-credentials">添加DockerHub凭据</h2>

<p>为了允许我们的项目将Docker映像发布到Docker Hub，我们需要在Jenkins中定义Docker Hub凭证。</p>

<ol>
<li>点击<strong> <span class="path">管理詹金斯➜管理凭证</span> </strong>，导航至凭证部分。</li>
<li>选择<strong>詹金斯</strong>，点击<strong>全球凭证</strong>。</li>
<li>点击<strong>添加凭证</strong>，进入Docker Hub凭证，将<strong> ID </strong>设置为<strong> dockerhub </strong>，点击<strong> OK </strong>按钮:</li>
</ol>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/newcredentials.png" class="zoom" data-title=""> <img src="../Images/c4061f70a1b654acaf5d50b3066eafd6.png" class="img-fluid center" alt="Define the Docker Hub credentials" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/newcredentials.png"/> </a> <em>定义Docker Hub凭证。</em></p>

<p>我们现在拥有了在Jenkins中构建Docker映像所需的一切。下一步是定义Jenkins项目。</p>

<h2 id="define-the-jenkins-project">定义詹金斯项目</h2>

<p>在高层次上，Jenkins提供了两种类型的项目。</p>

<p>第一种格式称为自由式项目，在Jenkins UI中定义。虽然可以导出和共享自由式项目，但这很难做到，因为底层数据格式不是为手动编辑而设计的。</p>

<p>第二种格式称为管道，本质上是一个脚本，其创建和管理方式与应用程序中的代码非常相似。管道可以与您的项目代码一起保存在一个名为<code>Jenkinsfile</code>的文件中，它将您的应用程序代码和构建定义保存在同一个地方。</p>

<p>我们将为我们的项目创建一个<code>Jenkinsfile</code>,用下面的代码构建并发布我们的Docker图像:</p>

<pre><code>pipeline {
    agent {
        label 'docker'
    }
    stages {
        stage('Building our image') {
            steps {
                script {
                    dockerImage = docker.build "mcasperson/petclinic:$BUILD_NUMBER"
                }
            }
        }
        stage('Deploy our image') {
            steps {
                script {
                    // Assume the Docker Hub registry by passing an empty string as the first parameter
                    docker.withRegistry('' , 'dockerhub') {
                        dockerImage.push()
                    }
                }
            }
        }
    }
}
</code></pre>

<p>让我们把这个文件分解一下。</p>

<p>所有声明性管道都以<code>pipeline</code>开头:</p>

<pre><code>pipeline {
</code></pre>

<p>运行这个构建的代理在<code>agent</code>部分中定义。在这里，我们已经将构建配置为在任何带有标签<code>docker</code>的代理上运行。这确保了构建运行在我们的外部节点上，它可以访问Docker守护进程，而不是运行在Jenkins服务器本身上，它不能访问Docker:</p>

<pre><code>    agent {
        label 'docker'
    }
</code></pre>

<p>组成流水线的阶段包含在<code>stages</code>部分:</p>

<pre><code>stages {
</code></pre>

<p>第一阶段构建docker映像。我们利用<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#script" rel="nofollow">脚本</a>步骤调用我们之前安装的Docker Pipeline插件来构建映像。这个构建的结果保存在一个名为<code>dockerImage</code>的变量中。注意使用<code>$BUILD_NUMBER</code>变量为每个构建分配一个新版本作为图像标签。这确保了该管道的每次执行都将构建一个新的不同的Docker映像:</p>

<pre><code>        stage('Building our image') {
            steps {
                script {
                    dockerImage = docker.build "mcasperson/petclinic:$BUILD_NUMBER"
                }
            }
        }
</code></pre>

<p>第二阶段将新创建的映像推送到Docker Hub。<code>withRegistry</code>方法将Docker注册表作为第一个参数，或者如果它留空，则默认为Docker Hub。第二个参数是我们之前在Jenkins中创建的凭证的名称:</p>

<pre><code>        stage('Deploy our image') {
            steps {
                script {
                    // Assume the Docker Hub registry by passing an empty string as the first parameter
                    docker.withRegistry('' , 'dockerhub') {
                        dockerImage.push()
                    }
                }
            }
        }
</code></pre>

<p>这个文件和我们的应用程序代码一起被提交。下一步是创建一个Jenkins项目来检查代码并运行管道。</p>

<h2 id="create-a-pipeline-project">创建管道项目</h2>

<p>在Jenkins仪表板上，单击<strong>新项目</strong>链接。输入<strong> Petclinic </strong>作为项目名称，并选择<strong>管道</strong>选项:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/newitem.png" class="zoom" data-title=""> <img src="../Images/6f273f52fab464e7a309bcb3ff62d000.png" class="img-fluid center" alt="New project creation" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/newitem.png"/> </a> <em>新项目创建。</em></p>

<p>在<strong>管道</strong>部分下，从SCM 中选择<strong>管道脚本，输入Git存储库URL(本例中为<a href="https://github.com/mcasperson/spring-petclinic.git" rel="nofollow">https://github.com/mcasperson/spring-petclinic.git</a>)并选择要构建的分支(本例中为<strong> main </strong>)。然后点击<strong>保存</strong>:</strong></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/itemconfig.png" class="zoom" data-title=""> <img src="../Images/d654262389fbdbca6c63124f4b0b03c6.png" class="img-fluid center" alt="Define the pipeline GIT repository" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/itemconfig.png"/> </a> <em>定义管道GIT库。</em></p>

<p>从项目仪表板中，单击<strong> Build Now </strong>链接手动运行一个构建，并单击构建链接图标:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/build.png" class="zoom" data-title=""> <img src="../Images/3356a04004cb3fd3cd7e45e6fb40526c.png" class="img-fluid center" alt="A Jenkins project build" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/build.png"/> </a> <em>一个詹金斯项目的构建。</em></p>

<p>点击<strong>控制台输出</strong>链接查看构建输出:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/console.png" class="zoom" data-title=""> <img src="../Images/9db98288f3ec56fb4c524736d96bb374.png" class="img-fluid center" alt="Jenkins project build console output" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/console.png"/> </a> <em>詹金斯项目构建控制台输出。</em></p>

<p>当构建完成时，Docker映像在Jenkins节点上构建并被推送到<a href="https://hub.docker.com/r/mcasperson/petclinic/tags" rel="nofollow"> Docker Hub </a>，带有基于构建号的标签:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/dockerhubtags.png" class="zoom" data-title=""> <img src="../Images/5a20280fd78651d2092fa6c189b1b754.png" class="img-fluid center" alt="The resulting image in Docker Hub" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-local-to-ci/dockerhubtags.png"/> </a> <em>由此产生的图像出现在Docker中枢。</em></p>

<p>这样，我们就成功地配置了Jenkins来编译和测试应用程序代码，然后构建Docker映像并将其推送到Docker Hub。</p>

<h2 id="conclusion">结论</h2>

<p>Jenkins提供了一个中央平台，多个开发人员可以通过这个平台构建、测试和分发他们的代码。Jenkins维护更改的历史记录以及这些更改是否导致了成功的构建，维护分发Docker映像所需的凭证，并消除个人在每次构建时上传可能很大的Docker映像的需要。</p>

<p>在本文中，我们逐步完成了将Jenkins作为Docker容器运行的过程，连接了一个节点来执行构建，并编写了一个Jenkins管道来定义Jenkins将如何构建和推送Docker映像。这样做的最终结果是一个持续的集成系统，它可以自动构建和发布我们的应用程序，消除了单个开发人员手动管理这个过程的需要。我们实现了持续整合。</p>

<p>下一步是在某个地方部署我们新创建的Docker映像。为此，我们将在AWS中配置一个Kubernetes集群。</p>

<p>浏览<a href="https://octopus.com/devops/"> DevOps工程师手册</a>以了解更多关于持续集成和持续交付(CI/CD)的信息。</p>

                    
                    
</body>
</html>