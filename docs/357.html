<html>
<head>
<title>Java CI/CD: From Continuous Integration to release management - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Java CI/CD:从持续集成到发布管理- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/java-ci-cd-co/from-ci-to-cd#2022-12-19">https://octopus.com/blog/java-ci-cd-co/from-ci-to-cd#2022-12-19</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/blogimage-java-blog-series-5.png" class="zoom" data-title=""><img src="../Images/7de29f8fc694baff5241e76f426596c5.png" class="img-fluid center" alt="Java CI/CD: From Continuous Integration to release management" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/blogimage-java-blog-series-5.png"/>T2】</a></p>

<p>本文是展示Jenkins、Docker和Octopus示例部署管道系列的一部分:</p>



<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/releasedeploy.svg" class="zoom" data-title=""><img src="../Images/94b84c2ace7f7f2ff9bbcd4bc8f6d6b0.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/releasedeploy.svg"/>T2】</a></p>

<p><a href="/blog/java-ci-cd-co/from-ci-to-cloud">在之前的博文</a>中，我们使用EKS在AWS中使用Octopus构建了一个Kubernetes集群，然后将Jenkins创建的Docker映像部署为Kubernetes部署和服务。</p>

<p>然而，我们仍然没有一个完整的<a href="https://octopus.com/devops/continuous-delivery/what-is-a-deployment-pipeline/">部署管道</a>解决方案，因为Jenkins没有与Octopus集成，让我们手动协调构建和部署。</p>

<p>在这篇博文中，我们将扩展我们的Jenkins构建来调用Octopus，并在Docker映像被推送到Docker Hub时启动部署。我们还将创建额外的环境，并管理从本地开发环境到最终生产环境的发布。</p>

<h2 id="install-the-jenkins-plugins">安装Jenkins插件</h2>

<p>Octopus为Jenkins提供了一个插件，该插件公开了自由式项目和管道脚本中的集成步骤。通过导航到<strong> <span class="path">管理詹金斯➜管理插件</span> </strong>安装此插件。从这里，你可以搜索“章鱼”并安装插件。</p>

<p>Octopus插件使用<a href="https://octopus.com/docs/octopus-rest-api/octopus-cli"> Octopus CLI </a>与Octopus服务器集成。我们可以在代理上手动安装CLI，但在本例中，我们将使用<strong>定制工具</strong>插件下载Octopus CLI并将其推送到代理:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/customtoolsplugin.png" class="zoom" data-title=""> <img src="../Images/5be5a8458e340637e7302cc26d115f30.png" class="img-fluid center" alt="Install the custom tools plugin" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/customtoolsplugin.png"/> </a> <em>安装自定义工具插件。</em></p>



<p>我们添加Octopus服务器，我们的管道将连接到，通过导航到<strong> <span class="path">管理詹金斯➜配置系统</span> </strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octopusserver.png" class="zoom" data-title=""> <img src="../Images/3d0dcf1d31ce0234555d1ef2bebff2ca.png" class="img-fluid center" alt="Define the Octopus Server" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octopusserver.png"/> </a> <em>定义八达通服务器。</em></p>

<p>然后我们需要在<strong> <span class="path">管理詹金斯➜全球工具配置</span> </strong>下定义一个定制工具。自定义工具的名称为<strong>Octopus CLI</strong>，因为在我的例子中代理运行在Windows上，Octopus CLI将从<a href="https://download.octopusdeploy.com/octopus-tools/7.4.1/OctopusTools.7.4.1.win-x64.zip" rel="nofollow">https://download . Octopus deploy . com/Octopus-tools/7 . 4 . 1/Octopus tools . 7 . 4 . 1 . win-x64 . zip</a>下载。对于最新版本的CLI，以及支持其他操作系统的二进制文件，请参见<a href="https://octopus.com/downloads/octopuscli"> Octopus下载页面</a>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octocli.png" class="zoom" data-title=""> <img src="../Images/9397fb1b13ae818f0699164d91b47202.png" class="img-fluid center" alt="Define the Octopus CLI custom tool" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octocli.png"/> </a> <em>定义Octopus CLI自定义工具。</em></p>

<p>在<strong>全局工具配置</strong>页面上，我们定义了Octopus CLI的路径。自定义工具插件将Octopus CLI安装到目录<code>&lt;jenkins home&gt;/tools/com.cloudbees.jenkins.plugins.customtools.CustomTool/OctoCLI</code>，其中<code>&lt;jenkins home&gt;</code>是Jenkins服务器或执行构建的代理的主目录。在我的例子中，代理主目录是<code>C:\JenkinsAgent</code>，所以从<code>C:\JenkinsAgent\tools\com.cloudbees.jenkins.plugins.customtools.CustomTool\OctoCLI\octo</code>开始就可以使用Octopus CLI。刀具名称保留为<strong>默认</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octopuscli.png" class="zoom" data-title=""> <img src="../Images/b583a83fedab460c6ecbd870ade86cd1.png" class="img-fluid center" alt="Define the Octopus CLI path" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octopuscli.png"/> </a> <em>定义Octopus CLI路径。</em></p>

<p>通过配置这些工具，我们可以在Docker映像被推送到Docker Hub之后，更新管道脚本来启动Octopus中的部署。</p>

<h2 id="update-the-jenkins-pipeline">更新詹金斯管道</h2>

<p>我们现有的管道被配置为构建Docker映像并将其推送到Docker Hub。我们将保留这些步骤，并添加额外的步骤来安装作为定制工具的Octopus CLI，然后在Docker映像被推送后在Octopus中创建和部署一个版本。让我们看看完整的管道:</p>

<pre><code class="language-groovy">pipeline {
    agent {
        label 'docker'
    }
    parameters {
        string(defaultValue: 'Spaces-1', description: '', name: 'SpaceId', trim: true)
        string(defaultValue: 'Petclinic', description: '', name: 'ProjectName', trim: true)
        string(defaultValue: 'Dev', description: '', name: 'EnvironmentName', trim: true)
        string(defaultValue: 'Octopus', description: '', name: 'ServerId', trim: true)
    }
    stages {
        stage ('Add tools') {
            steps {
                tool('OctoCLI')
            }
        }
        stage('Building our image') {
            steps {
                script {
                    dockerImage = docker.build "mcasperson/petclinic:$BUILD_NUMBER"
                }
            }
        }
        stage('Deploy our image') {
            steps {
                script {
                    // Assume the Docker Hub registry by passing an empty string as the first parameter
                    docker.withRegistry('' , 'dockerhub') {
                        dockerImage.push()
                    }
                }
            }
        }
        stage('deploy') {
            steps {                                
                octopusCreateRelease deployThisRelease: true, environment: "${EnvironmentName}", project: "${ProjectName}", releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default', waitForDeployment: true                
            }
        }
    }
}
</code></pre>

<p>这个管道有一些新的设置来支持与Octopus的集成。</p>

<p>我们从定义公共参数开始。当我们在Octopus中创建和部署一个版本时，将会引用这些参数，它们提供了一种很好的方法来将Octopus细节从任何特定的实例中分离出来，同时还提供了合理的默认值:</p>

<pre><code class="language-groovy">    parameters {
        string(defaultValue: 'Spaces-1', description: '', name: 'SpaceId', trim: true)
        string(defaultValue: 'Petclinic', description: '', name: 'ProjectName', trim: true)
        string(defaultValue: 'Dev', description: '', name: 'EnvironmentName', trim: true)
        string(defaultValue: 'Octopus', description: '', name: 'ServerId', trim: true)
    }
</code></pre>

<p>为了让自定义工具插件提取代理主目录中的Octopus CLI，我们需要调用<code>tool('OctoCLI')</code>:</p>

<pre><code>        stage ('Add tools') {
            steps {
                tool('OctoCLI')
            }
        }
</code></pre>

<p>最后一个阶段调用<code>octopusCreateRelease</code>来创建一个发布并将其部署到Octopus中的第一个环境。默认情况下，Octopus将使用部署步骤中引用的最新版本的包来创建部署，这意味着我们将部署Jenkins在前一阶段上传到Docker Hub的Docker映像:</p>

<pre><code>        stage('deploy') {
            steps {                                
                octopusCreateRelease deployThisRelease: true, environment: "${EnvironmentName}", project: "${ProjectName}", releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default', waitForDeployment: true                
            }
        }
</code></pre>

<p>通过对管道的这些更改，我们在Jenkins中重新运行了该项目，从控制台日志中，我们可以看到Jenkins已经成功地触发了Octopus中的部署:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/jenkinslogs.png" class="zoom" data-title=""> <img src="../Images/79f6e89919d8f111b0c7213899acfd84.png" class="img-fluid center" alt="Jenkins project build logs showing the Octopus deployment output" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/jenkinslogs.png"/> </a> <em> Jenkins项目构建日志显示了Octopus部署输出。</em></p>

<p>以下是Octopus中相应的部署:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octopusdeployment.png" class="zoom" data-title=""> <img src="../Images/0c42e6e90b51df84c40f483840a61a56.png" class="img-fluid center" alt="The Octopus deployment" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/octopusdeployment.png"/> </a> <em>章鱼部署。</em></p>

<h2 id="continuous-deployment-vs-continuous-delivery">持续部署与持续交付</h2>

<p>多年来，首字母缩略词CI/CD 的<a href="https://octopus.com/devops/continuous-delivery/what-is-continuous-deployment/"> CD半已经确定了两个定义:</a></p>

<ul>
<li>连续部署，这意味着一个完全自动的部署管道，假设所有测试和其他自动化需求都得到满足，那么每次提交都会进入生产环境。</li>
<li>连续交付，这意味着每个提交<em>可以</em>通过自动化的，但不一定是自动的，部署管道进入生产。通过环境提升(或不通过环境提升)的决定仍然是由人做出的。</li>
</ul>

<p>虽然连续部署，就其定义而言，消除了部署过程中的所有摩擦，但是有许多有效的理由来实现连续交付。例如，您可能需要与其他团队协调部署，产品负责人可能需要签署新功能，法规要求可能要求开发人员在没有一些审查过程的情况下不得修改生产基础结构，或者您可能只想保留在发布进入生产之前手动测试和验证发布的能力。</p>

<p>如果您阅读了关于CI/CD最佳实践的博客文章，您可能会留下这样的印象，即持续部署是您必须努力实现的事情。虽然允许真正的连续部署管道的实践将会有价值，但是我们交谈过的大多数开发团队都报告说连续交付对他们有效。</p>


<p>对于这个博客，我们将创建一个连续的交付管道，通过Octopus仪表板管理向多个环境的发布。</p>

<h2 id="add-the-environments">添加环境</h2>

<p>我们在Octopus中只有一个环境叫做<strong> Dev </strong>。但是，典型的工作流会在生产过程中通过多个环境促进部署。为了实现这一点，我们需要在Octopus中创建更多的环境，我们称之为<strong>测试</strong>和<strong>生产</strong>:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/testandprod.png" class="zoom" data-title=""> <img src="../Images/cf8b403ba692b21ef25550aa7dd3a11b.png" class="img-fluid center" alt="Add the Test and Prod environments" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/testandprod.png"/> </a> <em>添加测试和生产环境。</em></p>

<p>我们需要确保我们的Kubernetes目标也在这些新环境中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/k8starget.png" class="zoom" data-title=""> <img src="../Images/d694fb52aa035824fb7a0724e11c7518.png" class="img-fluid center" alt="Add the Kubernetes target to the new environments" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/k8starget.png"/> </a> <em>将Kubernetes目标添加到新环境中。</em></p>

<p>我们现在能够通过Octopus仪表板将版本从<strong>开发</strong>环境升级到<strong>测试</strong>环境:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/progression.png" class="zoom" data-title=""> <img src="../Images/b25e24244d9cd08b2f60fd01a9d5f280.png" class="img-fluid center" alt="The Octopus dashboard showing the next environment to deploy to" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/progression.png"/> </a> <em>显示下一个部署环境的Octopus仪表盘。</em></p>

<p>将发布升级到<strong>测试</strong>环境，我们可以看到我们的Kubernetes资源正在<strong> petclinic-test </strong>名称空间中创建。如果您还记得上一篇博文，我们配置了Kubernetes步骤来部署到一个名为<strong>pet clinic-# { Octopus }的名称空间。Environment.Name | ToLower} </strong>，这就是为什么新环境的部署被放置在新的名称空间中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/testdeployment.png" class="zoom" data-title=""> <img src="../Images/7e471fca1da2791ebbffccd65bd38668.png" class="img-fluid center" alt="A deployment to the Test environment" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/testdeployment.png"/> </a> <em>一个部署到测试环境中。</em></p>

<p>为了证明这一点，我们可以在<strong>测试</strong>环境中重新运行runbook <strong> Get服务</strong>。我们可以看到，已经为新的服务资源创建了一个新的负载平衡器主机名:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/testlb.png" class="zoom" data-title=""> <img src="../Images/4152eb50eb534f4d68a3ed57d097a7c6.png" class="img-fluid center" alt="The details of the load balancer service created in the Test environment" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-ci-to-cd/testlb.png"/> </a> <em>在测试环境中创建的负载平衡器服务的详细信息。</em></p>

<p>这样，我们就有了完整的部署渠道。</p>

<h2 id="conclusion">结论</h2>

<p>在这篇文章中，在Jenkins完成Docker映像的构建和推送之后，我们在Octopus中触发了一个部署。这意味着我们已经实现了与Jenkins的持续集成，测试、构建和发布Docker映像，以及与Octopus的持续交付，提供了到开发环境的自动部署，以及准备在其他环境中手动触发的自动化流程。</p>

<p>现在，我们只需点击几个简单的按钮，就可以将应用程序源代码转化为产品。那些负责发布管理的人除了web浏览器之外不需要任何特殊的工具。每个构建和部署都在Jenkins和Octopus仪表板中被跟踪、审计和总结。</p>

<p>但是那些看到他们的代码放在客户手中的人知道，虽然没有什么比生产部署的前10分钟更能激发信心，但接下来的几个小时和几天是艰难的。需要管理数据库备份，需要安排操作系统更新，需要收集日志来诊断支持问题，并且需要执行一些好的、老式的开关操作。</p>

<p>在下一篇博文中，我们将展示在运行手册中实现的这些维护过程的例子，以完成我们管道的最后阶段:运营。</p>

<p>浏览<a href="https://octopus.com/devops/"> DevOps工程师手册</a>了解有关DevOps和CI/CD的更多信息。</p>

                    
                    
</body>
</html>