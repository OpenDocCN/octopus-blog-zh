<html>
<head>
<title>Lessons learned using Docker for development and testing on Windows - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Windows - Octopus Deploy上使用Docker进行开发和测试的经验教训</h1>
<blockquote>原文：<a href="https://octopus.com/blog/lessons-learned-using-docker-for-development-and-testing#2021-08-12">https://octopus.com/blog/lessons-learned-using-docker-for-development-and-testing#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker_development_testing.png" class="zoom" data-title=""><img src="../Images/0616707bad0bfa39e2206e54ccfa71d7.png" class="img-fluid center" alt="Illustration showing a book of docker lessons learned for development and testing" data-original-src="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker_development_testing.png"/>T2】</a></p>

<p>在Windows开发者机器上使用Docker进行开发和测试有多难？Docker有我想的那么大那么吓人吗？几周前，我挑战自己回答这些问题。事实证明，Windows上的Docker既没有我想象的那么大，也没有我想象的那么可怕。也就是说，有一点学习曲线，我想与你分享我学到的一些教训。</p>



<h2 id="the-scenario">场景</h2>

<p>我本质上是一个. NET开发者。我喜欢使用Visual Studio。Visual Studio内置的Docker功能非常好用。这几乎太容易了。右键单击一个项目，并配置它在Docker中运行。启动调试器，我要去比赛了。</p>

<p>我想后退一步，学习Docker实际上是如何工作的，尤其是在Windows上，而我正好有一个完美的场景来完成这个任务。我演示了许多CI/CD管道，无论是在会议上还是与客户的一对一交流中。虽然我不是每天都在会议上发言或做演示，但是一直运行CI/CD管道会消耗资源。我可以在Docker中运行CI/CD管道吗？</p>

<p>我的CI/CD管道使用GitHub进行源代码控制，TeamCity作为构建服务器，Octopus Deploy作为部署服务器(大惊喜，我知道)，SQL Server作为数据库后端。当我写这篇文章的时候，CI/CD管道的核心与我过去从事的应用程序没有太大的不同。您可以用托管在<a href="https://nginx.com" rel="nofollow"> NGINX </a>中的Angular应用程序、托管在IIS中的ASP.NET Web API或使用SQL Server作为数据库的Windows服务来替换所有CI/CD组件。</p>

<p>通过学习如何在Docker中托管CI/CD管道，我还学习了如何在Docker中托管几乎任何其他应用程序。</p>

<h2 id="lesson-1-its-hard-to-bootstrap-a-stateful-app-using-docker-compose">第一课:使用Docker Compose很难引导一个有状态的应用程序</h2>

<p><a href="https://docs.docker.com/compose/" rel="nofollow"> Docker Compose </a>通过将应用程序定义为YAML文件，可以轻松配置多个容器。当所有容器都是无状态的时候，Docker Compose工作得很好，但是添加一个有状态的容器会使事情变得棘手。在我的CI/CD管道中，我在配置SQL Server容器时直接遇到了这个问题。SQL Server容器包含Octopus Deploy的数据库。简而言之，我想要一个引导脚本来:</p>

<ul>
<li>如果Octopus部署数据库不存在，则创建它。</li>
<li>将Octopus Deploy数据库挂载到容器中(如果存在的话)。</li>
</ul>

<p>当数据库不存在时，Docker合成文件为:</p>

<pre><code class="language-YAML">  SQLServer:
   image: microsoft/mssql-server-windows-developer
   environment:
     - ACCEPT_EULA=Y
     - SA_PASSWORD=Password_01
   ports:
     - '1433:1433'   
   volumes:
     - c:\Docker\Volumes\SQLServer\Databases:c:\SQLData     
</code></pre>

<p>但是，创建数据库后，Docker合成文件会发生变化:</p>

<pre><code class="language-YAML">  SQLServer:
   image: microsoft/mssql-server-windows-developer
   environment:
     - ACCEPT_EULA=Y
     - SA_PASSWORD=Password_01
     - attach_dbs=[{'dbName':'OctopusDeploy','dbFiles':['C:\\SQLData\\OctopusDeploy.mdf','C:\\SQLData\\OctopusDeploy_log.ldf']}]
   ports:
     - '1433:1433'   
   volumes:
     - c:\Docker\Volumes\SQLServer\Databases:c:\SQLData     
</code></pre>

<p>可以从包含attach_dbs环境变量的Docker合成文件开始。如果指定了找不到的数据库文件，容器将继续运行。</p>

<p>【T2 <img src="../Images/3ab4b6fc4495d1d5a4837d07c6b3c64f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-start-sql-server-missing-database.png"/></p>

<p>如果这是我需要运行的唯一容器，那没什么大不了的。打开SSMS，添加数据库，我就可以走了。然而，我在Docker组合文件中有另一个容器Octopus Deploy，它要求数据库在那里。且章鱼部署容器需要在那里，以便章鱼触须工作。对于完全托管在Docker容器中的Octopus Deploy，Docker合成文件必须:</p>

<ol>
<li>在Docker容器中启动SQL Server。</li>
<li>如果Octopus部署数据库不存在，则创建它。</li>
<li>启动Octopus部署Docker容器。</li>
<li>配置Octopus Deploy，并创建触须可以注册的API密钥。</li>
<li>启动Octopus部署触手Docker容器。</li>
</ol>

<p>Octopus Deploy服务器和Octopus Deploy触手容器都需要延迟它们的启动，直到它们的依赖容器<em>就绪</em>。在每种情况下，<em> ready </em>意味着不同的东西，但是Docker Compose怎么知道呢？简单的事实是，它不能。如果你看看Docker网站上提供的例子，你会发现处理重试和等待是代码的责任。</p>

<p>我用的是预建的Docker图像，所以我没有那个闲心。对于Octopus Deploy和Octopus Deploy触手容器，我可以利用Docker Compose文件中的<a href="https://docs.docker.com/compose/compose-file/#command" rel="nofollow">命令</a>选项，但是这会覆盖默认命令并阻止服务在容器中安装和启动。</p>

<p>最后，我选择遍历Docker Compose文件。为了保持重启次数最少，我决定同时进行TeamCity和Octopus部署。</p>

<ol>
<li>将SQL Server添加到Docker Compose，并使用<code>docker-compose up</code>启动它。</li>
<li>创建数据库，并更新Docker合成文件，以确保它们在重新启动时附加到SQL Server。</li>
<li>跑<code>docker-compose down</code>把所有东西都拆了。</li>
<li>将TeamCity和Octopus Deploy添加到Docker Compose并启动它。</li>
<li>配置团队城市和八达通部署。</li>
<li>使用与之前相同的命令拆除所有东西。</li>
<li>将TeamCity构建代理和Octopus Deploy触手添加到Docker Compose文件并启动它。</li>
</ol>

<p>Docker Compose是应用程序配置的理想状态。如果我想让我的CI/CD管道具有可移植性，我会包含一个引导脚本来下载映像并配置一切。Docker合成文件将是最终状态。如果我想让我正在开发的应用程序在Docker中运行，我会添加必要的代码，让它知道等待。</p>

<h2 id="lesson-2-windows-based-containers-tend-to-consume-more-resources-and-run-differently-than-linux-based-containers">经验2:基于Windows的容器比基于Linux的容器消耗更多的资源，运行方式也不同</h2>

<p>基于Linux的容器运行在Hyper-V虚拟机<code>Docker Desktop VM</code>上。该虚拟机被分配了vCPUs并分配了内存。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-linux-hyper-v-vm.png" class="zoom" data-title=""><img src="../Images/574b6da6c7b3893c0397e972841aa789.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-linux-hyper-v-vm.png"/>T2】</a></p>

<p>每个基于Windows的容器都在自己的进程中运行，在任务管理器中显示为<code>Vnmem</code>。他们可以根据需要消耗任意多的资源，特别是CPU。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-windows-based-containers-running.png" class="zoom" data-title=""><img src="../Images/5b18fd1e194a4601cb9e3ae963ece055.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-windows-based-containers-running.png"/>T2】</a></p>

<p>我在CI/CD管道中的第一次尝试就启动了11个Docker容器。不用说，它消耗了大量资源。在启动后的大约10分钟内，当这些容器运行它们的引导脚本时，笔记本电脑的CPU跳到100%。当我了解到每个容器都是一个独立的进程时，我将容器的数量缩减为5个。</p>

<p>此外，基于Windows的映像会消耗更多的磁盘空间。以下是我笔记本电脑上基于Linux的Docker图片。记下SQL Server映像，<code>mcr.microsoft.com/mssql/server</code>。它包括映像的所有依赖项。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-linux-images.png" class="zoom" data-title=""><img src="../Images/c85ba35f71cc74d3605b91eadca3ca41.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/docker-linux-images.png"/>T2】</a></p>

<p>与基于Windows的图像相比。当包含所有依赖项时，SQL Server映像的大小是它的10倍。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/windows-docker-images.png" class="zoom" data-title=""><img src="../Images/35911daa75e1e8d9e0ca0daf01bcca90.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2019-10/lessons-learned-using-docker-for-development-and-testing/windows-docker-images.png"/>T2】</a></p>

<h2 id="lesson-3-containers-are-closer-to-headless-vms-than-read-only-images">第3课:容器比只读映像更接近无头虚拟机</h2>

<p>当我读到短语<code>Docker Image</code>时，我想象了一个ISO文件，它是不可更改的。Docker容器就不是这样了。图像是容器的基础。事实上，许多Docker映像都包含一个配置脚本来启动任何必要的配置。Octopus部署图像做到了这一点。当您第一次使用Octopus Deploy映像启动一个容器时，它会运行几个<code>Octopus.Server.exe</code>命令，比如<code>configure</code>、<code>admin</code>、<code>license</code>和<code>metrics</code>。这里可以看到章鱼运行<a href="https://github.com/OctopusDeploy/Octopus-Docker/blob/master/Server/Scripts/configure.ps1" rel="nofollow">的脚本。</a></p>

<p>当Docker容器运行时，可以对其进行更改。可以在上面安装新的软件，但是重要的是要注意，当容器被销毁时，这些更改会丢失。容器通常会因为配置的更新或更改而被销毁和重新创建。</p>

<h2 id="lesson-4.net-framework-connection-strings-require-sql-server-to-be-referenced-by-ip-address-when-using-docker-compose">第四课:。NET Framework连接字符串要求在使用Docker Compose时通过IP地址引用SQL Server</h2>

<p>让SQL Server在容器中运行很容易。下一个问题是，我如何让Octopus Deploy看到SQL Server。Docker Compose提供了命名Docker容器的能力，它做了大量的幕后工作，因此其他容器可以通过名称相互引用。我以为那会有用。网络连接字符串。例如:</p>

<pre><code>Server=SQLServer,1433;Initial Catalog=OctopusDeploy;Persist Security Info=False;User ID=sa;Password=Password_01;MultipleActiveResultSets=False;Connection Timeout=30;
</code></pre>

<p>它没有工作。网络连接字符串。Octopus Deploy是一个. NET Framework应用程序，它在同一个Docker网络上无法通过容器名称找到SQL Server。只有当连接字符串使用服务器的IP地址时，它才起作用。但是，每次运行<code>docker-compose up</code>时，IP地址都会改变。我通过在Docker Compose文件中创建新网络解决了这个问题:</p>

<pre><code class="language-YAML">networks:
  cicd_net:
    ipam:
      driver: default
      config:
        - subnet: 172.28.0.0/16
</code></pre>

<p>使用这个网络，我硬编码了每个容器的IP地址:</p>

<pre><code class="language-YAML">  SQLServer:
   image: microsoft/mssql-server-windows-developer
   environment:
     - ACCEPT_EULA=Y
     - SA_PASSWORD=Password_01
     - attach_dbs=[{'dbName':'OctopusDeploy','dbFiles':['C:\\SQLData\\OctopusDeploy.mdf','C:\\SQLData\\OctopusDeploy_log.ldf']}]
   ports:
     - '1433:1433'   
   volumes:
     - c:\Docker\Volumes\SQLServer\Databases:c:\SQLData
     - c:\Docker\Volumes\SQLServer\Backups:c:\Backups
   networks:
    cicd_net:
      ipv4_address: 172.28.1.1   
</code></pre>

<p>产生的连接字符串是:</p>

<pre><code>Server=172.28.1.1,1433;Initial Catalog=OctopusDeploy;Persist Security Info=False;User ID=sa;Password=Password_01;MultipleActiveResultSets=False;Connection Timeout=30;
</code></pre>

<p>Octopus Deploy的Docker合成文件如下所示:</p>

<pre><code class="language-YAML">version: '3.7'
services:
  SQLServer:
   image: microsoft/mssql-server-windows-developer
   environment:
     - ACCEPT_EULA=Y
     - SA_PASSWORD=Password_01
     - attach_dbs=[{'dbName':'OctopusDeploy','dbFiles':['C:\\SQLData\\OctopusDeploy.mdf','C:\\SQLData\\OctopusDeploy_log.ldf']}]
   ports:
     - '1433:1433'   
   volumes:
     - c:\Docker\Volumes\SQLServer\Databases:c:\SQLData
     - c:\Docker\Volumes\SQLServer\Backups:c:\Backups
   networks:
    cicd_net:
      ipv4_address: 172.28.1.1   
  OctopusDeploy:
   image: octopusdeploy/octopusdeploy    
   ports:
     - '81:81'
     - '10943:10943'
   depends_on:
     - SQLServer       
   environment:
     - sqlDbConnectionString=Server=172.28.1.1,1433;Initial Catalog=OctopusDeploy;Persist Security Info=False;User ID=sa;Password=Password_01;MultipleActiveResultSets=False;Connection Timeout=30;
     - masterKey=YtnHskuInxiyH5MUIFEdVA==
   volumes:
     - c:\Docker\Volumes\Octopus\Server:c:\Octopus
     - c:\Docker\Volumes\Octopus\Server\Artifacts:c:\Artifacts
     - c:\Docker\Volumes\Octopus\Server\Repository:c:\Repository
     - c:\Docker\Volumes\Octopus\Server\TaskLogs:c:\TaskLogs
   links:
     - SQLServer
   networks:
    cicd_net:
      ipv4_address: 172.28.1.2  
  OctopusDeploy_Worker01:
   image: octopusdeploy/tentacle    
   ports:     
     - '85:80'
   depends_on:
     - OctopusDeploy       
   environment:
     - serverApiKey=API-JSZTATMYECVBOY9CPWARAANHM0
     - serverUrl="http://172.28.1.2:81"
     - targetWorkerPool=DatabaseWorker     
     - serverPort=10943
     - targetName=DockerTentacle-DatabaseWorker01
   volumes:
     - C:\Docker\Volumes\Octopus\Worker01:c:\Applications
     - c:\Docker\Volumes\SQLServer\Backups:c:\Backups     
   links:
     - OctopusDeploy
   networks:
    cicd_net:
      ipv4_address: 172.28.1.3
networks:
  cicd_net:
    ipam:
      driver: default
      config:
        - subnet: 172.28.0.0/16           
</code></pre>

<h2 id="lesson-5-pointing-docker-container-volumes-at-different-folders-makes-local-development-and-testing-easier">第5课:将Docker容器卷指向不同的文件夹使得本地开发和测试更加容易</h2>

<p>了解Docker的工作原理打开了一个可能性的世界。对于这个例子，我在笔记本电脑上使用SQL Server开发一个. NET应用程序。过去，我在笔记本电脑上运行SQL Server作为Windows服务。</p>

<p>想象一下，我正在开发一个有大量数据库变更的特性，QA设法在测试环境中造成了一个错误，它阻塞了测试环境，他们需要立即修复这个错误以发布一个版本。在Docker之前，当这种情况发生时，我会做以下事情:</p>

<ul>
<li>将所有挂起的更改提交到分支。</li>
<li>检查测试中的提交。</li>
<li>将代码指向测试数据库并开始调试。</li>
</ul>

<p>QA是天生好奇的人，当我还在调试的时候，他们会在UI周围转一转，这样会运行正确的代码来修复错误。事后看来，我不应该将笔记本电脑上运行的代码指向测试数据库。我这样做是因为通常坏数据发生在数据模型的一部分。要将这一个坏数据放到我的笔记本电脑上，我必须克隆整个数据模型。</p>

<p>我可以使用像Redgate的SQL数据比较工具来解决这个问题。或者我可以为我的应用程序编写一个定制的克隆工具。但是为了让它们正常工作，我会在我的本地数据库上恢复任何挂起的数据库更改。这非常烦人，因为我可能会删除我正在开发的特性的一堆测试数据。我可以将测试数据库备份并恢复到我的本地机器上，但是我不想覆盖我现有的数据库，这意味着要进入并更改连接字符串。</p>

<p>如果我将SQL Server作为Docker容器运行，我可以编写一个脚本来:</p>

<ol>
<li>停止当前的SQL Server Docker容器。</li>
<li>将数据库从测试服务器备份到共享位置。</li>
<li>启动新的SQL Server Docker容器。</li>
<li>将备份还原到该容器中。</li>
<li>数据库名(MyAppDatabase)和服务器名(localhost)将和以前一样，所以不需要更改连接字符串。</li>
</ol>

<p>这只是一个例子。想象一下这对QA也有什么帮助。不是每个QA人员都必须连接一个中央数据库，而是给他们几个脚本来让应用程序在本地运行。他们可能有一个原始的数据库，可以克隆并用于测试运行。</p>

<h2 id="conclusion">结论</h2>

<p>Docker并不是一个又大又吓人的工具。它有一点学习曲线，特别是如果你想在生产中使用它。但是在本地使用它却出奇的顺利。当我开始构建我的CI/CD管道时，我理解了Docker的核心概念。我运行了一个容器，但是从来没有多个容器互相通信。总而言之，我用了不到一周的时间就在Docker容器中建立并运行了CI/CD管道。正如你在上面看到的，一路上我确实碰到了一些砖墙。我的希望是，当你遇到同样的困境时，这篇文章能减轻打击。</p>

                    
                    
</body>
</html>