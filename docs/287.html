<html>
<head>
<title>Running end-to-end tests in GitHub Actions - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在GitHub Actions - Octopus Deploy中运行端到端测试</h1>
<blockquote>原文：<a href="https://octopus.com/blog/githubactions-running-endtoend-tests#2023-02-27">https://octopus.com/blog/githubactions-running-endtoend-tests#2023-02-27</a></blockquote>
                        <p>GitHub Actions拥有一个大型的高质量第三方操作生态系统，以及对在Docker容器中执行构建步骤的内置支持。这意味着很容易将端到端测试作为工作流的一部分来运行，通常只需要一个步骤来运行具有所有必需依赖项的测试工具。</p>

<p>在这篇文章中，我将向您展示如何作为GitHub Actions工作流的一部分，用Cypress运行浏览器测试，用Postman运行API测试。</p>

<h2 id="getting-started">入门指南</h2>

<p>GitHub Actions是一个托管服务，所以你只需要一个GitHub帐户就可以开始了。所有其他依赖项，如软件开发工具包(SDK)或测试工具，都由测试平台发布的Docker镜像或GitHub动作提供。</p>

<h2 id="running-browser-tests-with-cypress">用Cypress运行浏览器测试</h2>

<p>Cypress是一个浏览器自动化工具，可以让你像终端用户一样与网页互动，比如点击按钮和链接，填写表格，滚动页面。您还可以验证页面的内容，以确保显示正确的结果。</p>

<p><a href="https://docs.cypress.io/guides/getting-started/writing-your-first-test" rel="nofollow"> Cypress文档提供了一个第一次测试的例子</a>，它已经被保存到<a href="https://github.com/OctopusSamples/junit-cypress-test" rel="nofollow">JUnit-Cypress-test GitHub repo</a>中。测试如下所示:</p>

<pre><code class="language-javascript">describe('My First Test', () =&gt; {
  it('Does not do much!', () =&gt; {
    expect(true).to.equal(true)
  })
})
</code></pre>

<p>该测试被配置为在<code>cypress.json</code>文件中生成一个JUnit报告文件:</p>

<pre><code class="language-json">{
  "reporter": "junit",
   "reporterOptions": {
      "mochaFile": "cypress/results/results.xml",
      "toConsole": true
   }
}
</code></pre>

<p>下面的工作流文件使用<a href="https://docs.cypress.io/guides/continuous-integration/github-actions#Cypress-GitHub-Action" rel="nofollow"> Cypress GitHub动作</a>执行这个测试，将生成的视频文件保存为工件，并处理测试结果。您可以在<a href="https://github.com/OctopusSamples/junit-cypress-test/actions" rel="nofollow">JUnit-cypress-test repository</a>中找到这个工作流的例子:</p>

<pre><code class="language-yaml">name: Cypress

on:
  push:
  workflow_dispatch:

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v1

      - name: Cypress run
        uses: cypress-io/github-action@v2

      - name: Save video
        uses: actions/upload-artifact@v2
        with:
          name: sample_spec.js.mp4
          path: cypress/videos/sample_spec.js.mp4

      - name: Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Cypress Tests
          path: cypress/results/results.xml
          reporter: java-junit
          fail-on-error: true
</code></pre>

<p>调用官方的Cypress GitHub动作来执行默认选项的测试:</p>

<pre><code class="language-yaml">      - name: Cypress run
        uses: cypress-io/github-action@v2
</code></pre>

<p>Cypress生成一个视频文件，在测试运行时捕获浏览器。您将视频文件存储为工件，以便在工作流程完成后下载和查看:</p>

<pre><code class="language-yaml">      - name: Save video
        uses: actions/upload-artifact@v2
        with:
          name: sample_spec.js.mp4
          path: cypress/videos/sample_spec.js.mp4
</code></pre>

<p>测试结果由<code>dorny/test-reporter</code>动作处理。</p>

<p>请注意，test-reporter能够处理Mocha JSON文件，而Cypress使用Mocha进行报告，因此一个更惯用的解决方案是让Cypress生成Mocha JSON报告。不幸的是，Cypress 中有一个<a href="https://github.com/cypress-io/cypress/issues/18014" rel="nofollow">错误，使得JSON reporter无法将结果保存为文件。在此问题解决之前，生成JUnit报告文件是一种有用的变通方法:</a></p>

<pre><code class="language-yaml">
      - name: Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Cypress Tests
          path: cypress/results/results.xml
          reporter: java-junit
          fail-on-error: true
</code></pre>

<p>以下是测试结果:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/cypress-results.png" class="zoom" data-title=""><img src="../Images/fa0b6a12a273c5cf666c33ab522f53d2.png" class="img-fluid center" alt="Cypress results" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/cypress-results.png"/>T2】</a></p>

<p>视频文件工件列在<strong>摘要</strong>页面中:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/github-actions-artifacts.png" class="zoom" data-title=""><img src="../Images/1ddeb5e4154109a89ab770493ce3ad30.png" class="img-fluid center" alt="Artifacts" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/github-actions-artifacts.png"/>T2】</a></p>

<p>并非所有测试平台都提供GitHub动作，在这种情况下，您可以针对标准Docker映像执行步骤。这将在下一节中演示。</p>

<h2 id="running-api-tests-with-newman">用Newman运行API测试</h2>

<p>与Cypress不同，<a href="https://www.postman.com/" rel="nofollow"> Postman </a>不提供官方的GitHub动作。但是，您可以在工作流程中直接使用<a href="https://hub.docker.com/r/postman/newman/" rel="nofollow"> postman/newman </a> Docker图像。您可以在<a href="https://github.com/OctopusSamples/junit-newman-test/actions" rel="nofollow">JUnit-Newman-test repository</a>中找到工作流的示例:</p>

<pre><code class="language-yaml">name: Cypress

on:
  push:
  workflow_dispatch:

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v1

      - name: Run Newman        
        uses: docker://postman/newman:latest
        with:
          args: run GitHubTree.json --reporters cli,junit --reporter-junit-export results.xml

      - name: Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Cypress Tests
          path: results.xml
          reporter: java-junit
          fail-on-error: true
</code></pre>

<p>步骤的<code>uses</code>属性可以是已发布动作的名称，也可以直接引用Docker图像。在这个例子中，您运行<a href="https://hub.docker.com/r/postman/newman/" rel="nofollow"> postman/newman </a> docker图像，用<code>with.args</code>参数定义命令行参数:</p>

<pre><code class="language-yaml">      - name: Run Newman       
        uses: docker://postman/newman:latest
        with:
          args: run GitHubTree.json --reporters cli,junit --reporter-junit-export results.xml
</code></pre>

<p>产生的JUnit报告文件然后由<code>dorny/test-reporter</code>动作处理:</p>

<pre><code class="language-yaml">      - name: Report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Cypress Tests
          path: results.xml
          reporter: java-junit
          fail-on-error: true
</code></pre>

<p>以下是测试结果:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/newman-test-results.png" class="zoom" data-title=""><img src="../Images/397f567007f3f4cc52e04002862632e3.png" class="img-fluid center" alt="Newman test results" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/newman-test-results.png"/>T2】</a></p>

<p>在后台，GitHub Actions使用大量与工作流相关的标准环境变量和卷挂载来执行所提供的Docker映像，这些卷挂载允许Docker容器在主文件系统上持久化更改(如报告文件)。</p>

<p>以下是在Docker映像中执行步骤的命令示例:</p>

<pre><code>/usr/bin/docker run --name postmannewmanlatest_fefcec --label f88420 --workdir /github/workspace --rm -e INPUT_ARGS -e HOME -e GITHUB_JOB -e GITHUB_REF -e GITHUB_SHA -e GITHUB_REPOSITORY -e GITHUB_REPOSITORY_OWNER -e GITHUB_RUN_ID -e GITHUB_RUN_NUMBER -e GITHUB_RETENTION_DAYS -e GITHUB_RUN_ATTEMPT -e GITHUB_ACTOR -e GITHUB_WORKFLOW -e GITHUB_HEAD_REF -e GITHUB_BASE_REF -e GITHUB_EVENT_NAME -e GITHUB_SERVER_URL -e GITHUB_API_URL -e GITHUB_GRAPHQL_URL -e GITHUB_WORKSPACE -e GITHUB_ACTION -e GITHUB_EVENT_PATH -e GITHUB_ACTION_REPOSITORY -e GITHUB_ACTION_REF -e GITHUB_PATH -e GITHUB_ENV -e RUNNER_OS -e RUNNER_NAME -e RUNNER_TOOL_CACHE -e RUNNER_TEMP -e RUNNER_WORKSPACE -e ACTIONS_RUNTIME_URL -e ACTIONS_RUNTIME_TOKEN -e ACTIONS_CACHE_URL -e GITHUB_ACTIONS=true -e CI=true -v "/var/run/docker.sock":"/var/run/docker.sock" -v "/home/runner/work/_temp/_github_home":"/github/home" -v "/home/runner/work/_temp/_github_workflow":"/github/workflow" -v "/home/runner/work/_temp/_runner_file_commands":"/github/file_commands" -v "/home/runner/work/junit-newman-test/junit-newman-test":"/github/workspace" postman/newman:latest run GitHubTree.json --reporters cli,junit --reporter-junit-export results.xml
</code></pre>

<p>这是一个复杂的命令，但是有一些我们感兴趣的参数。</p>

<p><code>-e</code>参数定义了容器的环境变量。您可以看到暴露了许多工作流环境变量。</p>

<p><code>--workdir /github/workspace</code>参数覆盖Docker容器的工作目录，而<code>-v "/home/runner/work/junit-newman-test/junit-newman-test":"/github/workspace"</code>参数将工作流工作区挂载到容器内的<code>/github/workspace</code>目录。这样做的效果是在Docker容器中挂载工作目录，从而公开签出的文件，并允许任何新创建的文件在容器关闭后保持不变:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/github-action-docker-command.png" class="zoom" data-title=""><img src="../Images/1c7cee448f39e889d441eaa00cc6bafd.png" class="img-fluid center" alt="Docker image command" data-original-src="https://i.octopus.com/blog/2023-02/githubactions-running-endtoend-tests/github-action-docker-command.png"/>T2】</a></p>

<p>因为每个主要的测试工具都提供了一个受支持的Docker映像，所以您用来运行Newman的过程可以用来运行大多数其他测试平台。</p>

<h2 id="conclusion">结论</h2>

<p>GitHub Actions在开发人员中被广泛采用，许多平台都支持在工作流中使用的操作。对于那些没有合适的动作可用的情况，GitHub Actions提供了一种简单的方法来执行标准Docker图像作为工作流的一部分。</p>

<p>在这篇文章中，您学习了如何运行Cypress动作来执行基于浏览器的测试，以及如何运行Newman Docker映像来执行API测试。</p>

<p>查看我们关于在GitHub Actions中测试的另一个帖子:</p>



<p><a href="https://oc.to/GithubActionsWorkflowGenerator" rel="nofollow">试用我们免费的GitHub Actions工作流工具</a>，帮助您快速为GitHub Actions部署生成可定制的工作流。</p>

<p>您还可以了解更多关于使用GitHub构建<a href="https://octopus.com/github">和使用Octopus </a>部署的信息，并在GitHub Marketplace 中使用我们的<a href="https://github.com/marketplace?query=octopus&amp;type=actions&amp;verification=verified_creator" rel="nofollow">验证操作。</a></p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>