<html>
<head>
<title>Implementing DevSecOps to respond to vulnerabilities - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>实施DevSecOps以应对漏洞- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/devsecops-respond-to-vulnerabilities#2022-07-04">https://octopus.com/blog/devsecops-respond-to-vulnerabilities#2022-07-04</a></blockquote>
                        <p>Log4j项目在2021年末因一个<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-45046" rel="nofollow">关键漏洞</a>成为关注的焦点。它引发了来自全球公司和框架开发者的大量<a href="https://octopus.com/blog/octopus-deploy-log4j-response">“我们对Log4j的回应”</a>公告，甚至更多的客户请求支持服务台和论坛来评估他们的暴露程度。</p>

<p>许多工程团队发现自己处于压力之下，需要识别任何受影响的代码库，提供描述任何暴露的准确报告，更新任何所需的依赖项，并尽快将新代码部署到生产环境中。</p>

<p>任何面临这一挑战的人都知道，这样的回应并不像听起来那么容易。像任何代码依赖一样，知道您的代码是否使用Log4j需要对您的应用程序的结构和当前部署的版本有深刻的理解。通常，这需要在表示应用程序部署版本的特定git提交处检查您的代码库，并深入研究您的直接依赖项及其子依赖项，以准确找到您的代码使用的库。</p>

<p>Runbooks与<a href="https://octopus.com/docs/packaging-applications/build-servers/build-information">构建信息</a>和对CI/CD管道的一些简单更改相结合，为查询部署的应用程序中包含的依赖项提供了一种方便的方法。</p>

<p>在这篇文章中，您将学习如何修改GitHub Actions工作流来捕获特定构建所使用的依赖项，并查看可以按需查询信息的示例操作手册。</p>

<h2 id="prerequisites">先决条件</h2>

<p>这篇文章使用GitHub Actions作为CI服务器。GitHub Actions对公共git库是免费的，所以你只需要一个GitHub账户就可以开始了。</p>

<p>示例runbook脚本是针对Python 3编写的，可以从<a href="https://www.python.org/downloads/" rel="nofollow"> Python网站</a>下载。你可以在<a href="https://github.com/OctopusSamples/DependencyQuery" rel="nofollow"> GitHub </a>上找到示例runbook源代码。</p>

<h2 id="capturing-dependencies-during-the-build-process">在构建过程中捕获依赖关系</h2>

<p>首先，作为GitHub Actions工作流的一部分，捕获构建过程所消耗的依赖项。如今，每种主要语言都提供了列出依赖项的能力，下面的列表显示了这些命令的示例，将输出捕获到一个名为<code>dependencies.txt</code>的文件中:</p>

<ul>
<li>腹部—<code>mvn --batch-mode dependency:tree --no-transfer-progress &gt; dependencies.txt</code></li>
<li>度—<code>gradle dependencies --console=plain &gt; dependencies.txt</code></li>
<li>Npm - <code>npm list --all &gt; dependencies.txt</code></li>
<li>PHP - <code>composer show --all &gt; dependencies.txt</code></li>
<li>Python - <code>pip install pipdeptree; pipdeptree &gt; dependencies.txt</code></li>
<li>去- <code>go list &gt; dependencies.txt</code></li>
<li>红宝石- <code>gem dep &gt; dependencies.txt</code></li>
<li>点网核心- <code>dotnet list package &gt; dependencies.txt</code></li>
</ul>

<p>必须向GitHub Actions工作流添加两个步骤，以将依赖项捕获为工件。下面的例子演示了如何捕获Maven依赖项，但是对于您的特定用例,<code>List Dependencies</code>步骤的<code>run</code>属性可以替换为上面的任何命令:</p>

<pre><code class="language-yaml">    - name: List Dependencies
      run: mvn --batch-mode dependency:tree --no-transfer-progress &gt; dependencies.txt
      shell: bash
    - name: Collect Dependencies
      uses: actions/upload-artifact@v2
      with:
        name: Dependencies
        path: dependencies.txt
</code></pre>

<p>下面的屏幕截图显示了与构建相关的工件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/dependencies-artifact.png" class="zoom" data-title=""><img src="../Images/22c6a7cc60a1de6884bc01fbbf65e4bb.png" class="img-fluid center" alt="Dependencies Artifact" data-original-src="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/dependencies-artifact.png"/>T2】</a></p>

<h2 id="producing-build-information">生成构建信息</h2>

<p><a href="https://octopus.com/docs/packaging-applications/build-servers/build-information">构建信息</a>为Octopus部署或runbook中引用的包提供额外的元数据。构建信息包是存储在Octopus服务器上的单独的工件，具有与它们所代表的包相同的包ID和版本。这使得Octopus可以跟踪各种包的元数据，无论是存储在内置提要中还是托管在外部存储库中。</p>

<p>构建信息包捕获的一个属性是返回到生成该包的CI构建的链接。下面的截图显示了GitHub操作运行的链接:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/build-information.png" class="zoom" data-title=""><img src="../Images/849d2525234adf4cba6e6f6408884b87.png" class="img-fluid center" alt="Build link" data-original-src="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/build-information.png"/>T2】</a></p>

<p><a href="https://github.com/xo-energy/action-octopus-build-information" rel="nofollow">XO-energy/action-octopus-build-information</a>动作提供了创建和上传构建信息包的能力。以下步骤显示了一个操作示例:</p>

<pre><code class="language-yaml">    - name: Generate Octopus Deploy build information
      uses: xo-energy/action-octopus-build-information@v1.1.2
      with:
        octopus_api_key: ${{ inputs.octopus_api_token }}
        octopus_project: Products Service
        octopus_server: ${{ inputs.octopus_server_url }}
        push_version: 0.1.${{ inputs.run_number }}${{ env.BRANCH_NAME != 'master' &amp;&amp; format('-{0}', env.BRANCH_NAME) || ''  }}
        push_package_ids: com.octopus.octopub:products-service
        push_overwrite_mode: OverwriteExisting
        output_path: octopus
        octopus_space: "Octopub"
        octopus_environment: "Development"
</code></pre>

<p>Octopus只需要推送构建信息包就可以将元数据链接到发行版。只要构建信息包ID和版本与Octopus步骤中使用的包相匹配，构建信息就会链接到发布。</p>

<p>下一步是编写一个定制脚本来查询Octopus API，以提取给定环境中CI服务器最新版本的链接。</p>

<h2 id="querying-the-build-information-to-download-ci-artifacts">查询构建信息以下载CI工件</h2>

<p>现在您已经有了跟踪Octopus版本中使用的任何包的依赖关系的所有信息。可以手动遍历Octopus UI中显示的链接，返回到GitHub操作运行，下载依赖项工件，并扫描其中的文本文件。但是这种手动工作流不能随着应用程序数量的增加而扩展。相反，您希望通过执行自定义Python脚本的runbook来自动化该过程。</p>

<p>第一步是在文件<code>requirements.txt</code>中定义脚本的依赖关系。该脚本利用<a href="https://pypi.org/project/requests/" rel="nofollow">请求</a>包来简化HTTP请求:</p>

<pre><code class="language-txt">requests==2.27.1
</code></pre>

<p>然后创建一个名为<code>main.py</code>的文件来保存脚本。完整的代码如下所示:</p>

<pre><code class="language-python">import os
import sys
from datetime import datetime
from functools import cmp_to_key
from requests.auth import HTTPBasicAuth
import tempfile
from requests import get
import zipfile
import argparse

parser = argparse.ArgumentParser(description='Scan a deployment for a dependency.')
parser.add_argument('--octopusUrl', 
                    dest='octopus_url', 
                    action='store', 
                    help='The Octopus server URL',
                    required=True)
parser.add_argument('--octopusApiKey', 
                    dest='octopus_api_key', 
                    action='store', 
                    help='The Octopus API key',
                    required=True)
parser.add_argument('--githubUser', 
                    dest='github_user', 
                    action='store', 
                    help='The GitHub username',
                    required=True)
parser.add_argument('--githubToken', 
                    dest='github_token', 
                    action='store', 
                    help='The GitHub token/password',
                    required=True)
parser.add_argument('--octopusSpace', 
                    dest='octopus_space', 
                    action='store', 
                    help='The Octopus space',
                    required=True)
parser.add_argument('--octopusProject', 
                    dest='octopus_project', 
                    action='store',
                    help='A comma separated list of Octopus projects', 
                    required=True)
parser.add_argument('--octopusEnvironment', 
                    dest='octopus_environment', 
                    action='store', 
                    help='The Octopus environment',
                    required=True)
parser.add_argument('--searchText', 
                    dest='search_text', 
                    action='store',
                    help='The text to search for in the list of dependencies',
                    required=True)
parser.add_argument('--githubDependencyArtifactName', 
                    default="Dependencies", 
                    dest='github_dependency_artifact',
                    action='store',
                    help='The name of the GitHub Action run artifact that contains the dependencies')

args = parser.parse_args()

headers = {"X-Octopus-ApiKey": args.octopus_api_key}
github_auth = HTTPBasicAuth(args.github_user, args.github_token)


def compare_dates(date1, date2):
    # Python 3.6 doesn't handle the colon in the timezone of a string like "2022-01-04T04:23:02.941+00:00".
    # So we need to manually strip it out.
    date1_parsed = datetime.strptime(date1["Created"][:-3] + date1["Created"][-2:], '%Y-%m-%dT%H:%M:%S.%f%z')
    date2_parsed = datetime.strptime(date2["Created"][:-3] + date2["Created"][-2:], '%Y-%m-%dT%H:%M:%S.%f%z')
    if date1_parsed &lt; date2_parsed:
        return -1
    if date1_parsed == date2_parsed:
        return 0
    return 1


def get_space_id(space_name):
    url = args.octopus_url + "/api/spaces?partialName=" + space_name.strip() + "&amp;take=1000"
    response = get(url, headers=headers)
    spaces_json = response.json()

    filtered_items = [a for a in spaces_json["Items"] if a["Name"] == space_name.strip()]

    if len(filtered_items) == 0:
        sys.stderr.write("The space called " + space_name + " could not be found.\n")
        return None

    first_id = filtered_items[0]["Id"]
    return first_id


def get_resource_id(space_id, resource_type, resource_name):
    if space_id is None:
        return None

    url = args.octopus_url + "/api/" + space_id + "/" + resource_type + "?partialName=" \
        + resource_name.strip() + "&amp;take=1000"
    response = get(url, headers=headers)
    json = response.json()

    filtered_items = [a for a in json["Items"] if a["Name"] == resource_name.strip()]
    if len(filtered_items) == 0:
        sys.stderr.write("The resource called " + resource_name + " could not be found in space " + space_id + ".\n")
        return None

    first_id = filtered_items[0]["Id"]
    return first_id


def get_release_id(space_id, environment_id, project_id):
    if space_id is None or environment_id is None or project_id is None:
        return None

    url = args.octopus_url + "/api/" + space_id + "/deployments?environments=" + environment_id + "&amp;take=1000"
    response = get(url, headers=headers)
    json = response.json()

    filtered_items = [a for a in json["Items"] if a["ProjectId"] == project_id]
    if len(filtered_items) == 0:
        sys.stderr.write("The project id " + project_id + " did not have a deployment in " + space_id + ".\n")
        return None

    sorted_list = sorted(filtered_items, key=cmp_to_key(compare_dates), reverse=True)
    release_id = sorted_list[0]["ReleaseId"]

    return release_id


def get_build_urls(space_id, release_id, project):
    if space_id is None or release_id is None:
        return None

    url = args.octopus_url + "/api/" + space_id + "/releases/" + release_id
    response = get(url, headers=headers)
    json = response.json()

    build_information_with_urls = [a for a in json["BuildInformation"] if "github.com" in a["BuildUrl"]]
    build_urls = list(map(lambda b: b["BuildUrl"], build_information_with_urls))

    if len(build_urls) == 0:
        sys.stderr.write("No build information results contained build URLs to GitHub for project "
                         + project.strip() + ".\n")
        sys.stderr.write("This script assumes GitHub Actions were used to build the packages deployed by Octopus.\n")

    return build_urls


def download_file(url):
    with tempfile.NamedTemporaryFile(delete=False, suffix=".zip") as tmp_file:
        # get request
        response = get(url, auth=github_auth)
        # write to file
        tmp_file.write(response.content)
        return tmp_file.name


def get_artifacts(build_urls, dependency_artifact_name):
    if build_urls is None:
        return None

    files = []

    for url in build_urls:
        # turn https://github.com/OctopusSamples/OctoPub/actions/runs/1660462851 into
        # https://api.github.com/repos/OctopusSamples/OctoPub/actions/runs/1660462851/artifacts
        artifacts_api_url = url.replace("github.com", "api.github.com/repos") + "/artifacts"
        response = get(artifacts_api_url, auth=github_auth)
        artifact_json = response.json()

        filtered_items = [a for a in artifact_json["artifacts"] if a["name"] == dependency_artifact_name]

        if len(filtered_items) == 0:
            print("No artifacts were found in the GitHub Action run called " + dependency_artifact_name)

        for artifact in filtered_items:
            artifact_url = artifact["archive_download_url"]
            files.append(download_file(artifact_url))

    return files


def unzip_files(zip_files):
    if zip_files is None:
        return None

    text_files = []
    for file in zip_files:
        with zipfile.ZipFile(file, 'r') as zip_ref:
            with tempfile.TemporaryDirectory() as tmp_dir:
                zip_ref.extractall(tmp_dir)
                for extracted_file in os.listdir(tmp_dir):
                    filename = os.fsdecode(extracted_file)
                    if filename.endswith(".txt"):
                        with open(os.path.join(tmp_dir, extracted_file)) as f:
                            content = f.read()
                            text_files.append(content)
    return text_files


def search_files(text_files, text, project):
    found = False
    for file in text_files:
        if text in file:
            found = True
            print(text + " found in the following list of dependencies for project " + project.strip())
            print(file)

    return found


def scan_dependencies():
    space_id = get_space_id(args.octopus_space)
    environment_id = get_resource_id(space_id, "environments", args.octopus_environment)
    found = False
    for project in args.octopus_project.split(","):
        project_id = get_resource_id(space_id, "projects", project)
        release_id = get_release_id(space_id, environment_id, project_id)
        urls = get_build_urls(space_id, release_id, project)
        files = get_artifacts(urls, args.github_dependency_artifact)
        text_files = unzip_files(files)
        if search_files(text_files, args.search_text, project):
            found = True

    print("Searching project(s) " + args.octopus_project + " for dependency " + args.search_text)
    if found:
        print("\n\nSearch text " + args.search_text + " was found in the list of dependencies.")
        print("See the logs above for the complete text file listing the application dependencies.")
    else:
        print("\n\nSearch text " + args.search_text + " was not found in any dependencies.")


scan_dependencies()
</code></pre>

<p>让我们分解这段代码，了解它在做什么。</p>

<p>您的脚本接受来自命令行参数的参数，使其可以跨多个Octopus实例和空间重用。参数由<a href="https://docs.python.org/3/library/argparse.html" rel="nofollow"> argparse模块</a>解析。在Real Python的帖子<a href="https://realpython.com/command-line-interfaces-python-argparse/" rel="nofollow">中了解更多关于使用<code>argparse</code>的信息，如何用argparse在Python中构建命令行接口</a>:</p>

<pre><code class="language-python">parser = argparse.ArgumentParser(description='Scan a deployment for a dependency.')
parser.add_argument('--octopusUrl', 
                    dest='octopus_url', 
                    action='store', 
                    help='The Octopus server URL',
                    required=True)
parser.add_argument('--octopusApiKey', 
                    dest='octopus_api_key', 
                    action='store', 
                    help='The Octopus API key',
                    required=True)
parser.add_argument('--githubUser', 
                    dest='github_user', 
                    action='store', 
                    help='The GitHub username',
                    required=True)
parser.add_argument('--githubToken', 
                    dest='github_token', 
                    action='store', 
                    help='The GitHub token/password',
                    required=True)
parser.add_argument('--octopusSpace', 
                    dest='octopus_space', 
                    action='store', 
                    help='The Octopus space',
                    required=True)
parser.add_argument('--octopusProject', 
                    dest='octopus_project', 
                    action='store',
                    help='A comma separated list of Octopus projects', 
                    required=True)
parser.add_argument('--octopusEnvironment', 
                    dest='octopus_environment', 
                    action='store', 
                    help='The Octopus environment',
                    required=True)
parser.add_argument('--searchText', 
                    dest='search_text', 
                    action='store',
                    help='The text to search for in the list of dependencies',
                    required=True)
parser.add_argument('--githubDependencyArtifactName', 
                    default="Dependencies", 
                    dest='github_dependency_artifact',
                    action='store',
                    help='The name of the GitHub Action run artifact that contains the dependencies')

args = parser.parse_args()
</code></pre>

<p>该脚本向Octopus和GitHub APIs发出许多请求，所有请求都需要认证。</p>

<p>Octopus API使用<code>X-Octopus-ApiKey</code>头来传递用于认证请求的API密钥。你可以在<a href="https://octopus.com/docs/octopus-rest-api/how-to-create-an-api-key"> Octopus文档</a>中找到更多关于如何创建API的信息。</p>

<p>GitHub API使用标准的HTTP基本认证，密码使用个人访问令牌。GitHub文档提供了创建令牌的细节。</p>

<p>下面的代码捕获包含凭证的对象，这些凭证通过脚本的其余部分随每个API请求传递:</p>

<pre><code class="language-python">headers = {"X-Octopus-ApiKey": args.octopus_api_key}
github_auth = HTTPBasicAuth(args.github_user, args.github_token)
</code></pre>

<p>这个脚本的一个重要方面是能够找到部署到给定环境的最新版本。这意味着比较由Octopus API返回的日期。</p>

<p>Octopus API返回ISO 8601格式的日期，看起来像<code>2022-01-04T04:23:02.941+00:00</code>。不幸的是，<a href="https://bugs.python.org/issue15873" rel="nofollow"> Python 3.6不支持包含冒号</a>的时区偏移量，这迫使您在解析和比较日期之前将它们去掉。</p>

<p><code>compare_dates</code>函数将两个日期作为字符串，去掉冒号，解析结果，并返回一个值<code>1</code>、<code>0</code>或<code>-1</code>，表示<code>date1</code>与<code>date2</code>相比如何:</p>

<pre><code class="language-python">def compare_dates(date1, date2):
    # Python 3.6 doesn't handle the colon in the timezone of a string like "2022-01-04T04:23:02.941+00:00".
    # So we need to manually strip it out.
    date1_parsed = datetime.strptime(date1["Created"][:-3] + date1["Created"][-2:], '%Y-%m-%dT%H:%M:%S.%f%z')
    date2_parsed = datetime.strptime(date2["Created"][:-3] + date2["Created"][-2:], '%Y-%m-%dT%H:%M:%S.%f%z')
    if date1_parsed &lt; date2_parsed:
        return -1
    if date1_parsed == date2_parsed:
        return 0
    return 1
</code></pre>

<p>这个脚本(以及大多数使用Octopus API的脚本)中的一个常见模式是查找命名资源的ID。<code>get_space_id</code>函数获取Octopus空间的名称，并查询API以返回空间ID:</p>

<pre><code class="language-python">def get_space_id(space_name):
</code></pre>

<p><code>/api/spaces</code>端点返回Octopus服务器中定义的空间列表。<code>partialName</code>查询参数将结果限制为名称包含所提供值的空格，而<code>take</code>参数被设置为一个较大的数字，以确保您不需要循环任何分页的结果:</p>

<pre><code class="language-python">    url = args.octopus_url + "/api/spaces?partialName=" + space_name.strip() + "&amp;take=1000"
</code></pre>

<p>对端点发出GET HTTP请求，包括Octopus身份验证头，JSON结果被解析到Python嵌套字典中:</p>

<pre><code class="language-python">    response = get(url, headers=headers)
    spaces_json = response.json()
</code></pre>

<p>返回的结果可以匹配名称为或包含所提供的空间名称的任何空间。这意味着如果我们搜索名为<code>MySpace</code>的空间，将返回名为<code>MySpace</code>和<code>MySpaceTwo</code>的空间。</p>

<p>为了确保用正确的名称返回空间的ID，一个<a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions" rel="nofollow">列表理解</a>将返回的空间过滤为与提供的空间名称完全匹配的空间:</p>

<pre><code class="language-python">    filtered_items = [a for a in spaces_json["Items"] if a["Name"] == space_name.strip()]
</code></pre>

<p>如果没有空格与提供的空格名称匹配，该函数将返回<code>None</code>:</p>

<pre><code class="language-python">    if len(filtered_items) == 0:
        sys.stderr.write("The space called " + space_name + " could not be found.\n")
        return None
</code></pre>

<p>如果有匹配的空格，则返回ID:</p>

<pre><code class="language-python">    first_id = filtered_items[0]["Id"]
    return first_id
</code></pre>

<p>空间是Octopus中的顶级资源，而您在该脚本中与之交互的所有其他资源都是空间的子资源。正如您对<code>get_space_id</code>函数所做的一样，<code>get_resource_id</code>函数将一个已命名的Octopus资源转换成它的id。这里唯一的区别是所请求的端点在路径中包含了空间ID，并且提供了资源类型来构建路径中的第二个元素。否则<code>get_resource_id</code>遵循为<code>get_space_id</code>功能描述的相同模式:</p>

<pre><code class="language-python">def get_resource_id(space_id, resource_type, resource_name):
    if space_id is None:
        return None

    url = args.octopus_url + "/api/" + space_id + "/" + resource_type + "?partialName=" \
        + resource_name.strip() + "&amp;take=1000"
    response = get(url, headers=headers)
    json = response.json()

    filtered_items = [a for a in json["Items"] if a["Name"] == resource_name.strip()]
    if len(filtered_items) == 0:
        sys.stderr.write("The resource called " + resource_name + " could not be found in space " + space_id + ".\n")
        return None

    first_id = filtered_items[0]["Id"]
    return first_id
</code></pre>

<p>现在，您需要提供一种方法来确定最后一次部署到所选项目的所选环境中的版本。</p>

<p>发布是部署过程、包版本和变量的快照。这是当您单击Octopus UI中的<strong> CREATE RELEASE </strong>按钮时创建的资源。</p>

<p>然后，部署是对环境发布的执行。</p>

<p>因此，为了找到哪个包版本被部署到指定的环境中(在处理漏洞时，我们通常指的是生产环境)，您必须列出一个环境的部署，将它们过滤到指定项目的部署中，对部署进行排序以确保您找到最新的版本，并返回部署执行的版本的ID。</p>

<p><code>get_release_id</code>函数实现了这个查询:</p>

<pre><code class="language-python">def get_release_id(space_id, environment_id, project_id):
    if space_id is None or environment_id is None or project_id is None:
        return None
</code></pre>

<p>您查询<code>/deployments</code>端点以返回部署列表，并传递<code>environments</code>查询参数以将结果限制为指定环境的那些部署:</p>

<pre><code class="language-python">    url = args.octopus_url + "/api/" + space_id + "/deployments?environments=" + environment_id + "&amp;take=1000"
    response = get(url, headers=headers)
    json = response.json()
</code></pre>

<p>结果列表被过滤为与指定项目相关的项目:</p>

<pre><code class="language-python">    filtered_items = [a for a in json["Items"] if a["ProjectId"] == project_id]
    if len(filtered_items) == 0:
        sys.stderr.write("The project id " + project_id + " did not have a deployment in " + space_id + ".\n")
        return None
</code></pre>

<p>对过滤后的列表进行排序，以确保最新部署是第一项:</p>

<pre><code class="language-python">    sorted_list = sorted(filtered_items, key=cmp_to_key(compare_dates), reverse=True)
</code></pre>

<p>然后返回最新部署的发布ID:</p>

<pre><code class="language-python">    release_id = sorted_list[0]["ReleaseId"]

    return release_id
</code></pre>

<p>正如您在前面看到的，当构建信息可用于发布中引用的包时，详细信息(如返回到创建该包的CI构建的链接)也是可用的。这个链接暴露在Octopus API返回的release资源中，由<code>get_build_urls</code>函数提取:</p>

<pre><code class="language-python">def get_build_urls(space_id, release_id, project):
    if space_id is None or release_id is None:
        return None
</code></pre>

<p>您查询Octopus API以从指定的发布ID返回完整的发布资源:</p>

<pre><code class="language-python">    url = args.octopus_url + "/api/" + space_id + "/releases/" + release_id
    response = get(url, headers=headers)
    json = response.json()
</code></pre>

<p>每个版本可以有多个相关的构建信息资源，每个资源都被过滤以找到任何包含<code>github.com</code>的构建URL，这表明该包是使用GitHub Actions构建的:</p>

<pre><code class="language-python">    build_information_with_urls = [a for a in json["BuildInformation"] if "github.com" in a["BuildUrl"]]
</code></pre>

<p>包含所有构建信息的字典被展平为一个链接数组:</p>

<pre><code class="language-python">    build_urls = list(map(lambda b: b["BuildUrl"], build_information_with_urls))
</code></pre>

<p>如果没有找到返回GitHub的链接，则会显示一条警告消息:</p>

<pre><code class="language-python">    if len(build_urls) == 0:
        sys.stderr.write("No build information results contained build URLs to GitHub for project "
                         + project.strip() + ".\n")
        sys.stderr.write("This script assumes GitHub Actions were used to build the packages deployed by Octopus.\n")
</code></pre>

<p>然后返回URL列表:</p>

<pre><code class="language-python">    return build_urls
</code></pre>

<p>GitHub动作工件是简单的zip文件，可以像普通文件一样从任何其他web服务器上下载。<code>download_file</code>函数创建一个临时文件，并将提供的URL的内容写入其中，返回文件名:</p>

<pre><code class="language-python">def download_file(url):
    with tempfile.NamedTemporaryFile(delete=False, suffix=".zip") as tmp_file:
        # get request
        response = get(url, auth=github_auth)
        # write to file
        tmp_file.write(response.content)
        return tmp_file.name
</code></pre>

<p><code>get_artifacts</code>函数向GitHub API查询与运行相关的工件的链接:</p>

<pre><code class="language-python">def get_artifacts(build_urls, dependency_artifact_name):
    if build_urls is None:
        return None

    files = []
</code></pre>

<p>由构建信息捕获的GitHub链接指向公共的、可浏览的网页，显示GitHub操作运行的结果。为了以编程方式与运行细节进行交互，您需要与GitHub API进行交互。</p>

<p>GitHub有两个相关的URL结构。以<code>https://github.com/</code>开头的URL公开网页浏览器的HTML页面，而以<code>https://api.github.com/repos/</code>开头的URL公开GitHub API。除了前缀之外，这两个URL结构基本相同。</p>

<p>这意味着我们必须将类似于<code>https://github.com/OctopusSamples/OctoPub/actions/runs/1660462851</code>的URL转换成<code>https://api.github.com/repos/OctopusSamples/OctoPub/actions/runs/1660462851</code>才能访问GitHub API:</p>

<pre><code class="language-python">    for url in build_urls:
        # turn https://github.com/OctopusSamples/OctoPub/actions/runs/1660462851 into
        # https://api.github.com/repos/OctopusSamples/OctoPub/actions/runs/1660462851/artifacts
        artifacts_api_url = url.replace("github.com", "api.github.com/repos") + "/artifacts"
        response = get(artifacts_api_url, auth=github_auth)
        artifact_json = response.json()
</code></pre>

<p>对工件列表进行过滤，以返回与预期工件名称相匹配的工件:</p>

<pre><code class="language-python">        filtered_items = [a for a in artifact_json["artifacts"] if a["name"] == dependency_artifact_name]
</code></pre>

<p>如果没有匹配的工件，将显示一个错误:</p>

<pre><code class="language-python">        if len(filtered_items) == 0:
            print("No artifacts were found in the GitHub Action run called " + dependency_artifact_name)
</code></pre>

<p>对于每个匹配的工件，提取下载URL，并返回URL列表:</p>

<pre><code class="language-python">        for artifact in filtered_items:
            artifact_url = artifact["archive_download_url"]
            files.append(download_file(artifact_url))

    return files
</code></pre>

<p>GitHub工件应该是包含文本文件的zip文件。<code>unzip_files</code>函数提取提供的文件，扫描结果文件中的文本文件，读取文本文件，并返回文本:</p>

<pre><code class="language-python">def unzip_files(zip_files):
    if zip_files is None:
        return None

    text_files = []
    for file in zip_files:
        with zipfile.ZipFile(file, 'r') as zip_ref:
            with tempfile.TemporaryDirectory() as tmp_dir:
                zip_ref.extractall(tmp_dir)
                for extracted_file in os.listdir(tmp_dir):
                    filename = os.fsdecode(extracted_file)
                    if filename.endswith(".txt"):
                        with open(os.path.join(tmp_dir, extracted_file)) as f:
                            content = f.read()
                            text_files.append(content)
    return 
</code></pre>

<p><code>search_files</code>函数从提取的文本文件的内容中打印任何包含指定搜索字符串的依赖列表:</p>

<pre><code class="language-python">def search_files(text_files, text, project):
    found = False
    for file in text_files:
        if text in file:
            found = True
            print(text + " found in the following list of dependencies for project " + project.strip())
            print(file)

    return found
</code></pre>

<p>在<code>scan_dependencies</code>函数中，上面的所有代码被组合在一起，以扫描所提供文本的依赖关系列表:</p>

<pre><code class="language-python">def scan_dependencies():
</code></pre>

<p>空间名称被转换成一个ID:</p>

<pre><code class="language-python">    space_id = get_space_id(args.octopus_space)
</code></pre>

<p>环境名被转换成一个ID:</p>

<pre><code>    environment_id = get_resource_id(space_id, "environments", args.octopus_environment)
</code></pre>

<p>这些项目可以以逗号分隔的列表形式提供，您可以对其进行循环:</p>

<pre><code class="language-python">    found = False
    for project in args.octopus_project.split(","):
</code></pre>

<p>项目名称被转换成一个ID:</p>

<pre><code class="language-python">        project_id = get_resource_id(space_id, "projects", project)
</code></pre>

<p>找到与项目到环境的最新部署相关联的版本:</p>

<pre><code class="language-python">        release_id = get_release_id(space_id, environment_id, project_id)
</code></pre>

<p>找到了工件下载URL:</p>

<pre><code class="language-python">        urls = get_build_urls(space_id, release_id, project)
</code></pre>

<p>然后下载每个URL:</p>

<pre><code class="language-python">        files = get_artifacts(urls, args.github_dependency_artifact)
</code></pre>

<p>解压缩zip文件，并读取其中包含的任何文本文件:</p>

<pre><code class="language-python">        text_files = unzip_files(files)
</code></pre>

<p>扫描这些文本文件的内容以查找搜索字符串:</p>

<pre><code class="language-python">        if search_files(text_files, args.search_text, project):
            found = True
</code></pre>

<p>然后打印汇总信息:</p>

<pre><code class="language-python">    print("Searching project(s) " + args.octopus_project + " for dependency " + args.search_text)
    if found:
        print("\n\nSearch text " + args.search_text + " was found in the list of dependencies.")
        print("See the logs above for the complete text file listing the application dependencies.")
    else:
        print("\n\nSearch text " + args.search_text + " was not found in any dependencies.")
</code></pre>

<p>最后一步是调用<code>scan_dependencies</code>函数，这将启动脚本:</p>

<pre><code class="language-python">scan_dependencies()
</code></pre>

<p>脚本写好了，是时候在runbook中执行它了。</p>

<h2 id="running-the-script-in-a-runbook">在操作手册中运行脚本</h2>

<p>第一步是公开将传递给脚本的3个变量:</p>

<ul>
<li><code>GitHubToken</code>是一个保存GitHub个人访问令牌的秘密，用于认证GitHub API调用。</li>
<li><code>ReadOnlyApiKey</code>是一个Octopus API密钥，分配给一个对Octopus服务器具有只读访问权限的帐户(因为这个脚本只查询API，从不修改任何资源)。</li>
<li><code>SearchText</code>是一个提示变量，定义在依赖文本文件中搜索的文本。</li>
</ul>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/variables.png" class="zoom" data-title=""><img src="../Images/9ee68f672c6bd604b06663a7f4947e39.png" class="img-fluid center" alt="Octopus variables" data-original-src="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/variables.png"/>T2】</a></p>

<p>runbook由单个<strong>运行脚本</strong>步骤和以下Bash脚本组成:</p>

<pre><code class="language-bash">cd DependencyQuery

echo "##octopus[stdout-verbose]"
python3 -m venv my_env
. my_env/bin/activate
pip --disable-pip-version-check install -r requirements.txt
echo "##octopus[stdout-default]"

python3 main.py \
    --octopusUrl https://tenpillars.octopus.app \
    --octopusApiKey "#{ReadOnlyApiKey}" \
    --githubUser mcasperson \
    --githubToken "#{GitHubToken}" \
    --octopusSpace "#{Octopus.Space.Name}" \
    --octopusEnvironment "#{Octopus.Environment.Name}" \
    --octopusProject "Products Service, Audits Service, Octopub Frontend" \
    --searchText "#{SearchText}"
</code></pre>

<p>这个脚本中发生了一些有趣的事情，所以让我们来分析一下。</p>

<p>您输入Octopus解压包含Python脚本的包的目录:</p>

<pre><code class="language-bash">cd DependencyQuery
</code></pre>

<p>打印<a href="https://octopus.com/docs/deployments/custom-scripts/logging-messages-in-scripts#service-message">服务消息</a> <code>##octopus[stdout-verbose]</code>指示Octopus将所有后续日志消息视为冗余:</p>

<pre><code class="language-bash">echo "##octopus[stdout-verbose]"
</code></pre>

<p>创建并激活一个名为<code>my_env</code>的新<a href="https://realpython.com/python-virtual-environments-a-primer/" rel="nofollow"> Python虚拟环境</a>，并安装脚本依赖项:</p>

<pre><code class="language-bash">python3 -m venv my_env
. my_env/bin/activate
pip --disable-pip-version-check install -r requirements.txt
</code></pre>

<p>服务消息<code>##octopus[stdout-default]</code>被打印，指示Octopus再次以默认级别处理后续日志消息:</p>

<pre><code class="language-bash">echo "##octopus[stdout-default]"
</code></pre>

<p>然后执行Python脚本。有些参数，如<code>octopusUrl</code>、<code>githubUser</code>、<code>octopusProject</code>，需要根据您的具体用例进行定制。将<code>octopusSpace</code>和<code>octopusEnvironment</code>参数设置为运行runbook的空间和环境允许您在运行runbook的任何环境中查找依赖关系:</p>

<pre><code class="language-bash">python3 main.py \
    --octopusUrl https://tenpillars.octopus.app \
    --octopusApiKey "#{ReadOnlyApiKey}" \
    --githubUser mcasperson \
    --githubToken "#{GitHubToken}" \
    --octopusSpace "#{Octopus.Space.Name}" \
    --octopusEnvironment "#{Octopus.Environment.Name}" \
    --octopusProject "Products Service, Audits Service, Octopub Frontend" \
    --searchText "#{SearchText}"
</code></pre>

<h2 id="executing-the-runbook">执行操作手册</h2>

<p>当runbook被执行时，它会扫描每个项目以获取当前环境的最新部署，从构建信息中找到GitHub Action run链接，下载依赖项工件，提取工件，并扫描文本文件以获取搜索文本。</p>

<p>只需单击一下<strong> RUN </strong>按钮，您就可以快速搜索Octopus部署的任何项目，这些项目都有相关的构建信息和所需的构建工件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/runbook-run.png" class="zoom" data-title=""><img src="../Images/df705c18c944e54ccb3908711a493101.png" class="img-fluid center" alt="Runbook run" data-original-src="https://i.octopus.com/blog/2022-q2/devsecops-respond-to-vulnerabilities/runbook-run.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>Log4j让许多工程团队认识到依赖漏洞是生活中的一个事实，及时的响应不仅对限制您暴露于漏洞是至关重要的，而且对减少支持团队回答客户问题的压力也是至关重要的。同样清楚的是，Log4j不会是最后一个广泛传播的漏洞，您的代码库受到泄漏的影响只是时间问题。</p>

<p>在这篇文章中，您了解了如何将应用程序构建所消耗的依赖项列表保存为GitHub操作中的工件，如何使用构建信息将运行链接到它们生成的包，然后使用运行手册执行自定义Python脚本，对部署到环境中的包中包含的依赖项执行简单的文本匹配。最终结果是能够在几分钟内知道您的应用程序是否暴露于依赖关系中报告的漏洞，并几乎立即开始响应。</p>

<p>阅读我们的<a href="https://octopus.com/blog/tag/Runbooks%20Series"> Runbooks系列</a>的其余部分。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>