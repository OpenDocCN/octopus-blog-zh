<html>
<head>
<title>Selenium series: Implementing Cucumber - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Selenium系列:实现黄瓜-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/selenium/25-implementing-cucumber/implementing-cucumber#2021-07-07">https://octopus.com/blog/selenium/25-implementing-cucumber/implementing-cucumber#2021-07-07</a></blockquote>
                        <p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

<p>到目前为止，我们所有的代码都是用Java编写的，并且我们实现了像页面对象模型这样的设计模式来增加代码的可读性和可维护性。</p>

<p>但是归根结底，这些代码仍然是用Java编写的，对设计、测试和维护web应用程序感兴趣的利益相关者中很少有人是Java专家。这意味着无论我们的代码有多干净和设计得多好，它都不是非开发人员能够阅读和理解的。</p>

<p>集成Cucumber库是让测试对非开发人员来说更容易理解的一种解决方案。我们可以使用cumber库作为Java代码和一种叫做Gherkin的语言之间的粘合剂，我们将在本文中这样做。</p>

<h2 id="the-gherkin-language">小黄瓜语言</h2>

<p>小黄瓜语言被设计成提供一种描述需求、行为和与系统交互的自然语言。小黄瓜使用一个惯例，所有的步骤都以单词<code>Given</code>、<code>When</code>、<code>Then</code>和<code>And</code>开始。这方面的一个例子是步骤:</p>

<pre><code>Given an employee named Bob making $12 per hour.
When Bob works 40 hours in one week;
Then Bob will be paid $480 on Friday evening.
</code></pre>

<p>即使对小黄瓜语言没有任何特别的理解，这种风格也非常易读。</p>

<p>我们想利用这种能力用自然语言描述一个系统，并将其应用于WebDriver测试。这将允许我们编写如下测试:</p>

<pre><code>Given I open the URL "https://ticket-monster.herokuapp.com"
When I click the "Buy tickets now" button
And I click the "Concert" link
And I click the "Rock concert of the decade" link
And I select the option "Toronto : Roy Thomson Hall" from the "Venues" drop-down list
And I click the "Book" button
And I select the option "A - Premier platinum reserve" from the "Sections" drop-down list
Then I verify the text from the "Adult Price" label equals "@ $167.75"
</code></pre>

<p>这些步骤测试的场景与我们在Java中测试的场景非常相似。与Java代码不同，任何人都可以阅读这个测试并理解它的含义。更好的是，只需少量的培训，任何人都可以编写这些测试。</p>

<p>首先，我们需要添加两个依赖项:<code>cucumber-java</code>和<code>cucumber-junit</code>。<code>cucumber-java</code>库提供了许多注释，我们将使用它们将小黄瓜步骤链接到Java方法。<code>cucumber-junit</code>库允许我们执行小黄瓜特性和场景，作为JUnit测试的一部分。当我们开始编写测试时，我们将了解更多关于特性和场景的信息:</p>

<pre><code class="language-xml">&lt;project 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;!-- ... --&gt;

  &lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;cucumber.version&gt;2.3.1&lt;/cucumber.version&gt;
  &lt;/properties&gt;

  &lt;!-- ... --&gt;

  &lt;dependencies&gt;
    &lt;!-- ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
      &lt;artifactId&gt;cucumber-java&lt;/artifactId&gt;
      &lt;version&gt;${cucumber.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.cucumber&lt;/groupId&gt;
      &lt;artifactId&gt;cucumber-junit&lt;/artifactId&gt;
      &lt;version&gt;${cucumber.version}&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>

<p>Cucumber的工作方式是给方法附加注释，将Gherkin步骤与正则表达式匹配，然后将这些正则表达式中的组与方法中的参数匹配。</p>

<p>这些注释被称为<code>@Given</code>、<code>@When</code>、<code>@And</code>和<code>@Then</code>。与小黄瓜语言本身一样，这些注释是可以互换的，并且不需要将注释与小黄瓜步骤中使用的相应前缀相匹配。</p>

<p>例如，我们可以用<code>@And</code>注释来注释一个打开给定URL的方法:</p>

<pre><code class="language-java">@And("^I open the URL \"([^\"]*)\"$")
public void goTo(String url) {

}
</code></pre>

<p>但是然后在一个带有步骤前缀<code>Given</code>的小黄瓜步骤中引用它，就像这样:</p>

<pre><code>Given I open the URL "http://google.com"
</code></pre>

<p>让我们分解一下分配给注释的正则表达式。</p>

<table class="table">
<thead>
<tr>
<th>模式</th>
<th>模式含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td><code>I open the URL \"</code></td>
<td>匹配文字字符串<code>I open the URL "</code></td>
</tr>
<tr>
<td><code>(</code></td>
<td>启动捕获组</td>
</tr>
<tr>
<td><code>[^"]*</code></td>
<td>匹配除双引号以外的任何字符零次或多次</td>
</tr>
<tr>
<td><code>)</code></td>
<td>结束捕获组</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>匹配文字字符串<code>"</code></td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串的结尾</td>
</tr>
</tbody>
</table>

<p>为了理解这些正则表达式，我们可以使用像http://regex-testdrive.com/en/这样的在线工具。这里我们已经输入了正则表达式和一个我们想要匹配正则表达式的目标字符串。点击<code>Test</code>按钮，我们就会看到这场比赛的结果。</p>

<p>可以看到这个匹配返回了两个组。正则表达式中的Group 0总是返回匹配的完整字符串，在我们的例子中是完整的句子<code>I open the URL "http://google.com"</code>。组1只返回括号中的字符，在本例中是URL<a href="http://google.com" rel="nofollow">http://google.com</a>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image1.png" class="zoom" data-title=""><img src="../Images/b2bc34538da76ef0c66181452cf53355.png" class="img-fluid center" alt="C:\a2b8c9a7303cc5bf8ca9c040bf678051" data-original-src="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image1.png"/>T2】</a></p>

<p>这些正则表达式组就是Cucumber从字符串中提取数据并将其传递给相关方法的方式。在我们的例子中，该方法采用单个字符串参数。Cucumber会将group 1的值传递给第一个参数。</p>

<p>所以我们的任务是将注释<code>@Given</code>、<code>@When</code>、<code>@And</code>和<code>@Then</code>添加到将执行一些有用工作的方法中。分配给注释的正则表达式定义了我们可以用来编写测试的小黄瓜方言。</p>

<p>在选择要应用这些注释的类时，有一些重要的考虑因素。</p>

<p>首先是注释必须放在具体的方法上。这意味着我们不能将注释应用于接口中定义的方法。</p>

<p>第二是注释所应用到的类不能被扩展。Cucumber不支持带有注释的类的继承。</p>

<p>第三，当执行带有Cucumber注释的方法时，Cucumber将管理包含该方法的类的生命周期。这意味着在创建类的新实例时，像<code>AutomatedBrowserFactory</code>这样的工厂将被绕过。</p>

<p>这让我们陷入了某种困境。考虑到这些限制，我们可以在哪里应用注释呢？</p>

<p>我们不能将注释放在<code>AutomatedBrowser</code>接口上，因为我们需要将注释添加到具体的类中。</p>

<p>乍一看，我们可能能够将注释放在<code>WebDriverDecorator</code>类上，因为这里定义了我们的大部分功能。然而，装饰器只有在特定的组合中构建时才有用。我们已经使用了<code>AutomatedBrowserFactory</code>类来为我们构建这些装饰器组合，但是因为Cucumber将控制带注释的类的生命周期，它将绕过<code>AutomatedBrowserFactory</code>使我们的装饰器变得无用。</p>

<p>唯一的另一个选项是<code>AutomatedBrowserBase</code>类，但是它已经被每个decorator类继承了，Cucumber不支持它。</p>

<p>幸运的是，Cucumber对用注释扩展类的限制有一个解决办法。你可能已经注意到，我们将<code>AutomatedBrowserBase</code>类单独放在它自己的包<code>com.octopus.decoratorbase</code>中。为一个单独的类准备一个包可能看起来很奇怪，但这是经过深思熟虑的。通过将包中的<code>AutomatedBrowserBase</code>类与所有扩展它的decorator类隔离开来，我们可以解决Cucumber的局限性。</p>

<p>为了了解这个变通方法是如何工作的，让我们从创建一个测试类开始，这个测试类使用了我们在<code>cucumber-junit</code> Maven依赖项中包含的代码。</p>

<pre><code class="language-java">package com.octopus;

import cucumber.api.CucumberOptions;
import cucumber.api.junit.Cucumber;
import org.junit.runner.RunWith;

@RunWith(Cucumber.class)
@CucumberOptions(glue = "com.octopus.decoratorbase")
public class CucumberTest {

}
</code></pre>

<p>这个测试类有两个注释，将它与Cucumber库集成在一起。</p>

<p>首先是<code>@RunWith</code>标注。这个JUnit注释接受一个类，可以用来修改测试的运行方式。在这种情况下，Cucumber类修改测试，在与测试类相同的包中查找任何<code>*.feature</code>文件，并执行它们:</p>

<pre><code class="language-java">@RunWith(Cucumber.class)
</code></pre>

<p>第二个标注是<code>@CucumberOptions</code>。这个注释用于定制Cucumber如何运行它找到的<code>*.feature</code>文件。这里我们已经将包<code>com.octopus.decoratorbase</code>作为包含“glue”类的包进行了传递。Glue类只是带有注释<code>@Given</code>、<code>@When</code>、<code>@And</code>或<code>@Then</code>的类。</p>

<p>Cucumber将对这个包中的类以及任何子包进行分类。在这个包里面和下面的Glue类不能互相扩展。</p>

<p>这意味着因为<code>AutomatedBrowserBase</code>类是这个包中找到的唯一的类，Cucumber确信不存在非法的类层次结构。<code>com.octopus.decorators</code>包下的所有装饰器类都扩展了<code>AutomatedBrowserBase</code>类，这没关系，因为Cucumber不知道这些装饰器类。</p>

<p>因此，通过将<code>AutomatedBrowserBase</code>类隔离在它自己的包中，我们可以将它用作黄瓜胶类:</p>

<pre><code class="language-java">@CucumberOptions(glue = "com.octopus.decoratorbase")
</code></pre>

<p>除了这两个注释，<code>CucumberTest</code>类应该是空的。与传统的JUnit测试类不同，在传统的JUnit测试类中，测试是在方法中定义的，所有Cucumber测试都是在外部<code>*.feature</code>文件中定义的。</p>

<p>因为<code>AutomatedBrowserBase</code>类中的方法是小黄瓜测试执行测试的唯一方式，我们需要公开一些方法来创建和销毁<code>AutomatedBrowser</code>实例。通常我们会在JUnit测试中执行这个逻辑，在测试开始时调用<code>AutomatedBrowserFactory.getAutomatedBrowser()</code>，在测试结束时调用<code>automatedBrowser.destroy()</code>。为了向Cucumber公开这个功能，我们创建了方法<code>openBrowser()</code>和<code>closeBrowser()</code>:</p>

<pre><code class="language-java">public class AutomatedBrowserBase implements AutomatedBrowser {

  static private final AutomatedBrowserFactory AUTOMATED_BROWSER_FACTORY
    = new AutomatedBrowserFactory();

  // ...

  @Given("^I open the browser \"([^\"]*)\"$")
  public void openBrowser(String browser) {
    automatedBrowser =
      AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser(browser);
    automatedBrowser.init();
  }

  @Given("^I close the browser$")
  public void closeBrowser() {
    if (automatedBrowser != null) {
      automatedBrowser.destroy();
      automatedBrowser = null;
  }
}

// ...

}
</code></pre>

<p>让我们更详细地看看这两种方法:</p>

<pre><code class="language-java">@Given("^I open the browser \"([^\"]*)\"$")
</code></pre>

<p>附加到<code>openBrowser()</code>方法的注释<code>@Given("^I open the browser \"([^\"]*)\"$")</code>的工作方式与前面的<code>@And("^I open the URL \"([^\"]*)\"$")</code>示例相同。注释<code>@Given</code>和<code>@And</code>可以互换。通常<code>@Given</code>用在执行某种初始化或管理功能的方法上，但这只是惯例而不是规则。</p>

<p>分配给<code>@Given</code>注释的正则表达式遵循相同的模式，使用脱字符(<code>^</code>)和美元(<code>$</code>)字符来结束表达式，字符串<code>I open the browser</code>的文字匹配，以及引号内的非贪婪捕获组。</p>

<p>然后捕获组的值被传递给名为<code>browser</code>的参数:</p>

<pre><code class="language-java">public void openBrowser(String browser) {
</code></pre>

<p>从这一点来看，该方法的工作方式与其他任何方法一样。在这种情况下，我们调用<code>AutomatedBrowserFactory.getAutomatedBrowser()</code>来构建指定的<code>AutomatedBrowser</code>配置，然后调用<code>init()</code>函数来初始化它:</p>

<pre><code class="language-java">automatedBrowser = AUTOMATED_BROWSER_FACTORY.getAutomatedBrowser(browser);
automatedBrowser.init();
</code></pre>

<p>附加到<code>closeBrowser()</code>方法的注释<code>@Given("^I close the browser$")</code>没有捕获组，这意味着它所附加的方法没有参数。这里的正则表达式只能匹配文字字符串<code>I close the browser</code>:</p>

<pre><code class="language-java">@Given("^I close the browser$")
public void closeBrowser() {
</code></pre>

<p>这个方法负责在由<code>openBrowser()</code>方法创建的<code>AutomatedBrowser</code>实例上调用<code>destroy()</code>方法:</p>

<pre><code class="language-java">  if (automatedBrowser != null) {
    automatedBrowser.destroy();
    automatedBrowser = null;
  }
}
</code></pre>

<p>我们现在有足够的证据来进行一个非常简单的黄瓜测试。在<code>src/test/resources/com/octopus</code>目录下创建以下名为<code>simpletest.feature</code>的文件。</p>

<p>默认情况下，目录<code>src/test/resources/com/octopus</code>是Maven为<code>com.octopus</code>包放置资源的地方。记住，我们需要将这个文件放在与测试类相同的包中，这样才能找到它。文件名可以是我们想要的任何东西，但是它必须有被Cucumber识别的<code>.feature</code>扩展名。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image2.png" class="zoom" data-title=""><img src="../Images/d3dec2f431f24469a81bc1e88da6f97a.png" class="img-fluid center" alt="C:\537406a0bc59b2f2768f2721fc6136d5" data-original-src="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image2.png"/>T2】</a></p>

<pre><code class="language-gherkin">Feature: A simple test
  Scenario: Open and close the browser
    Given I open the browser "ChromeNoImplicitWait"
    Then I close the browser
</code></pre>

<p>让我们把这个文件分解一下。</p>

<p>所有小黄瓜特征文件都以一个<code>Feature:</code>部分开始。功能是一组相关的场景:</p>

<pre><code class="language-gherkin">Feature: A simple test
</code></pre>

<p>接下来我们有了<code>Scenario:</code>。场景类似于传统单元测试类中的方法，因为它是自包含的，并且演示了被测试系统的某些方面:</p>

<pre><code class="language-gherkin">Scenario: Open and close the browser
</code></pre>

<p>最后，我们有在<code>AutomatedBrowserBase</code>类中定义的两个步骤。</p>

<p>请注意，这里使用的步骤前缀与注释的名称并不完全匹配。虽然如果这些步骤与注释名匹配就好了，但这不是必需的。</p>

<p>还要注意，我们定义的正则表达式并没有捕捉到单词<code>Given</code>、<code>When</code>、<code>Then</code>或<code>And</code>，尽管完整的步骤总是以这样的单词开始。我们定义的正则表达式从匹配这个初始单词之后的步骤的内容开始:</p>

<pre><code class="language-gherkin">Given I open the browser "ChromeNoImplicitWait"
Then I close the browser
</code></pre>

<p>要运行测试，点击测试类旁边的图标并选择<code>Run 'CucumberTest'</code>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image3.png" class="zoom" data-title=""><img src="../Images/034bdb8225906450f2d7ca968dfca428.png" class="img-fluid center" alt="C:\a277c2bd96ba8a3dfb01dacfccfd685e" data-original-src="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image3.png"/>T2】</a></p>

<p>运行测试将找到<code>simpletest.feature</code>文件并执行它。该功能文件将依次打开Chrome，然后立即关闭它。在测试结果中，我们可以看到我们成功地运行了1个场景，导致了2个步骤的运行。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image4.png" class="zoom" data-title=""><img src="../Images/2a9152c710b79cd4ec203d349b30b1e2.png" class="img-fluid center" alt="C:\c7c63543a445275fbcae1e3ace817ee9" data-original-src="https://i.octopus.com/blog/2018-10/selenium/25-implementing-cucumber/image4.png"/>T2】</a></p>

<p>我们现在已经为创建一种小黄瓜方言奠定了基础，这种方言将允许我们编写可以使用WebDriver验证的自然语言测试。然而，要创建端到端测试，我们还有很多工作要做。在下一篇文章中，我们将向Cucumber展示更多的<code>AutomatedBrowser</code>类，并努力创建一个可读的端到端测试。</p>

<p>这篇文章是关于<a href="/blog/selenium/0-toc/webdriver-toc">创建Selenium WebDriver测试框架</a>的系列文章的一部分。</p>

                    
                    
</body>
</html>