<html>
<head>
<title>Using Docker as a package manager - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Docker作为包管理器- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/docker-as-package-manager#2022-08-22">https://octopus.com/blog/docker-as-package-manager#2022-08-22</a></blockquote>
                        <p>自动化开发运维任务时的一个持续挑战是确保您拥有正确的工作工具。Linux用户长期以来一直享受着从大量维护良好的软件包库中安装工具的能力，而macOS用户有HomeBrew和MacPorts，Windows用户有Chocolatey和winget。</p>

<p>然而，越来越多的基于云的工具，例如特定于平台的CLI工具(例如eksctl、aws-iam-authenticator、kubectl、kind和helm)，只能通过直接二进制下载跨多个操作系统和Linux发行版可靠地安装。在自动化开发运维任务时，寻找和下载工具是一个难点。</p>

<p>Docker通过允许从Docker映像运行基于CLI的工具来提供解决方案。</p>

<p>在这篇文章中，我将探讨如何使用Docker作为一个通用的包管理器来跨多个操作系统下载和运行许多CLI工具。</p>



<p>DevOps完全是关于可重复性和自动化，并且经常需要使用专门的CLI工具编写脚本任务。许多运行脚本的环境本质上都是短暂的。示例包括根据需要创建和销毁的CI/CD代理、用于运行作业的Kubernetes pods，以及根据需求扩展和缩减的虚拟机。这通常意味着脚本编写者不能假定安装了CLI工具，或者依赖于工具的特定版本。</p>

<p>正如简介中提到的，DevOps团队需要的许多工具只提供直接的二进制下载。这意味着即使是一个简单的脚本也可能需要首先找到任何所需CLI工具的相应下载链接，下载它们(通常使用某种重试逻辑来处理网络不稳定性)，提取或安装工具，然后最终运行它们。</p>

<p>由于从互联网下载文件所需的工具因操作系统而异，这一任务变得复杂。Linux和macOS用户可能可以指望安装像<code>curl</code>或<code>wget</code>这样的工具，而Windows用户可能会使用PowerShell CmdLets。</p>

<p>但是如果有更好的方法呢？</p>

<h2 id="docker-as-a-universal-package-manager">Docker作为一个通用的包管理器</h2>

<p>如今，每个主要的CLI工具和平台都提供了维护良好的Docker映像。无论这些图片是由供应商自己发布在Docker Hub这样的存储库上，还是由第三方维护，比如T2 Bitnami T3，你都很有可能找到你需要的最新版本的CLI工具作为Docker图片。</p>

<p>运行Docker镜像的好处在于，下载和执行镜像的命令在所有操作系统和所有工具上都是相同的。</p>

<p>要下载映像，重用任何以前下载的映像并自动重试，请运行命令:</p>

<pre><code class="language-bash">docker pull image-name
</code></pre>

<p>然后，使用以下命令执行该映像:</p>

<pre><code class="language-bash">docker run image-name
</code></pre>

<p>正如您将在接下来的部分中看到的，对于短期管理任务，可靠地运行映像还需要额外的参数，但是一般来说，对于每个工具和操作系统，您只需要知道这两个命令。与在Windows和Linux之间编写独特的脚本来从自定义URL下载二进制文件相比，这是一个巨大的进步。</p>



<p>让我们看看helm，它是一个从Docker映像运行CLI工具的实际例子。第一步是在本地下载映像。注意这一步是可选的，因为Docker会在运行之前下载丢失的图像:</p>

<pre><code class="language-bash">docker pull alpine/helm
</code></pre>

<p>使用以下命令不带任何参数运行helm。传递给<code>docker</code>的<code>--rm</code>参数在完成时清理容器，这在为单个操作运行图像时是理想的:</p>

<pre><code class="language-bash">docker run --rm alpine/helm
</code></pre>

<p>这导致帮助文本被打印到控制台，就像您运行了一个本地安装的没有参数的<code>helm</code>版本一样。</p>

<p>用于DevOps自动化的CLI工具的一个常见要求是能够读取文件和目录，无论它们是配置文件、较大的包(如zip文件)还是包含应用程序代码的目录。</p>

<p>就其本质而言，Docker容器是自包含的，默认情况下不读取主机上的文件。然而，可以使用<code>-v</code>参数将本地文件和目录挂载到Docker容器中，允许进程在Docker容器中运行，以读写主机上的文件。</p>

<p>下面的命令用一个为运行<code>alpine/helm</code>映像而创建的容器挂载几个共享目录。这允许Docker容器中的<code>helm</code>可执行文件访问配置设置，比如helm存储库。它还传递参数<code>repo list</code>，其中列出了已配置的存储库:</p>

<pre><code class="language-bash">docker run --rm -v "$(pwd):/apps" -w /apps \
    -v ~/.kube:/root/.kube -v ~/.helm:/root/.helm -v ~/.config/helm:/root/.config/helm \
    -v ~/.cache/helm:/root/.cache/helm \
    alpine/helm repo list
</code></pre>

<p>如果您之前没有定义任何helm存储库，此命令的输出将是:</p>

<pre><code class="language-bash">Error: no repositories to show
</code></pre>

<p>为了演示卷挂载是如何工作的，使用本地安装版本的<code>helm</code>配置一个新的helm存储库:</p>

<pre><code class="language-bash">helm repo add nginx-stable https://helm.nginx.com/stable
</code></pre>

<p>运行helm Docker映像来列出存储库，这表明它已经加载了由本地安装的<code>helm</code>副本添加的存储库:</p>

<pre><code class="language-bash">NAME            URL
nginx-stable    https://helm.nginx.com/stable
</code></pre>

<p>反之亦然。运行以下命令，从helm Docker映像添加第二个存储库:</p>

<pre><code class="language-bash">docker run --rm -v "$(pwd):/apps" -w /apps \
    -v ~/.kube:/root/.kube -v ~/.helm:/root/.helm -v ~/.config/helm:/root/.config/helm \
    -v ~/.cache/helm:/root/.cache/helm \
    alpine/helm repo add kong https://charts.konghq.com
</code></pre>

<p>然后使用以下命令列出本地安装的工具中的repos:</p>

<pre><code class="language-bash">helm repo list
</code></pre>

<p>本地安装反映了新添加的repo:</p>

<pre><code class="language-bash">NAME            URL
nginx-stable    https://helm.nginx.com/stable
kong            https://charts.konghq.com
</code></pre>

<h2 id="aliasing-docker-run-commands">别名Docker运行命令</h2>

<p>虽然Docker让您可以方便地下载和运行图像，但键入<code>docker run</code>命令可能会变得非常冗长乏味。幸运的是，可以给<code>docker run</code>命令起别名，这样它就可以替代本地安装的工具。</p>

<p>使用<code>alias</code>命令将<code>docker run</code>映射到<code>helm</code>命令:</p>

<pre><code class="language-bash">alias helm='docker run --rm -v $(pwd):/apps -w /apps -v ~/.kube:/root/.kube -v ~/.helm:/root/.helm -v ~/.config/helm:/root/.config/helm -v ~/.cache/helm:/root/.cache/helm alpine/helm'
</code></pre>

<p>先前的alias命令仅在定义它的会话中有效。如果您注销并重新登录，别名会丢失。要使别名永久化，编辑<code>~/.bash_aliases</code>文件，并在新的一行中添加上面的alias命令:</p>

<pre><code class="language-bash">vim ~/.bash_aliases
</code></pre>

<p>在许多Linux发行版中，<code>~/.bash_aliases</code>文件是由<code>~/.bashrc</code>文件自动加载的。如果没有，将以下代码添加到<code>~/.bashrc</code>文件中:</p>

<pre><code class="language-bash">if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
</code></pre>

<h2 id="using-docker-images-in-octopus-script-steps">在Octopus脚本步骤中使用Docker图像</h2>

<p>如果您在非交互式shell中使用别名(比如在Octopus部署中运行脚本步骤)，您需要通过运行以下命令来确保别名得到扩展:</p>

<pre><code class="language-bash">shopt -s expand_aliases
</code></pre>

<p>以下代码片段显示了下载Docker映像并设置别名的脚本步骤。日志记录级别已设置为verbose，因此Docker映像下载消息不会填充部署日志。它还演示了通过<code>-e</code>参数将环境变量传递给<code>docker run</code>:</p>

<pre><code class="language-bash">echo "Downloading Docker images"

echo "##octopus[stdout-verbose]"

docker pull amazon/aws-cli 2&gt;&amp;1

# Alias the docker run commands
shopt -s expand_aliases
alias aws='docker run --rm -i -v $(pwd):/build -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY amazon/aws-cli'

echo "##octopus[stdout-default]"
</code></pre>

<h2 id="conclusion">结论</h2>

<p>Docker镜像为安装和运行通用DevOps CLI工具提供了一致且方便的方法，尤其是与编写OS命令从唯一的URL下载二进制文件相比。</p>

<p>在这篇文章中，我研究了如何从命令行或在脚本中运行Docker映像，并提供了一些技巧来允许Docker映像作为本地安装工具的替代运行。</p>

<h2 id="learn-more">了解更多信息</h2>

<p>如果你想在AWS平台上构建和部署容器化的应用程序，比如EKS和ECS，试试Octopus Workflow Builder。构建器使用GitHub Actions工作流构建的示例应用程序填充GitHub存储库，并使用示例部署项目配置托管的Octopus实例，展示漏洞扫描和基础架构即代码(IaC)等最佳实践。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>