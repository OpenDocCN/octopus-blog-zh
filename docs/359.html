<html>
<head>
<title>Java CI/CD: From JAR to Docker - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Java CI/CD:从JAR到Docker——Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/java-ci-cd-co/from-jar-to-docker#2022-12-14">https://octopus.com/blog/java-ci-cd-co/from-jar-to-docker#2022-12-14</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-jar-to-docker/blogimage-java-blog-series-2.png" class="zoom" data-title=""> <img src="../Images/227c4564c5ba86c1b4d66c307c7a949c.png" class="img-fluid center" alt="Java CI/CD: From JAR to Docker" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-jar-to-docker/blogimage-java-blog-series-2.png"/> </a></p>

<p>本文是展示Jenkins、Docker和Octopus示例部署管道系列的一部分:</p>



<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-jar-to-docker/code.svg" class="zoom" data-title=""><img src="../Images/a806e95ccd04d5b3007e1654e5eef39d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-jar-to-docker/code.svg"/>T2】</a></p>

<p>也许没有哪个公共项目比<a href="https://projects.spring.io/spring-petclinic/" rel="nofollow"> Spring PetClinic </a>更好地展示了一个长寿的Java应用程序。它诞生于21世纪初，至今仍自豪地出现在Spring网站上。</p>

<p>我们的DevOps生命周期之旅从本地工作站上PetClinic的本地构建开始。在这篇博客文章的结尾，我们已经用Docker封装了这个应用程序，提供了一个<a href="https://octopus.com/devops/continuous-delivery/what-is-a-deployment-pipeline/">可重复的构建和执行环境</a>。</p>

<h2 id="start-with-a-local-build">从本地构建开始</h2>

<p>首先，我们克隆PetClinic GIT存储库，并使用与应用程序源代码一起签入的Maven包装器来构建和运行本地JAR文件:</p>

<pre><code>git clone https://github.com/spring-projects/spring-petclinic.git
cd spring-petclinic
./mvnw spring-boot:run
</code></pre>

<p>这个初始构建需要一些时间，因为Maven下载了组成应用程序的各种Spring库。幸运的是，这些库都被缓存了，所以后续的构建会完成得更快。</p>

<p>要查看该应用程序，请打开http://localhost:8080:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-jar-to-docker/petclinic.png" class="zoom" data-title=""> <img src="../Images/3643dc19559a6714178301590b189d84.png" class="img-fluid center" alt="PetClinic running locally" data-original-src="https://i.octopus.com/blog/2020-09/java-ci-cd-co/from-jar-to-docker/petclinic.png"/> </a> <em> PetClinic本地运行。</em></p>

<p>要创建可分发的JAR文件，请运行以下命令:</p>

<pre><code>./mvnw package
</code></pre>

<p>这会运行单元测试，然后在<code>target</code>目录下创建一个独立的JAR文件，类似于<code>petclinic.2.3.1.BUILD-SNAPSHOT.jar</code>。我们可以使用以下命令运行该文件:</p>

<pre><code>java -jar .\target\petclinic.2.3.1.BUILD-SNAPSHOT.jar
</code></pre>

<p>这个本地测试、构建和运行的过程是每个应用程序的起点。</p>

<p>公平地说，PetClinic实现了许多特性来使这些构建可重复，并且结果易于分发。<code>mvnw</code>脚本是<a href="https://github.com/takari/maven-wrapper" rel="nofollow"> Maven包装器</a>，它提供了跨平台的脚本，如果本地机器没有安装Maven的适当版本，这些脚本可以被签入源代码控制。然后，Spring boot创建易于版本化、复制和部署的自包含JAR文件。</p>

<p>然而，您仍然需要Java开发工具包(JDK)来构建应用程序，并且需要JDK或Java运行时环境(JRE)来运行它。PetClinic依赖于一个相当老的Java版本，鉴于每六个月就会发布一个新的Java版本，不难想象开发人员必须修改Java安装来执行本地构建。</p>

<p>为了提供一个真正自包含的构建和执行环境，我们将把这个应用程序迁移到Docker。</p>

<h2 id="self-contained-builds-and-execution-with-docker">用Docker进行独立构建和执行</h2>

<p>Docker的主要特性之一是它能够将整个应用程序生态系统捆绑在一个自包含的映像中，该映像可以在一个隔离的环境中运行。对我们来说，这意味着我们可以用所需版本的Java和我们编译的应用程序构建和分发Docker映像，任何安装了Docker的人都可以运行它。</p>

<p>PetClinic repo的一个分支已经用下面的代码在<a href="https://github.com/mcasperson/spring-petclinic" rel="nofollow"> GitHub </a>中创建，以便于访问。</p>

<p>Docker映像由名为<code>Dockerfile</code>的文件中列出的步骤定义。我们的<code>Dockerfile</code>的内容如下所示:</p>

<pre><code>FROM maven:3.6.3-jdk-8 AS build-env
WORKDIR /app

COPY pom.xml ./
RUN mvn dependency:go-offline
RUN mvn spring-javaformat:help

COPY . ./
RUN mvn spring-javaformat:apply
RUN mvn package -DfinalName=petclinic

FROM openjdk:8-jre-alpine
EXPOSE 8080
WORKDIR /app

COPY --from=build-env /app/target/petclinic.jar ./petclinic.jar
CMD ["/usr/bin/java", "-jar", "/app/petclinic.jar"]
</code></pre>

<p>这个<code>Dockerfile</code>利用了一个叫做<a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="nofollow">多阶段构建</a>的特性。这允许我们创建一个更小的最终Docker映像来发布，因为它不包含构建应用程序所需的工具。</p>

<p>我们的构建基于Maven团队提供的现有Docker映像。这个映像预装了JDK和Maven工具:</p>

<pre><code>FROM maven:3.6.3-jdk-8 AS build-env
</code></pre>

<p>然后我们创建并移入一个名为<code>/app</code>的目录:</p>

<pre><code>WORKDIR /app
</code></pre>

<p>Maven <code>pom.xml</code>文件被复制到<code>/app</code>目录中:</p>

<pre><code>COPY pom.xml ./
</code></pre>

<p>然后我们运行Maven <code>dependency:go-offline</code>目标，它下载了构建应用程序所需的大多数库和Maven插件。</p>

<p>由于Docker缓存构建的方式，只要<code>pom.xml</code>文件没有改变，该映像的任何后续重建都将重用Maven的这次执行所执行的下载。对于PetClinic应用程序，这可以节省几分钟时间和数百兆字节:</p>

<pre><code>RUN mvn dependency:go-offline
</code></pre>

<p>Spring包括一个源代码格式化工具，可以确保所有代码都有一致的风格。我们将调用help函数来确保Maven下载插件，这意味着Docker将依次缓存下载内容。这将为我们节省一次下载和随后的Docker映像重建:</p>

<pre><code>RUN mvn spring-javaformat:help
</code></pre>

<p>我们现在可以复制应用程序源代码的其余部分。Docker检测被复制的源代码何时发生了变化，并从这一步重新运行映像构建过程来捕获变化。但是，所有的应用程序依赖项都已被缓存，因此从这一步开始的构建过程会相对较快:</p>

<pre><code>COPY . ./
</code></pre>

<p>将源代码从Windows工作站复制到Linux Docker映像通常会导致格式化插件抱怨行尾。在这里，我们运行格式插件来自动修复复制文件的任何问题:</p>

<pre><code>RUN mvn spring-javaformat:apply
</code></pre>

<p>我们现在可以以Maven <code>package</code>为目标构建应用程序。注意，我们还将变量<code>finalName</code>设置为<code>petclinic</code>。这将覆盖默认文件名<code>petclinic.2.3.1.BUILD-SNAPSHOT.jar</code>，生成一个名为<code>petclinic.jar</code>的一致文件:</p>

<pre><code>RUN mvn package -DfinalName=petclinic
</code></pre>

<p>我们的应用程序现在已经构建好了，我们进入多阶段构建的下一个阶段，生成我们想要分发的Docker映像。这个图像基于OpenJDK JRE。</p>

<p>JRE可以运行已编译的应用程序，但不包括编译应用程序所需的工具。这减小了最终图像的尺寸。</p>


<pre><code>FROM openjdk:8-jre-alpine
</code></pre>

<p>我们公开端口<code>8080</code>，这是我们的Spring应用程序监听的端口:</p>

<pre><code>EXPOSE 8080
</code></pre>

<p>我们创建并移入一个名为<code>/app</code>的目录:</p>

<pre><code>WORKDIR /app
</code></pre>

<p>在前一阶段编译的JAR文件被复制到当前映像中:</p>

<pre><code>COPY --from=build-env /app/target/petclinic.jar ./petclinic.jar
</code></pre>

<p>然后，我们指示映像在运行时执行JAR文件:</p>

<pre><code>CMD ["/usr/bin/java", "-jar", "/app/petclinic.jar"]
</code></pre>

<p>要构建Docker映像，请运行以下命令:</p>

<pre><code>docker build . -t petclinic
</code></pre>

<p>这将构建Docker映像，并给它分配标签<code>petclinic:latest</code>。请注意，如果没有指定其他标签，默认情况下会应用<code>latest</code>。</p>

<p>最后，使用以下命令运行Docker映像:</p>

<pre><code>docker run petclinic
</code></pre>

<p>和以前一样，这个应用程序可以在http://localhost:8080上找到。</p>

<p>我们现在有了一个<code>Dockerfile</code>，它包含了构建和运行我们的应用程序所需的所有步骤。现在，除了Docker之外，无需任何其他工具，就可以从源代码构建这个应用程序。我们现在有了一个真正独立的构建过程。</p>

<h2 id="distributing-docker-images">分发Docker图像</h2>

<p>Docker图像可以与许多Docker注册中心在线共享。最受欢迎的是<a href="https://hub.docker.com/" rel="nofollow"> Docker Hub </a>，它为托管公开可用的Docker图像提供免费账户。</p>

<p>为了共享PetClinic Docker图像，我们需要注册一个Docker Hub帐户。我的账号叫<code>mcasperson</code>。</p>

<p>创建帐户后，使用命令<code>docker login</code>登录Docker Hub:</p>

<pre><code>docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: mcasperson
Password:
Login Succeeded
</code></pre>

<p>要分享图片，需要用你的用户名进行标记。在我的例子中，我需要构建一个名为<code>mcasperson/petclinic</code>的映像(其中<code>mcasperson</code>是我的Docker Hub用户名):</p>

<pre><code>docker build . -t mcasperson/petclinic
</code></pre>

<p>构建应该会很快完成，因为没有文件被更改，所有步骤都被缓存。</p>

<p>要上传图像，运行以下命令，用您的Docker Hub用户名替换<code>mcasperson</code>:</p>

<pre><code>docker push mcasperson/petclinic
</code></pre>

<p>这张照片现在被<a href="https://hub.docker.com/r/mcasperson/petclinic" rel="nofollow">分享到网上</a>，任何人都可以访问。</p>

<p>要运行公共映像，请执行以下命令:</p>

<pre><code>docker run -p 8080:8080 mcasperson/petclinic
</code></pre>

<p>如果本地没有映像，Docker将下载它，然后像我们之前做的那样运行它。选项<code>-p 8080:8080</code>明确地将本地端口8080映射到容器端口8080。</p>

<h2 id="conclusion">结论</h2>

<p>在本文中，我们采用了一个典型的Java应用程序，并将其封装为Docker映像。这张图片被上传到Docker注册处，供公众使用。</p>

<p>通过这些改变，我们创建了一个<a href="https://octopus.com/devops/continuous-delivery/what-is-a-deployment-pipeline/">可重复的构建和执行过程</a>，任何人只需安装Docker就可以使用。如果我们切换到较新版本的Java，甚至完全切换语言，应用程序仍然可以用相同的Docker命令构建和运行。</p>

<p>虽然Docker可以方便地封装构建过程，但不能保证源代码编译成功或测试全部通过。随着越来越多的开发人员开始开发一个应用程序，代码库的健康状况需要由一个中心<em>真实来源</em>共享，这样每个人都知道应用程序的状态。这就是持续集成服务器的用武之地。</p>

<p>在下一篇<a href="/blog/java-ci-cd-co/from-local-to-ci">文章</a>中，我们将配置我们的应用程序，由流行的开源CI服务器Jenkins构建。</p>

                    
                    
</body>
</html>