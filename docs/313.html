<html>
<head>
<title>How we are using SQL Server in Octopus 3.0 - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>我们如何在Octopus 3.0中使用SQL Server-Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/how-we-are-using-sql#2015-09-25">https://octopus.com/blog/how-we-are-using-sql#2015-09-25</a></blockquote>
                        <p>在之前的一篇文章中，我宣布我们将把Octopus 3.0 的<a href="http://octopusdeploy.com/blog/3.0-switching-to-sql">从RavenDB切换到SQL Server。那篇帖子谈到了我们为什么要离开RavenDB，但没有过多解释我们计划如何使用SQL Server。在这篇文章中，我想谈谈我们如何使用SQL Server，并讨论一些小的突破性变化。</a></p>

<p>我们刚刚完成了将Octopus 3.0移植到SQL Server的大部分工作。我们有一套自动化的API测试，安装和配置Octopus服务器，注册一些触角，并使用REST API测试应用程序。这些测试现在已经通过，并且完全针对SQL Server运行:</p>

<p><img src="../Images/4b8f619f519985f078dfb7383f4c33dd.png" alt="End to end tests passing" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-12-16_at_3_12_08_pm_l7kpm3.png"/></p>

<h2>版本</h2>

<p>我们确保Octopus在以下情况下工作:</p>

<ul>
<li>SQL Server 2005、2008、2012、2014及以上版本；从Express到Enterprise的任何版本</li>
<li>SQL Azure</li>
</ul>

<p>为了使入门体验顺畅和容易，Octopus安装程序将为您提供自动下载和静默安装SQL Server Express edition的选项，这是免费的。当然，你也可以把它连接到一个集群SQL Server企业服务器上，尽管其他SQL Server版本的许可费用需要和微软讨论。-) </p>

<h2>高可用性</h2>

<p>如今，Octopus实际上使用几种不同的数据存储:</p>

<ul>
<li>大多数数据存储在RavenDB中</li>
<li>部署日志(总是被附加到)存储在磁盘上，因为除非你是<a href="http://en.wikipedia.org/wiki/Joel_Spolsky#Schlemiel_the_Painter.27s_algorithm"> Schlemiel the Painter </a>否则不可能附加到附件</li>
<li>关于正在进行的部署和其他任务的状态也存储在磁盘上</li>
<li>内置存储库中的NuGet包存储在磁盘上，元数据存储在Lucene.NET索引中</li>
</ul>

<p>虽然我们支持使用外部(集群)RavenDB实例，但大多数客户并不真正能够设置和管理它，所以我们几乎总是使用嵌入式版本的RavenDB。因为我们在许多地方都有数据，所以我们需要在产品中构建我们自己的备份和恢复功能。</p>

<p>对于Octopus 3.0，我们将确保我们有一个伟大的高可用性故事。大多数企业已经熟悉了如何设置一个集群SQL Server实例，并且现场有DBA可以帮助管理它。因此，我们的第一个设计原则将是一切(几乎)都需要在SQL Server中。具体来说:</p>

<ul>
<li>我们目前存储在Raven中的所有文档都将转到SQL Server</li>
<li>部署日志将被压缩(它们压缩得非常好)并存储在SQL中</li>
<li>正在进行的部署状态:我们将依赖于内存中的状态(参见下面的重大变化部分)</li>
<li>NuGet包仍将在磁盘上(您可以更改它们的存储位置，并将它们放在文件共享/SAN上)，但元数据将存储在SQL中</li>
</ul>

<p>此外，我们将确保您可以设置多个Octopus Deploy服务器，所有这些服务器都指向同一个SQL数据库/使用同一个包目录。安装向导和命令行工具将使设置<a href="http://en.wikipedia.org/wiki/Siphonophorae">虹吸管</a>变得容易:</p>

<p><img src="../Images/10c69afa9ccef9e176176eb3f058025a.png" alt="Octopus server load balanced" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-12-16_at_4_17_17_pm_iied8v.png"/></p>

<p>这不会完全是网络规模，但是<a href="http://stackexchange.com/performance"> Stack Exchange已经很好地证明了</a>通过横向扩展应用服务器和纵向扩展数据库，你可以走得很远。</p>

<p><strong>重大变化:</strong>有一个场景我们将不再支持:在部署期间重启Octopus服务器。</p>

<p>以前，您可以启动一个长时间运行的部署，然后关闭Octopus服务器，再次启动它，它很有可能会从停止的地方继续运行。我说“机会”是因为不可能测试所有的场景，我们知道在一些领域它不起作用，部署会处于一种奇怪的状态，他们说他们在运行，但实际上没有。通过移除这个特性，我们将能够简化事情并获得更好的性能，因为我不认为它曾经完全可靠地工作过，所以这应该是一个不错的改变。如果这影响到你，请在下面的评论中告诉我！</p>

<h2>作为文档存储的SQL</h2>

<p>使用像RavenDB这样的文档数据库时，我们喜欢(也将会怀念)的一个特性是无需大量连接就能存储和加载大而深的对象图。例如，Octopus允许您定义<a href="http://docs.octopusdeploy.com/display/OD/Variables">变量</a>，它们是可以应用于许多不同字段的键/值对。有些客户有成千上万个这样的东西，我们在每个版本中都给它们拍快照，所以用传统的关系模式建模会使事情变得非常复杂。我们实际上永远不会查询这些数据，我们只需要在部署期间将它们全部加载到内存中。</p>

<p>相反，我们将SQL视为文档存储。每种文档类型都有自己的表，我们查询的字段将作为常规列存储。但是我们不查询的所有字段和深层对象图都存储为JSON blob (a <code>nvarchar(max)</code>)。</p>

<p><img src="../Images/81cb9b2f461a89e6556b433a106bda79.png" alt="Storing documents in SQL" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2014-12-16_at_4_35_29_pm_yalwpb.png"/></p>

<p>因为我们不做任何连接，所以我们不需要ORM来帮助将对象图缝合在一起。相反，我们保持接近金属，本质上使用一些围绕<code>SqlConnection</code> / <code>SqlCommand</code>的包装器，这些包装器使用JSON.NET反序列化JSON blobs，然后设置额外的字段。自定义JSON.NET<code>JsonContractResolver</code>不包括映射为表列的属性，因此值不会存储两次。</p>

<p>这种设计的唯一缺点是，有一些地方我们必须对表进行<code>LIKE %x%</code>查询——例如，查找所有标记有给定角色的机器(角色列表存储为Machine表上用管道分隔的nvarchar列)。然而，在所有这些情况下，我们期望这些表有几千个条目，所以我真的不认为这有什么关系。如果测试显示不是这样，我们要么使用全文搜索，要么在一个类似CQRS的索引表中引入一个新表。</p>

<h2>备份、恢复和维护</h2>

<p>由于我们的所有数据都将位于SQL Server或文件共享(NuGet包)中，因此在此阶段，我希望能够删除我们的自定义备份/恢复功能，而只依赖SQL Server备份。我们将提供一些关于如何配置的指导，如果你有一段时间忘记进行SQL备份，我们将在Octopus UI中提供一些反馈，但总的来说，我认为SQL Server的内置备份/恢复功能比我们可能构建的任何功能都要好。</p>

<h2>移民</h2>

<p>从2.6到3.0的升级体验非常简单:您将安装3.0，选择/创建一个要使用的SQL Server数据库，然后选择要导入的Octopus 2.6备份。我们将根据需要转换数据，然后您很快就可以开始运行了。感觉会更像是在2.5到2.6之间升级，而不是从1.6升级到2.0。</p>

<p>到目前为止，我们已经完成了几乎所有到SQL Server的转换，并且还没有进行任何API更改，因此没有任何针对我们的2。X REST API将在3.0上工作。</p>

<h2>测试</h2>

<p>我们收集(选择加入)使用统计数据，并且有一些大型的Octopus安装——300多个项目，1000多台机器，超过20，000次部署。我们将使用这些数据来模拟类似的环境，并确保我们不会发布任何比我们已经拥有的更慢的东西。</p>

<p>我们将首先运行端到端测试，并将当前的2.6版本与即将到来的3.0版本进行比较，以确保我们当前的操作在较小的数据集上不会变慢。然后，我们将继续进行负载测试，以确保在没有疯狂硬件需求的情况下，我们可以处理比目前至少大5倍的安装。</p>

<p>如果有人对这些指标感兴趣，请在评论中告诉我，我会在这个系列的第三篇文章<strong> :-) </strong></p>

                    
                    
</body>
</html>