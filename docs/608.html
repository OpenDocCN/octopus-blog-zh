<html>
<head>
<title>Reusable YAML with CircleCI orbs - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>可重复使用的YAML与CircleCI球体-章鱼部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/reusable-yaml-with-circleci-orbs#2021-08-12">https://octopus.com/blog/reusable-yaml-with-circleci-orbs#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/reusable-yaml-with-circleci-orbs/octopus-circle-ci-orb.png" class="zoom" data-title=""><img src="../Images/ce1c537d64425c266c3f31b257d42072.png" class="img-fluid center" alt="Reusable YAML with CircleCI orbs" data-original-src="https://i.octopus.com/blog/2020-04/reusable-yaml-with-circleci-orbs/octopus-circle-ci-orb.png"/>T2】</a></p>

<p>持续集成和持续交付平台中的一个增长趋势是提供将管道定义为代码的能力，通常使用YAML。这个领域的领导者之一是CircleCI。在这篇文章中，我们将看看CircleCI配置，包括如何使用和创作CircleCI <code>orbs</code>。orb是一个可重用的YAML块，可以跨CircleCI管道使用。您可以从orb中引用功能，而不是在多个文件之间复制和粘贴相同的代码，并保持管道畅通。</p>

<h2 id="what-is-circleci">什么是CircleCI</h2>

<p>CircleCI是一个持续集成平台，它使用基于YAML的配置在Docker容器或虚拟机上执行作业。这些工作可以被编织到一个或多个工作流中，这些工作流将在您将代码提交到源代码控制时执行。</p>

<p>下面是一个名为<code>build</code>的CircleCI作业示例:</p>

<pre><code class="language-yaml">jobs:
  build:
    docker:
      - image: mcr.microsoft.com/dotnet/core/sdk:2.1.607-stretch
    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
    steps:
      - checkout
      - run:
          name: Install Cake
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet tool install -g Cake.Tool --version 0.35.0
      - run:
          name: Build
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet cake build.cake --target="Publish" --packageVersion="$PACKAGE_VERSION"
      - persist_to_workspace:
          root: publish
          paths:
            - "*"
</code></pre>

<p>让我们一点一点地把它分解。</p>

<p>首先，我们定义在哪个docker映像上执行我们的工作:</p>

<pre><code class="language-yaml">    docker:
      - image: mcr.microsoft.com/dotnet/core/sdk:2.1.607-stretch
</code></pre>

<p>我们为包含CircleCI管道号的包版本定义了一个环境变量:</p>

<pre><code class="language-yaml">    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
</code></pre>

<p>我们定义我们的步骤。第一步是检查我们的源代码:</p>

<pre><code class="language-yaml">    steps:
      - checkout
</code></pre>

<p>第二步在执行作业的容器上安装Cake:</p>

<pre><code class="language-yaml">      - run:
          name: Install Cake
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet tool install -g Cake.Tool --version 0.35.0
</code></pre>

<p>第三步调用cake来构建我们的项目:</p>

<pre><code class="language-yaml">      - run:
          name: Build
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet cake build.cake --target="Publish" --packageVersion="$PACKAGE_VERSION"
</code></pre>

<p>最后一步是将我们在<code>publish</code>文件夹中发布的应用程序保存到CircleCI工作区。工作区用于跨多个作业共享资产:</p>

<pre><code class="language-yaml">      - persist_to_workspace:
          root: publish
          paths:
            - "*"
</code></pre>

<p>让我们来看一个使用该作业的工作流。在定义工作流的作业时，我们可以将一个作业设置为依赖于一个或多个其他作业。我们已经创建了一个名为<code>build</code>的工作流，它将依次运行作业<code>build</code>、<code>package</code>、<code>push</code>、<code>create-release</code>和<code>deploy-release</code>:</p>

<pre><code class="language-yaml">workflows:
  version: 2
  build:
    jobs:
      - build
      - package:
          requires:
            - build
      - push:
          requires:
            - package
      - create-release:
          requires:
            - push
      - deploy-release:
          requires:
            - create-release
</code></pre>

<h2 id="reusable-yaml-and-circleci-orbs">可重复使用的YAML和CircleCI球体</h2>

<p>比方说，我们有多个使用Cake构建的项目，步骤都差不多。对于每个项目来说，使用一个标准的过程而不在每个配置中定义相同的YAML不是很好吗？</p>

<p>这就是球体出现的地方！orb定义了可重用的执行器(您的作业将在其中运行的环境)、可在作业中使用的命令以及可在工作流中使用的作业。</p>

<h3 id="using-an-orb">使用球体</h3>

<p>要使用orb，需要在配置中导入一个<code>orbs</code>部分。在下一节中，我们添加了松弛球，命名为<code>slack</code>，并将其映射到球<code>circleci/slack@3.4.2</code>。<code>circleci</code>是包含orb的名称空间。<code>slack</code>是宝珠的名字。<code>3.4.2</code>是我们要用的orb的版本。</p>

<p>在我们的<code>build</code>工作中，我们添加了一个新步骤<code>- slack\notify</code>。这一步是来自那个球的<code>notify</code>命令。您可以查看命令的<a href="https://circleci.com/orbs/registry/orb/circleci/slack#commands-notify" rel="nofollow">来源。这是相当多的YAML，我们不需要包括在我们的配置中。</a></p>

<pre><code class="language-yaml">version: 2.1

orbs:
  slack: circleci/slack@3.4.2

jobs:
  build:
    docker:
      - image: mcr.microsoft.com/dotnet/core/sdk:2.1.607-stretch
    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
    steps:
      - checkout
      - run:
          name: Install Cake
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet tool install -g Cake.Tool --version 0.35.0
      - run:
          name: Build
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet cake build.cake --target="Publish" --packageVersion="$PACKAGE_VERSION"
      - persist_to_workspace:
          root: publish
          paths:
            - OctopusSamples.OctoPetShop.Database
            - OctopusSamples.OctoPetShop.Infrastructure
            - OctopusSamples.OctoPetShop.ProductService
            - OctopusSamples.OctoPetShop.ShoppingCartService
            - OctopusSamples.OctoPetShop.Web
      - slack/notify:
          message: Build ${PACKAGE_VERSION} succeeded
</code></pre>

<p>因此，让我们为我们的蛋糕步骤创建一个球体。</p>

<h3 id="creating-an-inline-orb">创建内联球体</h3>

<p>在上面的例子中，我们在配置中导入了一个orb。我们也可以在配置中直接定义一个orb:</p>

<pre><code class="language-yaml">orbs:
  cake:
    executors:
      cake-executor:
        docker:
          - image: mcr.microsoft.com/dotnet/core/sdk:2.1.607-stretch
    jobs:
      build:
        executor: cake-executor
        parameters:
          cake_version:
            default: "0.35.0"
            type: string
          package_version:
            default: "$PACKAGE_VERSION"
            type: string
          publish_path:
            default: "publish"
            type: string
          target:
            default: "Publish"
            type: string
        steps:
          - checkout
          - run:
              name: Install Cake
              command: |
                export PATH="$PATH:$HOME/.dotnet/tools"
                dotnet tool install -g Cake.Tool --version &lt;&lt; parameters.cake_version &gt;&gt;
          - run:
              name: Build
              command: |
                export PATH="$PATH:$HOME/.dotnet/tools"
                dotnet cake build.cake --target="&lt;&lt; parameters.target &gt;&gt;" --packageVersion="&lt;&lt; parameters.package_version &gt;&gt;"
          - persist_to_workspace:
              root: &lt;&lt; parameters.publish_path &gt;&gt;
              paths:
                - "*"
</code></pre>

<p>在上面的orb中，我们创建了一个执行器，它定义了要使用的Docker映像。我们还定义了一个<code>build</code>作业，它接受Cake版本、包版本、发布路径和Cake目标作为参数。然后，它以类似于我们之前的步骤使用这些参数。</p>

<p>定义orb后，我们可以将工作流更新为以下内容:</p>

<pre><code class="language-yaml">workflows:
  version: 2
  build:
    jobs:
      - cake/build:
          package_version: 1.3.&lt;&lt; pipeline.number &gt;&gt;
      - package:
          requires:
            - cake/build
      - push:
          requires:
            - package
      - create-release:
          requires:
            - push
      - deploy-release:
          requires:
            - create-release
</code></pre>

<p>现在我们的工作流将使用我们在配置中定义的蛋糕orb中的<code>build</code>作业。</p>

<h3 id="publishing-an-orb">发布球体</h3>

<p>为了在多个项目中使用这个orb，我们需要发布它。为此，我们需要安装和配置<a href="https://circleci.com/docs/2.0/orb-author-cli/#install-the-cli-for-the-first-time" rel="nofollow"> CircleCI CLI </a>。</p>

<p>完成后，我们为我们的组织创建一个名称空间:</p>

<pre><code class="language-bash">circleci namespace create octopus-samples github OctopusSamples # replace with your values
</code></pre>

<p>然后，我们在名称空间中创建orb:</p>

<pre><code class="language-bash">circleci orb create octopus-samples/cake # replace with your values
</code></pre>

<p>现在要将内嵌的orb发布到CircleCI。我们需要将orb定义从我们的配置中移到它自己的YAML文件中。我们就把它命名为orb.yml。</p>

<pre><code class="language-yaml">version: 2.1

description: |
  Orb for using Cake with OctopusSamples.

executors:
  cake-executor:
    docker:
      - image: mcr.microsoft.com/dotnet/core/sdk:2.1.607-stretch
jobs:
  build:
    executor: cake-executor
    parameters:
      cake_version:
        default: "0.35.0"
        type: string
      package_version:
        default: "$PACKAGE_VERSION"
        type: string
      publish_path:
        default: "publish"
        type: string
      target:
        default: "Publish"
        type: string
    steps:
      - checkout
      - run:
          name: Install Cake
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet tool install -g Cake.Tool --version &lt;&lt; parameters.cake_version &gt;&gt;
      - run:
          name: Build
          command: |
            export PATH="$PATH:$HOME/.dotnet/tools"
            dotnet cake build.cake --target="&lt;&lt; parameters.target &gt;&gt;" --packageVersion="&lt;&lt; parameters.package_version &gt;&gt;"
      - persist_to_workspace:
          root: &lt;&lt; parameters.publish_path &gt;&gt;
          paths:
            - "*"
</code></pre>

<p>然后我们可以发布它:</p>

<pre><code class="language-bash">circleci orb publish orb.yml octopus-samples/cake@0.0.1
</code></pre>

<p>转眼间。我们有一个<a href="https://circleci.com/orbs/registry/orb/octopus-samples/cake" rel="nofollow">发布的orb </a>和我们的蛋糕制作工作。现在我们可以更新项目的配置，用发布的orb替换内联orb:</p>

<pre><code class="language-yaml">orbs:
  cake: octopus-samples/cake@0.0.1
</code></pre>

<h2 id="experimental-octopus-cli-orb">实验章鱼CLI orb</h2>

<p>说到已发布的球体，如果你同时使用CircleCI和Octopus，看看我们的<a href="https://circleci.com/orbs/registry/orb/octopusdeploylabs/octopus-cli" rel="nofollow">实验Octopus CLI球体</a>。有了这个orb，您可以使用Octopus CLI中的命令子集来管理您的包、发布和部署:</p>

<pre><code class="language-yaml">orbs:
  octo: octopusdeploylabs/octopus-cli@0.0.2

jobs:
  package:
    docker:
      - image: ubuntu:18.04
    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
    steps:
      - octo/install-tools
      - attach_workspace:
          at: publish
      - octo/pack:
          id: "OctopusSamples.OctoPetShop.Database"
          version: "$PACKAGE_VERSION"
          base_path: "publish/OctopusSamples.OctoPetShop.Database"
          out_folder: "package"
      - persist_to_workspace:
          root: package
          paths:
            - OctopusSamples*
  push:
    docker:
      - image: ubuntu:18.04
    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
    steps:
      - octo/install-tools
      - attach_workspace:
          at: package
      - octo/push:
          package: "package/OctopusSamples.OctoPetShop.Database.${PACKAGE_VERSION}.zip"
          server: "$OCTOPUS_SERVER"
          api_key: "$OCTOPUS_API_KEY"
          debug: true
      - octo/build-information:
          package_id: "OctopusSamples.OctoPetShop.Database"
          version: "$PACKAGE_VERSION"
          server: "$OCTOPUS_SERVER"
          api_key: "$OCTOPUS_API_KEY"
          debug: true
  create-release:
    docker:
      - image: ubuntu:18.04
    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
    steps:
      - octo/install-tools
      - octo/create-release:
          project: "Octo Pet Shop"
          server: "$OCTOPUS_SERVER"
          api_key: "$OCTOPUS_API_KEY"
          release_number: $PACKAGE_VERSION
</code></pre>

<p>另外，我们可以继续使用内联orb来进一步减少重复。让我们围绕<code>octo-exp\pack</code>做一个包装:</p>

<pre><code class="language-yaml">orbs:
  cake: octopus-samples/cake@0.0.1
  octo: octopusdeploylabs/octopus-cli@0.0.2
  octopetshop:
    orbs:
      octo: octopusdeploylabs/octopus-cli@0.0.2
    commands:
      pack:
        parameters:
          id:
            type: string
        steps:
          - octo/pack:
              id: "&lt;&lt; parameters.id &gt;&gt;"
              version: $PACKAGE_VERSION
              base_path: "publish/&lt;&lt; parameters.id &gt;&gt;"
              out_folder: "package"

jobs:
  package:
    executor:
      - name: octo/default
    environment:
      PACKAGE_VERSION: 1.3.&lt;&lt; pipeline.number &gt;&gt;
    steps:
      - octo/install-tools
      - attach_workspace:
          at: publish
      - octopetshop/pack:
          id: "OctopusSamples.OctoPetShop.Database"
      - octopetshop/pack:
          id: "OctopusSamples.OctoPetShop.Infrastructure"
      - octopetshop/pack:
          id: "OctopusSamples.OctoPetShop.ProductService"
      - octopetshop/pack:
          id: "OctopusSamples.OctoPetShop.ShoppingCartService"
      - octopetshop/pack:
          id: "OctopusSamples.OctoPetShop.Web"
      - persist_to_workspace:
          root: package
          paths:
            - OctopusSamples*
</code></pre>

<p>因为我们对octo/pack的调用将遵循相同的格式，但对<code>id</code>的值不同，所以我们可以使用<code>octopetshop\pack</code>来抽象这个逻辑。</p>

<h2 id="conclusion">结论</h2>

<p>CircleCI Orbs是为基于YAML的管道创建可重用命令或作业的一种方式。您可以将orb发布到CircleCI，以便跨项目或与其他组织共享。您还可以使用内联orb来帮助开发或者减少您自己的配置中的干扰。</p>

<p>查看<a href="https://circleci.com/orbs/" rel="nofollow"> CircleCI Orbs </a>了解更多信息，查看<a href="https://circleci.com/orbs/registry/orb/octopusdeploylabs/octopus-cli" rel="nofollow">实验章鱼CLI orb </a>了解如何一起使用CircleCI和章鱼的详细信息。</p>

                    
                    
</body>
</html>