<html>
<head>
<title>Deploying ASP.NET Core to Linux using Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Octopus - Octopus Deploy将ASP.NET核心部署到Linux</h1>
<blockquote>原文：<a href="https://octopus.com/blog/aspnet-core-linux#2016-07-11">https://octopus.com/blog/aspnet-core-linux#2016-07-11</a></blockquote>
                        <p>你可能已经看过了。NET Core和ASP.NET Core 1.0最近在<a href="http://www.devnation.org/">开发</a>上发布。</p>

<p>在<a href="https://www.youtube.com/watch?v=MiUrYH3ybX0">主题演讲</a>期间，斯科特·汉斯曼演示了使用Octopus Deploy将. NET核心应用程序部署到Red Hat Linux服务器上(<a href="https://youtu.be/MiUrYH3ybX0?t=48m15s">斯科特在48:15 </a>上台，<a href="https://youtu.be/MiUrYH3ybX0?t=1h2m">在1:02:00 </a>演示Octopus Deploy集成)。</p>

<p>我们很荣幸在斯科特的报告中被提及。我们对这种可能性感到兴奋。网芯。</p>

<p>斯科特可以理解地跳过了血淋淋的细节。对于那些感兴趣的人来说，这篇文章将更深入地探讨ASP.NET核心应用程序在Linux服务器上的真实部署。</p>

<p><strong>免责声明:</strong> IANALG(我不是Linux的家伙)。但我觉得这才是重点。大多数。NET开发人员(至少目前)最熟悉Windows。对于我们许多人来说，Linux是一个陌生的(老实说，是可怕的)新世界。来吧，让我们手牵手...</p>

<h2>最佳食用期</h2>

<p>写一篇技术程序文章的问题是，当你写完它的时候，它通常已经过时了(这个问题在关注。网芯)。</p>

<p>只要有可能，我都会参考官方文档，这些文档更容易维护。</p>

<h2>佐料</h2>

<ul>
<li><p>显然，我们将需要一个Octopus部署服务器。如果你手头没有，那么<a href="https://octopus.com/downloads">下载一个试用</a>实例或者从<a href="https://azure.microsoft.com/en-us/marketplace/partners/octopus/octopusdeployoctopus-deploy/"> Azure Marketplace </a>上升级一个。</p></li>
<li><p>要部署到的Linux服务器。在Hanselman先生的带领下，我们将使用运行Red Hat Enterprise Linux 7.2的服务器。你可以在Azure 中轻松创建一个<a href="https://azure.microsoft.com/en-us/marketplace/partners/redhat/redhatenterpriselinux72/"> RHEL虚拟机。</a></p></li>
<li><p>要部署的ASP.NET核心应用程序。我们将使用一个为此而创建的演示项目:<a href="https://github.com/MJRichardson/aspnetcoredemo">https://github.com/MJRichardson/aspnetcoredemo</a><br/>它很简单，但是包含两个相关的特性:</p>

<ul>
<li>它使用来自<code>appsettings.json</code>的配置设置(我们将把Octopus变量代入其中)</li>
<li>它包含一些位于<code>\conf</code>目录下的配置文件，我们将使用这些文件来配置我们的Linux服务器。</li>
</ul></li>
</ul>

<h2>创建一个包</h2>

<p><em>如果你想跳过创建包，你可以从GitHub库的<a href="https://github.com/MJRichardson/aspnetcoredemo/releases/tag/1.0.0">发布</a>页面下载zip文件。</em></p>

<p>如果您还没有，克隆示例应用程序repo:</p>

<pre><code>git clone https://github.com/MJRichardson/aspnetcoredemo.git
</code></pre>

<p>移动到您克隆项目的目录。下面的命令将从那里运行。</p>

<p><strong>注:</strong>我们章鱼总部有句话:<em>“朋友不让朋友右键-发布”</em>。在一个. NET核心世界里我们可能要把它更新为:<em>“朋友不让朋友dotnet发布”</em>。创建您的包并将其推送到Octopus应该由您的构建服务器来执行。插件可用于大多数流行的构建服务器(例如<a href="http://docs.octopusdeploy.com/display/OD/TeamCity">团队城市</a>、<a href="https://wiki.jenkins-ci.org/display/JENKINS/OctopusDeploy+Plugin">詹金斯</a>、<a href="http://docs.octopusdeploy.com/pages/viewpage.action?pageId=5669025"> TFS </a>)。</p>

<p>见<a href="http://docs.octopusdeploy.com/display/OD/Deploying+ASP.NET+Core+Web+Applications">此处</a>获取我们向Octopus发布ASP.NET核心应用的官方文档。</p>

<p>恢复NuGet包:</p>

<pre><code>dotnet restore src
</code></pre>

<p>将应用程序发布到目录:</p>

<pre><code>dotnet publish src --output published
</code></pre>

<p>目录的内容将是我们的包的内容。你可以用你喜欢的归档工具(我推荐<a href="http://www.7-zip.org"> 7-Zip </a>)将<code>\published</code>(不是目录)的<em>内容</em>归档到一个名为<code>aspnetcoredemo.1.0.0.zip</code>的文件中。</p>

<p>现在把包上传到Octopus Deploy。</p>

<p><img src="../Images/54b19afd729df9cce6bfefd2bf0b76c4.png" alt="Upload Package" data-original-src="https://i.octopus.com/blog/201607-upload_package-C593.png"/></p>

<p>您现在应该可以看到您发布的包:</p>

<p><img src="../Images/964f17259413eb231de19b5a871845dc.png" alt="Published Package" data-original-src="https://i.octopus.com/blog/201607-package_added-7WFL.png"/></p>

<h2>在Octopus中创建一个SSH目标</h2>

<h3>八达通要求</h3>

<p>Red Hat Linux服务器必须满足几个要求才能被添加为Octopus中的SSH目标:</p>

<h4>单声道的</h4>

<p>必须安装Mono。最新说明可在<a href="http://www.mono-project.com/docs/getting-started/install/linux/">单声道文档</a>中找到。对于RHEL服务器，请遵循“CentOS和衍生品”一节。</p>

<p>在一个<em>根外壳</em>中，执行:</p>

<pre><code>yum install yum-utils
rpm --import "http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0x3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF"
yum-config-manager --add-repo http://download.mono-project.com/repo/centos/
yum intall mono-complete
</code></pre>

<h4>SSH密钥</h4>

<p>Octopus将使用SSH密钥对与RHEL服务器进行认证。创建密钥对的指南可以在<a href="http://docs.octopusdeploy.com/display/OD/SSH+Key+Pair#SSHKeyPair-create-key-pair">这里</a>找到。</p>

<p>在您的Linux shell中，生成一个SSH密钥对:</p>

<pre><code>ssh-keygen -t rsa
</code></pre>

<p>将公钥添加到授权密钥中:</p>

<pre><code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>

<p>确保SSH目录的正确所有权:</p>

<pre><code>chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
</code></pre>

<h3>其他要求</h3>

<h4>。网络核心</h4>

<p>显然我们需要。网芯。安装说明。RHEL上的NET Core可以在这里找到<a href="https://www.microsoft.com/net/core#redhat">。为了充分披露，这位作者遵循了</a><a href="https://www.microsoft.com/net/core#centos"> CentOS说明</a>，而不是使用订阅管理器。</p>

<h4>NGINX</h4>

<p>对于我们的小演示应用程序，没有理由不让Kestrel直接服务于请求。但是<a href="https://github.com/aspnet/KestrelHttpServer/issues/612">共识</a>似乎是最佳实践是使用生产级web服务器作为ASP.NET核心应用程序前面的反向代理。在Windows上，这将是IIS。</p>

<p>我们将使用<a href="https://nginx.org/en/"> NGINX </a>。按照位于<a href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/#">https://www . nginx . com/resources/wiki/start/topics/tutorials/install/#</a>的说明，我创建了一个文件<code>/etc/yum.repos.d/nginx.repo</code>，并将其编辑为包含:</p>

<pre><code>[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/rhel/7/$basearch/
gpgcheck=0
enabled=1
</code></pre>

<p>我还修改了<code>/etc/nginx/nginx.conf</code>,加入了下面一行:</p>

<pre><code>include /etc/nginx/sites-enabled/*.conf;
</code></pre>

<p>我们还应该创建目录:</p>

<pre><code>mkdir /etc/nginx/sites-enabled
</code></pre>

<p>这在我们部署应用程序时非常重要。</p>

<p>因此<code>http</code>部分显示为:</p>

<pre><code>http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/sites-enabled/*.conf;
    include /etc/nginx/conf.d/*.conf;
}
</code></pre>

<h4>监督者</h4>

<p>通过执行<code>dotnet</code>实用程序来运行ASP.NET核心应用程序。当您在本地测试时，通过终端直接执行它是没问题的，但是对于部署到服务器，我们需要:</p>

<ul>
<li>为了能够启动和停止服务</li>
<li>对于服务器重新启动时自动启动的服务</li>
</ul>

<p>所以我们要用<a href="http://supervisord.org/">主管</a>。</p>

<p>遵循<a href="http://supervisord.org/installing.html">安装说明</a>:</p>

<pre><code>yum install python-setuptools
easy_install supervisor
</code></pre>

<p>我们将使用默认设置创建一个管理员配置文件，如下图<a href="http://supervisord.org/installing.html#creating-a-configuration-file">所示</a>:</p>

<pre><code>echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf
</code></pre>

<p>现在，我们将创建一个目录来保存特定于应用程序的supervisor配置:</p>

<pre><code>mkdir -p /etc/supervisor/conf.d
</code></pre>

<p>并编辑<code>/etc/supervisor/supervisord.conf</code>并在末尾添加:</p>

<pre><code>[include]
files = /etc/supervisor/conf.d/*.conf
</code></pre>

<p><em>注意:</em>使用<code>easy-install</code>安装监控程序似乎没有向<a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/chap-Managing_Services_with_systemd.html">系统和</a>注册监控程序。这似乎是你肯定想做的事情。点击可查看<a href="https://rayed.com/wordpress/?p=1496">完整的主管设置。</a></p>

<h4>安全性</h4>

<p>默认情况下，您的RHEL服务器可能会被锁定(理应如此)。因为我们将把它用作web服务器，所以我们需要放松束缚。</p>

<p>我不能说我没有资格提供Linux安全建议。请咨询您当地的系统管理员。并提前道歉。</p>

<p>我们需要打开端口80:</p>

<pre><code>firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --reload
</code></pre>

<p>默认情况下，SELinux阻止NGINX将HTTP请求代理给Kestrel。关于这方面的信息可以在找到<a href="https://www.nginx.com/blog/nginx-se-linux-changes-upgrading-rhel-6-6/">。</a></p>

<p>运行以下命令应该可以建立连接:</p>

<pre><code>setsebool httpd_can_network_connect on -P
</code></pre>

<h3>创造环境</h3>

<p>因为所有目标都需要属于一个环境，所以让我们先创建一个环境。</p>

<p><img src="../Images/24861f7ca5f83d66c77221dfa81ded08.png" alt="Create Environment" data-original-src="https://i.octopus.com/blog/201607-environments_add-DMCY.png"/></p>

<h3>创建SSH密钥对帐户</h3>

<p><a href="http://docs.octopusdeploy.com/display/OD/SSH+Key+Pair">章鱼文档</a>。</p>

<p><img src="../Images/f76d5182f06d5c1fc5edf2b615201b15.png" alt="Create SSH KeyPair Account" data-original-src="https://i.octopus.com/blog/201607-ssh_keypair_create-ZHUV.png"/></p>

<p>私钥可以通过以下方式获得:</p>

<pre><code>cat ~/.ssh/id_rsa
</code></pre>

<p>您需要将文本保存到一个文件中，该文件将提供给“私钥”字段，如下所示。</p>

<p><img src="../Images/f6455f42fa3c8167c6385d6f5517f2f0.png" alt="SSH KeyPair Account Details" data-original-src="https://i.octopus.com/blog/201607-ssh_keypair_details-6PR6.png"/></p>

<h3>创建SSH目标</h3>

<p><img src="../Images/c86dacde99f557df93bb237561e541e6.png" alt="Create SSH Target" data-original-src="https://i.octopus.com/blog/201607-ssh_target_create-PE72.png"/></p>

<p><img src="../Images/424778ef96978de19012d9e8a8d7ddbc.png" alt="SSH Target Details" data-original-src="https://i.octopus.com/blog/201607-ssh_target_details-2SYR.png"/></p>

<p>创建目标后，您可以运行运行状况检查以确保连接。</p>

<h2>在Octopus中创建一个项目</h2>

<p>现在我们将创建一个项目来部署我们的ASP.NET核心演示应用程序。</p>

<p><img src="../Images/4b3708cb29183b65a46a16ec2c6757fa.png" alt="Create Project" data-original-src="https://i.octopus.com/blog/201607-project_create-K7ZZ.png"/></p>

<h3>添加部署包步骤</h3>

<p>向您的项目添加一个<em>部署包</em>步骤。</p>

<p><img src="../Images/f1d3ee9fb2a9f0de38a6094c13520ddc.png" alt="Add Package Step" data-original-src="https://i.octopus.com/blog/201607-add_package_step-RDPN.png"/></p>

<p>它将引用我们之前上传的包。</p>

<p><img src="../Images/5a127a5c44376038a532c6dc154cb39d.png" alt="Package Step Details" data-original-src="https://i.octopus.com/blog/201607-deploy_pkg_step_details-ZKZ8.png"/></p>

<p>我们将为此步骤启用两个功能:</p>

<p><img src="../Images/78e83cf66df56b2b3e7aeb862916c8a0.png" alt="Package Step Features" data-original-src="https://i.octopus.com/blog/201607-deploy_pkg_step_features-DTRX.png"/></p>

<h4>JSON配置变量</h4>

<p>我们将使用<a href="http://docs.octopusdeploy.com/display/OD/JSON+Configuration+Variables+Feature"> JSON配置变量特性</a>来转换我们的<code>appsettings.json</code>文件。</p>

<p>在这种情况下，我们只是简单地改变了呈现的消息，但这演示了Octopus如何在JSON配置文件中转换层次变量。</p>

<h4>替换文件中的变量</h4>

<p>我们还将使用<a href="http://docs.octopusdeploy.com/display/OD/Substitute+Variables+in+Files">文件中的替代变量特性</a>为我们的NGINX和Supervisor配置文件提供变量。</p>

<p>如果您查看这些文件(位于<code>src\aspnetcoredemo\deployment</code>)，您会看到它们包含Octopus变量的占位符。例如，<code>nginx.conf</code>文件包含了<code>#{IPAddress}</code>变量:</p>

<pre><code>server {
 listen 80;
 server_name #{IPAddress};
 location / {
     proxy_pass http://localhost:5000;
     proxy_http_version 1.1;
     proxy_set_header Upgrade $http_upgrade;
     proxy_set_header Connection keep-alive;
     proxy_set_header Host $host;
     proxy_cache_bypass $http_upgrade;
 }
}
</code></pre>

<h3>配置NGINX</h3>

<p>接下来，我们将添加一个<em>运行脚本</em>步骤，将我们的NGINX配置文件移动到<code>/etc/nginx/sites-enabled</code>，并告诉NGINX重新加载。</p>

<p><img src="../Images/43fe612b56788eeb5ec8d79c71206d82.png" alt="NGINX Script Step Details" data-original-src="https://i.octopus.com/blog/201607-nginx_step_details-2YS7.png"/></p>

<p>脚本来源是:</p>

<pre><code>installed=$(get_octopusvariable 'Octopus.Action[Deploy Pkg].Output.Package.InstallationDirectoryPath')
nginxConf='/conf/nginx.conf'
dest='/etc/nginx/sites-enabled/aspnetcoredemo.conf'
echo "Moving $installed$nginxConf to $dest"
sudo mv -f $installed$nginxConf $dest

echo 'Reloading NGINX'
sudo nginx -s reload
</code></pre>

<p>第一行获取解压后的包的路径。</p>

<p>能够将文件放入<code>sites-enabled</code>目录使我们不必修改现有的<code>nginx.conf</code>。</p>

<p>显然，一种常见的方法是同时拥有一个<code>sites-available</code>和<code>sites-enabled</code>目录。实际的配置文件被部署到<code>sites-available</code>，符号链接被添加到<code>sites-enabled</code>。然后是包含在<code>nginx.conf</code>中的<code>sites-enabled</code>。我会把这个留给家庭作业。</p>

<h3>运行主管</h3>

<p>现在我们将添加另一个<em>运行脚本</em>步骤，将我们的Supervisor配置文件移动到<code>/etc/supervisor/conf.d/aspnetcoredemo.conf</code>并告诉Supervisor重新加载。</p>

<p><img src="../Images/fe45b2f0806ea7e9a76b0e088bd289fa.png" alt="Supervisor Script Step" data-original-src="https://i.octopus.com/blog/201607-supervisor_step_details-ZLYS.png"/></p>

<p>脚本来源是:</p>

<pre><code>installed=$(get_octopusvariable "Octopus.Action[Deploy Pkg].Output.Package.InstallationDirectoryPath")
supervisorConf='/conf/supervisor.conf'
dest='/etc/supervisor/conf.d/aspnetcoredemo.conf'
echo "Moving $installed$supervisorConf to $dest"
sudo mv -f $installed$supervisorConf $dest

echo 'Reloading supervisor'
sudo supervisorctl reload
</code></pre>

<h3>变量</h3>

<p>最后，我们需要添加将被替换到配置文件中的变量。</p>

<p><img src="../Images/a5543c6ab40b95e43bf2fa1db8d0e19a.png" alt="Variables" data-original-src="https://i.octopus.com/blog/201607-project_variables-JTV5.png"/></p>

<h2>部署</h2>

<p>此时，您的部署过程应该类似于:</p>

<p><img src="../Images/12a366dff969585c8d0b50b800c241b9.png" alt="Deployment Process" data-original-src="https://i.octopus.com/blog/201607-deployment_process-9YG4.png"/></p>

<p>你还在等什么？创建一个版本，然后部署！</p>

<p><img src="../Images/4ffcd68e28eecffbf0f6b9a5b56f3754.png" alt="Deployment Summary" data-original-src="https://i.octopus.com/blog/201607-deploy_task_summary-TDPX.png"/></p>

<p>如果一切顺利，您已经将ASP.NET核心应用程序部署到Red Hat Enterprise Linux服务器上。</p>

<p><img src="../Images/6d462059bf2737284a9fe374cf551068.png" alt="Browser serving application" data-original-src="https://i.octopus.com/blog/201607-linux_hello_world-ZN7P.png"/></p>

<p><em>自我提醒:将balloons.png添加到示例应用程序主页；)</em></p>

<h2>XPlat</h2>

<p>虽然这超出了本文的范围，但值得一提的是，只需很少的努力，我们就可以将同一个包部署到Windows 2012 R2服务器<em>和Azure Web应用</em>上。</p>

<p><img src="../Images/a14855f5794b8dfd4b9bf8296012ba34.png" alt="Windows, Azure and Linux Deployment Log" data-original-src="https://i.octopus.com/blog/201607-xplat_deploy_log-UJ8P.png"/></p>

<h2>未来</h2>

<p>。NET Core为我们改进部署到Linux目标的故事提供了一个很好的机会。</p>

<h3>无单声道</h3>

<p>事实上，目前您必须在您的Linux服务器上安装Mono框架，以使其成为Octopus部署目标，这在许多情况下是很尴尬的。我们正朝着使用。NET核心，完全消除了对Mono的依赖。</p>

<h3>无脚本</h3>

<p>我们主要关注的是提供将您想要的部署到您想要的位置的能力，而无需您自己编写脚本。章鱼在历史上一直是目标。NET，还有。NET一直是针对Windows的。。NET Core已经突破了Linux的防火墙。我们应该能够逐步完成并实现一些更多的以Linux为中心的部署步骤。</p>

<h2>反馈</h2>

<p>如果您正在使用Octopus(甚至考虑使用它)进行部署。NET核心应用程序移植到Linux上，我们希望收到您的来信。</p>

<p>请告诉我们哪些可行，哪些不可行，以及我们如何才能让您的部署更简单、更可靠。</p>

<p><em>愉快的(跨平台)部署！</em></p>

                    
                    
</body>
</html>