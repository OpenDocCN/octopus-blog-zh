<html>
<head>
<title>Perceptual consistency in RavenDB - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>RavenDB - Octopus部署中的感知一致性</h1>
<blockquote>原文：<a href="https://octopus.com/blog/perceptual-consistency-in-ravendb#2015-09-25">https://octopus.com/blog/perceptual-consistency-in-ravendb#2015-09-25</a></blockquote>
                        <p>在“<a href="http://octopusdeploy.com/blog/designing-for-eventual-consistency"> UI设计的最终一致性</a>”中，我写了我们通常如何得到这样的错误报告:</p>

<blockquote>
  <p>我转到“添加机器”页面，输入机器信息，单击保存，但是当我转到“环境”页面时，我的机器没有列出。几秒钟后，我点击刷新，它就在那里。</p>
</blockquote>

<p>这是Raven使用<a href="http://ravendb.net/docs/2.0/client-api/querying/stale-indexes">异步索引</a>的结果。作为一名使用RavenDB的开发人员，你应该拥抱<strong>最终一致性</strong>。有一些常见的模式可以处理这种情况，例如:</p>

<ul>
<li>您可以将“添加机器”请求作为一个命令接受，并将其排队等待处理，然后在处理完成时重定向用户；或者，</li>
<li>您可以将新机器存储在中间缓存中，并在查询列表时包含它</li>
</ul>

<p>当你的操作是“提交一个银行交易退款请求”时，这是有意义的。但是当你有一打不同的文档类型，你需要一点CRUD，而你又不是网络规模的时候，坦白地说，这些模式是多余的。</p>

<p>所以在我的天真中，Octopus 1.0被分散了:</p>

<pre><code>.Customize(x =&gt; x.WaitForNonStaleResultsAsOfNow())
</code></pre>

<p>这当然有问题，对于Octopus 2.0，我决定接受Raven最终的一致性。</p>

<p>首先，我让REST API返回一个标志，指示查询结果是否过时。然后，我们的UI会呈现一条消息来通知用户，或者在一秒钟后自动刷新以尝试获得非陈旧的结果。虽然它让用户界面感觉更快，但有点不协调。</p>

<p>然而，当构建一些命令行工具来使用API时，我意识到大多数时候，这些工具宁愿等待非陈旧的结果。因此，它成为了一个标志(例如，<code>/api/environments?nonStale=true</code>)，作为URI模板的一部分提供。这个<a href="http://lostechies.com/jimmybogard/2013/05/15/eventual-consistency-in-rest-apis/">引起了一些争论</a>；毕竟，客户应该能够要求这样的事情吗？</p>

<h2>知觉一致性</h2>

<p>我对这两种解决方案都不满意，我觉得没有好的折中方案。然后我偶然发现<a href="https://groups.google.com/forum/#!topic/ravendb/ncy9_fwF7P4">这个帖子</a>，克里斯·马里斯克提出了一个<a href="https://groups.google.com/d/msg/ravendb/ncy9_fwF7P4/IgqG-pOMl8kJ">巧妙的建议</a>(重点是我的):</p>

<blockquote>
  <p>您想写这个记录，<strong>然后在同一个请求</strong>中用waitfornonsaleresultsasoflashwrite查询那个索引，然后在索引同步后将用户重定向到列表。这避免了使普通的操作读总是等待，而使不普通的操作写必须等待。</p>
</blockquote>

<p>我以前从未见过这个建议，但我认为它很棒。我认为这是“感知一致性”，或者“每个用户的一致性”。</p>

<p><img src="../Images/f22889f6ab19ba8fa0aff1f9897ed318.png" alt="Perceptual consistency" data-original-src="https://i.octopus.com/blog/migrated/Screen_Shot_2013-09-02_at_8_47_00_PM_vhpcgy.png"/></p>

<p>它的意思是，在Octopus REST API中，当您执行PUT/POST/DELETE时，我们将在返回成功之前等待索引不陈旧(至少一小会儿)。因此，当您点击“创建机器”时，您可能会看到一个轻微的停顿。但是当您被重定向并执行GET时，请求者<strong>不会</strong>等待非陈旧结果。您不会在意，因为当您被重定向时，索引已经足够新，可以包含您刚刚添加的机器。太棒了。</p>

<p>我们仍然会在查询结果上提供non-stale标志来指示GET请求的结果是否过时，但是没有办法告诉API是否要等待非过时的结果。从用户界面的角度来看，你总能看到一致的结果。</p>

                    
                    
</body>
</html>