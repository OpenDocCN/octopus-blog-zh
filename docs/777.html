<html>
<head>
<title>Using Jenkins Pipelines with Octopus - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Jenkins管道和Octopus - Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/using-jenkins-pipelines#2021-08-12">https://octopus.com/blog/using-jenkins-pipelines#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/jenkins-plugin.png" class="zoom" data-title=""><img src="../Images/c1b04b4477b2ca5f4ffedbde1202003c.png" class="img-fluid center" alt="Using Jenkins Pipelines with Octopus" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/jenkins-plugin.png"/>T2】</a></p>

<p>Octopus Jenkins插件最近的更新增加了对管道的支持，允许创建包并将其推送到Octopus，创建和部署发布，以及将提交消息等元数据与包相关联。</p>

<p>在本文中，我们将介绍创建一个简单的Jenkins管道来部署一个示例Java应用程序的过程。</p>

<h2 id="install-and-configure-the-plugin">安装和配置插件</h2>

<p>Octopus插件可通过Jenkins插件管理器获得:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/plugin.png" class="zoom" data-title=""><img src="../Images/af1d625749b67fac701b91e2ac5ed242.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/plugin.png"/>T2】</a></p>

<p>这个插件通过调用Octopus CLI来工作。CLI可以单独安装，但在本例中，我们将让Jenkins通过自定义工具插件下载并安装CLI:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/customtools.png" class="zoom" data-title=""><img src="../Images/7a266b01017200d25e43e08583398e19.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/customtools.png"/>T2】</a></p>

<p>安装Octopus和自定义工具插件后，打开Jenkins <strong>全局工具配置</strong>页面，点击<strong>添加自定义工具</strong>按钮。</p>

<p>给新工具命名为<strong>Octopus CLI</strong>，并为二进制归档字段的<strong>下载URL提供<a href="https://octopus.com/downloads/octopuscli#linux"> Octopus CLI下载路径</a>，它将是一个类似于<a href="https://download.octopusdeploy.com/octopus-tools/7.4.0/OctopusTools.7.4.0.linux-x64.tar.gz" rel="nofollow">https://Download . Octopus deploy . com/Octopus-tools/7 . 4 . 0/Octopus tools . 7 . 4 . 0 . Linux-x64 . tar . gz</a>的URL(最新版本请访问<a href="https://octopus.com/downloads/octopuscli#linux">下载页面</a>):</strong></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/customtool.png" class="zoom" data-title=""><img src="../Images/cba32ee079ffc7e65819f65a86415710.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/customtool.png"/>T2】</a></p>

<p>当我们在管道中引用一个定制工具时，Jenkins会将工具的归档内容下载、提取并复制到一个类似于<code>/var/lib/jenkins/tools/com.cloudbees.jenkins.plugins.customtools.CustomTool</code>的目录中(根据Jenkins主目录，<code>/var/lib/jenkins</code>可能会因代理而异)。在本例中，Jenkins将Octopus CLI可执行文件提取到<code>/var/lib/jenkins/tools/com.cloudbees.jenkins.plugins.customtools.CustomTool/OctoCLI/octo</code>。</p>

<p>事先知道了这条路径，我们就可以在Jenkins中定义Octopus CLI工具了。在<strong> Octopus Deploy CLI </strong>部分，将<strong>默认</strong>工具的路径设置为<code>/var/lib/jenkins/tools/com.cloudbees.jenkins.plugins.customtools.CustomTool/OctoCLI/octo</code>。可以忽略该警告，因为当我们引用先前定义的定制工具运行管道时，该路径将是可用的:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/octo.png" class="zoom" data-title=""><img src="../Images/2ad6c3235c2d808ed1db75640d16342b.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/octo.png"/>T2】</a></p>

<p>要连接到Octopus服务器，我们需要创建一个API密钥:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/apikey.png" class="zoom" data-title=""><img src="../Images/57f07f7b4c05089cdfcf46a3ea81d963.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/apikey.png"/>T2】</a></p>

<p>然后在Jenkins <strong>配置系统</strong>屏幕中配置Octopus URL和API密钥:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/octopusdetails.png" class="zoom" data-title=""><img src="../Images/a7b8978551ca161c346f3f7324fe0577.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/octopusdetails.png"/>T2】</a></p>

<p>我们现在已经配置了所需的设置来支持Octopus插件。然而，我们将构建的示例Java应用程序需要另外两个工具:Maven和JDK。这些在Jenkins <strong>全球工具配置</strong>页面中进行配置。</p>

<p>在过去，获得JDK最简单的方法是从Oracle下载。但是现在，许可已经改变，这意味着大多数开发人员将使用OpenJDK构建。许多公司都提供OpenJDK版本，对于这个例子，我们将使用由<a href="https://adoptopenjdk.net" rel="nofollow"> AdoptOpenJDK </a>提供的版本。</p>

<p>我们将配置一个名为<strong> Java </strong>的JDK工具，并从<a href="https://github.com/AdoptOpenJDK/openjdk14-binaries/releases/download/jdk-14.0.1%2B7/OpenJDK14U-jdk_x64_linux_hotspot_14.0.1_7.tar.gz" rel="nofollow">https://github . com/adopt open JDK/open JDK 14-binaries/releases/download/JDK-14 . 0 . 1% 2b 7/open JDK 14 u-JDK _ x64 _ Linux _ hotspot _ 14 . 0 . 1 _ 7 . tar . gz</a>下载归档文件。解压子目录<strong> jdk-14.0.1+7 </strong>(这就是AdoptOpenJDK在归档中打包路径的方式):</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/jdk.png" class="zoom" data-title=""><img src="../Images/402f5185afcce1fed84d217d7cbcb56d.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/jdk.png"/>T2】</a></p>

<p>然后创建了一个名为<strong> Maven 3 </strong>的新Maven工具，它可以下载最新版本:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/maven.png" class="zoom" data-title=""><img src="../Images/25d05f0325a8024d7020c60e0aff86bb.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/maven.png"/>T2】</a></p>

<p>有了这些设置，我们就可以创建我们的第一个管道了。</p>

<h2 id="an-example-pipeline">一个示例流水线</h2>

<p>Jenkins有两种类型的管道:<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#scripted-pipeline" rel="nofollow">脚本式</a>和<a href="https://www.jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline" rel="nofollow">声明式</a>。通常推荐使用声明性管道，这是我们将在示例管道中使用的格式。</p>

<p>我们将构建一个名为Random Quotes的示例应用程序，它可以在<a href="https://github.com/OctopusSamples/RandomQuotes-Java" rel="nofollow"> GitHub </a>上找到。管道在名为<a href="https://github.com/OctopusSamples/RandomQuotes-Java/blob/master/Jenkinsfile" rel="nofollow"> Jenkinsfile </a>的文件中定义。Jenkinsfile的副本如下所示:</p>

<pre><code class="language-groovy">pipeline {
    //  parameters here provide the shared values used with each of the Octopus pipeline steps.
    parameters {
        // The space ID that we will be working with. The default space is typically Spaces-1.
        string(defaultValue: 'Spaces-1', description: '', name: 'SpaceId', trim: true)
        // The Octopus project we will be deploying.
        string(defaultValue: 'RandomQuotes', description: '', name: 'ProjectName', trim: true)
        // The environment we will be deploying to.
        string(defaultValue: 'Dev', description: '', name: 'EnvironmentName', trim: true)
        // The name of the Octopus instance in Jenkins that we will be working with. This is set in:
        // Manage Jenkins -&gt; Configure System -&gt; Octopus Deploy Plugin
        string(defaultValue: 'Octopus', description: '', name: 'ServerId', trim: true)
    }
    /*
        These are the tools we need for this pipeline. They are defined in Manage Jenkins -&gt; Global Tools Configuration.
    */
    tools {
        maven 'Maven 3'
        jdk 'Java'
    }
    agent any
    stages {
        /*
            The OctoCLI tool has been defined with the Custom Tools plugin: https://plugins.jenkins.io/custom-tools-plugin/
            This is a convenient way to have a tool placed on an agent, especially when using the Jenkins Docker image.
            This plugin will extract a .tar.gz file (for example https://download.octopusdeploy.com/octopus-tools/7.3.7/OctopusTools.7.3.7.linux-x64.tar.gz)
            to a directory like /var/jenkins_home/tools/com.cloudbees.jenkins.plugins.customtools.CustomTool/OctoCLI/Octo.
            This directory is then specified as the default location of the Octo CLI in Jenkins under
            Manage Jenkins -&gt; Global Tools Configuration -&gt; Octopus Deploy CLI.
        */
        stage ('Add tools') {
            steps {
                sh "echo \"OctoCLI: ${tool('OctoCLI')}\""
            }
        }
        stage('build') {
            steps {
                // Update the Maven project version to match the current build
                sh(script: "mvn versions:set -DnewVersion=1.0.${BUILD_NUMBER}", returnStdout: true)
                // Package the code
                sh(script: "mvn package", returnStdout: true)
            }
        }
        stage('deploy') {
            steps {                
                octopusPack additionalArgs: '', includePaths: "${env.WORKSPACE}/target/randomquotes.1.0.${BUILD_NUMBER}.jar", outputPath: "${env.WORKSPACE}", overwriteExisting: false, packageFormat: 'zip', packageId: 'randomquotes', packageVersion: "1.0.${BUILD_NUMBER}", sourcePath: '', toolId: 'Default', verboseLogging: false
                octopusPushPackage additionalArgs: '', overwriteMode: 'FailIfExists', packagePaths: "${env.WORKSPACE}/target/randomquotes.1.0.${BUILD_NUMBER}.jar", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default'
                /*
                    Note that the gitUrl param is passed manually from the environment variable populated when this Jenkinsfile is downloaded from Git.
                    This is from the Jenkins "Global Variable Reference" documentation:
                    SCM-specific variables such as GIT_COMMIT are not automatically defined as environment variables; rather you can use the return value of the checkout step.
                    This means if this pipeline checks out its own code, the checkout method is used to return the details of the commit. For example:
                    stage('Checkout') {
                        steps {
                            script {
                                def checkoutVars = checkout([$class: 'GitSCM', userRemoteConfigs: [[url: 'https://github.com/OctopusSamples/RandomQuotes-Java.git']]])
                                env.GIT_URL = checkoutVars.GIT_URL
                                env.GIT_COMMIT = checkoutVars.GIT_COMMIT
                            }
                            octopusPushBuildInformation additionalArgs: '', commentParser: 'GitHub', overwriteMode: 'FailIfExists', packageId: 'randomquotes', packageVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default', verboseLogging: false, gitUrl: "${GIT_URL}", gitCommit: "${GIT_COMMIT}"
                        }
                    }
                */
                octopusPushBuildInformation additionalArgs: '', commentParser: 'GitHub', overwriteMode: 'FailIfExists', packageId: 'randomquotes', packageVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default', verboseLogging: false, gitUrl: "${GIT_URL}", gitCommit: "${GIT_COMMIT}"
                octopusCreateRelease additionalArgs: '', cancelOnTimeout: false, channel: '', defaultPackageVersion: '', deployThisRelease: false, deploymentTimeout: '', environment: "${EnvironmentName}", jenkinsUrlLinkback: false, project: "${ProjectName}", releaseNotes: false, releaseNotesFile: '', releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", tenant: '', tenantTag: '', toolId: 'Default', verboseLogging: false, waitForDeployment: false
                octopusDeployRelease cancelOnTimeout: false, deploymentTimeout: '', environment: "${EnvironmentName}", project: "${ProjectName}", releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", tenant: '', tenantTag: '', toolId: 'Default', variables: '', verboseLogging: false, waitForDeployment: true
            }
        }
    }
}
</code></pre>

<p>让我们把这个文件分解一下。</p>

<p>所有声明性管道都以<code>pipeline</code>开头:</p>

<pre><code>pipeline {
</code></pre>

<p>为了使我们的Jenkinsfile通用，我们将所有Octopus特定变量作为参数公开。Jenkins第一次执行这个管道时，将使用默认值。然后运行管道将这些属性添加到Jenkins项目中，这意味着当第二次手动触发构建时，将通过web UI提示您输入这些属性:</p>

<pre><code>    //  parameters here provide the shared values used with each of the Octopus pipeline steps.
    parameters {
        // The space ID that we will be working with. The default space is typically Spaces-1.
        string(defaultValue: 'Spaces-1', description: '', name: 'SpaceId', trim: true)
        // The Octopus project we will be deploying.
        string(defaultValue: 'RandomQuotes', description: '', name: 'ProjectName', trim: true)
        // The environment we will be deploying to.
        string(defaultValue: 'Dev', description: '', name: 'EnvironmentName', trim: true)
        // The name of the Octopus instance in Jenkins that we will be working with. This is set in:
        // Manage Jenkins -&gt; Configure System -&gt; Octopus Deploy Plugin
        string(defaultValue: 'Octopus', description: '', name: 'ServerId', trim: true)
    }
</code></pre>

<p>我们在前面部分配置的Maven和Java工具通过<code>tools</code>部分包含在这个管道中:</p>

<pre><code>    tools {
        maven 'Maven 3'
        jdk 'Java'
    }
</code></pre>

<p>这个构建将在任何代理上运行，这用<code>agent</code>设置来表示:</p>

<pre><code>    agent any
</code></pre>

<p>然后，我们定义管道将经过的<code>stages</code>:</p>

<pre><code>    stages {
</code></pre>

<p>第一阶段回显名为<strong> OctoCLI </strong>的自定义工具的位置。有趣的是，自定义工具插件并没有在<code>tools</code>部分定义。本期<a href="https://issues.jenkins-ci.org/browse/JENKINS-30680" rel="nofollow">詹金斯刊</a>有关于这一限制的细节。但是通过调用<code>tool('OctoCLI')</code>，定制工具作为管道的一部分被安装:</p>

<pre><code>        stage ('Add tools') {
            steps {
                sh "echo \"OctoCLI: ${tool('OctoCLI')}\""
            }
        }
</code></pre>

<p>构建阶段调用Maven CLI(由于前面提到的Maven工具，它现在位于<code>PATH</code>上)来设置项目的版本并打包它:</p>

<pre><code>        stage('build') {
            steps {
                // Update the Maven project version to match the current build
                sh(script: "mvn versions:set -DnewVersion=1.0.${BUILD_NUMBER}", returnStdout: true)
                // Package the code
                sh(script: "mvn package", returnStdout: true)
            }
        }
</code></pre>

<p>最后一个阶段是用Octopus部署软件包:</p>

<pre><code>        stage('deploy') {
            steps {
</code></pre>

<p>我们首先将JAR文件打包成一个ZIP文件。我们不会使用生成的ZIP文件，因为Java部署通常直接使用JAR或WAR文件，将这些文件嵌套在第二个ZIP存档中是多余的。但是此处包含的步骤是作为使用<code>octopusPack</code>步骤的示例:</p>

<pre><code>                octopusPack additionalArgs: '', includePaths: "${env.WORKSPACE}/target/randomquotes.1.0.${BUILD_NUMBER}.jar", outputPath: "${env.WORKSPACE}", overwriteExisting: false, packageFormat: 'zip', packageId: 'randomquotes', packageVersion: "1.0.${BUILD_NUMBER}", sourcePath: '', toolId: 'Default', verboseLogging: false
</code></pre>

<p><code>octopusPushPackage</code>步骤将JAR文件推送到Octopus内置提要。请注意我们是如何引用先前定义为<code>${ServerId}</code>和<code>${SpaceId}</code>的参数的:</p>

<pre><code>                octopusPushPackage additionalArgs: '', overwriteMode: 'FailIfExists', packagePaths: "${env.WORKSPACE}/target/randomquotes.1.0.${BUILD_NUMBER}.jar", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default'
</code></pre>

<p>除了应用程序包，我们还将使用<code>octopusPushBuildInformation</code>步骤推送一个元数据包，其中包括GIT提交消息和链接。稍后我们将在Octopus中看到这些信息:</p>

<pre><code>                octopusPushBuildInformation additionalArgs: '', commentParser: 'GitHub', overwriteMode: 'FailIfExists', packageId: 'randomquotes', packageVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", toolId: 'Default', verboseLogging: false, gitUrl: "${GIT_URL}", gitCommit: "${GIT_COMMIT}"
</code></pre>

<p>这里需要注意的一点是，<code>GIT_URL</code>和<code>GIT_COMMIT</code>环境变量只有在Jenkins从GIT中提取包含Jenkinsfile的项目时才可用。如果管道直接进入Jenkins项目，您负责使用<code>checkout</code>步骤从GIT中检查代码，并根据返回对象中的属性创建<code>GIT_URL</code>和<code>GIT_COMMIT</code>环境变量:</p>
<pre><code>                script {
                    def checkoutVars = checkout([$class: 'GitSCM', userRemoteConfigs: [[url: 'https://github.com/OctopusSamples/RandomQuotes-Java.git']]])
                    env.GIT_URL = checkoutVars.GIT_URL
                    env.GIT_COMMIT = checkoutVars.GIT_COMMIT
                }
</code></pre>


<p>通过<code>octopusCreateRelease</code>步骤在Octopus中创建一个发布。我们再次引用了类似<code>${EnvironmentName}</code>、<code>${ProjectName}</code>、<code>${ServerId}</code>和<code>${SpaceId}</code>的参数:</p>

<pre><code>                octopusCreateRelease additionalArgs: '', cancelOnTimeout: false, channel: '', defaultPackageVersion: '', deployThisRelease: true, deploymentTimeout: '', environment: "${EnvironmentName}", jenkinsUrlLinkback: false, project: "${ProjectName}", releaseNotes: false, releaseNotesFile: '', releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", tenant: '', tenantTag: '', toolId: 'Default', verboseLogging: false, waitForDeployment: false
</code></pre>

<p>最后，我们用<code>octopusDeployRelease</code>步骤部署发布:</p>

<pre><code>                octopusDeployRelease cancelOnTimeout: false, deploymentTimeout: '', environment: "${EnvironmentName}", project: "${ProjectName}", releaseVersion: "1.0.${BUILD_NUMBER}", serverId: "${ServerId}", spaceId: "${SpaceId}", tenant: '', tenantTag: '', toolId: 'Default', variables: '', verboseLogging: false, waitForDeployment: true
            }
        }
    }
}
</code></pre>

<h2 id="create-the-jenkins-project">创建詹金斯项目</h2>

<p>在Jenkins中，构建来源于GIT存储库的管道非常容易。新建一个<strong>管道</strong>项目，从SCM 中选择<strong>管道脚本选项，将<strong>库URL </strong>设置为<a href="https://github.com/OctopusSamples/RandomQuotes-Java.git" rel="nofollow">https://github.com/OctopusSamples/RandomQuotes-Java.git</a>:</strong></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/jenkinsproject.png" class="zoom" data-title=""> T32 </a></p>

<p>然后，您可以触发构建。注意第一次运行构建时，不会提示您输入任何参数。参数通过管道添加到项目中，因此管道需要先运行一次。第一次运行后，您可以选择<strong>使用参数</strong>构建，并显示管道参数提示:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/parameters.png" class="zoom" data-title=""><img src="../Images/f755fcf67a3ff1b8b4a80b005d868110.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/parameters.png"/>T2】</a></p>

<h2 id="viewing-the-build-information">查看构建信息</h2>

<p>上面的管道推了两个包给章鱼。第一个是Maven创建的JAR文件。第二个是通过调用<code>octopusPushBuildInformation</code>推送的，创建并推送一个构建信息包。这个包包含关于包的元数据，包括返回到Jenkins构建和GIT提交信息的链接。</p>

<p>如果我们看一下被推送到内置提要的JAR包，我们会看到它有一个<strong>构建信息</strong>部分，指出这个包是由Jenkins构建的，还有一个链接指向Jenkins构建:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/buildinfo1.png" class="zoom" data-title=""><img src="../Images/7a278627948a034853e023705f511d0a.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/buildinfo1.png"/>T2】</a></p>

<p>但是请注意，没有关于GIT提交的信息。您将只能看到关于两次构建之间提交的信息，因为在Jenkins构建之间GIT存储库中没有发生任何变化，所以没有提交被记录。为了演示与元数据打包在一起的提交历史，我们将提交并在Jenkins中重建项目。现在，构建信息包含了Jenkins构建之间提交的链接:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/buildinfo2.png" class="zoom" data-title=""><img src="../Images/8597ce021f3ba01051b60927e34f39ef.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/buildinfo2.png"/>T2】</a></p>

<p>你可以在我们的文档中找到更多关于构建信息的信息。</p>

<h2 id="pipelines-in-blue-ocean">蓝色海洋中的管道</h2>

<p><a href="https://www.jenkins.io/projects/blueocean/" rel="nofollow">蓝色海洋</a>是詹金斯建造体验的再现。它作为插件安装:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/blueocean.png" class="zoom" data-title=""><img src="../Images/9cdd35d0943cbc97667dad63ac82cb94.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/blueocean.png"/></a>T2】</p>

<p>蓝海界面通过直观的交互式用户界面可视化管道。虽然旧的自由式詹金斯项目可以在蓝海观看，但体验已针对管道进行了大量优化:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/blueoceanpipeline.png" class="zoom" data-title=""><img src="../Images/28652a2dd5f6a80514e1e8074db8291f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2020-07/using-jenkins-pipelines/blueoceanpipeline.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>Jenkins管道是创建和共享可重复应用构建的强大工具。它们本身是有用的，当与像<a href="https://www.jenkins.io/projects/blueocean/" rel="nofollow"> Blue Ocean </a>这样的Jenkins插件结合时，提供了现代构建体验的基础。有了Octopus Jenkins插件中的新功能，部署可以通过Jenkins管道进行管理，步骤组合与自由式项目中相同。</p>

<p>如果你正在寻找一种快速测试Jenkins和Octopus的方法，可以看看<a href="https://octopus.com/testdrive?utm_campaign=nav&amp;utm_content=resources-testdrive">项目TestDrive </a>，该项目通过预装Jenkins和Octopus的vagger提供了多个虚拟机。</p>

                    
                    
</body>
</html>