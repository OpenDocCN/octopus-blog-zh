<html>
<head>
<title>Creating workers with the Tentacle Docker image - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用触手Docker图像创建工人- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/workers-as-containers#2021-10-14">https://octopus.com/blog/workers-as-containers#2021-10-14</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-02/workers-as-containers/blogimage-worker-as-containers.png" class="zoom" data-title=""><img src="../Images/7513dc81c0cdb0e3c143a23bd763524f.png" class="img-fluid center" alt="Creating workers with the Tentacle Docker image" data-original-src="https://i.octopus.com/blog/2021-02/workers-as-containers/blogimage-worker-as-containers.png"/>T2】</a></p>

<p>我最近需要在Octopus Deploy的<a href="https://samples.octopus.app" rel="nofollow">样本</a>云实例上创建一些额外的临时工人。由于我只需要短命的工人，集装箱似乎是完美的解决方案。我把它们旋转起来，它们做一些工作，然后我把它们拆下来。在这篇文章中，我演示了如何在Azure托管的容器中创建workers，执行健康检查，以及安装其他软件组件。</p>

<h2 id="spin-up-the-workers">动员工人</h2>

<p>我们需要执行的第一步是创建一本操作手册。这篇文章假设你对我们的<a href="https://octopus.com/docs/runbooks"> runbooks </a>功能有些熟悉。</p>

<p>我的操作手册由以下步骤组成:</p>

<ul>
<li>创建Azure资源组</li>
<li>运行ARM模板来创建Octopus Deploy触手容器</li>
<li>运行健康检查</li>
<li>安装附加软件</li>
</ul>

<p>在这个例子中，我使用的是微软的Azure平台，但也可以使用任何其他云，包括AWS和谷歌云。我们的<a href="/blog/aws-cloudformation-ec2-examples" class="alert-link">用CloudFormation在AWS中创建EC2实例</a>的博文用一个详细的例子介绍了AWS中的类似场景。</p>


<h3 id="create-azure-resource-group">创建Azure资源组</h3>

<p>为了便于移除和整体整洁，第一步使用<strong>运行Azure脚本</strong>步骤创建一个Azure资源组:</p>

<pre><code class="language-PowerShell">$resourceGroupName = $OctopusParameters["Azure.Network.ResourceGroup.Name"]
$resourceGroupLocation = $OctopusParameters["Azure.Location.Abbr"]

if ((az group exists --name $resourceGroupName) -eq $false)
{
    Write-Output "Creating resource group $resourceGroupName in $resourceGroupLocation"
    az group create --location $resourceGroupLocation --name $resourceGroupName
}
</code></pre>

<h3 id="run-an-arm-template">运行ARM模板</h3>

<p>Azure容器实例是一种快速简单的方法来提升工作容器。使用一个小的Azure资源管理器(ARM)模板，我们可以自动创建<a href="https://hub.docker.com/r/octopusdeploy/tentacle" rel="nofollow"> Octopus触手</a>容器。</p>

<p><details> <summary>模板代码</summary> </details></p>

<pre><code class="language-json">{
    "$schema": "https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
    "contentVersion": "1.0.0.0",
    "parameters": {
        "location": {
            "type": "string"
        },
        "containerName": {
            "type": "string"
        },
        "imageType": {
            "type": "string",
            "allowedValues": [
                "Public",
                "Private"
            ]
        },
        "imageName": {
            "type": "string"
        },
        "osType": {
            "type": "string",
            "allowedValues": [
                "Linux",
                "Windows"
            ]
        },
        "numberCpuCores": {
            "type": "string"
        },
        "memory": {
            "type": "string"
        },
        "restartPolicy": {
            "type": "string",
            "allowedValues": [
                "OnFailure",
                "Always",
                "Never"
            ]
        },
        "ipAddressType": {
            "type": "string"
        },
        "ports": {
            "type": "array"
        },
        "dnsNameLabel": {
            "type": "string"
        },
        "environmentVariables": {
            "type": "array"
        }
    },
    "resources": [
        {
            "location": "[parameters('location')]",
            "name": "[parameters('containerName')]",
            "type": "Microsoft.ContainerInstance/containerGroups",
            "apiVersion": "2018-10-01",
            "properties": {
                "containers": [
                    {
                        "name": "[parameters('containerName')]",
                        "properties": {
                            "image": "[parameters('imageName')]",
                            "resources": {
                                "requests": {
                                    "cpu": "[int(parameters('numberCpuCores'))]",
                                    "memoryInGB": "[float(parameters('memory'))]"
                                }
                            },
                            "ports": "[parameters('ports')]",
                            "environmentVariables": "[parameters('environmentVariables')]"
                        }
                    }
                ],
                "restartPolicy": "[parameters('restartPolicy')]",
                "osType": "[parameters('osType')]",
                "ipAddress": {
                    "type": "[parameters('ipAddressType')]",
                    "ports": "[parameters('ports')]",
                    "dnsNameLabel": "[parameters('dnsNameLabel')]"
                }
            },
            "tags": {}
        }
    ]
}
</code></pre>

<p/>

<p>模板需要输入一些参数:</p>

<ul>
<li><strong>位置</strong>:Azure中的位置代码，即centralus</li>
<li><strong>容器名</strong>:容器的名称</li>
<li><strong> imageType </strong>:公共|私有</li>
<li><strong>图像名</strong> : <code>octopusdeploy/tentacle</code></li>
<li>osType  : Linux | Windows</li>
<li><strong> numberCpuCores </strong>:要使用的内核数量</li>
<li><strong>内存</strong>:容器使用的数字(以GB为单位)</li>
<li><strong>重启策略</strong>:参见Docker <a href="https://docs.docker.com/config/containers/start-containers-automatically/" rel="nofollow">文档了解选项</a></li>
<li><strong>IP address type</strong>:Public | Private</li>
<li><strong>端口</strong>:要暴露的端口数组</li>
<li><strong> dnsNameLabel </strong> : DNS条目的DNS前缀，即【dnsNameLabel】。[azure region]. azure container . io</li>
<li><strong>环境变量</strong>:要传递给容器的环境变量数组</li>
</ul>

<p>该模板将启动Octopus Deploy触手的Azure容器实例。</p>

<p>我选择了Linux变种，因为它比Windows容器小得多(254.39 MB对2.27 GB)。</p>

<h3 id="run-a-health-check">运行健康检查</h3>

<p>内置的健康检查模板仅适用于部署目标，但是，有一个专门为工作人员开发的社区步骤:<a href="https://library.octopus.com/step-templates/c6c23c7b-876d-4758-a908-511f066156d7/actiontemplate-worker-health-check" rel="nofollow">工作人员健康检查</a>。运行此步骤可确保我们的员工身体健康，并为下一步做好准备。</p>

<h3 id="install-additional-software">安装附加软件</h3>

<p>工作人员将需要与Azure和AWS进行交互。触手映像只有运行所需的最少软件，所以我需要安装以下软件:</p>

<ul>
<li>PowerShell核心</li>
<li>Azure CLI</li>
<li>AWS CLI</li>
</ul>

<p>使用部署目标，您可以针对具有特定角色的所有目标执行步骤。由于工人没有角色，我需要找到一个替代者。脚本控制台允许您对池中的所有工作线程执行相同的代码。因为Octopus是API优先编写的，所以我能够复制脚本控制台的功能来运行代码，以便通过API针对整个池安装附加软件:</p>

<pre><code class="language-PowerShell"># Define parameters
$baseUrl = $OctopusParameters['Global.Base.Url'] 
$apiKey = $OctopusParameters['Global.Api.Key'] 
$spaceId = $OctopusParameters['Octopus.Space.Id']
$spaceName = $OctopusParameters['Octopus.Space.Name']
$workerPoolName = $OctopusParameters['Project.WorkerPool.Name']

if ($baseUrl.EndsWith("/"))
{
    $baseUrl = $baseUrl.SubString(0, $baseUrl.LastIndexOf("/"))
}

# Get worker pool
$workerPool = ((Invoke-RestMethod -Method Get -Uri "$baseUrl/api/$spaceId/workerpools/all" -Headers @{"X-Octopus-ApiKey"="$apiKey"}) | Where-Object {$_.Name -eq $workerPoolName})

# Build payload
$jsonPayload = @{
    Name = "AdHocScript"
    Description = "Script run from management console"
    Arguments = @{
        MachineIds = @()
        TenantIds = @()
        TargetRoles = @()
        EnvironmentIds = @()
        WorkerIds = @()
        WorkerPoolIds = @($workerPool.Id)
        TargetType = "WorkerPools"
        Syntax = "Bash"
        ScriptBody = @"
# Update the list of products
sudo apt-get update

# Install wget
sudo apt-get install wget -y

# Download the Microsoft repository GPG keys
wget https://packages.microsoft.com/config/debian/10/packages-microsoft-prod.deb

# Register the Microsoft repository GPG keys
sudo dpkg -i packages-microsoft-prod.deb

# Update the list of products
sudo apt-get update

# Install PowerShell
sudo apt-get install -y powershell

# Install az module
echo "Installing az module ..."
pwsh -Command "&amp; {Install-Module az -Scope AllUsers -Force}" &gt; /tmp/azModuleInstall.log

# Install Az cli
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

# Install aws cli
sudo apt-get install awscli -y
"@
    }
    SpaceId = "$spaceId"
}


$scriptTask = (Invoke-RestMethod -Method Post -Uri "$baseUrl/api/tasks" -Body ($jsonPayload | ConvertTo-Json -Depth 10) -Headers @{"X-Octopus-ApiKey"="$apiKey"})

# Check to see if the health check is queued
while ($scriptTask.IsCompleted -eq $false)
{
    Write-Output "Waiting 5 seconds ..."
    Start-Sleep -Seconds 5
    $scriptTask = (Invoke-RestMethod -Method Get -Uri "$baseUrl/api/tasks/$($scriptTask.Id)" -Headers @{"X-Octopus-ApiKey"="$apiKey"})
}

Write-Output "Installation complete!"
</code></pre>

<p>因为我需要创建多个工人，所以步骤2和3在我的流程中创建了多次</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-02/workers-as-containers/octopus-project-process.png" class="zoom" data-title=""><img src="../Images/34b6fac2ba3cc4668503aac927e05c5f.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-02/workers-as-containers/octopus-project-process.png"/>T2】</a></p>

<h2 id="containerized-workers">集装箱化工人</h2>

<p>当配置为监听模式时，触手容器被编码为自动连接到Octopus服务器并向指定的工作池注册。运行手册完成后，我有三个健康的工人。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2021-02/workers-as-containers/octopus-worker-pool.png" class="zoom" data-title=""><img src="../Images/3acf023a1c7ddde6ed8ca39221fabc42.png" class="img-fluid center" alt="" data-original-src="https://i.octopus.com/blog/2021-02/workers-as-containers/octopus-worker-pool.png"/>T2】</a></p>

<h2 id="conclusion">结论</h2>

<p>在这篇文章中，我演示了如何创建作为容器运行的工人。这为您提供了创建工作线程的灵活性，而无需管理虚拟机！</p>

                    
                    
</body>
</html>