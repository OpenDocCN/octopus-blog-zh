<html>
<head>
<title>Granting federated user accounts to an EKS cluster - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>将联合用户帐户授予EKS集群- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/eks-federated-users#2022-11-21">https://octopus.com/blog/eks-federated-users#2022-11-21</a></blockquote>
                        <p>如果你在AWS上使用过弹性Kubernetes服务(EKS ),你很可能经历过权限的挫败感。如果您不是EKS集群的创建者，那么您在AWS控制台中看到的唯一信息就是集群的整体状态。</p>

<p>有许多关于添加额外用户帐户的教程；然而，并没有一个明确的演示向您展示如何添加一个联合用户帐户。</p>

<p>在本文中，我将带您了解如何向EKS集群授予一个联合用户帐户。</p>

<h2 id="what-youll-learn">你会学到什么</h2>

<p>在与EKS合作完成我们的<a href="https://samples.octopus.app" rel="nofollow">样本</a>实例后，我决定写这篇文章。我需要查看由项目创建的集群上的部署资源的详细信息。该项目使用一个<a href="https://octopus.com/docs/runbooks">操作手册</a>来创建使用AWS账户的EKS集群。尽管对我们的AWS帐户有完全访问权限，但我看不到集群的详细信息。更复杂的是，我使用一个联邦用户帐户登录AWS控制台。在研究这个话题的时候，我找到了一些教程，但是没有一个涵盖了整个过程。</p>

<p>在本演练中，您将学习如何:</p>

<ul>
<li>使用不同的帐户创建EKS群集</li>
<li>查找联合帐户的信息</li>
<li>将联合帐户添加到集群中</li>
</ul>

<h3 id="creating-an-eks-cluster">创建EKS集群</h3>

<p>向EKS集群授予联合用户帐户时，如果您不是EKS集群的创建者，就会出现问题。不同的用户需要首先创建集群。</p>

<p>在我的例子中，我创建了一个拥有足够权限来创建EKS集群的用户帐户。我在Octopus中添加了<a href="https://octopus.com/docs/infrastructure/accounts/aws"> AWS帐户</a>,并使用操作手册中的以下步骤创建了一个集群:</p>

<ul>
<li><strong>创建EKS集群</strong></li>
<li><strong>添加集群作为部署目标</strong></li>
</ul>

<p>我使用的是Octopus Deploy runbook，但是<strong>创建EKS集群</strong>部分并不是Octopus特有的，因为它使用AWS CLI来创建集群。</p>

<h4 id="create-eks-cluster">创建EKS集群</h4>

<p>该步骤使用Octopus Deploy中的<strong>运行AWS CLI脚本</strong>步骤来创建EKS集群。</p>

<p>CLI需要以下变量来创建集群:</p>

<ul>
<li>群集Name</li>
<li>地区</li>
<li>阿恩的角色</li>
<li>前节点角色阿恩</li>
<li>子网id(我使用2)</li>
<li>安全组ID</li>
</ul>

<p>这篇文章假设你对AWS有足够的了解，知道这些值应该是什么。以下脚本使用CLI首先创建EKS集群，然后创建节点组。在这些活动完成之后，它将集群的URL端点存储在一个<a href="https://octopus.com/docs/projects/variables/output-variables">输出变量</a>中，供后续步骤使用。</p>

<pre><code class="language-powershell"># Get variables
$clusterName = $OctopusParameters['AWS.Kubernetes.Cluster.Name']
$region = $OctopusParameters['AWS.Region.Name']
$eksRoleArn = $OctopusParameters['AWS.EKS.Role.Arn']
$nodeRoleArn = $OctopusParameters['AWS.Node.Role.Arn']
$subnet1Id = $OctopusParameters['AWS.Network.Subnet1.Id']
$subnet2Id = $OctopusParameters['AWS.Network.Subnet2.Id']
$securityGroupId = $OctopusParameters['AWS.Network.SecurityGroup.Id']


# Create EKS cluster
$eksCluster = aws eks create-cluster --name $clusterName --role-arn $eksRoleArn --resources-vpc-config subnetIds=$subnet1Id,$subnet2Id,securityGroupIds=$securityGroupId
$eksCluster = $eksCluster | ConvertFrom-JSON

Write-Host "Waiting for cluster to be done creating..."
while ($eksCluster.Cluster.Status -eq "CREATING")
{
    # Wait for cluster to be done creating
    $eksCluster = aws eks describe-cluster --name $clusterName
    $eksCluster = $eksCluster | ConvertFrom-JSON
}


Write-Host "Status of cluster: $($eksCluster.Cluster.Status)" 

Write-Host "Creating node group..."
aws eks create-nodegroup --cluster-name $clusterName --nodegroup-name "$clusterName-workers" --subnets $subnet1Id $subnet2Id --instance-types "t3.medium" --node-role $nodeRoleArn --remote-access ec2SshKey="&lt;Your EC2 keypair&gt;"

Set-OctopusVariable -name "EKSURL" -value $eksCluster.Cluster.Endpoint
</code></pre>

<h4 id="add-cluster-as-deployment-target">将集群添加为部署目标</h4>

<p>该步骤将新创建的集群作为目标添加到Octopus Deploy中。如果您不使用Octopus，可以转到下一节，<a href="#info-federated">查找联邦帐户的信息</a>。</p>

<p>此步骤在<strong>运行脚本</strong>步骤中使用<a href="https://octopus.com/docs/infrastructure/deployment-targets/dynamic-infrastructure/kubernetes-target">New-octopuskubernetarget</a>cmdlet将新创建的EKS集群添加到Octopus Deploy。<code>$eksUrl</code>变量从上一步的输出变量中检索它的值。</p>

<pre><code class="language-powershell"># Get the variables
$clusterName = $OctopusParameters['AWS.Kubernetes.Cluster.Name']
$region = $OctopusParameters['AWS.Region.Name']
$eksUrl = $OctopusParameters['Octopus.Action[Create EKS Cluster].Output.EKSURL']

# Add new Kubernetes cluster target
New-OctopusKubernetesTarget -Name "Samples-#{Octopus.Space.Name | Replace " "}-EKS" -clusterName $clusterName -octopusRoles "PetClinic,EKS" -octopusAccountIdOrName "#{AWS.Account.Name}" -namespace "default" -skipTlsVerification $true -clusterUrl $eksUrl
</code></pre>

<h3 id="info-federated">查找联合帐户的信息</h3>

<p>在AWS控制台中导航到集群，您会看到以下消息:</p>

<p><code>Your current user or role does not have access to Kubernetes objects on this EKS cluster. This may be due to the current user or role not having Kubernetes RBAC permissions to describe cluster resources or not having an entry in the cluster’s auth config map.</code></p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-access-denied.png" class="zoom" data-title=""><img src="../Images/66abc5e9ebaf9daffc56143828d953ac.png" class="img-fluid center" alt="EKS cluster access denied" data-original-src="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-access-denied.png"/>T2】</a></p>

<p>您可以看到群集处于活动和健康状态，但仅此而已。</p>

<p>解决方案是将您的用户帐户添加到<code>aws-auth</code>配置图中。然而，对于联合帐户，这个过程是不同的，因为它们不会出现在AWS控制台的<strong> IAM用户</strong>部分。</p>

<p>联合用户被映射到一个<strong> AWS角色</strong>，因此您需要确定您的帐户被映射到哪个角色。幸运的是，这可以通过点击AWS控制台右上角的您的帐户轻松完成。这将显示您的联合帐户映射到的角色。</p>

<p>在这种情况下，您可以看到我的帐户被映射到<code>AWSReservedSSO_DeveloperAccess_645f9848983dec35</code>角色。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-iam-account.png" class="zoom" data-title=""><img src="../Images/ba7208e18ea1880e10a76d8667172fa8.png" class="img-fluid center" alt="AWS User Account" data-original-src="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-iam-account.png"/>T2】</a></p>

<h3 id="add-the-federated-account-to-the-cluster">将联合帐户添加到集群中</h3>

<p>在添加联邦用户之前，您必须首先获得<code>aws-auth</code>配置映射的当前值。这可以使用<code>kubectl</code>命令<code>kubectl get configmap/aws-auth -n kube-system</code>来完成。</p>

<p>为了更容易地处理他的文件，我将命令输出到JSON，并将其写入文件。这让我可以将JSON反序列化为PowerShell对象。</p>

<pre><code class="language-powershell"># Get current aws-auth configmap
kubectl get configmap/aws-auth -n kube-system -o json | Set-Content aws-auth.json

# Load the JSON as an object
$jsonPayload = (Get-Content aws-auth.json | Out-String | ConvertFrom-Json)
</code></pre>

<p>加载到<code>$jsonPayload</code>变量后，您可以通过导航到变量的<code>.data.mapRoles</code>属性来访问相关数据。</p>

<p>默认情况下，<code>mapRoles</code>的值应该如下所示:</p>

<p>尽管对象被从JSON反序列化为PowerShell对象，<code>mapRoles</code>部分仍然是YAML。</p>


<pre><code class="language-yaml">- groups: 
  - system:bootstrappers 
  - system:nodes 
  rolearn: arn:aws:iam::&lt;AWS account ID&gt;:role/&lt;Role used to create cluster&gt;
  username: system:node:{{EC2PrivateDNSName}}
</code></pre>

<p>要添加您的联合用户，请附加以下内容:</p>

<pre><code class="language-yaml">- rolearn: arn:aws:iam:&lt;AWS account ID&gt;:role/&lt;role name&gt;
  username: "{{SessionName}}"
  groups:
    - system:masters
</code></pre>

<p>整个部分应该如下所示:</p>

<pre><code class="language-yaml">- rolearn: arn:aws:iam:&lt;AWS account ID&gt;:role/AWSReservedSSO_DeveloperAccess_645f9848983dec35
  username: "{{SessionName}}"
  groups:
    - system:masters
- groups: 
  - system:bootstrappers 
  - system:nodes 
  rolearn: arn:aws:iam::&lt;AWS account ID&gt;:role/&lt;Role used to create cluster&gt;
  username: system:node:{{EC2PrivateDNSName}}
</code></pre>

<p>最后一步是用修改后的版本替换现有的<code>aws-auth</code>配置图。使用kubectl CLI的<code>replace</code>命令来完成此操作。因为我是在Octopus Deploy runbook中这样做的，所以我使用了下面的PowerShell来进行修改:</p>

<pre><code class="language-powershell"># Get current aws-auth configmap
kubectl get configmap/aws-auth -n kube-system -o json | Set-Content aws-auth.json

# Load the JSON as an object
$jsonPayload = (Get-Content aws-auth.json | Out-String | ConvertFrom-Json)

# Create federated users rolearn piece
$federatedUsers = 
@"
`n
- rolearn: arn:aws:iam::&lt;AWS Account ID&gt;:role/AWSReservedSSO_DeveloperAccess_645f9848983dec35
  username: "{{SessionName}}"
  groups:
    - system:masters
- groups:
    - system:bootstrappers 
    - system:nodes
  username: system:node:{{EC2PrivateDNSName}} 
  rolearn: arn:aws:iam::&lt;Your AWS Account ID&gt;:role/&lt;Role used to create cluster&gt;
"@

# Add federated users to maproles
$jsonPayload.data.mapRoles = $federatedUsers

# Write the new information to file
Set-Content aws-auth.json -Value ($jsonPayload | ConvertTo-Json -depth 10)

# Replace the config map
kubectl replace -n kube-system -f aws-auth.json
</code></pre>

<p>添加了联合用户帐户后，您现在可以看到集群的详细信息:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-cluster-resources.png" class="zoom" data-title=""><img src="../Images/cbd848158bd6ab3c05faba79919dd222.png" class="img-fluid center" alt="EKS cluster resources" data-original-src="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-cluster-resources.png"/>T2】</a></p>

<h2 id="troubleshooting">解决纷争</h2>

<p>应用更新后，您可能会注意到<code>Node group</code>处于降级状态:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-nodegroup-degraded.png" class="zoom" data-title=""><img src="../Images/d057a7c8242b559a9d1b492e932565b2.png" class="img-fluid center" alt="EKS node group degraded" data-original-src="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-nodegroup-degraded.png"/>T2】</a></p>

<p>如果您注意到这一点，请检查节点组的<strong>健康问题</strong>。如果<strong>问题类型</strong>是带有描述<code>The aws-auth ConfigMap in your cluster is invalid.</code>的<strong>拒绝访问</strong>，请确保将联合账户YAML的<code>{{SessionName}}</code>部分用双引号括起来:</p>

<pre><code class="language-yaml">- rolearn: arn:aws:iam::&lt;Your AWS Account ID&gt;:role/AWSReservedSSO_DeveloperAccess_645f9848983dec35
  username: "{{SessionName}}"
  groups:
    - system:masters
</code></pre>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-nodegroup-health.png" class="zoom" data-title=""><img src="../Images/a8101b32ae0d101930e0bf0303e1bd27.png" class="img-fluid center" alt="EKS node group health" data-original-src="https://i.octopus.com/blog/2022-11/eks-federated-users/aws-eks-nodegroup-health.png"/>T2】</a></p>

<p>更新可能需要大约10分钟，但健康问题应该会解决。</p>

<h2 id="conclusion">结论</h2>

<p>我花了大量时间搜索和收集将联合用户帐户添加到EKS集群所需的信息。解决<code>{{SessionName}}</code>需要用双引号括起来的问题特别耗时。我希望这篇文章通过引导你完成这个过程来节省你的时间。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>