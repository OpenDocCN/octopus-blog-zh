<html>
<head>
<title>Automating Octopus with Azure Functions - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Azure功能自动化Octopus-Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/automating-octopus-with-azure-functions#2016-12-22">https://octopus.com/blog/automating-octopus-with-azure-functions#2016-12-22</a></blockquote>
                        <p>随着微软和亚马逊分别发布Azure Functions和T2，托管小型服务和脚本的努力和成本壁垒已经降低。这些服务可以与Octopus <a href="http://docs.octopusdeploy.com/display/OD/Octopus+REST+API"> REST API </a>和<a href="http://docs.octopusdeploy.com/display/OD/Subscriptions">订阅功能</a>相结合，提供高于Octopus现成功能的自动化。</p>

<p>这篇文章探讨了两个这样的集成。第一个示例升级无人认领的手动干预，第二个示例响应机器离线。两个例子都使用了<a href="http://docs.octopusdeploy.com/display/OD/Octopus.Client"> Octopus。客户端</a>带C# <a href="https://azure.microsoft.com/en-us/services/functions/"> Azure函数的库</a>。也使用了<a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-twilio"> Twilio SMS集成</a>，但这可以用您选择的通知方法来代替，或者只是一条日志消息。</p>

<h2>示例1 -无人认领的干预</h2>

<p>该示例定期查询Octopus服务器，并查找任何具有待定手动干预的部署。如果在检查时，那些手动干预没有被分配给任何人，并且已经超过一分钟，则发送SMS。引导故障也包括在内，因为它们是人工干预的特殊情况。</p>

<h3>功能设置</h3>

<p><img src="../Images/f0a4cef724bdc80ea56cd8da5fce6879.png" alt="Function Editor" data-original-src="https://i.octopus.com/blog/201612-function-KX5C.PNG"/></p>

<p>使用您的Azure帐户创建新功能应用后，添加新功能并选择<code>TimerTrigger-CSharp</code>模板。给它一个名称，并保持默认的时间表。</p>

<p>以章鱼为参照。客户端nuget包，选择<code>View Files</code>(见上图sceenshot)，添加一个名为<code>project.json</code>的文件，内容如下。更多细节请看<a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-csharp#package-management"> Azure功能包管理</a>。</p>

<pre><code>{
  "frameworks": {
    "net46":{
      "dependencies": {
        "Octopus.Client": "4.5.0"
      }
    }
   }
}
</code></pre>

<p>接下来设置Octopus公共URL和<a href="http://docs.octopusdeploy.com/display/OD/How+to+create+an+API+key"> API键</a>。为此，选择<code>Function app settings</code>项(见截图)，然后选择<code>Configure app settings</code>。添加两个app设置，<code>OctopusUrl</code>和<code>OctopusApiKey</code>。</p>

<p>最后，设置Twilo集成。这是可选的，所以如果跳过它，从代码中删除对Twilo和<code>SMSMessage</code>的引用。再次选择该功能，然后选择<code>Integrate</code>。创建新的<code>Output</code>，选择<code>Twilio SMS</code>。输入您的Twilo详细信息。请注意，SID和令牌是对应用程序设置的引用，因此您需要到那里输入实际的SID和应用程序设置。</p>

<h3>该功能</h3>

<p>将函数体(<code>run.csx</code>)替换为以下内容:</p>

<pre><code>#r "Twilio.Api"

using System.Net;
using Octopus.Client;
using Octopus.Client.Model;
using Twilio;

public static async Task Run(TimerInfo myTimer, TraceWriter log, IAsyncCollector&lt;SMSMessage&gt; message)
{
    var endpoint = new OctopusServerEndpoint(GetSetting("OctopusUrl"), GetSetting("OctopusApiKey"));
    var client = await OctopusAsyncClient.Create(endpoint);

    var tasks = await client.Repository.Tasks.GetAllActive();
    foreach (var task in tasks.Where(t =&gt; t.HasPendingInterruptions))
    {
        var interruptions = await client.Repository.Interruptions.List(pendingOnly: true, regardingDocumentId: task.Id);
        var unhandled = from i in interruptions.Items
                        where i.IsPending &amp;&amp; i.ResponsibleUserId == null
                        select (TimeSpan?) DateTimeOffset.Now.Subtract(i.Created);
        var oldest = unhandled.Max();
        if (oldest.HasValue &amp;&amp; oldest &gt; TimeSpan.FromMinutes(1))
        {
            var sms = new SMSMessage();
            sms.Body = $"The task {task.Description} has not been actioned after {oldest.Value.TotalMinutes:n0} minutes";
            log.Info(sms.Body);
            await message.AddAsync(sms);
        }
    }  
}

public static string GetSetting(string name) =&gt;  System.Environment.GetEnvironmentVariable(name, EnvironmentVariableTarget.Process);
</code></pre>

<p>点击<code>Save and run</code>按钮，查看日志输出，应该运行成功。</p>

<h3>测试</h3>

<p>为了测试集成，创建一个带有<a href="http://docs.octopusdeploy.com/display/OD/Manual+intervention+and+approvals">手动干预</a>步骤的新项目(或者使用一个现有的项目)并部署它。或者导致部署因<a href="http://docs.octopusdeploy.com/display/OD/Guided+failures">导向故障</a>而暂停。等待一分钟，然后再次手动运行该功能(或等待该功能在计时器上运行)。</p>

<h2>示例2 -脱机计算机</h2>

<p>这个例子是由一个<a href="http://docs.octopusdeploy.com/display/OD/Subscriptions">订阅</a>触发的，当一台机器由于运行状况检查或部署而从可用转换到不可用时。然后，它确定是删除该机器还是采取一些补救措施。如果机器无法恢复，将发送短信。为了简单起见，下面的实现总是确定不应该删除该机器，补救措施是什么也不做。</p>

<h2>设置</h2>

<p>基于<code>HttpTrigger-CSharp</code>模板添加一个新功能(保持授权级别为<code>Function</code>)，并按照上述说明设置Octopus。客户和Twilio。</p>

<p>接下来在Octopus实例中添加一个<a href="http://docs.octopusdeploy.com/display/OD/Subscriptions">订阅</a>，带有一个事件过滤器<code>Machine found to be unavailable</code>和一个Azure函数的有效负载URL。</p>

<p><img src="../Images/e709d4875994f96058badd09043018a7.png" alt="Subscription" data-original-src="https://i.octopus.com/blog/201612-subscription-TTBH.PNG"/></p>

<h3>测试</h3>

<p>由于该函数响应外部事件和有效负载，为了加速该函数的开发和测试，可以使用内置测试功能捕获有效负载，然后重放。首先，用以下内容替换函数体(<code>run.csx</code>)并保存:</p>

<pre><code>#r "Twilio.Api"

using System.Net;
using Twilio;

public static async Task&lt;HttpResponseMessage&gt; Run(HttpRequestMessage req, TraceWriter log, IAsyncCollector&lt;SMSMessage&gt; message)
{
    dynamic data = await req.Content.ReadAsAsync&lt;object&gt;();
    log.Info(data.ToString());
    return req.CreateResponse(HttpStatusCode.OK);
}
</code></pre>

<p>接下来，停止服务器的一个触角，并对该触角运行健康检查。这项检查应该会失败。</p>

<p>查看您的函数的日志输出，您应该看到Octopus请求有效负载。如果没有，检查<a href="http://docs.octopusdeploy.com/display/OD/Log+files">服务器日志</a>中的警告。</p>

<p>从日志输出中复制请求有效负载，并选择Test菜单项(在View Files旁边)。将有效负载粘贴到请求正文部分。现在再次单击Run按钮，有效负载将再次打印到输出中。</p>

<h3>该功能</h3>

<p>为了简单起见，这个函数有两个占位符方法<code>HasBeenDecommissioned</code>和<code>AttemptToBringOnline</code>。在完整的实现中，这些方法将与外部系统交互，如Azure管理API或一些基础设施监控软件。</p>

<p>将函数体(<code>run.csx</code>)替换为以下内容:</p>

<pre><code>#r "Twilio.Api"

using System.Net;
using Octopus.Client;
using Octopus.Client.Model;
using Twilio;

public static async Task&lt;HttpResponseMessage&gt; Run(HttpRequestMessage req, TraceWriter log, IAsyncCollector&lt;SMSMessage&gt; message)
{
    var endpoint = new OctopusServerEndpoint(GetSetting("OctopusUrl"), GetSetting("OctopusApiKey"));
    var client = await OctopusAsyncClient.Create(endpoint);

    var machineIds = await GetAffectedMachineIds(req);
    log.Info($"Machines {string.Join(", ", machineIds)} have gone offline");

    var failedMachines = new List&lt;MachineResource&gt;();
    foreach(var id in machineIds)
    {
        var machine = await client.Repository.Machines.Get(id);
        if(HasBeenDecommissioned(machine))
        {
            log.Info($"Machine {machine.Id} is no longer required, removing");
            await client.Repository.Machines.Delete(machine);
        }
        else
        {
            log.Info($"Machine {machine.Id} should not have gone offline");
            failedMachines.Add(machine);
        }
    }

    await SendOutageSms(failedMachines.Count, message);
    await AttemptToBringOnline(failedMachines);
    var task = await client.Repository.Tasks.ExecuteHealthCheck();

    return req.CreateResponse(HttpStatusCode.OK);
}

public static string GetSetting(string name) =&gt;  System.Environment.GetEnvironmentVariable(name, EnvironmentVariableTarget.Process);

static async Task&lt;string[]&gt; GetAffectedMachineIds(HttpRequestMessage req)
{
    dynamic data = await req.Content.ReadAsAsync&lt;object&gt;();
    var ids = (string[]) data.Payload.Event.RelatedDocumentIds.ToObject&lt;string[]&gt;();
    return ids.Where(i =&gt; i.StartsWith("Machines-")).ToArray();
}

// Call out to cloud provider or monitoring software
static bool HasBeenDecommissioned(MachineResource machine) =&gt; false;

static Task SendOutageSms(int count, IAsyncCollector&lt;SMSMessage&gt; message)
{
    var sms = new SMSMessage();
    sms.Body = $"{count} machines has become unavailable";
    return message.AddAsync(sms);
}

// Take some remedial action
static Task AttemptToBringOnline(List&lt;MachineResource&gt; machines) =&gt; Task.CompletedTask;
</code></pre>

<p>点击<code>Save and run</code>按钮并检查日志输出，它应该报告机器已经离线。</p>

<h2>更多信息</h2>

<p>参见<a href="http://docs.octopusdeploy.com/display/OD/Coordinating+Multiple+Projects">协调多个项目</a>文档页面，该页面概述了一些进一步的场景以及一些示例代码。</p>

<p>有关更多代码示例，请参见<a href="https://github.com/OctopusDeploy/OctopusDeploy-Api"> OctopusDeploy-Api </a> GitHub资源库。</p>

<p>最后，<a href="https://www.linqpad.net/"> LinqPad </a>是编辑和测试部分功能的绝佳工具。</p>

                    
                    
</body>
</html>