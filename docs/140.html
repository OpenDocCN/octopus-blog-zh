<html>
<head>
<title>Continuous Delivery for PowerShell Modules using Octopus Deploy and TakoFukku - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Octopus Deploy和TakoFukku - Octopus Deploy连续交付PowerShell模块</h1>
<blockquote>原文：<a href="https://octopus.com/blog/continuous-delivery-powershell-octopus-takofukku#2022-07-07">https://octopus.com/blog/continuous-delivery-powershell-octopus-takofukku#2022-07-07</a></blockquote>
                        <p>传统上，Octopus Deploy是一个推出应用程序的引擎——从历史的角度来说。NET应用程序-到服务器。但如今，远不止如此。</p>

<p>因为Octopus是一个优秀的分布式任务运行器，具有丰富的预滚动模板集，所以它可以用于驱动许多工作负载和流程，否则这些工作负载和流程可能需要手动完成，或者使用在CI服务器中运行的精心手工滚动的脚本来完成。事实上，对于PowerShell模块来说，它们通常是小而分散的功能块，没有长时间的编译阶段，Octopus是一个完美的选择。</p>

<p>我有几个开源项目，我使用Octopus来驱动对它们的测试和发布，所以今天我将使用StatusCakeDSC作为一个例子，向您介绍这是如何完成的。StatusCakeDSC是一个用于设置状态监控的状态配置模块。我们在八达通这里用它，我自己也用它。它可以在PowerShell Gallery上获得，当我想发布新版本时，Octopus会为我完成这项工作。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/statuscakedsc-project-process.png" class="zoom" data-title=""><img src="../Images/29ce4247317db6a287eefdb797a8f826.png" class="img-fluid center" alt="The StatuscakeDSC Deployment process" data-original-src="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/statuscakedsc-project-process.png"/>T2】</a></p>

<h2 id="the-project-setup">项目设置</h2>

<p>这只是一个标准的Octopus项目，但是你会注意到这里的一切都运行在Octopus服务器上。这并不一定；只是在基础设施方面更便宜。这些步骤基本上可以在任何安装了PowerShell的目标上运行，因此我可以针对一个VM、一个容器，甚至是我的家庭网络上的一个轮询触角。</p>

<p>我在项目中存储了一些重要的、敏感的变量。我的PowerShell Gallery的NuGet API密钥，我的StatusCake凭据，这样我就可以运行测试和我的Slack webhook端点。这使得我可以将这些敏感的字符串远离GitHub，所以我很少有机会不小心发布它们。我发现对于这样的项目来说，使用八达通是保护我的秘密安全和远离公众视线的好方法。</p>

<p>然后我有一套相当简单的Octopus步骤来完成这项工作，稍后我将概述一下。</p>

<p>对于这个项目，我有两个环境，<code>DevTest</code>和<code>Production</code>。当部署到<code>Production</code>时，所有的步骤都被配置为运行。但在DevTest中，我明确排除了“发布到PS Gallery”这一步。这是为生产保留的，因为我不希望预发布代码错误地进入画廊。</p>

<h2 id="triggering-the-project">触发项目</h2>

<p>该项目使用Webhooks基于Github中的提交触发，使用我的一个名为Takofukku的小项目。Takofukku是一个面向Octopus deploy的轻量级、无服务器的webhook解决方案，开放给任何人使用。您只需将一个名为<a href="https://github.com/stopthatastronaut/takofukku/blob/master/takofiles.md" rel="nofollow"> takofile </a>的YAML文档放入GitHub repo中，<a href="https://github.com/stopthatastronaut/takofukku#ok-so-how-do-i-hook-this-up" rel="nofollow">在push事件上配置一个webhook </a>，就可以开始了。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/github-hook.png" class="zoom" data-title=""><img src="../Images/69b8bec4800a44ae3a2b27e744f5fbf8.png" class="img-fluid center" alt="The GitHub webhook" data-original-src="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/github-hook.png"/>T2】</a></p>

<p>每次push事件发生时，GitHub都会向端点发送POST请求。Takofukku接收这个钩子，然后从指定的repo中获取takofile，如果找到有效的映射，就在您的Octopus服务器上触发Octopus部署。GitHub 上有完整的文档，当然也接受拉取请求。</p>

<p>在这个具体的例子中，我的takofile将GitHub <code>master</code>分支映射到Octopus <code>production</code>环境，将GitHub <code>develop</code>分支映射到Octopus <code>DevTest</code>环境。每当我们在这些分支上进行推送/合并时，Takofukku将创建一个新的发布，将最后一次推送的提交消息作为发布说明，并将该发布部署到指定的环境中。</p>

<h2 id="getting-the-code">获取代码</h2>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/git-pull.png" class="zoom" data-title=""><img src="../Images/0c3e589ee9b74116e7b1a5319417514a.png" class="img-fluid center" alt="The Git Pull Step" data-original-src="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/git-pull.png"/>T2】</a></p>

<p>它做的第一件事是git pull，使用来自章鱼库的<a href="https://library.octopus.com/step-templates/5c08170d-e919-4afe-9da3-7616c797d42b/actiontemplate-git-pull-(https)" rel="nofollow">社区步骤模板。如果我们在<code>Production</code>部署，我们克隆<code>master</code>分支。如果在<code>DevTest</code>中，我们克隆<code>develop</code>，使用一个简单的作用域变量。</a></p>

<p>在这个步骤之后，您可以看到有一个编写. creds文件的步骤。这是特定于模块的，因为StatusCakeDSC允许你在磁盘上存储凭证，使测试变得更容易——这在模块的库的<a href="https://github.com/stopthatastronaut/StatusCakeDSC/blob/master/README.md#credentials" rel="nofollow">中有解释，所以我在这里不赘述。</a></p>

<h2 id="running-the-tests">运行测试</h2>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/runtests.png" class="zoom" data-title=""><img src="../Images/248d46c4ab4a75a8ec2a8c2e28263359.png" class="img-fluid center" alt="The Run Tests Step" data-original-src="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/runtests.png"/>T2】</a></p>

<p>StatusCakeDSC使用Pester来运行测试，这个PowerShell脚本步骤非常简单:</p>

<pre><code>$error.Clear()             # make sure errors are empty
pushd c:\StatusCakeDSC     # make sure we're in the right working path
# invoke pester
$failcount = Invoke-Pester -EnableExit -Verbose
if($failcount -gt 0 -or $error.count -gt 0)  # if tests have failed _or_ the step has thrown errors, exit
{
    Fail-Step "Pester returned $failcount failed tests"
}
popd
</code></pre>

<p>我在Pester测试中发现的一个小问题是，测试直接范围之外的错误并不总是如预期的那样失败。因此，这一步检查步骤中的纠缠故障和一般错误，然后如果出现问题，使用Octopus的<code>Fail-Step</code> cmdlet使部署失败。</p>

<h2 id="publishing-to-the-powershell-gallery">发布到PowerShell画廊</h2>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/publish.png" class="zoom" data-title=""><img src="../Images/b70bcba5195fb66cc0496ae01593af36.png" class="img-fluid center" alt="The Publish Step" data-original-src="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/publish.png"/>T2】</a></p>

<p>我尊敬的同事Chris van Dal不久前请求将<code>publish.ps1</code>添加到这个repo中，以便我可以轻松地部署到PS Gallery中。你可以在GitHub repo 上看到这个脚本<a href="https://github.com/stopthatastronaut/StatusCakeDSC/blob/master/publish.ps1" rel="nofollow">，它几乎是大多数PowerShell模块作者用来推出他们的模块的。我只是从我的章鱼步骤如下驱动它:</a></p>

<pre><code>Set-Location c:\StatuscakeDSC
.\publish.ps1 -nugetapikey $psgalleryapikey
</code></pre>

<p>此步骤的运行条件设置为仅在前面所有步骤都成功运行时运行，并且仅在生产环境中运行。</p>

<p>为了把这个放到Octopus中，我对原始脚本做了一些简单的调整。它现在:</p>

<ul>
<li>将API键作为参数引入，这样我可以将它安全地存储在Octopus中。</li>
<li>检查模块清单以查找版本号。</li>
<li>检查PowerShell库以查看该版本是否已经发布。</li>
<li>如果成功，并且版本已经增加，它发布新的模块。</li>
<li>在最近的代码中，它将一个git标签推回到GitHub中，用图库中的版本号标记最新的代码。</li>
</ul>

<h2 id="finishing-it-all-up">完成这一切</h2>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/slack.png" class="zoom" data-title=""><img src="../Images/ac79e63d22eb45d59aa017e1e796e533.png" class="img-fluid center" alt="The Slack Notification Step" data-original-src="https://i.octopus.com/blog/2018-02/continuous-delivery-powershell-octopus-takofukku/slack.png"/></a>T2】</p>

<p>最后一步是一个<a href="https://library.octopusdeploy.com/step-template/actiontemplate-slack-notify-deployment" rel="nofollow">空闲通知</a>，运行条件为“总是运行”。这一步足够智能，可以知道部署何时失败，并相应地调整其消息。我喜欢这个步骤模板，因为它意味着我甚至不需要登录我的Octopus服务器就可以知道在我提交一些提交之后部署是否正常。无论我身在何处，我的手机都会收到一个延迟通知。</p>

<p>因此，所有这一切的实际结果是，每当我想对StatusCakeDSC进行更改时，我真正需要做的就是合并到git中正确的分支，Octopus将负责运行我的测试并发布到Gallery。这是PowerShell模块的持续交付，我很喜欢。</p>

<p>请随意复制或增强这个过程，如果您添加了任何增强功能，请让我们知道。分散在step库中的这一步有很多改进的可能性，事实上，您可以编写的任何脚本都可以容纳在Octopus中。</p>

<p>愉快的部署！</p>

                    
                    
</body>
</html>