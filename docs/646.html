<html>
<head>
<title>Safe schema updates - Continuous Integration is misunderstood - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>安全模式更新-持续集成被误解- Octopus部署</h1>
<blockquote>原文：<a href="https://octopus.com/blog/safe-schema-updates-3-ci-is-misunderstood#2021-12-16">https://octopus.com/blog/safe-schema-updates-3-ci-is-misunderstood#2021-12-16</a></blockquote>
                        <p>这篇博文是我的安全模式更新系列的第3部分。本系列其他文章的链接如下:</p>

<p><strong>批评现有系统:</strong></p>



<p><strong>想象更好的系统:</strong></p>



<p><strong>构建更好的系统:</strong></p>



<p>许多人听到<em>“持续集成”</em> (CI)会立刻想到构建服务器、测试框架和自动化。Jenkins、JUnit和GitHub的行为很棒，但是任何声称使用这些工具为他们赢得CI徽章的人都没有抓住要点。</p>

<p>如果<em>持续集成</em>是关于持续构建的，我们会称之为<em>持续构建</em>。</p>

<p>当然，测试和验证是CI的基础。重要的是要确保任何已经集成到我们的源代码控制主分支中的代码都已经通过了所有适当和必要的检查。</p>

<p>定期的、自动化的构建是相当没有争议的，并且被普遍接受。正是这一点涉及到构建服务器和测试框架。但是那些构建脚本和那些小小的、令人欣慰的绿色标记是手段，而不是目的。它们只是一个更大想法的一小部分。</p>

<h2 id="why-do-we-run-automated-builds-and-tests"><em>为什么</em>我们要运行自动化构建和测试？</h2>

<p>大多数人可能会用“捕捉错误”或“快速反馈”这样的回答来回应。是的，这些都很棒。然而，这仍然只是故事的一部分。这些答案还是没有抓住根本点。</p>

<p><strong>连续<em>整合</em>约<em>整合</em>。</strong></p>

<p>从字面上看，就这么简单。(选词是有意的，而且准确。)</p>

<p>大多数人错过了摆在他们面前的答案。CI是关于减少在制品(WIP)的数量和避免大的合并。它是将广泛的目标分解成更小的(但可交付的)任务，这些任务可以独立开发、测试和集成。一旦集成了变更，就不需要从源代码控制中“挑选”这个变更或那个更新来进行部署，因为整个集成的变更集已经被作为一个整体进行了验证。一旦变更被集成，它们应该以最小的风险发布。</p>

<p>这些构建纯粹是为了验证我们的常规集成工作。毕竟，如果我们每三个月才集成一次代码，也许一周的测试阶段并不痛苦？然而，如果我们计划一天集成多次，一周的测试阶段是不实际的。这些构建的存在不仅仅是为了捕捉bugs它们的存在是为了支持对主源代码控制分支的可部署变更的<em>持续集成</em>——一天多次。</p>

<p>这意味着任何真正的持续集成实践者，也将实践某种形式的基于主干的开发。</p>

<p>有些人会反对基于主干开发的想法。他们可能希望保持不同功能/工作项目/标签的交付相互隔离，原因是业务目标冲突、时间安排或协调等。例如:</p>

<ul>
<li>"这项功能需要在那项功能之后推出."</li>
<li>"这个版本需要与一些营销发布/合同期限相协调."</li>
<li>“我们需要快速跟踪这个修补程序。”</li>
<li>“这个可怕的大功能还没有准备好部署。”</li>
</ul>

<p>这就是为什么持续集成从根本上来说是一个项目管理问题，为什么那些花哨的构建工具只是一个实现细节，以及许多其他技术和管理实践。</p>

<p>我们需要以这样一种方式管理我们的开发、测试和部署工作，使得上述问题消失。我们需要这样做，因为真正的<em>持续集成</em>的好处，比仅仅<em>持续构建</em>的好处要小得多。</p>

<h2 id="why-do-we-need-continuous-integration">为什么我们需要持续的<em>集成</em>？</h2>

<p>你曾经在一个为期12个月的项目中工作过，而第11个月是留给“整合”的吗？你觉得怎么样？我猜事情不太顺利。</p>

<p>集成阶段通常是痛苦的，因为我们所有人(特别是项目经理，显然)都倾向于低估关于所有子系统应该如何集成的坏假设的数量。不管我们在Visio或OmniGraffle方面有多有才华，这些微妙的复杂性往往不会在干净的架构图中引用。</p>

<p>这导致发现比预期更多的问题。这很烦人，但这不是世界末日。真正的问题是这些错误是基于6个月前写的代码。</p>

<p>我们现在处理的是“承重虫”。</p>

<p/>  

<p>每个问题现在都变得更加棘手，因为彻底解决问题需要复杂的重构，并且可能需要从根本上重新思考这个位应该如何与那个位一起工作。由于依赖性，我们的负载bug修复可能会产生意想不到的后果，每个后果都需要时间来理解和修复。不幸的是，我们没有时间或预算来打开这个潘多拉魔盒，所以我们解决了这个问题，在快速破解和管道胶带的基础上堆积了<a href="https://en.wikipedia.org/wiki/Code_smell" rel="nofollow">难闻的</a>变通方法。</p>

<p>这一切都证明了在制品(WIP)是负债，而不是资产。是一个<a href="https://en.wikipedia.org/wiki/Sunk_cost" rel="nofollow">沉没成本</a>。如果你的8人团队在某个复杂的新特性上投入了6个月的开发时间，那就是4个开发人员年的投资，可能是6位数的总和，这是赌在你没有问题地集成代码的能力上。</p>

<p>开发分支和主开发分支之间的差异越大，合并就越复杂，遇到讨厌的负载bug的机会就越大。这将花费时间和金钱来修复，以及(很可能)降低代码的整体质量。此外，并发WIP越多，管理复杂的分支模式、不一致的开发环境、令人头疼的合并和危险的大爆炸式部署所浪费的管理开销就越大。相对于整合的规模，隐性成本以非线性方式增加。</p>

<p>除了成本增加之外，大型集成还会带来巨大的风险。集成越大，集成失败的可能性就越大，或者该特性就越有可能被放弃。或者，它可能会吸收资源，因为沉没成本谬误或人类骄傲会影响人们推动合并，尽管存在可笑的风险和/或成本。<a href="https://octopus.com/blog/devops-reading-list#phoenix">凤凰计划</a>就是一个典型的例子。</p>

<p>快速反馈很好，但是自动化构建不会突出<em>集成</em>问题，直到并发开发任务被<em>集成</em>。因此，保持小规模和频繁的集成对于交付可靠的IT系统至关重要。</p>

<h2 id="beyond-builds-what-else-does-continuous-integration-require">除了构建，持续集成还需要什么？</h2>

<p>简单地说，优先考虑<em>合并</em>而不是<em>分离</em>的开发过程会是什么样子？</p>

<p>当然，自动化构建和测试是必要的。然而，CI从业者面临的问题远不止构建这么简单。例如:</p>

<ul>
<li>我们如何将一个为期12个月的项目分解成无数个小时/天的任务，每个任务都可以单独完成？</li>
<li>我们如何平衡长期愿景、迭代学习和更敏捷的优先排序和决策？</li>
<li>那些需要一天以上才能交付的棘手的大变更，以及那些不能在不完整的状态下交付的变更，又该如何处理呢？</li>
<li>当一个子模块的依赖项被频繁更新而没有警告时，我们如何管理它的可靠性？(无需求助于<a href="https://octopus.com/blog/change-advisory-boards-dont-work">痛苦的人工审查过程</a>。)</li>
<li>如果客户/用户仍然计划年度预算、季度发布和不频繁的软件更新，我们如何管理与他们的关系？高管和股东呢？</li>
<li>我们如何管理业务、法律或合同义务要求不频繁、大量发布的情况？</li>
<li>当我们一天多次发布变更时，一个合适的评审过程是什么样的？</li>
<li>我们如何大规模实践持续集成？在一天之内挤满了多次提交变更的开发人员的超大型IT职能部门中，我们如何管理这一点呢？</li>
</ul>

<p>为了解决这些问题，我们需要仔细考虑我们的软件架构和我们管理依赖的方式。我们需要集成代码和频繁部署变更的方法，同时保留按照不同的时间表向用户发布/展示这些更新的能力，该时间表针对商业目标而不是纯粹的工程问题进行了优化。我们需要官僚化的过程，这种过程基于许多短交付周期的小变更的频繁交付，而不是长交付周期的不频繁的大变更。我们需要确保开发和生产之间的差异始终保持较小。</p>

<p>这是一个包含一大堆想法的简短段落。在这篇文章中，我不打算一一解开。在接下来的文章中，你可以看到处理这些挑战的技术。这篇文章的重点是强调持续构建只是持续集成冰山的一角。持续集成非常重要。</p>

<p>现在，猜度地说:</p>

<ul>
<li>如果您正在您的功能分支上运行自动化构建，但是您没有将您的大功能与主分支合并，因为它还没有准备好…对不起，那不是CI。</li>
<li>如果您在您的主分支上运行自动化构建，但是当涉及到部署时，您只是挑选这个提交或那个文件进行部署…对不起，这不是CI。</li>
<li>如果您正在运行自动化构建，但是在您的主要源代码控制分支和产品之间有一个巨大的差异…对不起，那不是CI。</li>
<li>如果你的开发环境和你的生产环境大相径庭，也许有不同版本的依赖或者堆积如山的废弃WIP…对不起，那不是CI。</li>
</ul>

<h2 id="how-does-all-this-relate-to-safe-database-updates">所有这些与安全数据库更新有什么关系？</h2>

<p>这个关于CI的小抱怨听起来有点离题，但是在接下来的两篇文章中深入讨论松耦合之前，我们正确理解CI是很重要的。当然，更小的系统更容易测试，但是不仅仅是这样，如果清楚地理解弹性和持续集成的更广泛的意义和价值，进入我们关于松散耦合和领域驱动开发(DDD)的讨论将会很有用。</p>

<p>此外，DDD从根本上是关于打破数据模型，数据库通常是许多其他系统的共享依赖。松散耦合要求与独立服务相关的数据分离。因此，当我们开始讨论根据CI考虑拆分数据库的价值时，理解完整意义上的持续集成是有用的，而不是肤浅但普遍的“持续构建”误解。</p>

<h2 id="next-time">下次</h2>

<p>在接下来的两篇文章中，我们将转换话题，从技术和人的角度讨论数据库架构。我们将讨论松散耦合和领域驱动开发，以及这些原则如何帮助我们实践持续集成并产生安全、有弹性的IT系统。</p>

<p>本系列其他文章的链接如下:</p>

<p><strong>批评现有系统:</strong></p>



<p><strong>想象更好的系统:</strong></p>



<p><strong>打造更好的系统:</strong></p>



<h2 id="watch-the-webinars">观看网络研讨会</h2>

<p>我们的第一次网络研讨会讨论了松耦合架构如何带来可维护性、创新性和安全性。第二部分讨论了如何将一个成熟的系统从一种架构转换到另一种架构。</p>

<h3 id="database-devops-imagining-better-systems">数据库开发:想象更好的系统</h3>

<iframe src="https://www.youtube.com/embed/oJAbUMZ6bQY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">VIDEO</iframe>

<h3 id="database-devops-building-better-systems">数据库开发:构建更好的系统</h3>

<iframe src="https://www.youtube.com/embed/joogIAcqMYo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">VIDEO</iframe>

<p>愉快的部署！</p>

                    
                    
</body>
</html>