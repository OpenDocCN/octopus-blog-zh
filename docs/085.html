<html>
<head>
<title>Bitbucket Pipelines: Pipes and integrating with Octopus Deploy - Octopus Deploy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Bitbucket管道:管道和与Octopus Deploy集成- Octopus Deploy</h1>
<blockquote>原文：<a href="https://octopus.com/blog/bitbucket-pipes-and-octopus-deploy#2021-08-12">https://octopus.com/blog/bitbucket-pipes-and-octopus-deploy#2021-08-12</a></blockquote>
                        <p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bitbucket-cd.png" class="zoom" data-title=""><img src="../Images/2a0514ff42330facdc09b3c1b69f9c46.png" class="img-fluid center" alt="Bitbucket Pipelines" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bitbucket-cd.png"/>T2】</a></p>

<p>Atlassian的<a href="https://bitbucket.org/product/features/pipelines" rel="nofollow"> Bitbucket Pipelines </a>是一个轻量级的云持续集成服务器，它使用预配置的Docker容器，允许您将基础架构定义为代码。<a href="https://bitbucket.org/product/features/pipelines/integrations" rel="nofollow"> Pipes </a>允许您向管道添加配置，对于第三方工具尤其有用。</p>

<p>在本文中，我为一个<a href="https://g.octopushq.com/OctopusCLI" rel="nofollow"> Octopus CLI </a>命令创建了一个实验管道，在我们的示例node.js应用程序<a href="https://bitbucket.org/octopussamples/randomquotes-js" rel="nofollow"> RandomQuotes-Js </a>的Bitbucket管道中使用它，最后，将管道与Octopus集成。</p>

<h2>在这篇文章中</h2>



<h2 id="what-are-bitbucket-pipes">什么是比特桶管道？</h2>

<p>亚特兰蒂斯人<a href="https://confluence.atlassian.com/bitbucket/learn-about-pipes-978200267.html" rel="nofollow">说</a>:</p>

<blockquote class="blockquote">
<p>管道提供了一种配置管道的简单方法。当您想使用第三方工具时，它们尤其强大。只需将管道粘贴到YAML文件中，提供一些关键信息，剩下的事情就为您完成了。您可以在步骤中添加任意数量的管道，因此可能性是无穷的！</p>
</blockquote>

<p>管道建立在管道、容器的核心概念上。管道使用位于<a href="https://www.docker.com/" rel="nofollow"> Docker </a>容器中的脚本，它通常包含在管道可用之前您在管道YAML文件中编写的命令。</p>

<h2 id="example-pipe-usage">管道使用示例</h2>

<p>这是Atlassian<a href="https://bitbucket.org/product/features/pipelines/integrations?p=atlassian/bitbucket-upload-file" rel="nofollow">bit bucket-upload-file</a>管道在您的管道YAML文件中的样子:</p>

<pre><code class="language-yaml">- pipe: atlassian/bitbucket-upload-file:0.1.3
  variables:
    BITBUCKET_USERNAME: '&lt;string&gt;'
    BITBUCKET_APP_PASSWORD: '&lt;string&gt;'
    FILENAME: '&lt;string&gt;'
    # ACCOUNT: '&lt;string&gt;' # Optional
    # REPOSITORY: '&lt;string&gt;' # Optional
    # DEBUG: '&lt;boolean&gt;' # Optional
</code></pre>

<ul>
<li><code>atlassian/bitbucket-upload-file:0.1.3</code>是包含要运行的管道的Docker <a href="https://hub.docker.com/r/bitbucketpipelines/bitbucket-upload-file" rel="nofollow">图像</a>的名称。</li>
<li><code>BITBUCKET_USERNAME</code>是一个您需要提供的变量的例子，该变量包含管道在容器内部执行时要使用的值。</li>
</ul>

<h3 id="refer-to-a-pipe-in-a-pipeline-step">参照管线步骤中的管道</h3>

<p>有两种方法可以在管线内的步骤中引用管道:</p>

<ol>
<li>直接参考Docker图像:</li>
</ol>

<pre><code class="language-yaml">pipe: docker://&lt;Docker_Account_Name&gt;/&lt;Image_Name&gt;:&lt;tag&gt;
</code></pre>

<ol start="2">
<li>引用托管在Bitbucket上的管道存储库:</li>
</ol>

<pre><code class="language-yaml">pipe: &lt;Bitbucket_account&gt;/&lt;Bitbucket_repo&gt;:&lt;tag&gt;
</code></pre>

<p>这个方法从引用的<code>&lt;Bitbucket_account&gt;/&lt;Bitbucket_repo&gt;</code>管道库中的<code>pipe.yml</code>文件中寻找Docker图像的位置。</p>

<h2 id="why-are-pipes-useful">管道为什么有用？</h2>

<p>为什么要大费周章写管道呢？</p>

<p>管道都是关于<em>再利用</em>。它们允许您在管道的多个步骤中重复相同的操作。通过将核心操作集中到一个管道中，您最终会得到一个更简单的管道配置。与在管道中直接编写脚本相比，管道的另一个关键特性是能够包含主管道不需要的依赖项。</p>

<h2 id="create-a-bitbucket-pipe">创建位桶管道</h2>

<p>管道由构成Docker映像的一组文件组成。我创建的管道的图像基于预先存在的<a href="https://hub.docker.com/r/octopusdeploy/octo" rel="nofollow"> octopusdeploy/octo </a>图像。成品管已在Docker Hub上发布为<a href="https://hub.docker.com/r/octopipes/pack/" rel="nofollow"> octopipes/pack </a>。</p>

<p>起初，创建一个管道可能看起来相当令人生畏，但是Atlassian提供了一个有帮助的分步指南。</p>

<p>我在Ubuntu机器上使用Bash终端创建了这个管道。如果您使用不同的平台，您可能需要调整您使用的命令。</p>


<h2 id="choose-a-candidate-for-a-pipe">选择烟斗的候选人</h2>

<p>我经常听人说，对于软件来说，命名是最困难的事情，选择一个命令来包装在管道中也是如此。然而，在大多数CI/CD管道中，在您对代码构建并运行任何测试之后，您可能想要打包您的应用程序。所以选择Octopus CLI <a href="https://octopus.com/docs/octopus-rest-api/octopus-cli/pack"> pack </a>命令来创建管道是很自然的。</p>

<p>额外的好处是<code>pack</code>命令只有几个必需的参数，可选的参数可以用一些管道魔术来处理(稍后的<a href="#optional-pipe-variables"/>会有更多)。</p>

<p>可以创建两种类型的管道:</p>



<p>我选择了一个<strong>完整的</strong>管道，这样我就可以发布它并在其他存储库中使用它。</p>

<h3 id="create-the-pipe-repository">创建管道存储库</h3>

<p>接下来，我需要在Bitbucket中创建一个新的<a href="https://bitbucket.org/octopusdeploy/pack" rel="nofollow"> octopusdeploy/pack </a> Git存储库，并在本地克隆它。</p>

<p>有关创建新的Git存储库的更多信息，请参见Atlassian <a href="https://confluence.atlassian.com/bitbucket/create-a-git-repository-759857290.html" class="alert-link" rel="nofollow">文档</a>。</p>


<h3 id="create-the-pipe-skeleton">创建管道骨架</h3>

<p>Atlassian提供了一种使用<a href="http://yeoman.io/" rel="nofollow"> Yeoman </a>生成管道库框架的方法。当您安装了所有的先决条件(<code>nodejs</code>和<code>npm</code>)后，您可以从终端使用<code>yo</code>命令运行生成器:</p>

<pre><code class="language-bash">yo bitbucket-pipe
</code></pre>

<p>这将提示您选择要创建的管道。我选了<strong>新高级管(Bash) </strong>。</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/pipe-generator-welcome.png" class="zoom" data-title=""><img src="../Images/4681f6d867dc7847b13d25a766ddafc2.png" class="img-fluid center" alt="Bitbucket pipe generator -welcome" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/pipe-generator-welcome.png"/>T2】</a></p>

<p>系统会提示您一些问题，帮助您为管道的使用者填写元数据和其他有用的信息。完成后，它将生成您开始工作所需的文件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/pipe-generator-complete.png" class="zoom" data-title=""><img src="../Images/5610bd1d476e590428e1ac469f8f22cc.png" class="img-fluid center" alt="Bitbucket pipe generator - complete" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/pipe-generator-complete.png"/>T2】</a></p>

<p>至少，您需要编辑以下文件以满足您的管道要求:</p>



<p><strong>提示:</strong>检查其他的库，看看他们是如何编写管道的！</p>
<p>每个Bitbucket管道的一个优点是代码是公开的，所以你可以浏览它。例如，您可以在<a href="https://bitbucket.org/atlassian/bitbucket-upload-file/" class="alert-link" rel="nofollow">位桶</a>上查看<code>bitbucket-upload-file</code>管道的源代码。</p>
<p>这是了解其他作者如何构建管道的一个非常好的方式。</p>




<p>当你创建一个<strong>完整的</strong>管道时，Atlassian要求你创建一个<code>pipe.yml</code>文件。本文档包含有关管道的元数据，包括以下内容:</p>

<ul>
<li>管道的名称。</li>
<li>管道的Docker中心图像，格式为:<code>account/repo:tag</code>。</li>
<li>可以在其中指定默认值的管道变量列表。</li>
</ul>

<p>如果您使用管道生成器选择了一个<em>高级</em>管道，将会为您创建一个<code>pipe.yml</code>文件，其中已经添加了所有相关信息。以下是我自动生成的<a href="https://bitbucket.org/octopusdeploy/pack/src/master/pipe.yml" rel="nofollow"> pipe.yml </a>文件的内容:</p>

<pre><code class="language-yaml">name: Octo Pack
image: octopipes/pack:0.0.0
description: Creates a package (.nupkg or .zip) from files on disk, without needing a .nuspec or .csproj
repository: https://bitbucket.org/octopusdeploy/pack
maintainer: support@octopus.com
tags:
    - octopus
    - package
    - deployment
</code></pre>

<h3 id="create-the-pipe-script">创建管道脚本</h3>

<p>管道的主要部分是在容器中执行时将运行的脚本或二进制文件。它将包括执行管道任务所需的所有逻辑。你可以选择任何你熟悉的语言。当我早先创建我们管道的<a href="#create-the-pipe-skeleton">骨架</a>时，我使用了<a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)" rel="nofollow"> Bash </a>，并且创建了一个示例<code>pipe/pipe.sh</code>文件供我完成。</p>

<p><strong>TL；博士</strong></p>

<p>如果您想查看完整的管道脚本，直接跳到<a href="#complete-pipe-script">结尾</a>或查看<a href="https://bitbucket.org/octopusdeploy/pack/src/master/pipe/pipe.sh" rel="nofollow">源代码</a>。如果没有，请继续阅读！</p>

<p>管道脚本文件的一般结构遵循以下约定:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bitbucket-pipe-script-flow.png" class="zoom" data-title=""><img src="../Images/b0d16f2eabaafc7b2a79533c55f09307.png" class="img-fluid center" alt="pipe script flow" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bitbucket-pipe-script-flow.png"/>T2】</a></p>

<h4 id="mandatory-pipe-variables">强制管道变量</h4>

<p><code>pack</code>命令有五个我希望管道处理的参数:</p>

<ol>
<li>要创建的包的<code>--id</code>。</li>
<li>包装的<code>--format</code>，如<code>NuPkg</code>或<code>Zip</code>。</li>
<li>封装的<code>--version</code>(SEM ver)。</li>
<li><code>--basePath</code>指定包含要打包的文件和文件夹的根文件夹。</li>
<li><code>--outFolder</code>指定生成的包将被写入的文件夹。</li>
</ol>

<p>为了支持这些参数，我将每个参数映射到一个位桶管道<a href="https://confluence.atlassian.com/bitbucket/variables-in-pipelines-794502608.html" rel="nofollow">变量</a>。</p>

<p>我还遵循了变量的验证，如Atlassian<a href="https://bitbucket.org/atlassian/demo-pipe-bash/src/master/pipe/pipe.sh" rel="nofollow">demo-pipe-bash</a>脚本所示:</p>

<pre><code class="language-bash">NAME=${NAME:?'NAME variable missing.'}
</code></pre>

<p>这将检查一个<code>$NAME</code>变量值，并在变量不存在时显示一条错误消息。</p>

<p>对于我创建的五个变量，我的变量验证如下所示:</p>

<pre><code class="language-bash"># mandatory parameters
ID=${ID:?'ID variable missing.'}
FORMAT=${FORMAT:?'FORMAT variable missing.'}
VERSION=${VERSION:?'VERSION variable missing.'}
SOURCE_PATH=${SOURCE_PATH:?'SOURCE_PATH variable missing.'}
OUTPUT_PATH=${OUTPUT_PATH:?'OUTPUT_PATH variable missing.'}
</code></pre>

<h4 id="optional-pipe-variables">可选管道变量</h4>

<p>接下来是一些可选变量，管道消费者可以根据自己的意愿选择提供。</p>

<p>我包含了一个<code>EXTRA_ARGS</code>数组变量来为<code>pack</code>命令包含多个额外的参数。您可以通过在管道中使用特殊的位存储桶数组类型来指定此变量:</p>

<pre><code class="language-yaml">variables:
  EXTRA_ARGS: ['--description', 'text containing spaces', '--verbose']
</code></pre>

<p>数组类型非常有用，因为它提供了一种向管道提供任何其他参数的简单方法。在我的例子中，这允许<code>pack</code>管道的消费者能够提供我没有显式处理的任何附加参数选项。</p>

<p><strong>高级管道写作技巧:</strong></p>
<p>要了解更多关于数组类型及其值如何传递给Docker容器的信息，请参阅Atlassian的<a href="https://confluence.atlassian.com/bitbucket/advanced-techniques-for-writing-pipes-969511009.html" class="alert-link" rel="nofollow">文档</a>。</p>


<p>最后，我包含了一个布尔变量<code>DEBUG</code>来包含额外的调试信息。您在管道中指定它的值，如下所示:</p>

<pre><code class="language-yaml">variables:
  DEBUG: 'true'
</code></pre>

<h4 id="run-the-pack-pipe">下封隔管</h4>

<p>管道的唯一目的是打包一组文件，为了实现这个目的，我们引用了我用作管道Docker映像基础的<a href="https://hub.docker.com/r/octopusdeploy/octo" rel="nofollow">octopus deploy/octo</a>Docker映像。这使我们能够在管道中访问完整的Octopus CLI。</p>

<p>为了将文件打包到Bitbucket管道中，我们的脚本需要运行<code>pack</code>命令并传入我们的变量:</p>

<pre><code class="language-bash">run octo pack --id "$ID" --version "$VERSION" --format "$FORMAT" --basePath "$SOURCE_PATH" --outFolder "$OUTPUT_PATH" "${EXTRA_ARGS[@]}"
</code></pre>

<p>最后，我们检查命令是否成功。如果是，我们将显示一条成功消息，并用所创建的包的文件名设置一个变量。如果没有，我们会显示一条错误消息并暂停执行。</p>

<p><code>run</code>命令是一个在单独的<code>common.sh</code>文件中指定的辅助函数。看起来是这样的:</p>
<pre><code class="language-bash">run() {
  output_file="/var/tmp/pipe-$(date +%s)-$RANDOM"

  echo "$@"
  set +e
  "$@" | tee "$output_file"
  status=$?
  set -e
}
</code></pre>
<p>该函数包装对所提供命令的调用，在本例中是<code>octo pack</code>，将输出记录到一个临时文件中，并捕获退出状态。</p>


<h4 id="complete-pipe-script">完整管道脚本</h4>

<p>这就是我们剧本的全部内容。下面是完成的<code>pipe.sh</code>文件:</p>

<pre><code class="language-bash">#!/usr/bin/env bash

# Creates a package (.nupkg or .zip) from files on disk, without needing a .nuspec or .csproj
#
# Required globals:
#   ID
#   FORMAT
#   VERSION
#   SOURCE_PATH
#   OUTPUT_PATH
#
# Optional globals:
#   EXTRA_ARGS
#   DEBUG

source "$(dirname "$0")/common.sh"

# mandatory parameters
ID=${ID:?'ID variable missing.'}
FORMAT=${FORMAT:?'FORMAT variable missing.'}
VERSION=${VERSION:?'VERSION variable missing.'}
SOURCE_PATH=${SOURCE_PATH:?'SOURCE_PATH variable missing.'}
OUTPUT_PATH=${OUTPUT_PATH:?'OUTPUT_PATH variable missing.'}

FORMAT=$(echo "$FORMAT" | tr '[:upper:]' '[:lower:]')

# Default parameters
EXTRA_ARGS_COUNT=${EXTRA_ARGS_COUNT:="0"}
DEBUG=${DEBUG:="false"}

enable_debug

if [ "${EXTRA_ARGS_COUNT}" -eq 0 ]; then
  # Flatten array of extra args
  debug "Setting EXTRA_ARGS to empty array"
  EXTRA_ARGS=
fi

debug "Flattening EXTRA_ARGS"
init_array_var 'EXTRA_ARGS'

debug ID: "${ID}"
debug FORMAT: "${FORMAT}"
debug VERSION: "${VERSION}"
debug SOURCE_PATH: "${SOURCE_PATH}"
debug OUTPUT_PATH: "${OUTPUT_PATH}"
debug EXTRA_ARGS_COUNT: "${EXTRA_ARGS_COUNT}"
debug EXTRA_ARGS: "${EXTRA_ARGS}"

run octo pack --id "$ID" --version "$VERSION" --format "$FORMAT" --basePath "$SOURCE_PATH" --outFolder "$OUTPUT_PATH" "${EXTRA_ARGS[@]}"

if [ "${status}" -eq 0 ]; then
  OCTO_PACK_FILENAME="$ID.$VERSION.$FORMAT"
  success "Packaging successful. Created package $OUTPUT_PATH/$OCTO_PACK_FILENAME."

else
  fail "Packaging failed."
fi
</code></pre>

<h3 id="create-the-pipe-dockerfile">创建管道Dockerfile文件</h3>

<p>现在我们有了要运行的主脚本，我们需要使用docker文件创建我们的图像。如果您运行了管道生成器，那么您已经准备好了docker文件来进行编辑以适合您的管道。</p>

<p>对于<code>pack</code>管道，docker文件如下所示:</p>

<pre><code class="language-docker">FROM octopusdeploy/octo:7.3.2

RUN apk add --update --no-cache bash

COPY pipe /
RUN chmod a+x /*.sh

ENTRYPOINT ["/pipe.sh"]
</code></pre>

<p>Dockerfile以<code>octopusdeploy/octo</code>为基础，然后将<code>bash</code>添加到图像中。然后，它复制<code>pipe</code>文件夹的内容，并授予所有用户执行当前的<code>.sh</code>文件的权限。最后，它将容器的<code>ENTRYPOINT</code>设置为我们之前创建的<a href="#complete-pipe-script"> pipe.sh </a>文件。</p>

<h3 id="create-the-pipes-own-pipeline">创建管道自己的管线</h3>

<p>完成管道后，您可以将Docker映像手动部署到Docker Hub。然而，当您使用自己的<code>bitbucket-pipelines.yml</code>文件将更改推送到Bitbucket存储库时，也可以让Bitbucket管道自动为您完成繁重的工作。</p>

<p>对于<code>pack</code>管道，在自动生成的文件中，我只修改了推送步骤:</p>

<pre><code class="language-yaml">
push: &amp;push
  step:
    name: Push and Tag
    image: python:3.7
    script:
    - pip install semversioner==0.7.0
    - chmod a+x ./ci-scripts/*.sh
    - ./ci-scripts/bump-version.sh
    - ./ci-scripts/docker-release.sh octopipes/$BITBUCKET_REPO_SLUG
    - ./ci-scripts/git-push.sh
    services:
    - docker
</code></pre>

<p>该步骤安装<a href="https://pypi.org/project/semversioner/" rel="nofollow">seversioner</a>，这是一个python工具，帮助自动生成发行说明，并根据<a href="https://semver.org/" rel="nofollow"> SemVer </a>为您的管道版本化。之后，它增加管道的版本，创建一个新的Docker映像，并将其推送到Docker Hub。最后，它标记新版本并将其推回Bitbucket存储库。</p>

<p>你可以在<a href="https://bitbucket.org/octopusdeploy/pack/src/master/bitbucket-pipelines.yml" rel="nofollow">位桶</a>上查看<code>pack</code>钻杆的完整<code>bitbucket-pipelines.yml</code>文件。</p>

<p><strong>无双Docker推送:</strong><br/><code>push</code>步骤在自己提交并推回到位存储库时，不会触发将两个Docker映像推送到Docker Hub。这样做的原因是，如果提交消息中的任何地方包含了<code>[skip ci]</code>或<code>[ci skip]</code>，位桶管道支持跳过管道运行的选项。</p>


<h3 id="create-the-pipe-readme">创建管道自述文件</h3>

<p>您可能会想，“为什么要花时间创建自述文件呢？”嗯，亚特兰蒂斯人自己推荐它:</p>

<blockquote class="blockquote">
<p>你的自述是你的用户如何知道如何使用你的管道。我们可以在Bitbucket中显示它，所以它需要用markdown以特定的格式编写。</p>
</blockquote>

<p>包含一个信息丰富的<code>README</code>会增加你的用户成功使用你的管道的机会。</p>

<p><code>README</code>更重要的部分之一是<strong> YAML定义</strong>。这告诉用户向他们的<code>bitbucket-pipeline.yml</code>文件添加什么。</p>

<p>下面是<code>pack</code>的样子:</p>

<pre><code class="language-yaml">script:
  - pipe: octopipes/pack:0.6.0
    variables:
      ID: "&lt;string&gt;"
      FORMAT: "&lt;string&gt;"
      VERSION: "&lt;string&gt;"
      SOURCE_PATH: "&lt;string&gt;"
      OUTPUT_PATH: "&lt;string&gt;"
      # EXTRA_ARGS: "['&lt;string&gt;','&lt;string&gt;' ..]" # Optional
      # DEBUG: "&lt;boolean&gt;" # Optional
</code></pre>

<p>点击可以查看<code>octopipes/pack</code>的<code>README</code>全文<a href="https://bitbucket.org/octopusdeploy/pack/src/master/README.md" rel="nofollow">。</a></p>

<h2 id="run-the-pipe">运行管道</h2>

<p>因为管道只是一个Docker映像，在您构建了映像之后，您可以使用<code>docker run</code>执行管道，将任何需要的参数作为环境变量传入。</p>

<p>下面是运行<code>pack</code>管道从我们的<code>RandomQuotes-JS</code>应用程序打包根目录的命令:</p>

<pre><code class="language-bash">sudo docker run \
   -e ID="randomquotes-js" \
   -e FORMAT="Zip" \
   -e VERSION="1.0.0.0" \
   -e SOURCE_PATH="." \
   -e OUTPUT_PATH="./out" \
   -e DEBUG="false" \
   -v $(pwd):$(pwd) \
   -w $(pwd) \
 octopipes/pack:0.6.0
</code></pre>

<p>输出显示成功打包了<code>randomquotes-js.1.0.0.0.zip</code>文件:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/docker-run-octopipes-pack.png" class="zoom" data-title=""><img src="../Images/d432b18aa050f9bffd889d07aad6c615.png" class="img-fluid center" alt="docker run octopipes pack" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/docker-run-octopipes-pack.png"/>T2】</a></p>

<h2 id="test-the-pipe">测试管道</h2>

<p>为了确保您的管道如您所愿，为它编写测试是一个好主意。在Atlassian的带领下，我选择使用<a href="https://www.systutorials.com/docs/linux/man/1-bats/" rel="nofollow"> BATS </a> (Bash自动化测试系统)。</p>

<p>就像许多测试框架一样，一个测试文件(通常以<code>.bats</code>结尾)包含以下结构:</p>

<ul>
<li>一个<code>setup</code>方法来为你的测试设置任何需要的变量或者共享资源。</li>
<li>多个单独的<code>@test</code>声明；这些是你的测试案例。</li>
<li>一个<code>teardown</code>方法来删除你使用过的任何资源。</li>
</ul>

<p>下面是我的<a href="https://bitbucket.org/octopusdeploy/pack/src/master/test/test.bats" rel="nofollow"> test.bats </a>文件:</p>

<pre><code class="language-bash">#!/usr/bin/env bats

setup() {
  DOCKER_IMAGE=${DOCKER_IMAGE:="test/pack"}

  echo "Building image..."
  run docker build -t ${DOCKER_IMAGE}:test .

  # generated
  RANDOM_NUMBER=$RANDOM

  # locals
  ID="MyCompany.MyApp"
  FORMAT="zip"
  VERSION="1.0.0.0"
  SOURCE_PATH="test/code"
  OUTPUT_PATH="test/out"

  echo "$FORMAT"

  EXPECTED_FILE="$ID.$VERSION.$FORMAT"

  # Create test output dir
  rm -rf test/out
  mkdir test/out/extract -p

  echo "Create file with random content"
  echo $RANDOM_NUMBER &gt; test/code/test-content.txt
}

teardown() {
  echo "Cleaning up files"
  chmod -R a+rwx test/out/
  rm -rf test/out
}

@test "Create Zip package using Octo pack command" {

    echo "Run test"
    run docker run \
        -e ID="${ID}" \
        -e FORMAT="${FORMAT}" \
        -e VERSION="${VERSION}" \
        -e SOURCE_PATH="${SOURCE_PATH}" \
        -e OUTPUT_PATH="${OUTPUT_PATH}" \
        -e DEBUG="false" \
        -v $(pwd):$(pwd) \
        -w $(pwd) \
        ${DOCKER_IMAGE}:test

    echo "Status: $status"
    echo "Output: $output"
    [ "$status" -eq 0 ]

    # Verify
    unzip "test/out/$EXPECTED_FILE" -d test/out/extract
    run cat "test/out/extract/test-content.txt"
    echo "Output: $output"
    [[ "${status}" -eq 0 ]]
    [[ "${output}" == *"$RANDOM_NUMBER"* ]]

}
</code></pre>

<p>在我的<code>test.bats</code>文件中，<code>setup</code>构建了一个名为<code>test/pack</code>的管道的本地Docker映像。接下来，它用随机数创建一个文件。</p>

<p>然后我的<code>test</code>执行<code>docker run</code>(正如我在本地测试中所做的那样)并验证容器运行完成，最后从包中提取文件并检查内容是否与我在<code>setup</code>中生成的随机数匹配。</p>

<p>测试作为在我的<code>bitbucket-pipeline.yml</code>中配置的自动化CI/CD管道的一部分运行。如果你安装了<code>bats</code>，你也可以在本地运行测试。</p>

<p>下面是我的<code>test.bats</code>文件测试运行的输出:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bats-test-output.png" class="zoom" data-title=""><img src="../Images/ca2d174204e0fe5ccea35d05cef06104.png" class="img-fluid center" alt="bats test run output" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bats-test-output.png"/>T2】</a></p>

<p>这就是测试你的烟斗的全部内容！</p>

<h2 id="publish-the-pipe">发布管道</h2>

<p>当您对Pipe的工作感到满意时，您可以通过运行<code>docker push</code>直接发布Docker图像。</p>

<p>如果您已经像我们之前所做的那样建立了一个自动化的<a href="#create-the-pipes-own-pipeline">管道</a>，那么您可以利用<code>semversioner</code>来创建一个变更集:</p>

<pre><code class="language-bash">semversioner add-change --type patch --description "Initial Docker release"
</code></pre>

<p>提交变更集后，将它们推送到Bitbucket，剩下的工作应该由管道来处理。它还会自动更新以下位置的版本号:</p>

<ul>
<li><code>CHANGELOG.md</code>文件。</li>
<li><code>README.md</code>文件。</li>
<li>元数据<code>pipe.yml</code>。</li>
</ul>

<p>你可以在这里看到一个<code>pack</code>位桶管道创建<code>0.5.1</code>版本的例子:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bitbucket-pipe-pipeline-result.png" class="zoom" data-title=""><img src="../Images/1b6162ed6e17460d149d7177c7b6ec91.png" class="img-fluid center" alt="Bitbucket pipe pipeline result" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/bitbucket-pipe-pipeline-result.png"/>T2】</a></p>

<h2 id="integrating-the-pipe-into-a-pipeline">将管道集成到管道中</h2>

<p>如果您已经做到这一步，那么您已经将管道发布到Docker Hub，但是如何将该管道集成到另一个存储库的管道中呢？</p>

<p>为了找到答案，我将我们现有的node.js示例之一<code>RandomQuotes-JS</code>导入到一个新的Bitbucket存储库中，该示例驻留在<a href="https://github.com/OctopusSamples/RandomQuotes-js" rel="nofollow"> GitHub </a>上，并使用相同的<a href="https://bitbucket.org/octopussamples/randomquotes-js/" rel="nofollow">名称</a>。</p>

<h3 id="use-the-pipe">用管子</h3>

<p>接下来，我创建了一个<code>bitbucket-pipelines.yml</code>文件并设置了我的管道。在构建和测试步骤之后，我插入了一个包步骤，如下所示:</p>

<pre><code class="language-yaml">- step:
    name: Pack for Octopus
    script:
      - export VERSION=1.0.0.$BITBUCKET_BUILD_NUMBER
      - pipe: octopusdeploy/pack:0.6.0
        variables:
          ID: ${BITBUCKET_REPO_SLUG}
          FORMAT: 'Zip'
          VERSION: ${VERSION}
          SOURCE_PATH: '.'
          OUTPUT_PATH: './out'
          DEBUG: 'false'
    artifacts:
      - out/*.zip
</code></pre>

<p>该步骤看起来类似于管道的<code>README</code>文件中的示例。我在<code>pipe</code>指令前添加了一行来设置变量:</p>

<pre><code class="language-yaml">- export VERSION=1.0.0.$BITBUCKET_BUILD_NUMBER
</code></pre>

<p><code>export</code>命令告诉Bitbucket创建<code>VERSION</code>变量并在管道中使用它。</p>

<p>我还使用了Bitbucket <a href="https://confluence.atlassian.com/bitbucket/using-artifacts-in-steps-935389074.html" rel="nofollow">工件</a>，在这里我指定了一个glob模式来选择存在于<code>out</code>文件夹中的任何zip文件:</p>

<pre><code class="language-yaml">artifacts:
    - out/*.zip
</code></pre>

<p>这允许管道创建的包被管道中的后续步骤使用。</p>

<h2 id="integrate-the-pipeline-with-octopus">用Octopus整合管道</h2>

<p>在我创建了一个包之后，我想通过集成Bitbucket和Octopus来完成Bitbucket管道；具体来说，我想将我创建的包和相关的提交信息推送给Octopus。</p>

<h3 id="push-the-package-to-octopus">把包推给八达通</h3>

<p>在我之前创建的打包步骤之后，我添加了另一个步骤，将包推送到Octopus <a href="https://octopus.com/docs/packaging-applications/package-repositories/built-in-repository">内置的存储库</a>。</p>

<p>这个步骤利用了Bitbucket中的一个特性，该特性允许您指定一个容器映像，该映像可以不同于管道中其他地方使用的默认映像。在这种情况下，我选择了<code>octopusdeploy/octo:7.3.2</code> Docker图像。</p>

<p>这意味着我可以运行<code>octo push</code>命令并指定我在前面的<code>Pack for Octopus</code>步骤中创建的包，如下所示:</p>

<pre><code class="language-yaml">octo push --package ./out/$BITBUCKET_REPO_SLUG.$VERSION.zip  --server $OCTOPUS_SERVER --space $OCTOPUS_SPACE --apiKey $OCTOPUS_APIKEY
</code></pre>

<p>您可以在下面看到实现推送至Octopus所需的最小YAML:</p>

<pre><code class="language-yaml">- step:
    name: Push to Octopus
    image: octopusdeploy/octo:7.3.2
    script:
      - export VERSION=1.0.0.$BITBUCKET_BUILD_NUMBER
      - octo push --package ./out/$BITBUCKET_REPO_SLUG.$VERSION.zip  --server $OCTOPUS_SERVER --space $OCTOPUS_SPACE --apiKey $OCTOPUS_APIKEY
</code></pre>

<h3 id="push-build-information-to-octopus">将构建信息推送到Octopus</h3>

<p>为了完成集成，我想在Octopus中提供<a href="https://octopus.com/docs/packaging-applications/build-servers/build-information">构建信息</a>。</p>

<p>对我来说，Octopus最棒的一点是它是API优先的。这允许我们在它的基础上构建一流的CLI。推送构建信息被证明是非常容易的。一旦我知道了JSON有效载荷的格式，我就使用<a href="https://octopus.com/docs/octopus-rest-api/octopus-cli/build-information"> build-information </a>命令创建了一个<a href="https://bitbucket.org/octopussamples/randomquotes-js/src/master/create-build-info.sh" rel="nofollow"> Bash脚本</a>来完成这个任务。</p>

<p><strong>提示:构建信息有效负载</strong> <br/>为了帮助揭开构建信息有效负载的一些复杂性，我按照我的同事Shawn的优秀<a href="https://octopus.com/blog/manually-push-build-information-to-octopus" class="alert-link">片段</a>对其结构进行了描述。</p>


<p>为了添加到我们前面的<code>Push to Octopus</code>步骤中，我们也可以包含这个脚本来推送构建信息。完整的步骤如下所示:</p>

<pre><code class="language-yaml">- step:
    name: Push to Octopus
    image: octopusdeploy/octo:7.3.2
    script:
      - apk update &amp;&amp; apk upgrade &amp;&amp; apk add --no-cache git curl jq
      - export VERSION=1.0.0.$BITBUCKET_BUILD_NUMBER
      - octo push --package ./out/$BITBUCKET_REPO_SLUG.$VERSION.zip  --server $OCTOPUS_SERVER --space $OCTOPUS_SPACE --apiKey $OCTOPUS_APIKEY
      - /bin/sh create-build-info.sh $BITBUCKET_REPO_OWNER $BITBUCKET_REPO_SLUG $BITBUCKET_BUILD_NUMBER $BITBUCKET_COMMIT $BITBUCKET_BRANCH $BITBUCKET_GIT_HTTP_ORIGIN
      - octo build-information --package-id $BITBUCKET_REPO_SLUG --version $VERSION --file=octopus.buildinfo --server $OCTOPUS_SERVER --space $OCTOPUS_SPACE --apiKey $OCTOPUS_APIKEY
</code></pre>

<p><code>create-build-info.sh</code>脚本创建一个名为<code>octopus.buildinfo</code>的JSON有效负载输出文件，然后我们在<code>build-information</code>命令中使用它来推送提交信息。</p>

<p>在提交被推送到Octopus之后，您可以在库的Packages部分看到它们:</p>

<p><a href="#" data-featherlight="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/randomquotes-js-buildinfo.png" class="zoom" data-title=""><img src="../Images/a22c08992abf45f80fd6d61e84847084.png" class="img-fluid center" alt="randomquotes-js buildinfor" data-original-src="https://i.octopus.com/blog/2020-04/bitbucket-pipes-and-octopus-deploy/randomquotes-js-buildinfo.png"/>T2】</a></p>

<p>就是这样！</p>

<p>您可以在<a href="https://bitbucket.org/octopussamples/randomquotes-js/src/master/bitbucket-pipelines.yml" rel="nofollow">位桶</a>上查看完整的<code>bitbucket-pipelines.yml</code>文件。</p>

<p><strong>样本Octopus项目</strong> <br/>您可以在我们的<a href="https://samples.octopus.app/app#/Spaces-104/projects/randomquotes-js/" class="alert-link" rel="nofollow">样本</a>实例中查看RandomQuotes-JS Octopus项目设置。</p>


<h2 id="conclusion">结论</h2>

<p>创建我的第一个Bitbucket管道非常简单。我肯定能看到在Bitbucket中创建管道的优势。也就是说，我发现当对管道进行更改时，反馈周期需要一段时间才能恢复正常。我的建议是只写你需要的最少的功能，然后随着时间的推移在此基础上构建。使用Octopus CLI将Bitbucket管道与Octopus集成是轻而易举的事情，对于任何更复杂的事情，您总是可以随意使用API。</p>

<h2 id="learn-more">了解更多信息</h2>



<p>观看我们最近的网络研讨会，了解如何将Atlassian云管道与Octopus Deploy集成。我们涵盖了这篇文章中的许多概念，所以请查看:</p>

<iframe src="https://www.youtube.com/embed/yPjooXDJUA0" frameborder="0" allowfullscreen="">VIDEO</iframe>

<p>欢迎发表评论，让我们知道您对Bitbucket管道、管道或基于容器的构建链的看法！</p>

                    
                    
</body>
</html>